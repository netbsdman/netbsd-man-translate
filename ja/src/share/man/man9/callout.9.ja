.\"	$NetBSD: callout.9,v 1.24 2009/05/04 13:37:57 wiz Exp $
.\"
.\" Copyright (c) 2000, 2003, 2009 The NetBSD Foundation, Inc.
.\" All rights reserved.
.\"
.\" This code is derived from software contributed to The NetBSD Foundation
.\" by Jason R. Thorpe.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
.\" ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
.\" TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
.\" PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
.\" BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
.\" CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
.\" SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
.\" INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
.\" CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
.\" ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd August 3, 2009
.Dt CALLOUT 9
.Os
.Sh NAME
.Nm callout_init ,
.Nm callout_destroy ,
.Nm callout_halt ,
.Nm callout_reset ,
.Nm callout_schedule ,
.Nm callout_setfunc ,
.Nm callout_stop ,
.Nm callout_pending ,
.Nm callout_expired ,
.Nm callout_invoking ,
.Nm callout_ack
.Nd 指定時間後に関数を実行する
.Sh SYNOPSIS
.In sys/callout.h
.Ft void
.Fn "callout_init" "callout_t *c" "u_int flags"
.Ft void
.Fn "callout_destroy" "callout_t *c"
.Ft void
.Fn "callout_reset" "callout_t *c" "int ticks" \
    "void (*func)(void *)" "void *arg"
.Ft void
.Fn "callout_schedule" "callout_t *c" "int ticks"
.Ft void
.Fn "callout_setfunc" "callout_t *c" "void (*func)(void *)" "void *arg"
.Ft bool
.Fn "callout_stop" "callout_t *c"
.Ft bool
.Fn "callout_halt" "callout_t *c" "kmutex_t *interlock"
.Ft bool
.Fn "callout_pending" "callout_t *c"
.Ft bool
.Fn "callout_expired" "callout_t *c"
.Ft bool
.Fn "callout_active" "callout_t *c"
.Ft bool
.Fn "callout_invoking" "callout_t *c"
.Ft bool
.Fn "callout_ack" "callout_t *c"
.Sh DESCRIPTION
.Nm callout
とは与えられた時間経過によって関数を実行するしくみ。
そのタイマーは
.Dv hz
毎秒を度数としたハードクロックタイマーを
基準にしている。実行される関数はソフトクロック割り込みから呼び出される。
.Pp
.Nm callout
の使用者は、callout の構造体や
.Dq ハンドル
をあらかじめ確保しておかなければならない。
.Nm callout
は歴史的な
.Ux
関数である
.Fn timeout
や
.Fn untimeout
を置き換える。
.Sh FUNCTIONS
.Fn callout_init
関数は callout ハンドル
.Fa c
を初期化して使用可能にする。
初期化前の状態では callout に対する操作を行なうことはできない。
.Fa flags
引数を
.Dv CALLOUT_MPSAFE
に設定すると、
そのハンドラはグローバル kernel ロックをかけずに呼び出される。
この場合、そのハンドラはマルチプロセッサセーフな関数のみを呼び出すように
気をつけなければならない。
.Pp
.Fn callout_destroy
は callout を解放して以降の使用を禁止する。
これはバグ検出を目的とした診断機構である。
将来への互換性を保証するため、
(例えば、デバイスが取り外された場合など)
callout が不要になった場合
.Fn callout_destroy
が必ず呼び出されるべきである。
.Pp
.Fn callout_reset
関数は callout ハンドル
.Fa c
に関連したタイマーをリセットして再度開始させる。
.Fa ticks Ns No /hz
秒経過するとタイマーは発火し、
.Fa func
で指定した関数が
.Fa arg
で指定した引数で呼び出される。
callout ハンドルに関連したタイマーが既に実行中の場合、
単に callout は新しく指定した時間で再度スケジューリングされる。
タイマーが開始されたら、callout ハンドルは
.Em PENDING
としてマークされる。
タイマーが発火すると、
そのハンドルは
.Em EXPIRED
かつ
.Em INVOKING
としてマークされ、
.Em PENDING
マークが削除される。
.Pp
.Fn callout_setfunc
関数は、callout ハンドル
.Fa c
に
.Fa func
関数と
.Fa arg
引数を設定する。
当該 callout ハンドルは初期化済みでなければならない。
callout がいつも同じ関数と引数を使用する場合、
.Fn callout_setfunc
を
.Fn callout_schedule
と合わせて使った方が
.Fn callout_reset
を単体で使うよりも便利である。
.Pp
.Fn callout_stop
関数は callout ハンドル
.Fa c
に関連したタイマーを停止させる。
callout ハンドルに付いている
.Em PENDING
と
.Em EXPIRED
マークは削除される。
タイマー発火した callout ハンドルに対して
.Fn callout_stop
を呼び出しても問題ない。ただし当該ハンドルは初期化済みでなければならない。
もし callout が
.Em EXPIRED
であったら、
.Fn callout_stop
関数は非ゼロを返す。
以下に注意。
callout が異なる CPU や同一の CPU であっても異なる割り込み優先度で実行中
であっても
.Fn callout_stop
関数は return する。
本関数の完了は、明示的に再スケジュールしない限り、
それ以降 callout がタイマー発火によって実行されないということしか
意味していない。
callout を停止させてかつそのcalloutの実行完了を待ち合わせる場合には
.Fn callout_halt
を使うべきである。
.Pp
.Fn callout_halt
関数の動作は
.Fn callout_stop
関数と良く似ているが、
実行中 callout の完了を待ち合わせるところが異なる。
.Fn callout_halt
関数はハード割り込みハンドラから呼び出されないべきである。
なぜなら対象となるcalloutが実行中の場合、本関数はsleepしてしまうから。
もし callout が (mutex や RW ロックのような) ロック取得を行なう場合、
.Fn callout_halt
関数の呼び出し元はそれらのロック保持を行なってはならない。
さもないとデッドロックが発生することになる。
上記をうまく扱うために、
.Fn callout_halt
関数は
.Fa interlock
引数で解放する mutex を一つだけ指定することができる。
もし
.Fa interlock
を非
.Dv NULL
に設定してかつ呼び出しスレッドが callout 実行完了を待ち合わせる場合、
.Fa interlock
は待ち合わせ前に解放され、関数 return 前に再取得される。
もし待ち合わせが不要な場合、
.Fa interlock
は解放されない。
とはいえ、競合状態を回避するため、呼び出し元は
.Fa interlock
が解放/再取得される可能性があることをいつも念頭におくべきである。
.Pp
.Fn callout_pending
関数は callout ハンドル
.Fa c
の状態が
.Em PENDING
かどうか調べる。
.Em PENDING
状態にある callout とは、タイマーは開始しているが、
対応する関数はまだ呼び出されていない状態である。
以下に注意。
もしソフトクロック割り込みが入るように割り込みレベルを落していない場合、
callout に対応する関数が呼び出されることなしに
callout のタイマーが発火してしまうことがありうる。
また、ソフトクロック割り込みレベルかそれよりも
高い割り込みレベルにおいてのみ
.Em PENDING
状態確認が安全に使えることにも注意すること。
.Pp
.Fn callout_expired
関数は callout のタイマーが発火済みでかつ対応する関数が呼び出されたかどうか
を調べる。
.Pp
.Fn callout_active
関数はタイマーが開始していて、
たとえタイマーが既に発火済みであったとしても明示的にタイマーを
停止させていなければ、true を返す。
.Fn callout_active foo
と
.Fn callout_pending foo
||
.Fn callout_expired foo ;
は論理的に等価である。
この分離された関数の実装は
.Fx
と互換性があり、
.Fn TCP_TIMER_ISARMED
はその特殊ケースである。
しかし、上記関数の使用は推奨されない。
.Pp
.Fn callout_invoking
関数は callout ハンドル
.Fa c
の状態が
.Em INVOKING
かどうか調べる。
このフラグは callout 関数が呼び出される直前に設定される。
callout 関数の呼び出し前に優先度低に設定されるので、
その callout 関数が実行許可される前に
その他未実行の優先度高の処理が実行されるかもしれない。
もし優先度高の処理が、callout 関数がまさに実行しようとしている
callout 構造体を含むメモリを解放した場合、
競合状態を引き起こす可能性がある。
このような場合、解放済みメモリへの参照を防止する1つのテクニックとして、
.Fn callout_invoking
を使って callout 関数が
.Em INVOKING
状態にあるかどうか調べ、
そうであればその callout 関数が実行されるまでメモリの解放を延期させるように、
そのデータ構造体にフラグを付ける方法がある。
このハンドシェイクが動作するようにするため、
その callout 関数は
.Fn callout_ack
関数で先のフラグを削除すべきである。
.Pp
.Fn callout_ack
関数は callout ハンドル
.Fa c
の
.Em INVOKING
フラグを削除する。
これは
.Fn callout_invoking
の章で説明したような競合状態を防止する必要がある場面で使われる。
.Sh CONCURRENCY
callout が実行する個々の操作がアトミックであることを保証するために、
callout 機構は内部にロックを持つ。
本機構は、作成された callout データのライフサイクルを管理しない。
また、複数の操作 (複数の関数呼び出しなど) がアトミックに実行されること
を保証することもない。
これらの callout 管理については、callout 機構の使用者の責務である。
.Pp
スケジューリングされた callout 群は
callout 機構の使用者とは異なるコンテキストで並列実行されるかもしれない。
例えば、異なる CPU、異なる割り込み優先度、同じ CPU の異なるスレッドなどである。
callout 機構は、どのような callout 同士も並列に実行されないことのみを保証する。
.Sh SEE ALSO
.Xr condvar 9 ,
.Xr hz 9 ,
.Xr softint 9 ,
.Xr workqueue 9
.Sh HISTORY
.Nm callout
機構は、G. Varghese と A. Lauckによる論文
Hashed and Hierarchical Timing Wheels: Data Structures for the
Efficient Implementation of a Timer Facility
in the Proceedings of the 11th ACM Annual Symposium on Operating System
Principles, Austin, Texas, November 1987
を参考に、Artur Grabowski と Thomas Nordin によって実装された。
また Jason R. Thorpe によって
.Nx
kernel に移植された。
