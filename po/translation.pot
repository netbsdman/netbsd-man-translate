# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2012-03-15 22:52+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Dd
#: org_netbsd/src/share/man/man9/CTASSERT.9:30 org_netbsd/src/share/man/man9/sysmon_taskq.9:30
#, no-wrap
msgid "January 24, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/CTASSERT.9:31
#, no-wrap
msgid "CTASSERT 9"
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/CTASSERT.9:33 org_netbsd/src/share/man/man9/KASSERT.9:30 org_netbsd/src/share/man/man9/LWP_CACHE_CREDS.9:32 org_netbsd/src/share/man/man9/RUN_ONCE.9:32 org_netbsd/src/share/man/man9/SET.9:33 org_netbsd/src/share/man/man9/STACK.9:33 org_netbsd/src/share/man/man9/accept_filter.9:32 org_netbsd/src/share/man/man9/accf_data.9:32 org_netbsd/src/share/man/man9/accf_http.9:32 org_netbsd/src/share/man/man9/altq.9:32 org_netbsd/src/share/man/man9/arp.9:34 org_netbsd/src/share/man/man9/audio.9:33 org_netbsd/src/share/man/man9/autoconf.9:33 org_netbsd/src/share/man/man9/bcdtobin.9:33 org_netbsd/src/share/man/man9/bcmp.9:36 org_netbsd/src/share/man/man9/bcopy.9:37 org_netbsd/src/share/man/man9/bintime_add.9:33 org_netbsd/src/share/man/man9/bluetooth.9:36 org_netbsd/src/share/man/man9/boothowto.9:30 org_netbsd/src/share/man/man9/bpf.9:30 org_netbsd/src/share/man/man9/buffercache.9:107 org_netbsd/src/share/man/man9/bufq.9:33 org_netbsd/src/share/man/man9/bus_dma.9:34 org_netbsd/src/share/man/man9/bus_space.9:33 org_netbsd/src/share/man/man9/byteorder.9:32 org_netbsd/src/share/man/man9/bzero.9:37 org_netbsd/src/share/man/man9/callback.9:30 org_netbsd/src/share/man/man9/callout.9:33 org_netbsd/src/share/man/man9/cardbus.9:33 org_netbsd/src/share/man/man9/cnmagic.9:38 org_netbsd/src/share/man/man9/condvar.9:33 org_netbsd/src/share/man/man9/config.9:33 org_netbsd/src/share/man/man9/cons.9:30 org_netbsd/src/share/man/man9/copy.9:38 org_netbsd/src/share/man/man9/coredump_write.9:33 org_netbsd/src/share/man/man9/cprng.9:33 org_netbsd/src/share/man/man9/cpu_configure.9:33 org_netbsd/src/share/man/man9/cpu_coredump.9:33 org_netbsd/src/share/man/man9/cpu_dumpconf.9:33 org_netbsd/src/share/man/man9/cpu_idle.9:32 org_netbsd/src/share/man/man9/cpu_initclocks.9:33 org_netbsd/src/share/man/man9/cpu_lwp_fork.9:33 org_netbsd/src/share/man/man9/cpu_need_resched.9:33 org_netbsd/src/share/man/man9/cpu_number.9:33 org_netbsd/src/share/man/man9/cpu_reboot.9:38 org_netbsd/src/share/man/man9/cpu_rootconf.9:33 org_netbsd/src/share/man/man9/cpu_startup.9:33 org_netbsd/src/share/man/man9/cpu_switchto.9:32 org_netbsd/src/share/man/man9/cpufreq.9:31 org_netbsd/src/share/man/man9/csf.9:33 org_netbsd/src/share/man/man9/ctod.9:33 org_netbsd/src/share/man/man9/curproc.9:33 org_netbsd/src/share/man/man9/ddc.9:35 org_netbsd/src/share/man/man9/delay.9:33 org_netbsd/src/share/man/man9/deviter.9:56 org_netbsd/src/share/man/man9/disk.9:36 org_netbsd/src/share/man/man9/disklabel.9:33 org_netbsd/src/share/man/man9/dmover.9:39 org_netbsd/src/share/man/man9/do_setresuid.9:34 org_netbsd/src/share/man/man9/dofileread.9:33 org_netbsd/src/share/man/man9/dopowerhooks.9:33 org_netbsd/src/share/man/man9/doshutdownhooks.9:38 org_netbsd/src/share/man/man9/driver.9:33 org_netbsd/src/share/man/man9/edid.9:35 org_netbsd/src/share/man/man9/errno.9:36 org_netbsd/src/share/man/man9/ethersubr.9:33 org_netbsd/src/share/man/man9/evcnt.9:38 org_netbsd/src/share/man/man9/extattr.9:32 org_netbsd/src/share/man/man9/extent.9:33 org_netbsd/src/share/man/man9/fetch.9:38 org_netbsd/src/share/man/man9/file.9:33 org_netbsd/src/share/man/man9/fileassoc.9:31 org_netbsd/src/share/man/man9/filedesc.9:33 org_netbsd/src/share/man/man9/firmload.9:33 org_netbsd/src/share/man/man9/flash.9:35 org_netbsd/src/share/man/man9/fork1.9:34 org_netbsd/src/share/man/man9/fsetown.9:33 org_netbsd/src/share/man/man9/fstrans.9:33 org_netbsd/src/share/man/man9/getiobuf.9:30 org_netbsd/src/share/man/man9/hardclock.9:33 org_netbsd/src/share/man/man9/hash.9:33 org_netbsd/src/share/man/man9/hashinit.9:33 org_netbsd/src/share/man/man9/humanize_number.9:33 org_netbsd/src/share/man/man9/hz.9:33 org_netbsd/src/share/man/man9/ieee80211.9:34 org_netbsd/src/share/man/man9/ieee80211_crypto.9:33 org_netbsd/src/share/man/man9/ieee80211_input.9:33 org_netbsd/src/share/man/man9/ieee80211_ioctl.9:33 org_netbsd/src/share/man/man9/ieee80211_node.9:33 org_netbsd/src/share/man/man9/ieee80211_output.9:33 org_netbsd/src/share/man/man9/ieee80211_proto.9:33 org_netbsd/src/share/man/man9/ieee80211_radiotap.9:34 org_netbsd/src/share/man/man9/iic.9:40 org_netbsd/src/share/man/man9/imax.9:30 org_netbsd/src/share/man/man9/in4_cksum.9:33 org_netbsd/src/share/man/man9/in_getifa.9:33 org_netbsd/src/share/man/man9/inittodr.9:38 org_netbsd/src/share/man/man9/intro.9:33 org_netbsd/src/share/man/man9/ioasic.9:33 org_netbsd/src/share/man/man9/ioctl.9:33 org_netbsd/src/share/man/man9/ipkdb.9:33 org_netbsd/src/share/man/man9/isa.9:33 org_netbsd/src/share/man/man9/isapnp.9:33 org_netbsd/src/share/man/man9/itimerfix.9:33 org_netbsd/src/share/man/man9/kauth.9:31 org_netbsd/src/share/man/man9/kcopy.9:33 org_netbsd/src/share/man/man9/kcpuset.9:31 org_netbsd/src/share/man/man9/kfilter_register.9:33 org_netbsd/src/share/man/man9/kmem.9:32 org_netbsd/src/share/man/man9/knote.9:33 org_netbsd/src/share/man/man9/kpause.9:35 org_netbsd/src/share/man/man9/kpreempt.9:32 org_netbsd/src/share/man/man9/kprintf.9:33 org_netbsd/src/share/man/man9/kthread.9:33 org_netbsd/src/share/man/man9/linedisc.9:38 org_netbsd/src/share/man/man9/lock.9:30 org_netbsd/src/share/man/man9/log.9:33 org_netbsd/src/share/man/man9/ltsleep.9:33 org_netbsd/src/share/man/man9/m_tag.9:31 org_netbsd/src/share/man/man9/makeiplcookie.9:32 org_netbsd/src/share/man/man9/malloc.9:33 org_netbsd/src/share/man/man9/mb.9:33 org_netbsd/src/share/man/man9/mbuf.9:33 org_netbsd/src/share/man/man9/mca.9:33 org_netbsd/src/share/man/man9/memcmp.9:38 org_netbsd/src/share/man/man9/memcpy.9:39 org_netbsd/src/share/man/man9/memmove.9:38 org_netbsd/src/share/man/man9/memoryallocators.9:31 org_netbsd/src/share/man/man9/memset.9:38 org_netbsd/src/share/man/man9/mi_switch.9:33 org_netbsd/src/share/man/man9/microseq.9:32 org_netbsd/src/share/man/man9/microtime.9:59 org_netbsd/src/share/man/man9/microuptime.9:32 org_netbsd/src/share/man/man9/module.9:33 org_netbsd/src/share/man/man9/mstohz.9:30 org_netbsd/src/share/man/man9/mutex.9:33 org_netbsd/src/share/man/man9/namecache.9:33 org_netbsd/src/share/man/man9/namei.9:33 org_netbsd/src/share/man/man9/npf_ncode.9:33 org_netbsd/src/share/man/man9/nullop.9:33 org_netbsd/src/share/man/man9/opencrypto.9:22 org_netbsd/src/share/man/man9/optstr.9:33 org_netbsd/src/share/man/man9/panic.9:33 org_netbsd/src/share/man/man9/pathbuf.9:33 org_netbsd/src/share/man/man9/pci.9:33 org_netbsd/src/share/man/man9/pci_configure_bus.9:39 org_netbsd/src/share/man/man9/pci_intr.9:33 org_netbsd/src/share/man/man9/pckbport.9:31 org_netbsd/src/share/man/man9/pcmcia.9:33 org_netbsd/src/share/man/man9/pcq.9:33 org_netbsd/src/share/man/man9/percpu.9:33 org_netbsd/src/share/man/man9/pfil.9:30 org_netbsd/src/share/man/man9/physio.9:33 org_netbsd/src/share/man/man9/pmap.9:33 org_netbsd/src/share/man/man9/pmatch.9:29 org_netbsd/src/share/man/man9/pmc.9:39 org_netbsd/src/share/man/man9/pmf.9:30 org_netbsd/src/share/man/man9/pool.9:33 org_netbsd/src/share/man/man9/pool_cache.9:60 org_netbsd/src/share/man/man9/powerhook_establish.9:33 org_netbsd/src/share/man/man9/ppi.9:33 org_netbsd/src/share/man/man9/ppsratecheck.9:33 org_netbsd/src/share/man/man9/preempt.9:33 org_netbsd/src/share/man/man9/proc_find.9:33 org_netbsd/src/share/man/man9/pserialize.9:30 org_netbsd/src/share/man/man9/putter.9:30 org_netbsd/src/share/man/man9/radio.9:30 org_netbsd/src/share/man/man9/ras.9:33 org_netbsd/src/share/man/man9/rasops.9:33 org_netbsd/src/share/man/man9/ratecheck.9:33 org_netbsd/src/share/man/man9/resettodr.9:38 org_netbsd/src/share/man/man9/rnd.9:33 org_netbsd/src/share/man/man9/roundup.9:33 org_netbsd/src/share/man/man9/rssadapt.9:33 org_netbsd/src/share/man/man9/rt_timer.9:34 org_netbsd/src/share/man/man9/rwlock.9:33 org_netbsd/src/share/man/man9/scanc.9:32 org_netbsd/src/share/man/man9/sched_4bsd.9:33 org_netbsd/src/share/man/man9/sched_m2.9:33 org_netbsd/src/share/man/man9/scsipi.9:30 org_netbsd/src/share/man/man9/secmodel.9:31 org_netbsd/src/share/man/man9/secmodel_bsd44.9:31 org_netbsd/src/share/man/man9/secmodel_extensions.9:33 org_netbsd/src/share/man/man9/secmodel_overlay.9:31 org_netbsd/src/share/man/man9/secmodel_securelevel.9:32 org_netbsd/src/share/man/man9/secmodel_suser.9:31 org_netbsd/src/share/man/man9/select.9:34 org_netbsd/src/share/man/man9/setbit.9:33 org_netbsd/src/share/man/man9/setjmp.9:33 org_netbsd/src/share/man/man9/shutdownhook_establish.9:38 org_netbsd/src/share/man/man9/signal.9:33 org_netbsd/src/share/man/man9/skpc.9:32 org_netbsd/src/share/man/man9/sockopt.9:29 org_netbsd/src/share/man/man9/softintr.9:65 org_netbsd/src/share/man/man9/spl.9:33 org_netbsd/src/share/man/man9/splraiseipl.9:32 org_netbsd/src/share/man/man9/store.9:38 org_netbsd/src/share/man/man9/suspendsched.9:33 org_netbsd/src/share/man/man9/sysctl.9:33 org_netbsd/src/share/man/man9/sysmon_envsys.9:33 org_netbsd/src/share/man/man9/sysmon_pswitch.9:33 org_netbsd/src/share/man/man9/sysmon_taskq.9:33 org_netbsd/src/share/man/man9/tc.9:33 org_netbsd/src/share/man/man9/tcp_congctl.9:33 org_netbsd/src/share/man/man9/time_second.9:38 org_netbsd/src/share/man/man9/timecounter.9:43 org_netbsd/src/share/man/man9/todr.9:33 org_netbsd/src/share/man/man9/tvtohz.9:32 org_netbsd/src/share/man/man9/ubc.9:30 org_netbsd/src/share/man/man9/ucas.9:32 org_netbsd/src/share/man/man9/ucom.9:33 org_netbsd/src/share/man/man9/uiomove.9:30 org_netbsd/src/share/man/man9/usbdi.9:33 org_netbsd/src/share/man/man9/userret.9:33 org_netbsd/src/share/man/man9/uvm.9:30 org_netbsd/src/share/man/man9/uvm_km.9:30 org_netbsd/src/share/man/man9/uvm_map.9:30 org_netbsd/src/share/man/man9/vattr.9:33 org_netbsd/src/share/man/man9/vcons.9:30 org_netbsd/src/share/man/man9/veriexec.9:33 org_netbsd/src/share/man/man9/vfs.9:33 org_netbsd/src/share/man/man9/vfs_hooks.9:33 org_netbsd/src/share/man/man9/vfsops.9:33 org_netbsd/src/share/man/man9/vfssubr.9:33 org_netbsd/src/share/man/man9/video.9:31 org_netbsd/src/share/man/man9/vme.9:33 org_netbsd/src/share/man/man9/vmem.9:32 org_netbsd/src/share/man/man9/vnfileops.9:33 org_netbsd/src/share/man/man9/vnode.9:33 org_netbsd/src/share/man/man9/vnodeops.9:33 org_netbsd/src/share/man/man9/vnsubr.9:33 org_netbsd/src/share/man/man9/wdc.9:29 org_netbsd/src/share/man/man9/workqueue.9:32 org_netbsd/src/share/man/man9/wscons.9:33 org_netbsd/src/share/man/man9/wsdisplay.9:33 org_netbsd/src/share/man/man9/wsfont.9:33 org_netbsd/src/share/man/man9/wskbd.9:33 org_netbsd/src/share/man/man9/wsmouse.9:33 org_netbsd/src/share/man/man9/xcall.9:33 org_netbsd/src/share/man/man9/man9.i386/bios32_service.9:33 org_netbsd/src/share/man/man9/man9.i386/bioscall.9:33 org_netbsd/src/share/man/man9/man9.i386/return_address.9:33 org_netbsd/src/share/man/man9/man9.i386/splraise.9:30 org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:33 org_netbsd/src/share/man/man9/man9.x86/nmi.9:33 org_netbsd/src/share/man/man9/man9.x86/rdmsr.9:33 org_netbsd/src/share/man/man9/man9.x86/tsc.9:33 org_netbsd/src/share/man/man9/man9.x86/x86_msr_xcall.9:33
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/CTASSERT.9:35
msgid "E<.Nm CTASSERT>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/CTASSERT.9:35
#, no-wrap
msgid "compile time assertion macro"
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/CTASSERT.9:36 org_netbsd/src/share/man/man9/KASSERT.9:36 org_netbsd/src/share/man/man9/LWP_CACHE_CREDS.9:36 org_netbsd/src/share/man/man9/RUN_ONCE.9:36 org_netbsd/src/share/man/man9/SET.9:36 org_netbsd/src/share/man/man9/STACK.9:36 org_netbsd/src/share/man/man9/accept_filter.9:39 org_netbsd/src/share/man/man9/accf_data.9:35 org_netbsd/src/share/man/man9/accf_http.9:35 org_netbsd/src/share/man/man9/altq.9:35 org_netbsd/src/share/man/man9/arp.9:40 org_netbsd/src/share/man/man9/autoconf.9:53 org_netbsd/src/share/man/man9/bcdtobin.9:37 org_netbsd/src/share/man/man9/bcmp.9:39 org_netbsd/src/share/man/man9/bcopy.9:40 org_netbsd/src/share/man/man9/bintime_add.9:37 org_netbsd/src/share/man/man9/bluetooth.9:39 org_netbsd/src/share/man/man9/boothowto.9:34 org_netbsd/src/share/man/man9/bpf.9:33 org_netbsd/src/share/man/man9/buffercache.9:123 org_netbsd/src/share/man/man9/bufq.9:46 org_netbsd/src/share/man/man9/bus_dma.9:52 org_netbsd/src/share/man/man9/bus_space.9:119 org_netbsd/src/share/man/man9/byteorder.9:61 org_netbsd/src/share/man/man9/bzero.9:40 org_netbsd/src/share/man/man9/callback.9:33 org_netbsd/src/share/man/man9/callout.9:46 org_netbsd/src/share/man/man9/cardbus.9:57 org_netbsd/src/share/man/man9/cnmagic.9:47 org_netbsd/src/share/man/man9/condvar.9:46 org_netbsd/src/share/man/man9/cons.9:39 org_netbsd/src/share/man/man9/copy.9:46 org_netbsd/src/share/man/man9/coredump_write.9:36 org_netbsd/src/share/man/man9/cprng.9:47 org_netbsd/src/share/man/man9/cpu_configure.9:36 org_netbsd/src/share/man/man9/cpu_coredump.9:36 org_netbsd/src/share/man/man9/cpu_dumpconf.9:39 org_netbsd/src/share/man/man9/cpu_idle.9:36 org_netbsd/src/share/man/man9/cpu_initclocks.9:36 org_netbsd/src/share/man/man9/cpu_lwp_fork.9:38 org_netbsd/src/share/man/man9/cpu_need_resched.9:36 org_netbsd/src/share/man/man9/cpu_number.9:38 org_netbsd/src/share/man/man9/cpu_reboot.9:41 org_netbsd/src/share/man/man9/cpu_rootconf.9:37 org_netbsd/src/share/man/man9/cpu_startup.9:38 org_netbsd/src/share/man/man9/cpu_switchto.9:38 org_netbsd/src/share/man/man9/cpufreq.9:44 org_netbsd/src/share/man/man9/csf.9:38 org_netbsd/src/share/man/man9/ctod.9:36 org_netbsd/src/share/man/man9/curproc.9:39 org_netbsd/src/share/man/man9/ddc.9:38 org_netbsd/src/share/man/man9/delay.9:37 org_netbsd/src/share/man/man9/deviter.9:63 org_netbsd/src/share/man/man9/disk.9:49 org_netbsd/src/share/man/man9/disklabel.9:40 org_netbsd/src/share/man/man9/dmover.9:49 org_netbsd/src/share/man/man9/do_setresuid.9:38 org_netbsd/src/share/man/man9/dofileread.9:39 org_netbsd/src/share/man/man9/dopowerhooks.9:36 org_netbsd/src/share/man/man9/doshutdownhooks.9:41 org_netbsd/src/share/man/man9/driver.9:36 org_netbsd/src/share/man/man9/edid.9:38 org_netbsd/src/share/man/man9/errno.9:39 org_netbsd/src/share/man/man9/ethersubr.9:45 org_netbsd/src/share/man/man9/evcnt.9:44 org_netbsd/src/share/man/man9/extattr.9:35 org_netbsd/src/share/man/man9/extent.9:43 org_netbsd/src/share/man/man9/fetch.9:47 org_netbsd/src/share/man/man9/file.9:42 org_netbsd/src/share/man/man9/fileassoc.9:34 org_netbsd/src/share/man/man9/filedesc.9:52 org_netbsd/src/share/man/man9/firmload.9:36 org_netbsd/src/share/man/man9/flash.9:38 org_netbsd/src/share/man/man9/fork1.9:37 org_netbsd/src/share/man/man9/fsetown.9:38 org_netbsd/src/share/man/man9/fstrans.9:45 org_netbsd/src/share/man/man9/getiobuf.9:35 org_netbsd/src/share/man/man9/hardclock.9:36 org_netbsd/src/share/man/man9/hash.9:39 org_netbsd/src/share/man/man9/hashinit.9:37 org_netbsd/src/share/man/man9/humanize_number.9:37 org_netbsd/src/share/man/man9/hz.9:40 org_netbsd/src/share/man/man9/ieee80211.9:42 org_netbsd/src/share/man/man9/ieee80211_crypto.9:36 org_netbsd/src/share/man/man9/ieee80211_input.9:36 org_netbsd/src/share/man/man9/ieee80211_ioctl.9:36 org_netbsd/src/share/man/man9/ieee80211_node.9:48 org_netbsd/src/share/man/man9/ieee80211_output.9:37 org_netbsd/src/share/man/man9/ieee80211_proto.9:41 org_netbsd/src/share/man/man9/ieee80211_radiotap.9:37 org_netbsd/src/share/man/man9/iic.9:48 org_netbsd/src/share/man/man9/imax.9:40 org_netbsd/src/share/man/man9/in4_cksum.9:38 org_netbsd/src/share/man/man9/in_getifa.9:36 org_netbsd/src/share/man/man9/inittodr.9:41 org_netbsd/src/share/man/man9/ioasic.9:41 org_netbsd/src/share/man/man9/ioctl.9:36 org_netbsd/src/share/man/man9/ipkdb.9:36 org_netbsd/src/share/man/man9/isa.9:58 org_netbsd/src/share/man/man9/isapnp.9:39 org_netbsd/src/share/man/man9/itimerfix.9:36 org_netbsd/src/share/man/man9/kauth.9:34 org_netbsd/src/share/man/man9/kcopy.9:36 org_netbsd/src/share/man/man9/kcpuset.9:51 org_netbsd/src/share/man/man9/kfilter_register.9:37 org_netbsd/src/share/man/man9/kmem.9:36 org_netbsd/src/share/man/man9/knote.9:37 org_netbsd/src/share/man/man9/kpause.9:39 org_netbsd/src/share/man/man9/kpreempt.9:36 org_netbsd/src/share/man/man9/kprintf.9:44 org_netbsd/src/share/man/man9/kthread.9:39 org_netbsd/src/share/man/man9/linedisc.9:44 org_netbsd/src/share/man/man9/log.9:38 org_netbsd/src/share/man/man9/ltsleep.9:38 org_netbsd/src/share/man/man9/m_tag.9:48 org_netbsd/src/share/man/man9/makeiplcookie.9:36 org_netbsd/src/share/man/man9/malloc.9:47 org_netbsd/src/share/man/man9/mb.9:39 org_netbsd/src/share/man/man9/mbuf.9:71 org_netbsd/src/share/man/man9/mca.9:41 org_netbsd/src/share/man/man9/memcmp.9:41 org_netbsd/src/share/man/man9/memcpy.9:42 org_netbsd/src/share/man/man9/memmove.9:41 org_netbsd/src/share/man/man9/memset.9:41 org_netbsd/src/share/man/man9/mi_switch.9:36 org_netbsd/src/share/man/man9/microseq.9:35 org_netbsd/src/share/man/man9/microtime.9:67 org_netbsd/src/share/man/man9/microuptime.9:40 org_netbsd/src/share/man/man9/module.9:43 org_netbsd/src/share/man/man9/mstohz.9:34 org_netbsd/src/share/man/man9/mutex.9:44 org_netbsd/src/share/man/man9/namecache.9:42 org_netbsd/src/share/man/man9/namei.9:42 org_netbsd/src/share/man/man9/npf_ncode.9:36 org_netbsd/src/share/man/man9/nullop.9:36 org_netbsd/src/share/man/man9/opencrypto.9:37 org_netbsd/src/share/man/man9/optstr.9:36 org_netbsd/src/share/man/man9/panic.9:36 org_netbsd/src/share/man/man9/pathbuf.9:40 org_netbsd/src/share/man/man9/pci.9:66 org_netbsd/src/share/man/man9/pci_configure_bus.9:44 org_netbsd/src/share/man/man9/pci_intr.9:40 org_netbsd/src/share/man/man9/pckbport.9:46 org_netbsd/src/share/man/man9/pcmcia.9:55 org_netbsd/src/share/man/man9/pcq.9:36 org_netbsd/src/share/man/man9/percpu.9:41 org_netbsd/src/share/man/man9/pfil.9:40 org_netbsd/src/share/man/man9/physio.9:36 org_netbsd/src/share/man/man9/pmap.9:36 org_netbsd/src/share/man/man9/pmatch.9:32 org_netbsd/src/share/man/man9/pmc.9:58 org_netbsd/src/share/man/man9/pmf.9:52 org_netbsd/src/share/man/man9/pool.9:43 org_netbsd/src/share/man/man9/pool_cache.9:75 org_netbsd/src/share/man/man9/powerhook_establish.9:37 org_netbsd/src/share/man/man9/ppi.9:36 org_netbsd/src/share/man/man9/ppsratecheck.9:36 org_netbsd/src/share/man/man9/preempt.9:37 org_netbsd/src/share/man/man9/proc_find.9:37 org_netbsd/src/share/man/man9/pserialize.9:33 org_netbsd/src/share/man/man9/ras.9:38 org_netbsd/src/share/man/man9/rasops.9:38 org_netbsd/src/share/man/man9/ratecheck.9:36 org_netbsd/src/share/man/man9/resettodr.9:41 org_netbsd/src/share/man/man9/rnd.9:40 org_netbsd/src/share/man/man9/roundup.9:36 org_netbsd/src/share/man/man9/rssadapt.9:41 org_netbsd/src/share/man/man9/rt_timer.9:42 org_netbsd/src/share/man/man9/rwlock.9:46 org_netbsd/src/share/man/man9/scanc.9:36 org_netbsd/src/share/man/man9/sched_4bsd.9:36 org_netbsd/src/share/man/man9/sched_m2.9:36 org_netbsd/src/share/man/man9/scsipi.9:33 org_netbsd/src/share/man/man9/secmodel.9:34 org_netbsd/src/share/man/man9/secmodel_overlay.9:34 org_netbsd/src/share/man/man9/select.9:40 org_netbsd/src/share/man/man9/setbit.9:36 org_netbsd/src/share/man/man9/setjmp.9:37 org_netbsd/src/share/man/man9/shutdownhook_establish.9:42 org_netbsd/src/share/man/man9/signal.9:58 org_netbsd/src/share/man/man9/skpc.9:36 org_netbsd/src/share/man/man9/sockopt.9:37 org_netbsd/src/share/man/man9/softintr.9:71 org_netbsd/src/share/man/man9/spl.9:45 org_netbsd/src/share/man/man9/splraiseipl.9:36 org_netbsd/src/share/man/man9/store.9:47 org_netbsd/src/share/man/man9/suspendsched.9:36 org_netbsd/src/share/man/man9/sysctl.9:36 org_netbsd/src/share/man/man9/sysmon_envsys.9:36 org_netbsd/src/share/man/man9/sysmon_pswitch.9:36 org_netbsd/src/share/man/man9/sysmon_taskq.9:36 org_netbsd/src/share/man/man9/tc.9:45 org_netbsd/src/share/man/man9/tcp_congctl.9:36 org_netbsd/src/share/man/man9/time_second.9:43 org_netbsd/src/share/man/man9/timecounter.9:47 org_netbsd/src/share/man/man9/todr.9:40 org_netbsd/src/share/man/man9/tvtohz.9:35 org_netbsd/src/share/man/man9/ubc.9:33 org_netbsd/src/share/man/man9/ucas.9:36 org_netbsd/src/share/man/man9/uiomove.9:33 org_netbsd/src/share/man/man9/usbdi.9:36 org_netbsd/src/share/man/man9/userret.9:36 org_netbsd/src/share/man/man9/uvm.9:33 org_netbsd/src/share/man/man9/uvm_km.9:33 org_netbsd/src/share/man/man9/uvm_map.9:34 org_netbsd/src/share/man/man9/vattr.9:37 org_netbsd/src/share/man/man9/vcons.9:33 org_netbsd/src/share/man/man9/veriexec.9:36 org_netbsd/src/share/man/man9/vfs_hooks.9:37 org_netbsd/src/share/man/man9/vfsops.9:48 org_netbsd/src/share/man/man9/vfssubr.9:56 org_netbsd/src/share/man/man9/video.9:34 org_netbsd/src/share/man/man9/vme.9:50 org_netbsd/src/share/man/man9/vmem.9:36 org_netbsd/src/share/man/man9/vnfileops.9:43 org_netbsd/src/share/man/man9/vnode.9:59 org_netbsd/src/share/man/man9/vnodeops.9:81 org_netbsd/src/share/man/man9/vnsubr.9:47 org_netbsd/src/share/man/man9/wdc.9:32 org_netbsd/src/share/man/man9/workqueue.9:36 org_netbsd/src/share/man/man9/wsdisplay.9:40 org_netbsd/src/share/man/man9/wsfont.9:45 org_netbsd/src/share/man/man9/wskbd.9:41 org_netbsd/src/share/man/man9/wsmouse.9:38 org_netbsd/src/share/man/man9/xcall.9:39 org_netbsd/src/share/man/man9/man9.i386/bios32_service.9:36 org_netbsd/src/share/man/man9/man9.i386/bioscall.9:36 org_netbsd/src/share/man/man9/man9.i386/return_address.9:36 org_netbsd/src/share/man/man9/man9.i386/splraise.9:34 org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:39 org_netbsd/src/share/man/man9/man9.x86/nmi.9:38 org_netbsd/src/share/man/man9/man9.x86/rdmsr.9:39 org_netbsd/src/share/man/man9/man9.x86/tsc.9:36 org_netbsd/src/share/man/man9/man9.x86/x86_msr_xcall.9:36
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/CTASSERT.9:39
msgid "E<.Ft void> E<.Fn CTASSERT expression>"
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/CTASSERT.9:39 org_netbsd/src/share/man/man9/KASSERT.9:45 org_netbsd/src/share/man/man9/LWP_CACHE_CREDS.9:43 org_netbsd/src/share/man/man9/RUN_ONCE.9:45 org_netbsd/src/share/man/man9/SET.9:44 org_netbsd/src/share/man/man9/STACK.9:48 org_netbsd/src/share/man/man9/accept_filter.9:55 org_netbsd/src/share/man/man9/accf_data.9:38 org_netbsd/src/share/man/man9/accf_http.9:38 org_netbsd/src/share/man/man9/altq.9:61 org_netbsd/src/share/man/man9/arp.9:48 org_netbsd/src/share/man/man9/audio.9:36 org_netbsd/src/share/man/man9/autoconf.9:97 org_netbsd/src/share/man/man9/bcdtobin.9:43 org_netbsd/src/share/man/man9/bcmp.9:43 org_netbsd/src/share/man/man9/bcopy.9:44 org_netbsd/src/share/man/man9/bintime_add.9:53 org_netbsd/src/share/man/man9/bluetooth.9:78 org_netbsd/src/share/man/man9/boothowto.9:40 org_netbsd/src/share/man/man9/bpf.9:36 org_netbsd/src/share/man/man9/buffercache.9:154 org_netbsd/src/share/man/man9/bufq.9:66 org_netbsd/src/share/man/man9/bus_dma.9:95 org_netbsd/src/share/man/man9/bus_space.9:387 org_netbsd/src/share/man/man9/byteorder.9:117 org_netbsd/src/share/man/man9/bzero.9:44 org_netbsd/src/share/man/man9/callback.9:47 org_netbsd/src/share/man/man9/callout.9:73 org_netbsd/src/share/man/man9/cardbus.9:124 org_netbsd/src/share/man/man9/cnmagic.9:63 org_netbsd/src/share/man/man9/condvar.9:69 org_netbsd/src/share/man/man9/config.9:40 org_netbsd/src/share/man/man9/cons.9:55 org_netbsd/src/share/man/man9/copy.9:67 org_netbsd/src/share/man/man9/coredump_write.9:41 org_netbsd/src/share/man/man9/cprng.9:83 org_netbsd/src/share/man/man9/cpu_configure.9:40 org_netbsd/src/share/man/man9/cpu_coredump.9:42 org_netbsd/src/share/man/man9/cpu_dumpconf.9:50 org_netbsd/src/share/man/man9/cpu_idle.9:43 org_netbsd/src/share/man/man9/cpu_initclocks.9:40 org_netbsd/src/share/man/man9/cpu_lwp_fork.9:45 org_netbsd/src/share/man/man9/cpu_need_resched.9:40 org_netbsd/src/share/man/man9/cpu_number.9:43 org_netbsd/src/share/man/man9/cpu_reboot.9:45 org_netbsd/src/share/man/man9/cpu_rootconf.9:44 org_netbsd/src/share/man/man9/cpu_startup.9:42 org_netbsd/src/share/man/man9/cpu_switchto.9:45 org_netbsd/src/share/man/man9/cpufreq.9:70 org_netbsd/src/share/man/man9/csf.9:86 org_netbsd/src/share/man/man9/ctod.9:50 org_netbsd/src/share/man/man9/curproc.9:47 org_netbsd/src/share/man/man9/ddc.9:46 org_netbsd/src/share/man/man9/delay.9:43 org_netbsd/src/share/man/man9/deviter.9:73 org_netbsd/src/share/man/man9/disk.9:73 org_netbsd/src/share/man/man9/disklabel.9:49 org_netbsd/src/share/man/man9/dmover.9:73 org_netbsd/src/share/man/man9/do_setresuid.9:44 org_netbsd/src/share/man/man9/dofileread.9:56 org_netbsd/src/share/man/man9/dopowerhooks.9:39 org_netbsd/src/share/man/man9/doshutdownhooks.9:44 org_netbsd/src/share/man/man9/driver.9:48 org_netbsd/src/share/man/man9/edid.9:54 org_netbsd/src/share/man/man9/errno.9:41 org_netbsd/src/share/man/man9/ethersubr.9:66 org_netbsd/src/share/man/man9/evcnt.9:53 org_netbsd/src/share/man/man9/extattr.9:39 org_netbsd/src/share/man/man9/extent.9:75 org_netbsd/src/share/man/man9/fetch.9:58 org_netbsd/src/share/man/man9/file.9:56 org_netbsd/src/share/man/man9/fileassoc.9:56 org_netbsd/src/share/man/man9/filedesc.9:87 org_netbsd/src/share/man/man9/firmload.9:58 org_netbsd/src/share/man/man9/flash.9:42 org_netbsd/src/share/man/man9/fork1.9:42 org_netbsd/src/share/man/man9/fsetown.9:46 org_netbsd/src/share/man/man9/fstrans.9:68 org_netbsd/src/share/man/man9/getiobuf.9:42 org_netbsd/src/share/man/man9/hardclock.9:39 org_netbsd/src/share/man/man9/hash.9:48 org_netbsd/src/share/man/man9/hashinit.9:48 org_netbsd/src/share/man/man9/humanize_number.9:43 org_netbsd/src/share/man/man9/hz.9:49 org_netbsd/src/share/man/man9/ieee80211.9:78 org_netbsd/src/share/man/man9/ieee80211_crypto.9:45 org_netbsd/src/share/man/man9/ieee80211_input.9:51 org_netbsd/src/share/man/man9/ieee80211_ioctl.9:46 org_netbsd/src/share/man/man9/ieee80211_node.9:86 org_netbsd/src/share/man/man9/ieee80211_output.9:52 org_netbsd/src/share/man/man9/ieee80211_proto.9:56 org_netbsd/src/share/man/man9/ieee80211_radiotap.9:43 org_netbsd/src/share/man/man9/iic.9:94 org_netbsd/src/share/man/man9/imax.9:57 org_netbsd/src/share/man/man9/in4_cksum.9:45 org_netbsd/src/share/man/man9/in_getifa.9:41 org_netbsd/src/share/man/man9/inittodr.9:44 org_netbsd/src/share/man/man9/intro.9:36 org_netbsd/src/share/man/man9/ioasic.9:58 org_netbsd/src/share/man/man9/ioctl.9:41 org_netbsd/src/share/man/man9/ipkdb.9:56 org_netbsd/src/share/man/man9/isa.9:117 org_netbsd/src/share/man/man9/isapnp.9:55 org_netbsd/src/share/man/man9/itimerfix.9:40 org_netbsd/src/share/man/man9/kauth.9:36 org_netbsd/src/share/man/man9/kcopy.9:40 org_netbsd/src/share/man/man9/kcpuset.9:87 org_netbsd/src/share/man/man9/kfilter_register.9:43 org_netbsd/src/share/man/man9/kmem.9:54 org_netbsd/src/share/man/man9/knote.9:42 org_netbsd/src/share/man/man9/kpause.9:46 org_netbsd/src/share/man/man9/kpreempt.9:49 org_netbsd/src/share/man/man9/kprintf.9:101 org_netbsd/src/share/man/man9/kthread.9:50 org_netbsd/src/share/man/man9/linedisc.9:52 org_netbsd/src/share/man/man9/lock.9:45 org_netbsd/src/share/man/man9/log.9:46 org_netbsd/src/share/man/man9/ltsleep.9:44 org_netbsd/src/share/man/man9/m_tag.9:77 org_netbsd/src/share/man/man9/makeiplcookie.9:43 org_netbsd/src/share/man/man9/malloc.9:70 org_netbsd/src/share/man/man9/mb.9:47 org_netbsd/src/share/man/man9/mbuf.9:143 org_netbsd/src/share/man/man9/mca.9:57 org_netbsd/src/share/man/man9/memcmp.9:45 org_netbsd/src/share/man/man9/memcpy.9:46 org_netbsd/src/share/man/man9/memmove.9:45 org_netbsd/src/share/man/man9/memoryallocators.9:34 org_netbsd/src/share/man/man9/memset.9:45 org_netbsd/src/share/man/man9/mi_switch.9:39 org_netbsd/src/share/man/man9/microseq.9:39 org_netbsd/src/share/man/man9/microtime.9:93 org_netbsd/src/share/man/man9/microuptime.9:54 org_netbsd/src/share/man/man9/module.9:69 org_netbsd/src/share/man/man9/mstohz.9:40 org_netbsd/src/share/man/man9/mutex.9:65 org_netbsd/src/share/man/man9/namecache.9:62 org_netbsd/src/share/man/man9/namei.9:65 org_netbsd/src/share/man/man9/npf_ncode.9:44 org_netbsd/src/share/man/man9/nullop.9:52 org_netbsd/src/share/man/man9/opencrypto.9:117 org_netbsd/src/share/man/man9/optstr.9:40 org_netbsd/src/share/man/man9/panic.9:43 org_netbsd/src/share/man/man9/pathbuf.9:50 org_netbsd/src/share/man/man9/pci.9:156 org_netbsd/src/share/man/man9/pci_configure_bus.9:55 org_netbsd/src/share/man/man9/pci_intr.9:51 org_netbsd/src/share/man/man9/pckbport.9:76 org_netbsd/src/share/man/man9/pcmcia.9:108 org_netbsd/src/share/man/man9/pcq.9:50 org_netbsd/src/share/man/man9/percpu.9:54 org_netbsd/src/share/man/man9/pfil.9:61 org_netbsd/src/share/man/man9/physio.9:46 org_netbsd/src/share/man/man9/pmap.9:109 org_netbsd/src/share/man/man9/pmatch.9:36 org_netbsd/src/share/man/man9/pmc.9:94 org_netbsd/src/share/man/man9/pmf.9:92 org_netbsd/src/share/man/man9/pool.9:71 org_netbsd/src/share/man/man9/pool_cache.9:122 org_netbsd/src/share/man/man9/powerhook_establish.9:43 org_netbsd/src/share/man/man9/ppi.9:40 org_netbsd/src/share/man/man9/ppsratecheck.9:40 org_netbsd/src/share/man/man9/preempt.9:44 org_netbsd/src/share/man/man9/proc_find.9:45 org_netbsd/src/share/man/man9/pserialize.9:46 org_netbsd/src/share/man/man9/putter.9:33 org_netbsd/src/share/man/man9/radio.9:33 org_netbsd/src/share/man/man9/ras.9:48 org_netbsd/src/share/man/man9/rasops.9:45 org_netbsd/src/share/man/man9/ratecheck.9:40 org_netbsd/src/share/man/man9/resettodr.9:44 org_netbsd/src/share/man/man9/rnd.9:50 org_netbsd/src/share/man/man9/roundup.9:48 org_netbsd/src/share/man/man9/rssadapt.9:60 org_netbsd/src/share/man/man9/rt_timer.9:55 org_netbsd/src/share/man/man9/rwlock.9:71 org_netbsd/src/share/man/man9/scanc.9:43 org_netbsd/src/share/man/man9/sched_4bsd.9:50 org_netbsd/src/share/man/man9/sched_m2.9:38 org_netbsd/src/share/man/man9/scsipi.9:58 org_netbsd/src/share/man/man9/secmodel.9:47 org_netbsd/src/share/man/man9/secmodel_bsd44.9:37 org_netbsd/src/share/man/man9/secmodel_extensions.9:36 org_netbsd/src/share/man/man9/secmodel_overlay.9:36 org_netbsd/src/share/man/man9/secmodel_securelevel.9:35 org_netbsd/src/share/man/man9/secmodel_suser.9:34 org_netbsd/src/share/man/man9/select.9:51 org_netbsd/src/share/man/man9/setbit.9:46 org_netbsd/src/share/man/man9/setjmp.9:44 org_netbsd/src/share/man/man9/shutdownhook_establish.9:47 org_netbsd/src/share/man/man9/signal.9:104 org_netbsd/src/share/man/man9/skpc.9:43 org_netbsd/src/share/man/man9/sockopt.9:51 org_netbsd/src/share/man/man9/softintr.9:79 org_netbsd/src/share/man/man9/spl.9:65 org_netbsd/src/share/man/man9/splraiseipl.9:43 org_netbsd/src/share/man/man9/store.9:58 org_netbsd/src/share/man/man9/suspendsched.9:41 org_netbsd/src/share/man/man9/sysctl.9:102 org_netbsd/src/share/man/man9/sysmon_envsys.9:56 org_netbsd/src/share/man/man9/sysmon_pswitch.9:44 org_netbsd/src/share/man/man9/sysmon_taskq.9:46 org_netbsd/src/share/man/man9/tc.9:68 org_netbsd/src/share/man/man9/tcp_congctl.9:45 org_netbsd/src/share/man/man9/time_second.9:49 org_netbsd/src/share/man/man9/timecounter.9:51 org_netbsd/src/share/man/man9/todr.9:52 org_netbsd/src/share/man/man9/tvtohz.9:39 org_netbsd/src/share/man/man9/ubc.9:45 org_netbsd/src/share/man/man9/ucas.9:47 org_netbsd/src/share/man/man9/ucom.9:36 org_netbsd/src/share/man/man9/uiomove.9:37 org_netbsd/src/share/man/man9/usbdi.9:39 org_netbsd/src/share/man/man9/userret.9:41 org_netbsd/src/share/man/man9/uvm.9:36 org_netbsd/src/share/man/man9/uvm_km.9:43 org_netbsd/src/share/man/man9/uvm_map.9:73 org_netbsd/src/share/man/man9/vattr.9:42 org_netbsd/src/share/man/man9/vcons.9:43 org_netbsd/src/share/man/man9/veriexec.9:74 org_netbsd/src/share/man/man9/vfs.9:36 org_netbsd/src/share/man/man9/vfs_hooks.9:42 org_netbsd/src/share/man/man9/vfsops.9:78 org_netbsd/src/share/man/man9/vfssubr.9:99 org_netbsd/src/share/man/man9/video.9:40 org_netbsd/src/share/man/man9/vme.9:100 org_netbsd/src/share/man/man9/vmem.9:68 org_netbsd/src/share/man/man9/vnfileops.9:61 org_netbsd/src/share/man/man9/vnode.9:109 org_netbsd/src/share/man/man9/vnodeops.9:210 org_netbsd/src/share/man/man9/vnsubr.9:79 org_netbsd/src/share/man/man9/wdc.9:39 org_netbsd/src/share/man/man9/workqueue.9:53 org_netbsd/src/share/man/man9/wscons.9:36 org_netbsd/src/share/man/man9/wsdisplay.9:57 org_netbsd/src/share/man/man9/wsfont.9:68 org_netbsd/src/share/man/man9/wskbd.9:57 org_netbsd/src/share/man/man9/wsmouse.9:46 org_netbsd/src/share/man/man9/xcall.9:48 org_netbsd/src/share/man/man9/man9.i386/bios32_service.9:41 org_netbsd/src/share/man/man9/man9.i386/bioscall.9:40 org_netbsd/src/share/man/man9/man9.i386/return_address.9:40 org_netbsd/src/share/man/man9/man9.i386/splraise.9:40 org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:50 org_netbsd/src/share/man/man9/man9.x86/nmi.9:44 org_netbsd/src/share/man/man9/man9.x86/rdmsr.9:51 org_netbsd/src/share/man/man9/man9.x86/tsc.9:48 org_netbsd/src/share/man/man9/man9.x86/x86_msr_xcall.9:40
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/CTASSERT.9:45
msgid ""
"The E<.Fn CTASSERT> macro evaluates E<.Fa expression> at compile time and "
"causes a compiler error if it is false."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/CTASSERT.9:51
msgid ""
"The E<.Fn CTASSERT> macro is useful for asserting the size or alignment of "
"important data structures and variables during compilation, which would "
"otherwise cause the code to fail at run time."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/CTASSERT.9:51 org_netbsd/src/share/man/man9/accept_filter.9:65 org_netbsd/src/share/man/man9/bus_dma.9:97 org_netbsd/src/share/man/man9/pmc.9:109
#, no-wrap
msgid "IMPLEMENTATION NOTES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/CTASSERT.9:59
msgid ""
"The E<.Fn CTASSERT> macro should not be used in a header file.  It is "
"implemented using a dummy typedef, with a name (based on line number)  that "
"may conflict with a E<.Fn CTASSERT> in a source file including that header."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/CTASSERT.9:59 org_netbsd/src/share/man/man9/RUN_ONCE.9:71 org_netbsd/src/share/man/man9/accf_data.9:46 org_netbsd/src/share/man/man9/accf_http.9:76 org_netbsd/src/share/man/man9/condvar.9:232 org_netbsd/src/share/man/man9/cons.9:137 org_netbsd/src/share/man/man9/cpu_idle.9:69 org_netbsd/src/share/man/man9/ddc.9:80 org_netbsd/src/share/man/man9/dmover.9:561 org_netbsd/src/share/man/man9/edid.9:106 org_netbsd/src/share/man/man9/evcnt.9:196 org_netbsd/src/share/man/man9/extent.9:325 org_netbsd/src/share/man/man9/fileassoc.9:231 org_netbsd/src/share/man/man9/fstrans.9:170 org_netbsd/src/share/man/man9/ieee80211_radiotap.9:230 org_netbsd/src/share/man/man9/ioctl.9:290 org_netbsd/src/share/man/man9/kauth.9:1528 org_netbsd/src/share/man/man9/nullop.9:77 org_netbsd/src/share/man/man9/pci_configure_bus.9:211 org_netbsd/src/share/man/man9/ppi.9:74 org_netbsd/src/share/man/man9/pserialize.9:76 org_netbsd/src/share/man/man9/ratecheck.9:72 org_netbsd/src/share/man/man9/roundup.9:85 org_netbsd/src/share/man/man9/scsipi.9:586 org_netbsd/src/share/man/man9/secmodel.9:249 org_netbsd/src/share/man/man9/setbit.9:67 org_netbsd/src/share/man/man9/shutdownhook_establish.9:88 org_netbsd/src/share/man/man9/splraiseipl.9:68 org_netbsd/src/share/man/man9/man9.i386/bioscall.9:85 org_netbsd/src/share/man/man9/man9.x86/x86_msr_xcall.9:80
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/CTASSERT.9:63
msgid "Assert that the size of the E<.Vt uuid> structure is 16 bytes."
msgstr ""

#. type: Dl
#: org_netbsd/src/share/man/man9/CTASSERT.9:64
#, no-wrap
msgid "CTASSERT(sizeof(struct uuid) == 16);"
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/CTASSERT.9:65 org_netbsd/src/share/man/man9/KASSERT.9:109 org_netbsd/src/share/man/man9/LWP_CACHE_CREDS.9:73 org_netbsd/src/share/man/man9/RUN_ONCE.9:105 org_netbsd/src/share/man/man9/SET.9:67 org_netbsd/src/share/man/man9/STACK.9:95 org_netbsd/src/share/man/man9/accept_filter.9:139 org_netbsd/src/share/man/man9/accf_data.9:60 org_netbsd/src/share/man/man9/accf_http.9:88 org_netbsd/src/share/man/man9/altq.9:589 org_netbsd/src/share/man/man9/arp.9:117 org_netbsd/src/share/man/man9/audio.9:593 org_netbsd/src/share/man/man9/autoconf.9:409 org_netbsd/src/share/man/man9/bcmp.9:73 org_netbsd/src/share/man/man9/bcopy.9:86 org_netbsd/src/share/man/man9/bintime_add.9:97 org_netbsd/src/share/man/man9/bluetooth.9:374 org_netbsd/src/share/man/man9/boothowto.9:254 org_netbsd/src/share/man/man9/buffercache.9:340 org_netbsd/src/share/man/man9/bus_dma.9:824 org_netbsd/src/share/man/man9/bus_space.9:1971 org_netbsd/src/share/man/man9/byteorder.9:179 org_netbsd/src/share/man/man9/bzero.9:72 org_netbsd/src/share/man/man9/callback.9:111 org_netbsd/src/share/man/man9/callout.9:299 org_netbsd/src/share/man/man9/cardbus.9:319 org_netbsd/src/share/man/man9/cnmagic.9:182 org_netbsd/src/share/man/man9/condvar.9:270 org_netbsd/src/share/man/man9/config.9:332 org_netbsd/src/share/man/man9/cons.9:153 org_netbsd/src/share/man/man9/copy.9:178 org_netbsd/src/share/man/man9/coredump_write.9:72 org_netbsd/src/share/man/man9/cprng.9:252 org_netbsd/src/share/man/man9/cpu_configure.9:72 org_netbsd/src/share/man/man9/cpu_coredump.9:72 org_netbsd/src/share/man/man9/cpu_dumpconf.9:80 org_netbsd/src/share/man/man9/cpu_idle.9:81 org_netbsd/src/share/man/man9/cpu_initclocks.9:51 org_netbsd/src/share/man/man9/cpu_lwp_fork.9:99 org_netbsd/src/share/man/man9/cpu_need_resched.9:89 org_netbsd/src/share/man/man9/cpu_number.9:52 org_netbsd/src/share/man/man9/cpu_reboot.9:115 org_netbsd/src/share/man/man9/cpu_rootconf.9:60 org_netbsd/src/share/man/man9/cpu_startup.9:61 org_netbsd/src/share/man/man9/cpu_switchto.9:144 org_netbsd/src/share/man/man9/cpufreq.9:290 org_netbsd/src/share/man/man9/csf.9:201 org_netbsd/src/share/man/man9/ctod.9:75 org_netbsd/src/share/man/man9/curproc.9:78 org_netbsd/src/share/man/man9/ddc.9:101 org_netbsd/src/share/man/man9/delay.9:57 org_netbsd/src/share/man/man9/deviter.9:190 org_netbsd/src/share/man/man9/disk.9:513 org_netbsd/src/share/man/man9/disklabel.9:180 org_netbsd/src/share/man/man9/dmover.9:603 org_netbsd/src/share/man/man9/do_setresuid.9:81 org_netbsd/src/share/man/man9/dofileread.9:119 org_netbsd/src/share/man/man9/dopowerhooks.9:59 org_netbsd/src/share/man/man9/doshutdownhooks.9:66 org_netbsd/src/share/man/man9/driver.9:369 org_netbsd/src/share/man/man9/edid.9:123 org_netbsd/src/share/man/man9/errno.9:108 org_netbsd/src/share/man/man9/ethersubr.9:173 org_netbsd/src/share/man/man9/evcnt.9:292 org_netbsd/src/share/man/man9/extattr.9:84 org_netbsd/src/share/man/man9/extent.9:370 org_netbsd/src/share/man/man9/fetch.9:90 org_netbsd/src/share/man/man9/file.9:248 org_netbsd/src/share/man/man9/filedesc.9:303 org_netbsd/src/share/man/man9/firmload.9:117 org_netbsd/src/share/man/man9/flash.9:82 org_netbsd/src/share/man/man9/fork1.9:156 org_netbsd/src/share/man/man9/fsetown.9:144 org_netbsd/src/share/man/man9/fstrans.9:216 org_netbsd/src/share/man/man9/getiobuf.9:77 org_netbsd/src/share/man/man9/hardclock.9:75 org_netbsd/src/share/man/man9/hashinit.9:118 org_netbsd/src/share/man/man9/humanize_number.9:115 org_netbsd/src/share/man/man9/hz.9:107 org_netbsd/src/share/man/man9/ieee80211.9:228 org_netbsd/src/share/man/man9/ieee80211_crypto.9:84 org_netbsd/src/share/man/man9/ieee80211_input.9:96 org_netbsd/src/share/man/man9/ieee80211_ioctl.9:75 org_netbsd/src/share/man/man9/ieee80211_node.9:231 org_netbsd/src/share/man/man9/ieee80211_output.9:124 org_netbsd/src/share/man/man9/ieee80211_proto.9:60 org_netbsd/src/share/man/man9/ieee80211_radiotap.9:253 org_netbsd/src/share/man/man9/iic.9:316 org_netbsd/src/share/man/man9/imax.9:79 org_netbsd/src/share/man/man9/in4_cksum.9:96 org_netbsd/src/share/man/man9/in_getifa.9:219 org_netbsd/src/share/man/man9/inittodr.9:99 org_netbsd/src/share/man/man9/ioasic.9:209 org_netbsd/src/share/man/man9/ioctl.9:318 org_netbsd/src/share/man/man9/ipkdb.9:178 org_netbsd/src/share/man/man9/isa.9:481 org_netbsd/src/share/man/man9/isapnp.9:224 org_netbsd/src/share/man/man9/itimerfix.9:59 org_netbsd/src/share/man/man9/kauth.9:1581 org_netbsd/src/share/man/man9/kcopy.9:56 org_netbsd/src/share/man/man9/kcpuset.9:223 org_netbsd/src/share/man/man9/kfilter_register.9:123 org_netbsd/src/share/man/man9/kmem.9:253 org_netbsd/src/share/man/man9/knote.9:93 org_netbsd/src/share/man/man9/kpause.9:120 org_netbsd/src/share/man/man9/kpreempt.9:84 org_netbsd/src/share/man/man9/kprintf.9:262 org_netbsd/src/share/man/man9/kthread.9:186 org_netbsd/src/share/man/man9/linedisc.9:95 org_netbsd/src/share/man/man9/lock.9:54 org_netbsd/src/share/man/man9/log.9:63 org_netbsd/src/share/man/man9/ltsleep.9:169 org_netbsd/src/share/man/man9/m_tag.9:215 org_netbsd/src/share/man/man9/makeiplcookie.9:56 org_netbsd/src/share/man/man9/malloc.9:346 org_netbsd/src/share/man/man9/mb.9:112 org_netbsd/src/share/man/man9/mbuf.9:725 org_netbsd/src/share/man/man9/mca.9:180 org_netbsd/src/share/man/man9/memcpy.9:66 org_netbsd/src/share/man/man9/memmove.9:62 org_netbsd/src/share/man/man9/memoryallocators.9:95 org_netbsd/src/share/man/man9/mi_switch.9:106 org_netbsd/src/share/man/man9/microseq.9:493 org_netbsd/src/share/man/man9/microtime.9:155 org_netbsd/src/share/man/man9/microuptime.9:109 org_netbsd/src/share/man/man9/module.9:449 org_netbsd/src/share/man/man9/mstohz.9:62 org_netbsd/src/share/man/man9/mutex.9:248 org_netbsd/src/share/man/man9/namecache.9:207 org_netbsd/src/share/man/man9/namei.9:409 org_netbsd/src/share/man/man9/npf_ncode.9:277 org_netbsd/src/share/man/man9/opencrypto.9:608 org_netbsd/src/share/man/man9/panic.9:106 org_netbsd/src/share/man/man9/pathbuf.9:120 org_netbsd/src/share/man/man9/pci.9:771 org_netbsd/src/share/man/man9/pci_configure_bus.9:274 org_netbsd/src/share/man/man9/pckbport.9:313 org_netbsd/src/share/man/man9/pcmcia.9:416 org_netbsd/src/share/man/man9/pcq.9:127 org_netbsd/src/share/man/man9/percpu.9:150 org_netbsd/src/share/man/man9/pfil.9:146 org_netbsd/src/share/man/man9/physio.9:141 org_netbsd/src/share/man/man9/pmap.9:1125 org_netbsd/src/share/man/man9/pmc.9:244 org_netbsd/src/share/man/man9/pmf.9:286 org_netbsd/src/share/man/man9/pool.9:311 org_netbsd/src/share/man/man9/pool_cache.9:357 org_netbsd/src/share/man/man9/powerhook_establish.9:103 org_netbsd/src/share/man/man9/ppi.9:90 org_netbsd/src/share/man/man9/ppsratecheck.9:79 org_netbsd/src/share/man/man9/proc_find.9:70 org_netbsd/src/share/man/man9/pserialize.9:96 org_netbsd/src/share/man/man9/putter.9:43 org_netbsd/src/share/man/man9/radio.9:99 org_netbsd/src/share/man/man9/ras.9:125 org_netbsd/src/share/man/man9/rasops.9:206 org_netbsd/src/share/man/man9/ratecheck.9:129 org_netbsd/src/share/man/man9/resettodr.9:49 org_netbsd/src/share/man/man9/rnd.9:213 org_netbsd/src/share/man/man9/roundup.9:96 org_netbsd/src/share/man/man9/rssadapt.9:363 org_netbsd/src/share/man/man9/rt_timer.9:114 org_netbsd/src/share/man/man9/rwlock.9:210 org_netbsd/src/share/man/man9/sched_4bsd.9:86 org_netbsd/src/share/man/man9/sched_m2.9:44 org_netbsd/src/share/man/man9/secmodel.9:499 org_netbsd/src/share/man/man9/secmodel_bsd44.9:48 org_netbsd/src/share/man/man9/secmodel_extensions.9:109 org_netbsd/src/share/man/man9/secmodel_overlay.9:47 org_netbsd/src/share/man/man9/secmodel_securelevel.9:274 org_netbsd/src/share/man/man9/secmodel_suser.9:86 org_netbsd/src/share/man/man9/select.9:121 org_netbsd/src/share/man/man9/setbit.9:77 org_netbsd/src/share/man/man9/setjmp.9:68 org_netbsd/src/share/man/man9/shutdownhook_establish.9:97 org_netbsd/src/share/man/man9/signal.9:504 org_netbsd/src/share/man/man9/sockopt.9:144 org_netbsd/src/share/man/man9/softintr.9:198 org_netbsd/src/share/man/man9/spl.9:210 org_netbsd/src/share/man/man9/splraiseipl.9:98 org_netbsd/src/share/man/man9/store.9:86 org_netbsd/src/share/man/man9/sysctl.9:667 org_netbsd/src/share/man/man9/sysmon_envsys.9:695 org_netbsd/src/share/man/man9/sysmon_pswitch.9:132 org_netbsd/src/share/man/man9/sysmon_taskq.9:92 org_netbsd/src/share/man/man9/tc.9:177 org_netbsd/src/share/man/man9/tcp_congctl.9:94 org_netbsd/src/share/man/man9/time_second.9:103 org_netbsd/src/share/man/man9/timecounter.9:174 org_netbsd/src/share/man/man9/todr.9:125 org_netbsd/src/share/man/man9/tvtohz.9:49 org_netbsd/src/share/man/man9/ubc.9:129 org_netbsd/src/share/man/man9/ucas.9:77 org_netbsd/src/share/man/man9/ucom.9:207 org_netbsd/src/share/man/man9/uiomove.9:151 org_netbsd/src/share/man/man9/usbdi.9:177 org_netbsd/src/share/man/man9/userret.9:77 org_netbsd/src/share/man/man9/uvm.9:596 org_netbsd/src/share/man/man9/uvm_km.9:173 org_netbsd/src/share/man/man9/uvm_map.9:352 org_netbsd/src/share/man/man9/vattr.9:103 org_netbsd/src/share/man/man9/vcons.9:205 org_netbsd/src/share/man/man9/veriexec.9:302 org_netbsd/src/share/man/man9/vfs.9:52 org_netbsd/src/share/man/man9/vfs_hooks.9:98 org_netbsd/src/share/man/man9/vfsops.9:414 org_netbsd/src/share/man/man9/vfssubr.9:210 org_netbsd/src/share/man/man9/video.9:177 org_netbsd/src/share/man/man9/vme.9:336 org_netbsd/src/share/man/man9/vmem.9:393 org_netbsd/src/share/man/man9/vnfileops.9:183 org_netbsd/src/share/man/man9/vnode.9:745 org_netbsd/src/share/man/man9/vnodeops.9:1440 org_netbsd/src/share/man/man9/vnsubr.9:271 org_netbsd/src/share/man/man9/wdc.9:394 org_netbsd/src/share/man/man9/workqueue.9:137 org_netbsd/src/share/man/man9/wscons.9:67 org_netbsd/src/share/man/man9/wsdisplay.9:413 org_netbsd/src/share/man/man9/wsfont.9:240 org_netbsd/src/share/man/man9/wskbd.9:340 org_netbsd/src/share/man/man9/wsmouse.9:231 org_netbsd/src/share/man/man9/xcall.9:145 org_netbsd/src/share/man/man9/man9.i386/bios32_service.9:50 org_netbsd/src/share/man/man9/man9.i386/splraise.9:81 org_netbsd/src/share/man/man9/man9.x86/nmi.9:123 org_netbsd/src/share/man/man9/man9.x86/rdmsr.9:117 org_netbsd/src/share/man/man9/man9.x86/tsc.9:154 org_netbsd/src/share/man/man9/man9.x86/x86_msr_xcall.9:96
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/CTASSERT.9:67
msgid "E<.Xr KASSERT 9>"
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/CTASSERT.9:67 org_netbsd/src/share/man/man9/KASSERT.9:115 org_netbsd/src/share/man/man9/accept_filter.9:151 org_netbsd/src/share/man/man9/accf_data.9:73 org_netbsd/src/share/man/man9/accf_http.9:100 org_netbsd/src/share/man/man9/arp.9:128 org_netbsd/src/share/man/man9/bufq.9:180 org_netbsd/src/share/man/man9/bus_dma.9:841 org_netbsd/src/share/man/man9/bus_space.9:1989 org_netbsd/src/share/man/man9/cnmagic.9:191 org_netbsd/src/share/man/man9/cpufreq.9:308 org_netbsd/src/share/man/man9/csf.9:211 org_netbsd/src/share/man/man9/ddc.9:108 org_netbsd/src/share/man/man9/deviter.9:197 org_netbsd/src/share/man/man9/disk.9:522 org_netbsd/src/share/man/man9/dmover.9:611 org_netbsd/src/share/man/man9/edid.9:129 org_netbsd/src/share/man/man9/ethersubr.9:178 org_netbsd/src/share/man/man9/evcnt.9:310 org_netbsd/src/share/man/man9/extent.9:377 org_netbsd/src/share/man/man9/fileassoc.9:342 org_netbsd/src/share/man/man9/firmload.9:126 org_netbsd/src/share/man/man9/flash.9:85 org_netbsd/src/share/man/man9/fstrans.9:227 org_netbsd/src/share/man/man9/ieee80211.9:243 org_netbsd/src/share/man/man9/ieee80211_crypto.9:93 org_netbsd/src/share/man/man9/ieee80211_input.9:105 org_netbsd/src/share/man/man9/ieee80211_ioctl.9:87 org_netbsd/src/share/man/man9/ieee80211_node.9:240 org_netbsd/src/share/man/man9/ieee80211_output.9:133 org_netbsd/src/share/man/man9/ieee80211_proto.9:69 org_netbsd/src/share/man/man9/ieee80211_radiotap.9:264 org_netbsd/src/share/man/man9/iic.9:341 org_netbsd/src/share/man/man9/in_getifa.9:228 org_netbsd/src/share/man/man9/kauth.9:1604 org_netbsd/src/share/man/man9/kfilter_register.9:135 org_netbsd/src/share/man/man9/knote.9:105 org_netbsd/src/share/man/man9/linedisc.9:102 org_netbsd/src/share/man/man9/mbuf.9:736 org_netbsd/src/share/man/man9/memoryallocators.9:102 org_netbsd/src/share/man/man9/microseq.9:502 org_netbsd/src/share/man/man9/microtime.9:175 org_netbsd/src/share/man/man9/microuptime.9:113 org_netbsd/src/share/man/man9/module.9:458 org_netbsd/src/share/man/man9/namecache.9:215 org_netbsd/src/share/man/man9/percpu.9:161 org_netbsd/src/share/man/man9/pfil.9:180 org_netbsd/src/share/man/man9/pmap.9:1167 org_netbsd/src/share/man/man9/pmc.9:253 org_netbsd/src/share/man/man9/pmf.9:294 org_netbsd/src/share/man/man9/ppi.9:100 org_netbsd/src/share/man/man9/rasops.9:216 org_netbsd/src/share/man/man9/rnd.9:220 org_netbsd/src/share/man/man9/rssadapt.9:379 org_netbsd/src/share/man/man9/rt_timer.9:122 org_netbsd/src/share/man/man9/scsipi.9:596 org_netbsd/src/share/man/man9/secmodel.9:537 org_netbsd/src/share/man/man9/secmodel_bsd44.9:54 org_netbsd/src/share/man/man9/secmodel_extensions.9:118 org_netbsd/src/share/man/man9/secmodel_overlay.9:51 org_netbsd/src/share/man/man9/secmodel_securelevel.9:279 org_netbsd/src/share/man/man9/secmodel_suser.9:91 org_netbsd/src/share/man/man9/sysctl.9:672 org_netbsd/src/share/man/man9/sysmon_envsys.9:707 org_netbsd/src/share/man/man9/sysmon_pswitch.9:137 org_netbsd/src/share/man/man9/sysmon_taskq.9:96 org_netbsd/src/share/man/man9/tvtohz.9:65 org_netbsd/src/share/man/man9/ubc.9:147 org_netbsd/src/share/man/man9/uvm.9:641 org_netbsd/src/share/man/man9/veriexec.9:311 org_netbsd/src/share/man/man9/video.9:179 org_netbsd/src/share/man/man9/vmem.9:406 org_netbsd/src/share/man/man9/xcall.9:153 org_netbsd/src/share/man/man9/man9.i386/return_address.9:90 org_netbsd/src/share/man/man9/man9.x86/nmi.9:131
#, no-wrap
msgid "AUTHORS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/CTASSERT.9:70
msgid ""
"This manual page was written by E<.An Hiten M. Pandya> E<.Aq "
"hmp@FreeBSD.org>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/KASSERT.9:27
#, no-wrap
msgid "September 27, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/KASSERT.9:28
#, no-wrap
msgid "KASSERT 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/KASSERT.9:35
msgid "E<.Nm KASSERT>, E<.Nm KASSERTMSG>, E<.Nm KDASSERT>, E<.Nm KDASSERTMSG>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/KASSERT.9:35
#, no-wrap
msgid "kernel expression verification macros"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/KASSERT.9:45
msgid ""
"E<.Ft void> E<.Fn KASSERT expression> E<.Ft void> E<.Fn KASSERTMSG "
"expression format ...> E<.Ft void> E<.Fn KDASSERT expression> E<.Ft void> "
"E<.Fn KDASSERTMSG expression format ...>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/KASSERT.9:54
msgid ""
"These machine independent assertion-checking macros cause a kernel E<.Xr "
"panic 9> if the given E<.Ar expression> evaluates to false.  Two "
"compile-time E<.Xr options 4> define the behavior of the checks."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/KASSERT.9:65
msgid ""
"The E<.Fn KASSERT> and E<.Fn KASSERTMSG> tests are included only in kernels "
"compiled with the E<.Dv DIAGNOSTIC> configuration option.  In a kernel that "
"does not have this configuration option, the macros are defined to be "
"no-ops."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/KASSERT.9:86
msgid ""
"The E<.Fn KDASSERT> and E<.Fn KDASSERTMSG> tests are included only in "
"kernels compiled with the E<.Dv DEBUG> configuration option.  The E<.Fn "
"KDASSERT> and E<.Fn KASSERT> macros are identical except for the controlling "
"option E<.Pf ( Dv DEBUG> vs E<.Dv DIAGNOSTIC>).  Basically, E<.Fn KASSERT> "
"should be used for light-weight checks and E<.Fn KDASSERT> should be used "
"for heavier ones."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/KASSERT.9:93
msgid ""
"Callers should not rely on the side effects of E<.Ar expression> because, "
"depending on the kernel compile options mentioned above, E<.Ar expression> "
"might not be evaluated at all."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/KASSERT.9:109
msgid ""
"The panic message will display the style of assertion (debugging "
"vs. diagnostic), the expression that failed and the filename, and line "
"number the failure happened on.  The E<.Fn KASSERTMSG> and E<.Fn "
"KDASSERTMSG> macros append to the E<.Xr panic 9> format string the message "
"specified by E<.Fa format> and its subsequent arguments, similar to E<.Xr "
"printf 9> functions."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/KASSERT.9:115
msgid ""
"E<.Xr config 1>, E<.Xr options 4>, E<.Xr CTASSERT 9>, E<.Xr panic 9>, E<.Xr "
"printf 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/KASSERT.9:118
msgid ""
"These macros were written by E<.An Chris G. Demetriou> E<.Aq "
"cgd@netbsd.org>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/LWP_CACHE_CREDS.9:28
#, no-wrap
msgid "December 9, 2007"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/LWP_CACHE_CREDS.9:29
#, no-wrap
msgid "LWP_CACHE_CREDS 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/LWP_CACHE_CREDS.9:34
msgid "E<.Nm LWP_CACHE_CREDS>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/LWP_CACHE_CREDS.9:34
#, no-wrap
msgid "synchronize LWP credential with process credential"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/LWP_CACHE_CREDS.9:37 org_netbsd/src/share/man/man9/userret.9:37
#, no-wrap
msgid "sys/lwp.h"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/LWP_CACHE_CREDS.9:43
msgid "E<.Ft void> E<.Fn LWP_CACHE_CREDS \"lwp_t *l\" \"struct proc *p\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/LWP_CACHE_CREDS.9:47
msgid ""
"E<.Fn LWP_CACHE_CREDS> updates the LWP's cached credential to match with the "
"process' credential if the latter has been changed after the last "
"synchronization."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/LWP_CACHE_CREDS.9:52
msgid ""
"Each LWPs have its cached credential so that it can be used without worrying "
"about potential of other LWP changing the process' credential.  E<.Fn "
"kauth_cred_get> returns the cached credential."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/LWP_CACHE_CREDS.9:58
msgid ""
"E<.Fn LWP_CACHE_CREDS> is called by MD entry code for system call and "
"various traps.  LWPs which can live in kernel for long period should call "
"E<.Fn LWP_CACHE_CREDS> by itsself to refresh its credential."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/LWP_CACHE_CREDS.9:61
msgid "E<.Fn LWP_CACHE_CREDS> takes the following arguments."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/LWP_CACHE_CREDS.9:62 org_netbsd/src/share/man/man9/bus_dma.9:260
#, no-wrap
msgid "Fa l"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/LWP_CACHE_CREDS.9:64
msgid "The calling lwp."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/LWP_CACHE_CREDS.9:64 org_netbsd/src/share/man/man9/kmem.9:118
#, no-wrap
msgid "Fa p"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/LWP_CACHE_CREDS.9:68
msgid "The process which the lwp E<.Fa l> belongs to."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/LWP_CACHE_CREDS.9:73
msgid "E<.Fn LWP_CACHE_CREDS> might be implemented as a macro."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/LWP_CACHE_CREDS.9:75
msgid "E<.Xr intro 9>, E<.Xr kauth 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/RUN_ONCE.9:28
#, no-wrap
msgid "July 7, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/RUN_ONCE.9:29
#, no-wrap
msgid "RUN_ONCE 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/RUN_ONCE.9:34
msgid "E<.Nm RUN_ONCE>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/RUN_ONCE.9:34
#, no-wrap
msgid "Run a function exactly once"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/RUN_ONCE.9:37
#, no-wrap
msgid "sys/once.h"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/RUN_ONCE.9:45
msgid ""
"E<.Vt ONCE_DECL(control);> E<.Ft int> E<.Fn RUN_ONCE \"once_t *control\" "
"\"int (*init_func)(void)\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/RUN_ONCE.9:59
msgid ""
"E<.Fn RUN_ONCE> provides a functionality similar to E<.Xr pthread_once 3>.  "
"It ensures that, for a given E<.Fa control>, E<.Fn init_func> is executed "
"(successfully) exactly once.  It is considered as a successful execution if "
"and only if E<.Fn init_func> returned 0.  As long as there was no successful "
"execution, E<.Fn RUN_ONCE> will try again each time it is called."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/RUN_ONCE.9:63
msgid "E<.Fn RUN_ONCE> can sleep if it's called concurrently."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/RUN_ONCE.9:63 org_netbsd/src/share/man/man9/bcdtobin.9:51 org_netbsd/src/share/man/man9/copy.9:162 org_netbsd/src/share/man/man9/cpu_switchto.9:121 org_netbsd/src/share/man/man9/ddc.9:70 org_netbsd/src/share/man/man9/dofileread.9:113 org_netbsd/src/share/man/man9/edid.9:87 org_netbsd/src/share/man/man9/extent.9:291 org_netbsd/src/share/man/man9/fetch.9:81 org_netbsd/src/share/man/man9/filedesc.9:286 org_netbsd/src/share/man/man9/fork1.9:142 org_netbsd/src/share/man/man9/fstrans.9:164 org_netbsd/src/share/man/man9/hash.9:112 org_netbsd/src/share/man/man9/hashinit.9:106 org_netbsd/src/share/man/man9/humanize_number.9:111 org_netbsd/src/share/man/man9/in4_cksum.9:94 org_netbsd/src/share/man/man9/ioctl.9:251 org_netbsd/src/share/man/man9/itimerfix.9:52 org_netbsd/src/share/man/man9/kfilter_register.9:109 org_netbsd/src/share/man/man9/kmem.9:237 org_netbsd/src/share/man/man9/kpause.9:97 org_netbsd/src/share/man/man9/kprintf.9:248 org_netbsd/src/share/man/man9/kthread.9:167 org_netbsd/src/share/man/man9/ltsleep.9:150 org_netbsd/src/share/man/man9/makeiplcookie.9:52 org_netbsd/src/share/man/man9/malloc.9:298 org_netbsd/src/share/man/man9/memcmp.9:56 org_netbsd/src/share/man/man9/memcpy.9:60 org_netbsd/src/share/man/man9/memmove.9:57 org_netbsd/src/share/man/man9/memset.9:55 org_netbsd/src/share/man/man9/mi_switch.9:102 org_netbsd/src/share/man/man9/mstohz.9:59 org_netbsd/src/share/man/man9/opencrypto.9:576 org_netbsd/src/share/man/man9/panic.9:102 org_netbsd/src/share/man/man9/pci_configure_bus.9:197 org_netbsd/src/share/man/man9/physio.9:121 org_netbsd/src/share/man/man9/pmatch.9:65 org_netbsd/src/share/man/man9/powerhook_establish.9:97 org_netbsd/src/share/man/man9/proc_find.9:60 org_netbsd/src/share/man/man9/roundup.9:75 org_netbsd/src/share/man/man9/scanc.9:56 org_netbsd/src/share/man/man9/secmodel.9:160 org_netbsd/src/share/man/man9/shutdownhook_establish.9:82 org_netbsd/src/share/man/man9/skpc.9:54 org_netbsd/src/share/man/man9/splraiseipl.9:63 org_netbsd/src/share/man/man9/store.9:82 org_netbsd/src/share/man/man9/sysmon_taskq.9:81 org_netbsd/src/share/man/man9/tcp_congctl.9:72 org_netbsd/src/share/man/man9/todr.9:106 org_netbsd/src/share/man/man9/tvtohz.9:46 org_netbsd/src/share/man/man9/ucas.9:67 org_netbsd/src/share/man/man9/uiomove.9:144 org_netbsd/src/share/man/man9/vmem.9:372 org_netbsd/src/share/man/man9/workqueue.9:125 org_netbsd/src/share/man/man9/man9.i386/bioscall.9:77 org_netbsd/src/share/man/man9/man9.i386/return_address.9:74
#, no-wrap
msgid "RETURN VALUES"
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/RUN_ONCE.9:71
msgid ""
"On failure, E<.Fn RUN_ONCE> returns what E<.Fn init_func> returned.  "
"Otherwise, it returns 0."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/RUN_ONCE.9:80
msgid ""
"The following example shows how E<.Fn RUN_ONCE> is used.  Regardless of how "
"many times E<.Fn some_func> is executed, E<.Fn init_func> will be executed "
"exactly once."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/RUN_ONCE.9:84
#, no-wrap
msgid ""
"static int\n"
"init_func(void)\n"
"{\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/RUN_ONCE.9:88
#, no-wrap
msgid ""
"\t/*\n"
"\t * do some initialization.\n"
"\t */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/RUN_ONCE.9:91
#, no-wrap
msgid ""
"\treturn 0; /* success */\n"
"}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/RUN_ONCE.9:96
#, no-wrap
msgid ""
"int\n"
"some_func(void)\n"
"{\n"
"\tstatic ONCE_DECL(control);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/RUN_ONCE.9:98
#, no-wrap
msgid "\tRUN_ONCE(\\*[Am]control, init_func);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/RUN_ONCE.9:103
#, no-wrap
msgid ""
"\t/*\n"
"\t * we are sure that init_func has already been completed here.\n"
"\t */\n"
"}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/RUN_ONCE.9:108
msgid "E<.Xr pthread_once 3>, E<.Xr condvar 9>, E<.Xr intro 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/SET.9:30 org_netbsd/src/share/man/man9/cpu_configure.9:30 org_netbsd/src/share/man/man9/cpu_lwp_fork.9:30 org_netbsd/src/share/man/man9/cpu_number.9:30 org_netbsd/src/share/man/man9/cpu_rootconf.9:30 org_netbsd/src/share/man/man9/cpu_startup.9:30 org_netbsd/src/share/man/man9/fstrans.9:30 org_netbsd/src/share/man/man9/physio.9:30
#, no-wrap
msgid "April 13, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/SET.9:31
#, no-wrap
msgid "SET 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/SET.9:35
msgid "E<.Nm SET>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/SET.9:35
#, no-wrap
msgid "primitive bit macros"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/SET.9:37 org_netbsd/src/share/man/man9/altq.9:36 org_netbsd/src/share/man/man9/copy.9:47 org_netbsd/src/share/man/man9/cpu_dumpconf.9:40 org_netbsd/src/share/man/man9/cpu_number.9:39 org_netbsd/src/share/man/man9/cpu_rootconf.9:38 org_netbsd/src/share/man/man9/disk.9:50 org_netbsd/src/share/man/man9/fetch.9:48 org_netbsd/src/share/man/man9/fork1.9:38 org_netbsd/src/share/man/man9/hash.9:40 org_netbsd/src/share/man/man9/microseq.9:36 org_netbsd/src/share/man/man9/panic.9:37 org_netbsd/src/share/man/man9/ras.9:39 org_netbsd/src/share/man/man9/store.9:48
#, no-wrap
msgid "sys/types.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/SET.9:44
msgid ""
"E<.Ft void> E<.Fn SET \"val\" \"x\"> E<.Ft void> E<.Fn ISSET \"val\" \"x\"> "
"E<.Ft void> E<.Fn CLR \"val\" \"x\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/SET.9:46
msgid "These macros define three standard bit-operations:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/SET.9:53
msgid "E<.Fn SET> sets the bit E<.Fa x> in E<.Fa val>;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/SET.9:60
msgid "E<.Fn CLR> clears the bit E<.Fa x> in E<.Fa val>; and"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/SET.9:66
msgid "E<.Fn ISSET> returns 1 if the bit E<.Fa x> is set in E<.Fa val>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/SET.9:69
msgid "E<.Xr bits 3>"
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/SET.9:69 org_netbsd/src/share/man/man9/buffercache.9:359 org_netbsd/src/share/man/man9/cpufreq.9:311 org_netbsd/src/share/man/man9/dmover.9:618 org_netbsd/src/share/man/man9/fetch.9:93 org_netbsd/src/share/man/man9/hashinit.9:203 org_netbsd/src/share/man/man9/ieee80211_input.9:111 org_netbsd/src/share/man/man9/in4_cksum.9:106 org_netbsd/src/share/man/man9/in_getifa.9:230 org_netbsd/src/share/man/man9/inittodr.9:103 org_netbsd/src/share/man/man9/isa.9:493 org_netbsd/src/share/man/man9/kprintf.9:304 org_netbsd/src/share/man/man9/m_tag.9:220 org_netbsd/src/share/man/man9/mca.9:187 org_netbsd/src/share/man/man9/microseq.9:511 org_netbsd/src/share/man/man9/microtime.9:180 org_netbsd/src/share/man/man9/mstohz.9:66 org_netbsd/src/share/man/man9/namei.9:415 org_netbsd/src/share/man/man9/opencrypto.9:641 org_netbsd/src/share/man/man9/pathbuf.9:122 org_netbsd/src/share/man/man9/pfil.9:187 org_netbsd/src/share/man/man9/pmap.9:1200 org_netbsd/src/share/man/man9/ppi.9:108 org_netbsd/src/share/man/man9/putter.9:46 org_netbsd/src/share/man/man9/ratecheck.9:139 org_netbsd/src/share/man/man9/rnd.9:224 org_netbsd/src/share/man/man9/rssadapt.9:381 org_netbsd/src/share/man/man9/secmodel_securelevel.9:281 org_netbsd/src/share/man/man9/shutdownhook_establish.9:99 org_netbsd/src/share/man/man9/ucas.9:81 org_netbsd/src/share/man/man9/usbdi.9:189 org_netbsd/src/share/man/man9/video.9:181 org_netbsd/src/share/man/man9/vme.9:345 org_netbsd/src/share/man/man9/vmem.9:411 org_netbsd/src/share/man/man9/vnode.9:756 org_netbsd/src/share/man/man9/man9.i386/bioscall.9:124 org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:123
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/SET.9:71
msgid ""
"The rationale is to provide clarity in the source code, but arguably these "
"operations are clear enough without the use of the macros."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/STACK.9:30 org_netbsd/src/share/man/man9/ctod.9:30
#, no-wrap
msgid "April 8, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/STACK.9:31
#, no-wrap
msgid "STACK 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/STACK.9:35
msgid "E<.Nm STACK>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/STACK.9:35
#, no-wrap
msgid "stack macros"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/STACK.9:37 org_netbsd/src/share/man/man9/accept_filter.9:41 org_netbsd/src/share/man/man9/autoconf.9:54 org_netbsd/src/share/man/man9/ctod.9:37 org_netbsd/src/share/man/man9/driver.9:37 org_netbsd/src/share/man/man9/extattr.9:36 org_netbsd/src/share/man/man9/makeiplcookie.9:37 org_netbsd/src/share/man/man9/mstohz.9:35 org_netbsd/src/share/man/man9/pfil.9:41 org_netbsd/src/share/man/man9/pmap.9:37 org_netbsd/src/share/man/man9/roundup.9:37 org_netbsd/src/share/man/man9/select.9:41 org_netbsd/src/share/man/man9/setbit.9:37 org_netbsd/src/share/man/man9/splraiseipl.9:37 org_netbsd/src/share/man/man9/sysctl.9:37 org_netbsd/src/share/man/man9/uvm.9:34 org_netbsd/src/share/man/man9/uvm_km.9:34 org_netbsd/src/share/man/man9/uvm_map.9:35 org_netbsd/src/share/man/man9/vattr.9:38 org_netbsd/src/share/man/man9/vfs_hooks.9:38 org_netbsd/src/share/man/man9/vfsops.9:49 org_netbsd/src/share/man/man9/vfssubr.9:57 org_netbsd/src/share/man/man9/vnfileops.9:44 org_netbsd/src/share/man/man9/vnode.9:60 org_netbsd/src/share/man/man9/vnodeops.9:82 org_netbsd/src/share/man/man9/vnsubr.9:48
#, no-wrap
msgid "sys/param.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/STACK.9:48
msgid ""
"E<.Ft type> E<.Fn STACK_ALLOC \"sp\" \"size\"> E<.Ft type> E<.Fn STACK_MAX "
"\"sp\" \"size\"> E<.Ft type> E<.Fn STACK_ALIGN \"sp\" \"bytes\"> E<.Ft type> "
"E<.Fn STACK_GROW \"sp\" \"size\"> E<.Ft type> E<.Fn STACK_SHRINK \"sp\" "
"\"size\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/STACK.9:55
msgid ""
"A stack is an area of memory with a fixed origin but with a variable size.  "
"A stack pointer points to the most recently referenced location on the "
"stack.  Initially, when the stack has a size of zero, the stack pointer "
"points to the origin of the stack.  When data items are added to the stack, "
"the stack pointer moves away from the origin."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/STACK.9:72
msgid ""
"The E<.Fn STACK_ALLOC> macro returns a pointer to allocated stack space of "
"some E<.Fa size>.  Given the returned pointer E<.Fa sp> and E<.Fa size>, "
"E<.Fn STACK_MAX> returns the maximum stack address of the allocated stack "
"space.  The E<.Fn STACK_ALIGN> macro can be used to align the stack pointer "
"E<.Fa sp> by the specified amount of E<.Fa bytes>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/STACK.9:90
msgid ""
"Two basic operations are common to all stacks: a data item is added E<.Pq Dq "
"push> to the location pointed by E<.Fa sp> or a data item is removed E<.Pq "
"Dq pop> from the stack.  The stack pointer must be subsequently adjusted by "
"the size of the data item.  The E<.Fn STACK_GROW> and E<.Fn STACK_SHRINK> "
"macros adjust the stack pointer E<.Fa sp> by given E<.Fa size>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/STACK.9:95
msgid ""
"A stack may grow either up or down.  The described macros take this into "
"account by using the E<.Dv __MACHINE_STACK_GROWS_UP> preprocessor define."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/STACK.9:97
msgid "E<.Xr param 3>, E<.Xr queue 3>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/accept_filter.9:29
#, no-wrap
msgid "November 12, 2008"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/accept_filter.9:30
#, no-wrap
msgid "ACCEPT_FILTER 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accept_filter.9:38
msgid ""
"E<.Nm accept_filter>, E<.Nm accept_filt_add>, E<.Nm accept_filt_del>, E<.Nm "
"accept_filt_generic_mod_event>, E<.Nm accept_filt_get>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/accept_filter.9:38
#, no-wrap
msgid "filter incoming connections"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accept_filter.9:41
msgid "E<.Fd #define ACCEPT_FILTER_MOD>"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/accept_filter.9:42 org_netbsd/src/share/man/man9/hz.9:41 org_netbsd/src/share/man/man9/time_second.9:47
#, no-wrap
msgid "sys/kernel.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/accept_filter.9:43 org_netbsd/src/share/man/man9/sysctl.9:38
#, no-wrap
msgid "sys/sysctl.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/accept_filter.9:44 org_netbsd/src/share/man/man9/coredump_write.9:37 org_netbsd/src/share/man/man9/cpu_coredump.9:37 org_netbsd/src/share/man/man9/signal.9:60
#, no-wrap
msgid "sys/signalvar.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/accept_filter.9:45 org_netbsd/src/share/man/man9/sockopt.9:38
#, no-wrap
msgid "sys/socketvar.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/accept_filter.9:46
#, no-wrap
msgid "netinet/accept_filter.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accept_filter.9:55
msgid ""
"E<.Ft int> E<.Fn accept_filt_add \"struct accept_filter *filt\"> E<.Ft int> "
"E<.Fn accept_filt_del \"char *name\"> E<.Ft int> E<.Fn "
"accept_filt_generic_mod_event \"module_t mod\" \"int event\" \"void *data\"> "
"E<.Ft struct accept_filter *> E<.Fn accept_filt_get \"char *name\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accept_filter.9:65
msgid ""
"Accept filters allow an application to request that the kernel pre-process "
"incoming connections.  This manual page describes the kernel interface for "
"accept filters.  User applications request accept filters via the E<.Xr "
"setsockopt 2> system call, passing in an E<.Fa optname> of E<.Dv "
"SO_ACCEPTFILTER>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accept_filter.9:70
msgid ""
"A module that wants to be an accept filter must provide a E<.Vt \"struct "
"accept_filter\"> to the system:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accept_filter.9:78
#, no-wrap
msgid ""
"struct accept_filter {\n"
"\tchar\taccf_name[16];\n"
"\tvoid\t(*accf_callback)(struct socket *so, void *arg, int waitflag);\n"
"\tvoid *\t(*accf_create)(struct socket *so, char *arg);\n"
"\tvoid\t(*accf_destroy)(struct socket *so);\n"
"\tSLIST_ENTRY(accept_filter) accf_next;\t/* next on the list */\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accept_filter.9:86
msgid ""
"The module should register it with the function E<.Fn accept_filt_add>, "
"passing a pointer to a E<.Vt \"struct accept_filter\">, allocated with E<.Xr "
"malloc 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accept_filter.9:96
msgid ""
"The accept filters currently provided with E<.Nx> E<.Xr ( accf_data 9> and "
"E<.Xr accf_http 9>)  are implemented as pseudo-devices, but an accept filter "
"may use any supported means of initializing and registering itself at system "
"startup or later, including the module framework if supported by the running "
"kernel."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accept_filter.9:100
msgid "The fields of E<.Vt \"struct accept_filter\"> are as follows:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/accept_filter.9:101
#, no-wrap
msgid "Va accf_name"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accept_filter.9:104
msgid "Name of the filter; this is how it will be accessed from userland."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/accept_filter.9:104
#, no-wrap
msgid "Va accf_callback"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accept_filter.9:111
msgid ""
"The callback that the kernel will do once the connection is established.  It "
"is the same as a socket upcall and will be called when the connection is "
"established and whenever new data arrives on the socket, unless the callback "
"modifies the socket's flags."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/accept_filter.9:111
#, no-wrap
msgid "Va accf_create"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accept_filter.9:116
msgid ""
"Called whenever a E<.Xr setsockopt 2> installs the filter onto a listening "
"socket."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/accept_filter.9:116
#, no-wrap
msgid "Va accf_destroy"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accept_filter.9:118
msgid "Called whenever the user removes the accept filter on the socket."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accept_filter.9:128
msgid ""
"The E<.Fn accept_filt_del> function passed the same string used in E<.Va "
"accept_filter.accf_name> during registration with E<.Fn accept_filt_add>, "
"the kernel will then disallow and further userland use of the filter."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accept_filter.9:134
msgid ""
"The E<.Fn accept_filt_get> function is used internally to locate which "
"accept filter to use via the E<.Xr setsockopt 2> system call."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accept_filter.9:139
msgid ""
"The E<.Fn accept_filt_generic_mod_event> function can be used by accept "
"filters which are loadable kernel modules to add and delete themselves."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accept_filter.9:144
msgid "E<.Xr setsockopt 2>, E<.Xr accf_data 9>, E<.Xr accf_http 9>, E<.Xr malloc 9>"
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/accept_filter.9:144 org_netbsd/src/share/man/man9/accf_data.9:64 org_netbsd/src/share/man/man9/accf_http.9:91 org_netbsd/src/share/man/man9/altq.9:595 org_netbsd/src/share/man/man9/arp.9:125 org_netbsd/src/share/man/man9/audio.9:595 org_netbsd/src/share/man/man9/autoconf.9:415 org_netbsd/src/share/man/man9/bluetooth.9:379 org_netbsd/src/share/man/man9/boothowto.9:278 org_netbsd/src/share/man/man9/bufq.9:175 org_netbsd/src/share/man/man9/bus_dma.9:836 org_netbsd/src/share/man/man9/bus_space.9:1974 org_netbsd/src/share/man/man9/byteorder.9:182 org_netbsd/src/share/man/man9/callout.9:304 org_netbsd/src/share/man/man9/cardbus.9:328 org_netbsd/src/share/man/man9/cnmagic.9:185 org_netbsd/src/share/man/man9/condvar.9:286 org_netbsd/src/share/man/man9/config.9:345 org_netbsd/src/share/man/man9/cprng.9:265 org_netbsd/src/share/man/man9/cpufreq.9:303 org_netbsd/src/share/man/man9/csf.9:206 org_netbsd/src/share/man/man9/ctod.9:77 org_netbsd/src/share/man/man9/ddc.9:105 org_netbsd/src/share/man/man9/deviter.9:193 org_netbsd/src/share/man/man9/disk.9:517 org_netbsd/src/share/man/man9/dmover.9:606 org_netbsd/src/share/man/man9/do_setresuid.9:89 org_netbsd/src/share/man/man9/edid.9:126 org_netbsd/src/share/man/man9/errno.9:111 org_netbsd/src/share/man/man9/ethersubr.9:175 org_netbsd/src/share/man/man9/evcnt.9:294 org_netbsd/src/share/man/man9/extent.9:372 org_netbsd/src/share/man/man9/fileassoc.9:337 org_netbsd/src/share/man/man9/firmload.9:121 org_netbsd/src/share/man/man9/fsetown.9:150 org_netbsd/src/share/man/man9/fstrans.9:222 org_netbsd/src/share/man/man9/hash.9:116 org_netbsd/src/share/man/man9/hashinit.9:125 org_netbsd/src/share/man/man9/humanize_number.9:117 org_netbsd/src/share/man/man9/ieee80211.9:236 org_netbsd/src/share/man/man9/ieee80211_crypto.9:86 org_netbsd/src/share/man/man9/ieee80211_input.9:98 org_netbsd/src/share/man/man9/ieee80211_ioctl.9:80 org_netbsd/src/share/man/man9/ieee80211_node.9:233 org_netbsd/src/share/man/man9/ieee80211_output.9:126 org_netbsd/src/share/man/man9/ieee80211_proto.9:62 org_netbsd/src/share/man/man9/ieee80211_radiotap.9:256 org_netbsd/src/share/man/man9/iic.9:333 org_netbsd/src/share/man/man9/intro.9:646 org_netbsd/src/share/man/man9/isa.9:488 org_netbsd/src/share/man/man9/isapnp.9:237 org_netbsd/src/share/man/man9/kauth.9:1583 org_netbsd/src/share/man/man9/kcpuset.9:225 org_netbsd/src/share/man/man9/kfilter_register.9:128 org_netbsd/src/share/man/man9/knote.9:96 org_netbsd/src/share/man/man9/kprintf.9:271 org_netbsd/src/share/man/man9/kthread.9:191 org_netbsd/src/share/man/man9/linedisc.9:97 org_netbsd/src/share/man/man9/lock.9:58 org_netbsd/src/share/man/man9/ltsleep.9:176 org_netbsd/src/share/man/man9/mb.9:118 org_netbsd/src/share/man/man9/microseq.9:497 org_netbsd/src/share/man/man9/module.9:452 org_netbsd/src/share/man/man9/mutex.9:265 org_netbsd/src/share/man/man9/namecache.9:212 org_netbsd/src/share/man/man9/npf_ncode.9:280 org_netbsd/src/share/man/man9/opencrypto.9:622 org_netbsd/src/share/man/man9/optstr.9:79 org_netbsd/src/share/man/man9/pci.9:780 org_netbsd/src/share/man/man9/pci_configure_bus.9:277 org_netbsd/src/share/man/man9/pckbport.9:319 org_netbsd/src/share/man/man9/pcmcia.9:429 org_netbsd/src/share/man/man9/pcq.9:130 org_netbsd/src/share/man/man9/percpu.9:156 org_netbsd/src/share/man/man9/pfil.9:148 org_netbsd/src/share/man/man9/pmap.9:1127 org_netbsd/src/share/man/man9/pmc.9:248 org_netbsd/src/share/man/man9/pmf.9:289 org_netbsd/src/share/man/man9/pool.9:317 org_netbsd/src/share/man/man9/ppi.9:96 org_netbsd/src/share/man/man9/ppsratecheck.9:84 org_netbsd/src/share/man/man9/pserialize.9:108 org_netbsd/src/share/man/man9/ras.9:139 org_netbsd/src/share/man/man9/rasops.9:211 org_netbsd/src/share/man/man9/ratecheck.9:134 org_netbsd/src/share/man/man9/rnd.9:217 org_netbsd/src/share/man/man9/rssadapt.9:375 org_netbsd/src/share/man/man9/rt_timer.9:117 org_netbsd/src/share/man/man9/rwlock.9:223 org_netbsd/src/share/man/man9/scanc.9:61 org_netbsd/src/share/man/man9/scsipi.9:591 org_netbsd/src/share/man/man9/secmodel.9:507 org_netbsd/src/share/man/man9/skpc.9:59 org_netbsd/src/share/man/man9/sockopt.9:147 org_netbsd/src/share/man/man9/softintr.9:206 org_netbsd/src/share/man/man9/spl.9:216 org_netbsd/src/share/man/man9/sysctl.9:669 org_netbsd/src/share/man/man9/sysmon_envsys.9:698 org_netbsd/src/share/man/man9/timecounter.9:190 org_netbsd/src/share/man/man9/tvtohz.9:55 org_netbsd/src/share/man/man9/ubc.9:144 org_netbsd/src/share/man/man9/ucom.9:213 org_netbsd/src/share/man/man9/usbdi.9:179 org_netbsd/src/share/man/man9/uvm.9:618 org_netbsd/src/share/man/man9/uvm_km.9:180 org_netbsd/src/share/man/man9/uvm_map.9:357 org_netbsd/src/share/man/man9/vfs_hooks.9:102 org_netbsd/src/share/man/man9/vfsops.9:421 org_netbsd/src/share/man/man9/vme.9:342 org_netbsd/src/share/man/man9/vnodeops.9:1448 org_netbsd/src/share/man/man9/xcall.9:148 org_netbsd/src/share/man/man9/man9.i386/bioscall.9:119 org_netbsd/src/share/man/man9/man9.i386/return_address.9:85 org_netbsd/src/share/man/man9/man9.x86/nmi.9:126
#, no-wrap
msgid "HISTORY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accept_filter.9:151
msgid ""
"The accept filter mechanism was introduced in E<.Fx 4.0>.  It was ported to "
"E<.Nx> by Coyote Point Systems, Inc. and appeared in E<.Nx 5.0>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accept_filter.9:158
msgid ""
"This manual page was written by E<.An -nosplit> E<.An Alfred Perlstein>, "
"E<.An Sheldon Hearn>, and E<.An Jeroen Ruigrok van der Werven>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accept_filter.9:163
msgid ""
"The accept filter concept was pioneered by E<.An David Filo> at Yahoo!\\& "
"and refined to be a loadable module system by E<.An Alfred Perlstein>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/accf_data.9:29
#, no-wrap
msgid "August 10, 2008"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/accf_data.9:30
#, no-wrap
msgid "ACCF_DATA 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accf_data.9:34
msgid "E<.Nm accf_data>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/accf_data.9:34
#, no-wrap
msgid "buffer incoming connections until data arrives"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accf_data.9:38
msgid "E<.Cd \"options INET\"> E<.Cd \"pseudo-device accf_data\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accf_data.9:42
msgid ""
"This is a filter to be placed on a socket that will be using E<.Fn accept> "
"to receive incoming connections."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accf_data.9:46
msgid ""
"It prevents the application from receiving the connected descriptor via "
"E<.Fn accept> until data arrives on the connection."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accf_data.9:53
msgid ""
"If the E<.Nm> accept filter is present in the kernel configuration, this "
"will enable the data accept filter on the socket E<.Fa sok>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accf_data.9:55 org_netbsd/src/share/man/man9/accf_http.9:83
#, no-wrap
msgid "\tstruct accept_filter_arg afa;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accf_data.9:59
#, no-wrap
msgid ""
"\tbzero(\\*[Am]afa, sizeof(afa));\n"
"\tstrcpy(afa.af_name, \"dataready\");\n"
"\tsetsockopt(sok, SOL_SOCKET, SO_ACCEPTFILTER, \\*[Am]afa, sizeof(afa));\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accf_data.9:64
msgid "E<.Xr setsockopt 2>, E<.Xr accept_filter 9>, E<.Xr accf_http 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accf_data.9:73 org_netbsd/src/share/man/man9/accf_http.9:100
msgid ""
"The accept filter mechanism and the E<.Nm> filter were introduced in E<.Fx "
"4.0>.  They were ported to E<.Nx> by Coyote Point Systems and appeared in "
"E<.Nx 5.0>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accf_data.9:75 org_netbsd/src/share/man/man9/accf_http.9:102
msgid "This manual page and the filter were written by E<.An Alfred Perlstein>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/accf_http.9:29
#, no-wrap
msgid "September 4, 2008"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/accf_http.9:30
#, no-wrap
msgid "ACCF_HTTP 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accf_http.9:34
msgid "E<.Nm accf_http>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/accf_http.9:34
#, no-wrap
msgid "buffer incoming connections until a certain complete HTTP requests arrive"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accf_http.9:38
msgid "E<.Cd \"options INET\"> E<.Cd \"pseudo-device accf_http\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accf_http.9:42
msgid ""
"This is a filter to be placed on a socket that will be using E<.Fn accept> "
"to receive incoming HTTP connections."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accf_http.9:53
msgid ""
"Once installed on a listening socket, this filter is activated when a "
"connection becomes ready to receive data (at which point E<.Xr accept 2> "
"would usually return the connected descriptor to the application).  The "
"filter prevents the descriptor from being returned immediately to the "
"application via E<.Xr accept 2>.  The descriptor is made available to the "
"application via E<.Xr accept 2> only when one of the following conditions is "
"met:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accf_http.9:57
msgid ""
"A complete, syntactically valid HTTP/1.0 or HTTP/1.1 HEAD or GET request has "
"been buffered by the kernel."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accf_http.9:60
msgid ""
"The data buffered by the kernel cannot be part of a complete, syntactically "
"valid HTTP 1.0 or HTTP/1.1 HEAD or GET request."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accf_http.9:76
msgid ""
"The utility of E<.Nm> is that a server will not have to context switch "
"several times before performing the initial parsing of the request.  This "
"effectively reduces the amount of required CPU utilization to handle "
"incoming requests by keeping active processes in preforking servers such as "
"Apache low and reducing the size of the file descriptor set that needs to be "
"managed by interfaces such as E<.Fn select>, E<.Fn poll> or E<.Fn kevent> "
"based servers."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accf_http.9:81
msgid ""
"If the accf_data accept filter is present in the kernel configuration, this "
"will enable the http accept filter on the socket E<.Fa sok>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accf_http.9:87
#, no-wrap
msgid ""
"\tbzero(\\*[Am]afa, sizeof(afa));\n"
"\tstrcpy(afa.af_name, \"httpready\");\n"
"\tsetsockopt(sok, SOL_SOCKET, SO_ACCEPTFILTER, \\*[Am]afa, sizeof(afa));\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/accf_http.9:91
msgid "E<.Xr setsockopt 2>, E<.Xr accept_filter 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/altq.9:28
#, no-wrap
msgid "October 12, 2006"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/altq.9:29
#, no-wrap
msgid "ALTQ 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:34
msgid "E<.Nm ALTQ>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/altq.9:34
#, no-wrap
msgid "kernel interfaces for manipulating output queues on network interfaces"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/altq.9:37
#, no-wrap
msgid "sys/socket.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/altq.9:38 org_netbsd/src/share/man/man9/pfil.9:43
#, no-wrap
msgid "net/if.h"
msgstr ""

#. macro
#. macro
#. macro
#. macro
#. macro
#. macro
#. macro
#. macro
#. macro
#. macro
#. macro
#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:61
msgid ""
"E<.Ft void > E<.Fn IFQ_ENQUEUE \"struct ifaltq *ifq\" \"struct mbuf *m\" "
"\"struct altq_pktattr *pattr\" \"int err\"> E<.Ft void > E<.Fn IFQ_DEQUEUE "
"\"struct ifaltq *ifq\" \"struct mbuf *m\"> E<.Ft void > E<.Fn IFQ_POLL "
"\"struct ifaltq *ifq\" \"struct mbuf *m\"> E<.Ft void > E<.Fn IFQ_PURGE "
"\"struct ifaltq *ifq\"> E<.Ft void > E<.Fn IFQ_CLASSIFY \"struct ifaltq "
"*ifq\" \"struct mbuf *m\" \"int af\" \"struct altq_pktattr *pattr\"> E<.Ft "
"void > E<.Fn IFQ_IS_EMPTY \"struct ifaltq *ifq\"> E<.Ft void > E<.Fn "
"IFQ_SET_MAXLEN \"struct ifaltq *ifq\" \"int len\"> E<.Ft void > E<.Fn "
"IFQ_INC_LEN \"struct ifaltq *ifq\"> E<.Ft void > E<.Fn IFQ_DEC_LEN \"struct "
"ifaltq *ifq\"> E<.Ft void > E<.Fn IFQ_INC_DROPS \"struct ifaltq *ifq\"> "
"E<.Ft void > E<.Fn IFQ_SET_READY \"struct ifaltq *ifq\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:75
msgid ""
"The E<.Nm> system is a framework to manage queueing disciplines on network "
"interfaces.  E<.Nm> introduces new macros to manipulate output queues.  The "
"output queue macros are used to abstract queue operations and not to touch "
"the internal fields of the output queue structure.  The macros are "
"independent from the E<.Nm> implementation, and compatible with the "
"traditional E<.Dv ifqueue> macros for ease of transition."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:92
msgid ""
"E<.Fn IFQ_ENQUEUE> enqueues a packet E<.Fa m> to the queue E<.Fa ifq>.  The "
"underlying queueing discipline may discard the packet.  E<.Fa err> is set to "
"0 on success, or E<.Dv ENOBUFS> if the packet is discarded.  E<.Fa m> will "
"be freed by the device driver on success or by the queueing discipline on "
"failure, so that the caller should not touch E<.Fa m> after calling E<.Fn "
"IFQ_ENQUEUE>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:107
msgid ""
"E<.Fn IFQ_DEQUEUE> dequeues a packet from the queue.  The dequeued packet is "
"returned in E<.Fa m>, or E<.Fa m> is set to E<.Dv NULL> if no packet is "
"dequeued.  The caller must always check E<.Fa m> since a non-empty queue "
"could return E<.Dv NULL> under rate-limiting."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:115
msgid ""
"E<.Fn IFQ_POLL> returns the next packet without removing it from the queue.  "
"It is guaranteed by the underlying queueing discipline that E<.Fn "
"IFQ_DEQUEUE> immediately after E<.Fn IFQ_POLL> returns the same packet."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:120
msgid ""
"E<.Fn IFQ_PURGE> discards all the packets in the queue.  The purge operation "
"is needed since a non-work conserving queue cannot be emptied by a dequeue "
"loop."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:124
msgid ""
"E<.Fn IFQ_CLASSIFY> classifies a packet to a scheduling class, and returns "
"the result in E<.Fa pattr>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:132
msgid ""
"E<.Fn IFQ_IS_EMPTY> can be used to check if the queue is empty.  Note that "
"E<.Fn IFQ_DEQUEUE> could still return E<.Dv NULL> if the queueing discipline "
"is non-work conserving."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:135
msgid "E<.Fn IFQ_SET_MAXLEN> sets the queue length limit to the default FIFO queue."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:140
msgid ""
"E<.Fn IFQ_INC_LEN> and E<.Fn IFQ_DEC_LEN> increment or decrement the current "
"queue length in packets."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:145
msgid ""
"E<.Fn IFQ_INC_DROPS> increments the drop counter and is equal to E<.Fn "
"IF_DROP>.  It is defined for naming consistency."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:150
msgid ""
"E<.Fn IFQ_SET_READY> sets a flag to indicate this driver is converted to use "
"the new macros.  E<.Nm> can be enabled only on interfaces with this flag."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/altq.9:150 org_netbsd/src/share/man/man9/bus_space.9:1959
#, no-wrap
msgid "COMPATIBILITY"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/altq.9:151
#, no-wrap
msgid "ifaltq structure"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:164
msgid ""
"In order to keep compatibility with the existing code, the new output queue "
"structure E<.Dv ifaltq> has the same fields.  The traditional E<.Fn IF_XXX> "
"macros and the code directly referencing the fields within E<.Dv if_snd> "
"still work with E<.Dv ifaltq>.  (Once we finish conversions of all the "
"drivers, we no longer need these fields.)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:177
#, no-wrap
msgid ""
"            ##old-style##                           ##new-style##\n"
"                                       |\n"
" struct ifqueue {                      | struct ifaltq {\n"
"    struct mbuf *ifq_head;             |    struct mbuf *ifq_head;\n"
"    struct mbuf *ifq_tail;             |    struct mbuf *ifq_tail;\n"
"    int          ifq_len;              |    int          ifq_len;\n"
"    int          ifq_maxlen;           |    int          ifq_maxlen;\n"
"    int          ifq_drops;            |    int          ifq_drops;\n"
" };                                    |    /* altq related fields */\n"
"                                       |    ......\n"
"                                       | };\n"
"                                       |\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:182
msgid "The new structure replaces E<.Dv struct ifqueue> in E<.Dv struct ifnet>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:193
#, no-wrap
msgid ""
"            ##old-style##                           ##new-style##\n"
"                                       |\n"
" struct ifnet {                        | struct ifnet {\n"
"     ....                              |     ....\n"
"                                       |\n"
"     struct ifqueue if_snd;            |     struct ifaltq if_snd;\n"
"                                       |\n"
"     ....                              |     ....\n"
" };                                    | };\n"
"                                       |\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:197
msgid "The (simplified) new E<.Fn IFQ_XXX> macros looks like:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:207
#, no-wrap
msgid ""
"\t#ifdef ALTQ\n"
"\t#define IFQ_DEQUEUE(ifq, m)\t\t\t\\e\n"
"\t\tif (ALTQ_IS_ENABLED((ifq))\t\t\\e\n"
"\t\t\tALTQ_DEQUEUE((ifq), (m));\t\\e\n"
"\t\telse\t\t\t\t\t\\e\n"
"\t\t\tIF_DEQUEUE((ifq), (m));\n"
"\t#else\n"
"\t#define IFQ_DEQUEUE(ifq, m)\tIF_DEQUEUE((ifq), (m));\n"
"\t#endif\n"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/altq.9:208
#, no-wrap
msgid "Enqueue operation"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:215
msgid ""
"The semantics of the enqueue operation are changed.  In the new style, "
"enqueue and packet drop are combined since they cannot be easily separated "
"in many queueing disciplines.  The new enqueue operation corresponds to the "
"following macro that is written with the old macros."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:232
#, no-wrap
msgid ""
"#define\tIFQ_ENQUEUE(ifq, m, pattr, err)                   \\e\n"
"do {                                                      \\e\n"
"        if (ALTQ_IS_ENABLED((ifq)))                       \\e\n"
"                ALTQ_ENQUEUE((ifq), (m), (pattr), (err)); \\e\n"
"        else {                                            \\e\n"
"                if (IF_QFULL((ifq))) {                    \\e\n"
"                        m_freem((m));                     \\e\n"
"                        (err) = ENOBUFS;                  \\e\n"
"                } else {                                  \\e\n"
"                        IF_ENQUEUE((ifq), (m));           \\e\n"
"                        (err) = 0;                        \\e\n"
"                }                                         \\e\n"
"        }                                                 \\e\n"
"        if ((err))                                        \\e\n"
"                (ifq)-\\*[Gt]ifq_drops++;                       \\e\n"
"} while (/*CONSTCOND*/ 0)\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:236
msgid "E<.Fn IFQ_ENQUEUE> does the following:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:239
msgid "queue a packet"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:241
msgid "drop (and free) a packet if the enqueue operation fails"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:258
msgid ""
"If the enqueue operation fails, E<.Fa err> is set to E<.Dv ENOBUFS>.  E<.Fa "
"m> is freed by the queueing discipline.  The caller should not touch mbuf "
"after calling E<.Fn IFQ_ENQUEUE> so that the caller may need to copy E<.Fa "
"m_pkthdr.len> or E<.Fa m_flags> field beforehand for statistics.  The caller "
"should not use E<.Fn senderr> since mbuf was already freed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:262
msgid "The new style E<.Fn if_output> looks as follows:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:297
#, no-wrap
msgid ""
"            ##old-style##                           ##new-style##\n"
"                                       |\n"
" int                                   | int\n"
" ether_output(ifp, m0, dst, rt0)       | ether_output(ifp, m0, dst, rt0)\n"
" {                                     | {\n"
"     ......                            |     ......\n"
"                                       |\n"
"                                       |     mflags = m-\\*[Gt]m_flags;\n"
"                                       |     len = m-\\*[Gt]m_pkthdr.len;\n"
"     s = splimp();                     |     s = splimp();\n"
"     if (IF_QFULL(\\*[Am]ifp-\\*[Gt]if_snd)) {     |     "
"IFQ_ENQUEUE(\\*[Am]ifp-\\*[Gt]if_snd, m,\n"
"                                       |                 NULL, error);\n"
"         IF_DROP(\\*[Am]ifp-\\*[Gt]if_snd);        |     if (error != 0) {\n"
"         splx(s);                      |         splx(s);\n"
"         senderr(ENOBUFS);             |         return (error);\n"
"     }                                 |     }\n"
"     IF_ENQUEUE(\\*[Am]ifp-\\*[Gt]if_snd, m);      |\n"
"     ifp-\\*[Gt]if_obytes +=                 |     ifp-\\*[Gt]if_obytes += "
"len;\n"
"                    m-\\*[Gt]m_pkthdr.len;   |\n"
"     if (m-\\*[Gt]m_flags \\*[Am] M_MCAST)         |     if (mflags \\*[Am] "
"M_MCAST)\n"
"         ifp-\\*[Gt]if_omcasts++;            |         "
"ifp-\\*[Gt]if_omcasts++;\n"
"                                       |\n"
"     if ((ifp-\\*[Gt]if_flags \\*[Am] IFF_OACTIVE) |     if "
"((ifp-\\*[Gt]if_flags \\*[Am] IFF_OACTIVE)\n"
"         == 0)                         |         == 0)\n"
"         (*ifp-\\*[Gt]if_start)(ifp);        |         "
"(*ifp-\\*[Gt]if_start)(ifp);\n"
"     splx(s);                          |     splx(s);\n"
"     return (error);                   |     return (error);\n"
"                                       |\n"
" bad:                                  | bad:\n"
"     if (m)                            |     if (m)\n"
"         m_freem(m);                   |         m_freem(m);\n"
"     return (error);                   |     return (error);\n"
" }                                     | }\n"
"                                       |\n"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/altq.9:298
#, no-wrap
msgid "Classifier"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:305
msgid ""
"The classifier mechanism is currently implemented in E<.Fn if_output>.  "
"E<.Dv struct altq_pktattr> is used to store the classifier result, and it is "
"passed to the enqueue function.  (We will change the method to tag the "
"classifier result to mbuf in the future.)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:311
#, no-wrap
msgid ""
"int\n"
"ether_output(ifp, m0, dst, rt0)\n"
"{\n"
"\t......\n"
"\tstruct altq_pktattr pktattr;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:313
#, no-wrap
msgid "\t......\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:316
#, no-wrap
msgid ""
"\t/* classify the packet before prepending link-headers */\n"
"\tIFQ_CLASSIFY(\\*[Am]ifp-\\*[Gt]if_snd, m, dst-\\*[Gt]sa_family, "
"\\*[Am]pktattr);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:319
#, no-wrap
msgid ""
"\t/* prepend link-level headers */\n"
"\t......\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:321
#, no-wrap
msgid "\tIFQ_ENQUEUE(\\*[Am]ifp-\\*[Gt]if_snd, m, \\*[Am]pktattr, error);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:324
#, no-wrap
msgid ""
"\t......\n"
"}\n"
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/altq.9:325
#, no-wrap
msgid "HOW TO CONVERT THE EXISTING DRIVERS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:329
msgid ""
"First, make sure the corresponding E<.Fn if_output> is already converted to "
"the new style."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:335
msgid ""
"Look for E<.Fa if_snd> in the driver.  You will probably need to make "
"changes to the lines that include E<.Fa if_snd>."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/altq.9:335
#, no-wrap
msgid "Empty check operation"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:340
msgid ""
"If the code checks E<.Fa ifq_head> to see whether the queue is empty or not, "
"use E<.Fn IFQ_IS_EMPTY>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:345
#, no-wrap
msgid ""
"            ##old-style##                           ##new-style##\n"
"                                       |\n"
" if (ifp-\\*[Gt]if_snd.ifq_head != NULL)     | if "
"(IFQ_IS_EMPTY(\\*[Am]ifp-\\*[Gt]if_snd) == 0)\n"
"                                       |\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:364
msgid ""
"Note that E<.Fn IFQ_POLL> can be used for the same purpose, but E<.Fn "
"IFQ_POLL> could be costly for a complex scheduling algorithm since E<.Fn "
"IFQ_POLL> needs to run the scheduling algorithm to select the next packet.  "
"On the other hand, E<.Fn IFQ_IS_EMPTY> checks only if there is any packet "
"stored in the queue.  Another difference is that even when E<.Fn "
"IFQ_IS_EMPTY> is E<.Dv false>, E<.Fn IFQ_DEQUEUE> could still return E<.Dv "
"NULL> if the queue is under rate-limiting."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/altq.9:364
#, no-wrap
msgid "Dequeue operation"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:380
msgid ""
"Replace E<.Fn IF_DEQUEUE> by E<.Fn IFQ_DEQUEUE>.  Always check whether the "
"dequeued mbuf is E<.Dv NULL> or not.  Note that even when E<.Fn "
"IFQ_IS_EMPTY> is E<.Dv false>, E<.Fn IFQ_DEQUEUE> could return E<.Dv NULL> "
"due to rate-limiting."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:387
#, no-wrap
msgid ""
"            ##old-style##                           ##new-style##\n"
"                                       |\n"
" IF_DEQUEUE(\\*[Am]ifp-\\*[Gt]if_snd, m);          | "
"IFQ_DEQUEUE(\\*[Am]ifp-\\*[Gt]if_snd, m);\n"
"                                       | if (m == NULL)\n"
"                                       |     return;\n"
"                                       |\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:391
msgid ""
"A driver is supposed to call E<.Fn if_start> from transmission complete "
"interrupts in order to trigger the next dequeue."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/altq.9:391
#, no-wrap
msgid "Poll-and-dequeue operation"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:397
msgid ""
"If the code polls the packet at the head of the queue and actually uses the "
"packet before dequeueing it, use E<.Fn IFQ_POLL> and E<.Fn IFQ_DEQUEUE>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:412
#, no-wrap
msgid ""
"            ##old-style##                           ##new-style##\n"
"                                       |\n"
" m = ifp-\\*[Gt]if_snd.ifq_head;             | "
"IFQ_POLL(\\*[Am]ifp-\\*[Gt]if_snd, m);\n"
" if (m != NULL) {                      | if (m != NULL) {\n"
"                                       |\n"
"     /* use m to get resources */      |     /* use m to get resources */\n"
"     if (something goes wrong)         |     if (something goes wrong)\n"
"         return;                       |         return;\n"
"                                       |\n"
"     IF_DEQUEUE(\\*[Am]ifp-\\*[Gt]if_snd, m);      |     "
"IFQ_DEQUEUE(\\*[Am]ifp-\\*[Gt]if_snd, m);\n"
"                                       |\n"
"     /* kick the hardware */           |     /* kick the hardware */\n"
" }                                     | }\n"
"                                       |\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:422
msgid ""
"It is guaranteed that E<.Fn IFQ_DEQUEUE> immediately after E<.Fn IFQ_POLL> "
"returns the same packet.  Note that they need to be guarded by E<.Fn splimp> "
"if called from outside of E<.Fn if_start>."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/altq.9:422
#, no-wrap
msgid "Eliminating IF_PREPEND"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:431
msgid ""
"If the code uses E<.Fn IF_PREPEND>, you have to eliminate it since the "
"prepend operation is not possible for many queueing disciplines.  A common "
"use of E<.Fn IF_PREPEND> is to cancel the previous dequeue operation.  You "
"have to convert the logic into poll-and-dequeue."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:451
#, no-wrap
msgid ""
"            ##old-style##                           ##new-style##\n"
"                                       |\n"
" IF_DEQUEUE(\\*[Am]ifp-\\*[Gt]if_snd, m);          | "
"IFQ_POLL(\\*[Am]ifp-\\*[Gt]if_snd, m);\n"
" if (m != NULL) {                      | if (m != NULL) {\n"
"                                       |\n"
"     if (something_goes_wrong) {       |     if (something_goes_wrong) {\n"
"         IF_PREPEND(\\*[Am]ifp-\\*[Gt]if_snd, m);  |\n"
"         return;                       |         return;\n"
"     }                                 |     }\n"
"                                       |\n"
"                                       |     /* at this point, the driver\n"
"                                       |      * is committed to send this\n"
"                                       |      * packet.\n"
"                                       |      */\n"
"                                       |     "
"IFQ_DEQUEUE(\\*[Am]ifp-\\*[Gt]if_snd, m);\n"
"                                       |\n"
"     /* kick the hardware */           |     /* kick the hardware */\n"
" }                                     | }\n"
"                                       |\n"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/altq.9:452
#, no-wrap
msgid "Purge operation"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:457
msgid ""
"Use E<.Fn IFQ_PURGE> to empty the queue.  Note that a non-work conserving "
"queue cannot be emptied by a dequeue loop."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:465
#, no-wrap
msgid ""
"            ##old-style##                           ##new-style##\n"
"                                       |\n"
" while (ifp-\\*[Gt]if_snd.ifq_head != NULL) {|  "
"IFQ_PURGE(\\*[Am]ifp-\\*[Gt]if_snd);\n"
"     IF_DEQUEUE(\\*[Am]ifp-\\*[Gt]if_snd, m);      |\n"
"     m_freem(m);                       |\n"
" }                                     |\n"
"                                       |\n"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/altq.9:466
#, no-wrap
msgid "Attach routine"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:477
msgid ""
"Use E<.Fn IFQ_SET_MAXLEN> to set E<.Fa ifq_maxlen> to E<.Fa len>.  Add E<.Fn "
"IFQ_SET_READY> to show this driver is converted to the new style.  (This is "
"used to distinguish new-style drivers.)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:484
#, no-wrap
msgid ""
"            ##old-style##                           ##new-style##\n"
"                                       |\n"
" ifp-\\*[Gt]if_snd.ifq_maxlen = qsize;       | "
"IFQ_SET_MAXLEN(\\*[Am]ifp-\\*[Gt]if_snd, qsize);\n"
"                                       | "
"IFQ_SET_READY(\\*[Am]ifp-\\*[Gt]if_snd);\n"
" if_attach(ifp);                       | if_attach(ifp);\n"
"                                       |\n"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/altq.9:485
#, no-wrap
msgid "Other issues"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:487
msgid "The new macros for statistics:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:496
#, no-wrap
msgid ""
"            ##old-style##                           ##new-style##\n"
"                                       |\n"
" IF_DROP(\\*[Am]ifp-\\*[Gt]if_snd);                | "
"IFQ_INC_DROPS(\\*[Am]ifp-\\*[Gt]if_snd);\n"
"                                       |\n"
" ifp-\\*[Gt]if_snd.ifq_len++;                | "
"IFQ_INC_LEN(\\*[Am]ifp-\\*[Gt]if_snd);\n"
"                                       |\n"
" ifp-\\*[Gt]if_snd.ifq_len--;                | "
"IFQ_DEC_LEN(\\*[Am]ifp-\\*[Gt]if_snd);\n"
"                                       |\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:500
msgid ""
"Some drivers instruct the hardware to invoke transmission complete "
"interrupts only when it thinks necessary.  Rate-limiting breaks its "
"assumption."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/altq.9:500
#, no-wrap
msgid "How to convert drivers using multiple ifqueues"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:509
msgid ""
"Some (pseudo) devices (such as slip) have another E<.Dv ifqueue> to "
"prioritize packets.  It is possible to eliminate the second queue since "
"E<.Nm> provides more flexible mechanisms but the following shows how to keep "
"the original behavior."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:516
#, no-wrap
msgid ""
"struct sl_softc {\n"
"\tstruct\tifnet sc_if;\t\t/* network-visible interface */\n"
"\t...\n"
"\tstruct\tifqueue sc_fastq;\t/* interactive output queue */\n"
"\t...\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:524
msgid ""
"The driver doesn't compile in the new model since it has the following line "
"E<.Po> E<.Fa if_snd> is no longer a type of E<.Dv struct ifqueue> E<.Pc>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:526
#, no-wrap
msgid "\tstruct ifqueue *ifq = \\*[Am]ifp-\\*[Gt]if_snd;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:536
msgid ""
"A simple way is to use the original E<.Fn IF_XXX> macros for E<.Fa sc_fastq> "
"and use the new E<.Fn IFQ_XXX> macros for E<.Fa if_snd>.  The enqueue "
"operation looks like:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:566
#, no-wrap
msgid ""
"            ##old-style##                           ##new-style##\n"
"                                       |\n"
" struct ifqueue *ifq = \\*[Am]ifp-\\*[Gt]if_snd;   | struct ifqueue *ifq = "
"NULL;\n"
"                                       |\n"
" if (ip-\\*[Gt]ip_tos \\*[Am] IPTOS_LOWDELAY)      | if ((ip-\\*[Gt]ip_tos "
"\\*[Am] IPTOS_LOWDELAY) \\*[Am]\\*[Am]\n"
"     ifq = \\*[Am]sc-\\*[Gt]sc_fastq;              | "
"!ALTQ_IS_ENABLED(\\*[Am]sc-\\*[Gt]sc_if.if_snd)) {\n"
"                                       |     ifq = "
"\\*[Am]sc-\\*[Gt]sc_fastq;\n"
" if (IF_QFULL(ifq)) {                  |     if (IF_QFULL(ifq)) {\n"
"     IF_DROP(ifq);                     |         IF_DROP(ifq);\n"
"     m_freem(m);                       |         m_freem(m);\n"
"     splx(s);                          |         error = ENOBUFS;\n"
"     sc-\\*[Gt]sc_if.if_oerrors++;           |     } else {\n"
"     return (ENOBUFS);                 |         IF_ENQUEUE(ifq, m);\n"
" }                                     |         error = 0;\n"
" IF_ENQUEUE(ifq, m);                   |     }\n"
"                                       | } else\n"
"                                       |     "
"IFQ_ENQUEUE(\\*[Am]sc-\\*[Gt]sc_if.if_snd,\n"
"                                       |                 m, NULL, error);\n"
"                                       |\n"
"                                       | if (error) {\n"
"                                       |     splx(s);\n"
"                                       |     sc-\\*[Gt]sc_if.if_oerrors++;\n"
"                                       |     return (error);\n"
"                                       | }\n"
" if ((sc-\\*[Gt]sc_oqlen =                   | if ((sc-\\*[Gt]sc_oqlen =\n"
"      sc-\\*[Gt]sc_ttyp-\\*[Gt]t_outq.c_cc) == 0)  |      "
"sc-\\*[Gt]sc_ttyp-\\*[Gt]t_outq.c_cc) == 0)\n"
"     slstart(sc-\\*[Gt]sc_ttyp);             |     "
"slstart(sc-\\*[Gt]sc_ttyp);\n"
" splx(s);                              | splx(s);\n"
"                                       |\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:568
msgid "The dequeue operations looks like:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:577
#, no-wrap
msgid ""
"            ##old-style##                           ##new-style##\n"
"                                       |\n"
" s = splimp();                         | s = splimp();\n"
" IF_DEQUEUE(\\*[Am]sc-\\*[Gt]sc_fastq, m);         | "
"IF_DEQUEUE(\\*[Am]sc-\\*[Gt]sc_fastq, m);\n"
" if (m == NULL)                        | if (m == NULL)\n"
"     IF_DEQUEUE(\\*[Am]sc-\\*[Gt]sc_if.if_snd, m); |     "
"IFQ_DEQUEUE(\\*[Am]sc-\\*[Gt]sc_if.if_snd, m);\n"
" splx(s);                              | splx(s);\n"
"                                       |\n"
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/altq.9:578
#, no-wrap
msgid "QUEUEING DISCIPLINES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:589
msgid ""
"Queueing disciplines need to maintain E<.Fa ifq_len> E<.Po> used by E<.Fn "
"IFQ_IS_EMPTY> E<.Pc>.  Queueing disciplines also need to guarantee the same "
"mbuf is returned if E<.Fn IFQ_DEQUEUE> is called immediately after E<.Fn "
"IFQ_POLL>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:595
msgid ""
"E<.Xr pf 4>, E<.Xr altq.conf 5>, E<.Xr pf.conf 5>, E<.Xr altqd 8>, E<.Xr "
"tbrconfig 8>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/altq.9:598
msgid "The E<.Nm> system first appeared in March 1997."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/arp.9:31 org_netbsd/src/share/man/man9/ethersubr.9:30
#, no-wrap
msgid "March 3, 1997"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/arp.9:32
#, no-wrap
msgid "ARP 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/arp.9:39
msgid "E<.Nm arp>, E<.Nm arp_ifinit>, E<.Nm arpresolve>, E<.Nm arpintr>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/arp.9:39
#, no-wrap
msgid "externally visible ARP functions"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/arp.9:41
#, no-wrap
msgid "netinet/if_inarp.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/arp.9:48
msgid ""
"E<.Ft void> E<.Fn arp_ifinit \"struct ifnet *ifp\" \"struct ifaddr *ifa\"> "
"E<.Ft int> E<.Fn arpresolve \"struct ifnet *ifp\" \"struct rtentry *rt\" "
"\"struct mbuf *m\" \"struct sockaddr *dst\" \"u_char *desten\"> E<.Ft void> "
"E<.Fn arpintr>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/arp.9:59
msgid ""
"The E<.Nm> functions provide the interface between the E<.Nm> module and the "
"network drivers which need E<.Nm> functionality.  Such drivers must request "
"the E<.Ar arp> attribute in their \"files\" declaration."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/arp.9:60
#, no-wrap
msgid "Fn arp_ifinit"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/arp.9:71
msgid ""
"Sets up the E<.Nm> specific fields in E<.Fa ifa>.  Additionally, it sends "
"out a gratuitous E<.Nm> request on E<.Fa ifp>, so that other machines are "
"warned that we have a (new) address and duplicate addresses can be detected."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/arp.9:74
msgid ""
"You must call this in your drivers' ioctl function when you get a "
"SIOCSIFADDR request with an AF_INET address family."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/arp.9:74
#, no-wrap
msgid "Fn arpresolve"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/arp.9:98
msgid ""
"is called by network output functions to resolve an IPv4 address.  If no "
"E<.Fa rt> is given, a new one is looked up or created.  If the passed or "
"found E<.Fa rt> does not contain a valid gateway link level address, a "
"pointer to the packet in E<.Fa m> is stored in the route entry, possibly "
"replacing older stored packets, and an E<.Nm> request is sent instead.  When "
"an E<.Nm> reply is received, the last held packet is send.  Otherwise, the "
"looked up address is returned and written into the storage E<.Fa desten> "
"points to.  E<.Fn arpresolve> returns 1, if a valid address was stored to "
"E<.Fa desten>, and the packet can be sent immediately.  Else a 0 is "
"returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/arp.9:98
#, no-wrap
msgid "Fn arpintr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/arp.9:116
msgid ""
"When an E<.Nm> packet is received, the network driver (class) input "
"interrupt handler queues the packet on the arpintrq queue, and requests an "
"E<.Fn arpintr> soft interrupt callback.  E<.Fn arpintr> dequeues the "
"packets, performs sanity checks and calls (for IPv4 E<.Nm> packets, which "
"are the only ones supported currently) the E<.Fn in_arpinput> function.  "
"E<.Fn in_arpinput> either generates a reply to request packets, and adds the "
"sender address translation to the routing table, if a matching route entry "
"is found.  If the route entry contained a pointer to a held packet, that "
"packet is sent."
msgstr ""

#.  .Xr fddi_ifattach 9 ,
#.  .Xr arc_ifattach 9
#. type: Plain text
#: org_netbsd/src/share/man/man9/arp.9:121
msgid "E<.Xr ether_ifattach 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/arp.9:123
msgid "Plummer, D., \"RFC826\", An Ethernet Address Resolution Protocol."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/arp.9:123 org_netbsd/src/share/man/man9/in4_cksum.9:103 org_netbsd/src/share/man/man9/in_getifa.9:222 org_netbsd/src/share/man/man9/memcmp.9:69 org_netbsd/src/share/man/man9/memcpy.9:68 org_netbsd/src/share/man/man9/memmove.9:64 org_netbsd/src/share/man/man9/memset.9:62
#, no-wrap
msgid "STANDARDS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/arp.9:125
msgid "RFC 826"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/arp.9:128
msgid "Rewritten to support other than Ethernet link level addresses in E<.Nx 1.3>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/arp.9:133
msgid ""
"E<.An UCB CSRG> (original implementation)  E<.An Ignatios Souvatzis> "
"(support for non-Ethernet)"
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/arp.9:133 org_netbsd/src/share/man/man9/autoconf.9:404 org_netbsd/src/share/man/man9/bluetooth.9:350 org_netbsd/src/share/man/man9/bpf.9:64 org_netbsd/src/share/man/man9/buffercache.9:337 org_netbsd/src/share/man/man9/bufq.9:171 org_netbsd/src/share/man/man9/callback.9:106 org_netbsd/src/share/man/man9/cardbus.9:306 org_netbsd/src/share/man/man9/condvar.9:263 org_netbsd/src/share/man/man9/config.9:321 org_netbsd/src/share/man/man9/coredump_write.9:59 org_netbsd/src/share/man/man9/cprng.9:239 org_netbsd/src/share/man/man9/cpu_coredump.9:59 org_netbsd/src/share/man/man9/cpu_initclocks.9:47 org_netbsd/src/share/man/man9/cpufreq.9:285 org_netbsd/src/share/man/man9/csf.9:187 org_netbsd/src/share/man/man9/deviter.9:185 org_netbsd/src/share/man/man9/disk.9:486 org_netbsd/src/share/man/man9/do_setresuid.9:86 org_netbsd/src/share/man/man9/dofileread.9:116 org_netbsd/src/share/man/man9/edid.9:97 org_netbsd/src/share/man/man9/ethersubr.9:182 org_netbsd/src/share/man/man9/evcnt.9:279 org_netbsd/src/share/man/man9/extent.9:360 org_netbsd/src/share/man/man9/file.9:245 org_netbsd/src/share/man/man9/fileassoc.9:332 org_netbsd/src/share/man/man9/filedesc.9:299 org_netbsd/src/share/man/man9/fstrans.9:219 org_netbsd/src/share/man/man9/hashinit.9:122 org_netbsd/src/share/man/man9/intro.9:45 org_netbsd/src/share/man/man9/ioasic.9:204 org_netbsd/src/share/man/man9/isa.9:476 org_netbsd/src/share/man/man9/isapnp.9:212 org_netbsd/src/share/man/man9/kcpuset.9:218 org_netbsd/src/share/man/man9/kmem.9:247 org_netbsd/src/share/man/man9/kprintf.9:269 org_netbsd/src/share/man/man9/kthread.9:181 org_netbsd/src/share/man/man9/m_tag.9:207 org_netbsd/src/share/man/man9/mbuf.9:717 org_netbsd/src/share/man/man9/mca.9:163 org_netbsd/src/share/man/man9/microtime.9:161 org_netbsd/src/share/man/man9/module.9:421 org_netbsd/src/share/man/man9/mutex.9:240 org_netbsd/src/share/man/man9/namecache.9:204 org_netbsd/src/share/man/man9/namei.9:406 org_netbsd/src/share/man/man9/npf_ncode.9:272 org_netbsd/src/share/man/man9/optstr.9:74 org_netbsd/src/share/man/man9/pathbuf.9:115 org_netbsd/src/share/man/man9/pci.9:753 org_netbsd/src/share/man/man9/pckbport.9:304 org_netbsd/src/share/man/man9/pcmcia.9:406 org_netbsd/src/share/man/man9/pcq.9:121 org_netbsd/src/share/man/man9/percpu.9:144 org_netbsd/src/share/man/man9/pmf.9:279 org_netbsd/src/share/man/man9/pool.9:307 org_netbsd/src/share/man/man9/pool_cache.9:352 org_netbsd/src/share/man/man9/pserialize.9:91 org_netbsd/src/share/man/man9/ras.9:115 org_netbsd/src/share/man/man9/rasops.9:199 org_netbsd/src/share/man/man9/rssadapt.9:353 org_netbsd/src/share/man/man9/rt_timer.9:127 org_netbsd/src/share/man/man9/rwlock.9:202 org_netbsd/src/share/man/man9/sched_4bsd.9:81 org_netbsd/src/share/man/man9/sched_m2.9:41 org_netbsd/src/share/man/man9/secmodel.9:483 org_netbsd/src/share/man/man9/secmodel_overlay.9:45 org_netbsd/src/share/man/man9/select.9:113 org_netbsd/src/share/man/man9/sockopt.9:139 org_netbsd/src/share/man/man9/sysmon_envsys.9:683 org_netbsd/src/share/man/man9/tc.9:172 org_netbsd/src/share/man/man9/timecounter.9:167 org_netbsd/src/share/man/man9/ubc.9:124 org_netbsd/src/share/man/man9/vattr.9:99 org_netbsd/src/share/man/man9/vfs_hooks.9:93 org_netbsd/src/share/man/man9/vfsops.9:409 org_netbsd/src/share/man/man9/vfssubr.9:205 org_netbsd/src/share/man/man9/vme.9:331 org_netbsd/src/share/man/man9/vmem.9:387 org_netbsd/src/share/man/man9/vnfileops.9:180 org_netbsd/src/share/man/man9/vnode.9:742 org_netbsd/src/share/man/man9/vnsubr.9:266 org_netbsd/src/share/man/man9/wdc.9:397 org_netbsd/src/share/man/man9/workqueue.9:131 org_netbsd/src/share/man/man9/wscons.9:64 org_netbsd/src/share/man/man9/wsdisplay.9:400 org_netbsd/src/share/man/man9/wsfont.9:235 org_netbsd/src/share/man/man9/wskbd.9:328 org_netbsd/src/share/man/man9/wsmouse.9:221 org_netbsd/src/share/man/man9/xcall.9:139 org_netbsd/src/share/man/man9/man9.i386/bioscall.9:114 org_netbsd/src/share/man/man9/man9.i386/return_address.9:80 org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:119 org_netbsd/src/share/man/man9/man9.x86/nmi.9:117
#, no-wrap
msgid "CODE REFERENCES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/arp.9:138
msgid ""
"The ARP code is implemented in E<.Pa sys/net/if_arp.h>, E<.Pa "
"sys/netinet/if_inarp.h> and E<.Pa sys/netinet/if_arp.c>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/audio.9:30
#, no-wrap
msgid "November 23, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/audio.9:31
#, no-wrap
msgid "AUDIO 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:35
msgid "E<.Nm audio>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/audio.9:35
#, no-wrap
msgid "interface between low and high level audio drivers"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:43
msgid ""
"The audio device driver is divided into a high level, hardware independent "
"layer, and a low level hardware dependent layer.  The interface between "
"these is the E<.Va audio_hw_if> structure."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:48
#, no-wrap
msgid ""
"struct audio_hw_if {\n"
"\tint\t(*open)(void *, int);\n"
"\tvoid\t(*close)(void *);\n"
"\tint\t(*drain)(void *);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:54
#, no-wrap
msgid ""
"\tint\t(*query_encoding)(void *, struct audio_encoding *);\n"
"\tint\t(*set_params)(void *, int, int,\n"
"\t\t    audio_params_t *, audio_params_t *,\n"
"\t\t    stream_filter_list_t *, stream_filter_list_t *);\n"
"\tint\t(*round_blocksize)(void *, int, int, const audio_params_t *);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:56
#, no-wrap
msgid "\tint\t(*commit_settings)(void *);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:65
#, no-wrap
msgid ""
"\tint\t(*init_output)(void *, void *, int);\n"
"\tint\t(*init_input)(void *, void *, int);\n"
"\tint\t(*start_output)(void *, void *, int, void (*)(void *),\n"
"\t            void *);\n"
"\tint\t(*start_input)(void *, void *, int, void (*)(void *),\n"
"\t\t    void *);\n"
"\tint\t(*halt_output)(void *);\n"
"\tint\t(*halt_input)(void *);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:69
#, no-wrap
msgid ""
"\tint\t(*speaker_ctl)(void *, int);\n"
"#define SPKR_ON  1\n"
"#define SPKR_OFF 0\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:72
#, no-wrap
msgid ""
"\tint\t(*getdev)(void *, struct audio_device *);\n"
"\tint\t(*setfd)(void *, int);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:75
#, no-wrap
msgid ""
"\tint\t(*set_port)(void *, mixer_ctrl_t *);\n"
"\tint\t(*get_port)(void *, mixer_ctrl_t *);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:77
#, no-wrap
msgid "\tint\t(*query_devinfo)(void *, mixer_devinfo_t *);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:82
#, no-wrap
msgid ""
"\tvoid\t*(*allocm)(void *, int, size_t, struct malloc_type *, int);\n"
"\tvoid\t(*freem)(void *, void *, struct malloc_type *);\n"
"\tsize_t\t(*round_buffersize)(void *, int, size_t);\n"
"\tpaddr_t\t(*mappage)(void *, void *, off_t, int);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:84
#, no-wrap
msgid "\tint \t(*get_props)(void *);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:92
#, no-wrap
msgid ""
"\tint\t(*trigger_output)(void *, void *, void *, int,\n"
"\t\t    void (*)(void *), void *, const audio_params_t *);\n"
"\tint\t(*trigger_input)(void *, void *, void *, int,\n"
"\t\t    void (*)(void *), void *, const audio_params_t *);\n"
"\tint\t(*dev_ioctl)(void *, u_long, void *, int, struct lwp *);\n"
"\tvoid\t(*get_locks)(void *, kmutex_t **, kmutex_t **);\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:100
#, no-wrap
msgid ""
"typedef struct audio_params {\n"
"\tu_int\tsample_rate;\t/* sample rate */\n"
"\tu_int\tencoding;\t/* e.g. mu-law, linear, etc */\n"
"\tu_int\tprecision;\t/* bits/subframe */\n"
"\tu_int\tvalidbits;\t/* valid bits in a subframe */\n"
"\tu_int\tchannels;\t/* mono(1), stereo(2) */\n"
"} audio_params_t;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:106
msgid ""
"The high level audio driver attaches to the low level driver when the latter "
"calls E<.Va audio_attach_mi>.  This call should be"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:112
#, no-wrap
msgid ""
"    void\n"
"    audio_attach_mi(ahwp, hdl, dev)\n"
"\tstruct audio_hw_if *ahwp;\n"
"\tvoid *hdl;\n"
"\tstruct device *dev;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:126
msgid ""
"The E<.Va audio_hw_if> struct is as shown above.  The E<.Va hdl> argument is "
"a handle to some low level data structure.  It is sent as the first argument "
"to all the functions in E<.Va audio_hw_if> when the high level driver calls "
"them.  E<.Va dev> is the device struct for the hardware device."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:135
msgid ""
"The upper layer of the audio driver allocates one buffer for playing and one "
"for recording.  It handles the buffering of data from the user processes in "
"these.  The data is presented to the lower level in smaller chunks, called "
"blocks.  If, during playback, there is no data available from the user "
"process when the hardware request another block a block of silence will be "
"used instead.  Furthermore, if the user process does not read data quickly "
"enough during recording data will be thrown away."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:140
msgid ""
"The fields of E<.Va audio_hw_if> are described in some more detail below.  "
"Some fields are optional and can be set to 0 if not needed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:141 org_netbsd/src/share/man/man9/video.9:122
#, no-wrap
msgid "Dv int open(void *hdl, int flags)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:149
msgid ""
"optional, is called when the audio device is opened.  It should initialize "
"the hardware for I/O.  Every successful call to E<.Va open> is matched by a "
"call to E<.Va close>.  Return 0 on success, otherwise an error code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:149 org_netbsd/src/share/man/man9/video.9:130
#, no-wrap
msgid "Dv void close(void *hdl)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:151 org_netbsd/src/share/man/man9/video.9:132
msgid "optional, is called when the audio device is closed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:151
#, no-wrap
msgid "Dv int drain(void *hdl)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:160
msgid ""
"optional, is called before the device is closed or when E<.Dv AUDIO_DRAIN> "
"is called.  It should make sure that no samples remain in to be played that "
"could be lost when E<.Va close> is called.  Return 0 on success, otherwise "
"an error code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:160
#, no-wrap
msgid "Dv int query_encoding(void *hdl, struct audio_encoding *ae)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:168
msgid ""
"is used when E<.Dv AUDIO_GETENC> is called.  It should fill the E<.Va "
"audio_encoding> structure and return 0 or, if there is no encoding with the "
"given number, return EINVAL."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:168
#, no-wrap
msgid "Dv int set_params(void *hdl, int setmode, int usemode,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:170
msgid "E<.Dv \"audio_params_t *play, audio_params_t *rec,\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:172
msgid "E<.Dv \"stream_filter_list_t *pfil, stream_filter_list_t *rfil)\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:187
msgid ""
"Called to set the audio encoding mode.  E<.Va setmode> is a combination of "
"the E<.Dv AUMODE_RECORD> and E<.Dv AUMODE_PLAY> flags to indicate which "
"mode(s) are to be set.  E<.Va usemode> is also a combination of these flags, "
"but indicates the current mode of the device (i.e., the value of E<.Va mode> "
"in the E<.Va audio_info> struct)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:196
msgid ""
"The E<.Va play> and E<.Va rec> structures contain the encoding parameters "
"that should be set.  The values of the structures may also be modified if "
"the hardware cannot be set to exactly the requested mode (e.g., if the "
"requested sampling rate is not supported, but one close enough is)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:220
msgid ""
"If the hardware requires software assistance with some encoding (e.g., it "
"might be lacking mu-law support) it should fill the E<.Va pfil> for playing "
"or E<.Va rfil> for recording with conversion information.  For example, if "
"E<.Va play> requests [8000Hz, mu-law, 8/8bit, 1ch] and the hardware does not "
"support 8bit mu-law, but 16bit slinear_le, the driver should call E<.Dv "
"pfil-\\*[Gt]append()> with E<.Va pfil>, E<.Va mulaw_to_slinear16>, and "
"audio_params_t representing [8000Hz, slinear_le, 16/16bit, 2ch].  If the "
"driver needs multiple conversions, a conversion nearest to the hardware "
"should be set to the head of E<.Va pfil> or E<.Va rfil>.  The definition of "
"E<.Dv stream_filter_list_t> follows:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:238
#, no-wrap
msgid ""
"typedef struct stream_filter_list {\n"
"\tvoid (*append)(struct stream_filter_list *,\n"
"\t\t       stream_filter_factory_t,\n"
"\t\t       const audio_params_t *);\n"
"\tvoid (*prepend)(struct stream_filter_list *,\n"
"\t\t\tstream_filter_factory_t,\n"
"\t\t\tconst audio_params_t *);\n"
"\tvoid (*set)(struct stream_filter_list *, int,\n"
"\t\t    stream_filter_factory_t,\n"
"\t\t    const audio_params_t *);\n"
"\tint req_size;\n"
"\tstruct stream_filter_req {\n"
"\t\tstream_filter_factory_t *factory;\n"
"\t\taudio_params_t param; /* from-param for recording,\n"
"\t\t\t\t\t to-param for playing */\n"
"\t} filters[AUDIO_MAX_FILTERS];\n"
"} stream_filter_list_t;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:243
msgid "For playing, E<.Va pfil> constructs conversions as follows:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:253
#, no-wrap
msgid ""
"\t(play) == write(2) input\n"
"\t  |\tpfil-\\*[Gt]filters[pfil-\\*[Gt]req_size-1].factory\n"
"\t(pfil-\\*[Gt]filters[pfil-\\*[Gt]req_size-1].param)\n"
"\t  |\tpfil-\\*[Gt]filters[pfil-\\*[Gt]req_size-2].factory\n"
"\t  :\n"
"\t  |\tpfil-\\*[Gt]filters[1].factory\n"
"\t(pfil-\\*[Gt]filters[1].param)\n"
"\t  |\tpfil-\\*[Gt]filters[0].factory\n"
"\t(pfil-\\*[Gt]filters[0].param)  == hardware input\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:258
msgid "For recording, E<.Va rfil> constructs conversions as follows:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:268
#, no-wrap
msgid ""
"\t(rfil-\\*[Gt]filters[0].param) == hardware output\n"
"\t  |\trfil-\\*[Gt]filters[0].factory\n"
"\t(rfil-\\*[Gt]filters[1].param)\n"
"\t  |\trfil-\\*[Gt]filters[1].factory\n"
"\t  :\n"
"\t  |\trfil-\\*[Gt]filters[rfil-\\*[Gt]req_size-2].factory\n"
"\t(rfil-\\*[Gt]filters[rfil-\\*[Gt]req_size-1].param)\n"
"\t  |\trfil-\\*[Gt]filters[rfil-\\*[Gt]req_size-1].factory\n"
"\t(rec)  == read(2) output\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:283
msgid ""
"If the device does not have the E<.Dv AUDIO_PROP_INDEPENDENT> property the "
"same value is passed in both E<.Va play> and E<.Va rec> and the encoding "
"parameters from E<.Va play> is copied into E<.Va rec> after the call to "
"E<.Va set_params>.  Return 0 on success, otherwise an error code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:283
#, no-wrap
msgid "Dv int round_blocksize(void *hdl, int bs, int mode,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:285 org_netbsd/src/share/man/man9/audio.9:454 org_netbsd/src/share/man/man9/audio.9:478
msgid "E<.Dv \"const audio_params_t *param)\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:298
msgid ""
"optional, is called with the block size, E<.Va bs>, that has been computed "
"by the upper layer, E<.Va mode>, E<.Dv AUMODE_PLAY> or E<.Dv AUMODE_RECORD>, "
"and E<.Va param>, encoding parameters for the hardware.  It should return a "
"block size, possibly changed according to the needs of the hardware driver."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:298
#, no-wrap
msgid "Dv int commit_settings(void *hdl)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:308
msgid ""
"optional, is called after all calls to E<.Va set_params>, and E<.Va "
"set_port>, are done.  A hardware driver that needs to get the hardware in "
"and out of command mode for each change can save all the changes during "
"previous calls and do them all here.  Return 0 on success, otherwise an "
"error code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:308
#, no-wrap
msgid "Dv int init_output(void *hdl, void *buffer, int size)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:316
msgid ""
"optional, is called before any output starts, but when the total E<.Va size> "
"of the output E<.Va buffer> has been determined.  It can be used to "
"initialize looping DMA for hardware that needs that.  Return 0 on success, "
"otherwise an error code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:316
#, no-wrap
msgid "Dv int init_input(void *hdl, void *buffer, int size)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:324
msgid ""
"optional, is called before any input starts, but when the total E<.Va size> "
"of the input E<.Va buffer> has been determined.  It can be used to "
"initialize looping DMA for hardware that needs that.  Return 0 on success, "
"otherwise an error code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:324
#, no-wrap
msgid "Dv int start_output(void *hdl, void *block, int blksize,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:326 org_netbsd/src/share/man/man9/audio.9:345
msgid "E<.Dv \"void (*intr)(void*), void *intrarg)\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:343
msgid ""
"is called to start the transfer of E<.Va blksize> bytes from E<.Va block> to "
"the audio hardware.  The call should return when the data transfer has been "
"initiated (normally with DMA).  When the hardware is ready to accept more "
"samples the function E<.Va intr> should be called with the argument E<.Va "
"intrarg>.  Calling E<.Va intr> will normally initiate another call to E<.Va "
"start_output>.  Return 0 on success, otherwise an error code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:343
#, no-wrap
msgid "Dv int start_input(void *hdl, void *block, int blksize,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:362
msgid ""
"is called to start the transfer of E<.Va blksize> bytes to E<.Va block> from "
"the audio hardware.  The call should return when the data transfer has been "
"initiated (normally with DMA).  When the hardware is ready to deliver more "
"samples the function E<.Va intr> should be called with the argument E<.Va "
"intrarg>.  Calling E<.Va intr> will normally initiate another call to E<.Va "
"start_input>.  Return 0 on success, otherwise an error code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:362
#, no-wrap
msgid "Dv int halt_output(void *hdl)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:367
msgid ""
"is called to abort the output transfer (started by E<.Va start_output>)  in "
"progress.  Return 0 on success, otherwise an error code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:367
#, no-wrap
msgid "Dv int halt_input(void *hdl)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:372
msgid ""
"is called to abort the input transfer (started by E<.Va start_input>)  in "
"progress.  Return 0 on success, otherwise an error code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:372
#, no-wrap
msgid "Dv int speaker_ctl(void *hdl, int on)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:378
msgid ""
"optional, is called when a half duplex device changes between playing and "
"recording.  It can, e.g., be used to turn on and off the speaker.  Return 0 "
"on success, otherwise an error code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:378
#, no-wrap
msgid "Dv int getdev(void *hdl, struct audio_device *ret)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:383
msgid ""
"Should fill the E<.Va audio_device> struct with relevant information about "
"the driver.  Return 0 on success, otherwise an error code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:383
#, no-wrap
msgid "Dv int setfd(void *hdl, int fd)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:388
msgid ""
"optional, is called when E<.Dv AUDIO_SETFD> is used, but only if the device "
"has AUDIO_PROP_FULLDUPLEX set.  Return 0 on success, otherwise an error "
"code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:388
#, no-wrap
msgid "Dv int set_port(void *hdl, mixer_ctrl_t *mc)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:396
msgid ""
"is called in when E<.Dv AUDIO_MIXER_WRITE> is used.  It should take data "
"from the E<.Va mixer_ctrl_t> struct at set the corresponding mixer values.  "
"Return 0 on success, otherwise an error code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:396
#, no-wrap
msgid "Dv int get_port(void *hdl, mixer_ctrl_t *mc)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:404
msgid ""
"is called in when E<.Dv AUDIO_MIXER_READ> is used.  It should fill the E<.Va "
"mixer_ctrl_t> struct.  Return 0 on success, otherwise an error code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:404
#, no-wrap
msgid "Dv int query_devinfo(void *hdl, mixer_devinfo_t *di)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:412
msgid ""
"is called in when E<.Dv AUDIO_MIXER_DEVINFO> is used.  It should fill the "
"E<.Va mixer_devinfo_t> struct.  Return 0 on success, otherwise an error "
"code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:412
#, no-wrap
msgid ""
"Dv \"void *allocm(void *hdl, int direction, size_t size, struct malloc_type "
"*type, int flags)\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:422
msgid ""
"optional, is called to allocate the device buffers.  If not present E<.Xr "
"malloc 9> is used instead (with the same arguments but the first two).  The "
"reason for using a device dependent routine instead of E<.Xr malloc 9> is "
"that some buses need special allocation to do DMA.  Returns the address of "
"the buffer, or 0 on failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:422
#, no-wrap
msgid "Dv void freem(void *hdl, void *addr, struct malloc_type *type)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:428
msgid ""
"optional, is called to free memory allocated by E<.Va alloc>.  If not "
"supplied E<.Xr free 9> is used."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:428
#, no-wrap
msgid "Dv size_t round_buffersize(void *hdl, int direction, size_t bufsize)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:435
msgid ""
"optional, is called at startup to determine the audio buffer size.  The "
"upper layer supplies the suggested size in E<.Va bufsize>, which the "
"hardware driver can then change if needed.  E.g., DMA on the ISA bus cannot "
"exceed 65536 bytes."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:435
#, no-wrap
msgid "Dv \"paddr_t mappage(void *hdl, void *addr, off_t offs, int prot)\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:447
msgid ""
"optional, is called for E<.Xr mmap 2>.  Should return the map value for the "
"page at offset E<.Va offs> from address E<.Va addr> mapped with protection "
"E<.Va prot>.  Returns -1 on failure, or a machine dependent opaque value on "
"success."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:447
#, no-wrap
msgid "Dv int get_props(void *hdl)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:450
msgid "Should return the device properties; i.e., a combination of AUDIO_PROP_xxx."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:450
#, no-wrap
msgid "Dv int trigger_output(void *hdl, void *start, void *end,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:452 org_netbsd/src/share/man/man9/audio.9:476
msgid "E<.Dv \"int blksize, void (*intr)(void*), void *intrarg,\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:474
msgid ""
"optional, is called to start the transfer of data from the circular buffer "
"delimited by E<.Va start> and E<.Va end> to the audio hardware, "
"parameterized as in E<.Va param>.  The call should return when the data "
"transfer has been initiated (normally with DMA).  When the hardware is "
"finished transferring each E<.Va blksize> sized block, the function E<.Va "
"intr> should be called with the argument E<.Va intrarg> (typically from the "
"audio hardware interrupt service routine).  Once started the transfer may be "
"stopped using E<.Va halt_output>.  Return 0 on success, otherwise an error "
"code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:474
#, no-wrap
msgid "Dv int trigger_input(void *hdl, void *start, void *end,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:498
msgid ""
"optional, is called to start the transfer of data from the audio hardware, "
"parameterized as in E<.Va param>, to the circular buffer delimited by E<.Va "
"start> and E<.Va end>.  The call should return when the data transfer has "
"been initiated (normally with DMA).  When the hardware is finished "
"transferring each E<.Va blksize> sized block, the function E<.Va intr> "
"should be called with the argument E<.Va intrarg> (typically from the audio "
"hardware interrupt service routine).  Once started the transfer may be "
"stopped using E<.Va halt_input>.  Return 0 on success, otherwise an error "
"code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:498
#, no-wrap
msgid "Dv int dev_ioctl(void *hdl, u_long cmd, void *addr,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:501
msgid "E<.Dv \"int flag, struct lwp *l)\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:506
msgid ""
"optional, is called when an E<.Xr ioctl 2> is not recognized by the generic "
"audio driver.  Return 0 on success, otherwise an error code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/audio.9:506
#, no-wrap
msgid "Dv void get_locks(void *hdl, kmutex_t **intr, kmutex_t **thread)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:508
msgid "Returns the interrupt and thread locks to the common audio layer."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:518
msgid ""
"The E<.Va query_devinfo> method should define certain mixer controls for "
"E<.Dv AUDIO_SETINFO> to be able to change the port and gain, and E<.Dv "
"AUDIO_GETINFO> to read them, as follows."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:552
msgid ""
"If the record mixer is capable of input from more than one source, it should "
"define E<.Dv AudioNsource> in class E<.Dv AudioCrecord>.  This mixer control "
"should be of type E<.Dv AUDIO_MIXER_ENUM> or E<.Dv AUDIO_MIXER_SET> and "
"enumerate the possible input sources.  Each of the named sources for which "
"the recording level can be set should have a control in the E<.Dv "
"AudioCrecord> class of type E<.Dv AUDIO_MIXER_VALUE>, except the E<.Qq "
"mixerout> source is special, and will never have its own control.  Its "
"selection signifies, rather, that various sources in class E<.Dv "
"AudioCrecord> will be combined and presented to the single recording output "
"in the same fashion that the sources of class E<.Dv AudioCinputs> are "
"combined and presented to the playback output(s).  If the overall recording "
"level can be changed, regardless of the input source, then this control "
"should be named E<.Dv AudioNmaster> and be of class E<.Dv AudioCrecord>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:559
msgid ""
"Controls for various sources that affect only the playback output, as "
"opposed to recording, should be in the E<.Dv AudioCinputs> class, as of "
"course should any controls that affect both playback and recording."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:583
msgid ""
"If the play mixer is capable of output to more than one destination, it "
"should define E<.Dv AudioNselect> in class E<.Dv AudioCoutputs>.  This mixer "
"control should be of type E<.Dv AUDIO_MIXER_ENUM> or E<.Dv AUDIO_MIXER_SET> "
"and enumerate the possible destinations.  For each of the named destinations "
"for which the output level can be set, there should be a control in the "
"E<.Dv AudioCoutputs> class of type E<.Dv AUDIO_MIXER_VALUE>.  If the overall "
"output level can be changed, which is invariably the case, then this control "
"should be named E<.Dv AudioNmaster> and be of class E<.Dv AudioCoutputs>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:593
msgid ""
"There's one additional source recognized specially by E<.Dv AUDIO_SETINFO> "
"and E<.Dv AUDIO_GETINFO>, to be presented as monitor_gain, and that is a "
"control named E<.Dv AudioNmonitor>, of class E<.Dv AudioCmonitor>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:595 org_netbsd/src/share/man/man9/ioctl.9:90
msgid "E<.Xr audio 4>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/audio.9:599
msgid "This E<.Nm> interface first appeared in E<.Nx 1.3>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/autoconf.9:30
#, no-wrap
msgid "June 26, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/autoconf.9:31
#, no-wrap
msgid "AUTOCONF 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:52
msgid ""
"E<.Nm autoconf>, E<.Nm config_search_loc>, E<.Nm config_search_ia>, E<.Nm "
"config_found_sm_loc>, E<.Nm config_found_ia>, E<.Nm config_found>, E<.Nm "
"config_match>, E<.Nm config_attach_loc>, E<.Nm config_attach>, E<.Nm "
"config_attach_pseudo>, E<.Nm config_detach>, E<.Nm config_deactivate>, E<.Nm "
"config_defer>, E<.Nm config_interrupts>, E<.Nm config_mountroot>, E<.Nm "
"config_pending_incr>, E<.Nm config_pending_decr>, E<.Nm "
"config_finalize_register>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/autoconf.9:52
#, no-wrap
msgid "autoconfiguration framework"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/autoconf.9:55 org_netbsd/src/share/man/man9/deviter.9:64 org_netbsd/src/share/man/man9/driver.9:38 org_netbsd/src/share/man/man9/pmf.9:53
#, no-wrap
msgid "sys/device.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/autoconf.9:56 org_netbsd/src/share/man/man9/driver.9:39 org_netbsd/src/share/man/man9/errno.9:40 org_netbsd/src/share/man/man9/todr.9:111
#, no-wrap
msgid "sys/errno.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:97
msgid ""
"E<.Ft cfdata_t> E<.Fn config_search_loc \"cfsubmatch_t func\" \"device_t "
"parent\" \"const char *ia\" \"const int *locs\" \"void *aux\"> E<.Ft "
"cfdata_t> E<.Fn config_search_ia \"cfsubmatch_t func\" \"device_t parent\" "
"\"const char *ia\" \"void *aux\"> E<.Ft device_t> E<.Fn config_found_sm_loc "
"\"device_t parent\" \"const char *ia\" \"const int *locs\" \"void *aux\" "
"\"cfprint_t print\" \"cfsubmatch_t submatch\"> E<.Ft device_t> E<.Fn "
"config_found_ia \"device_t parent\" \"const char *ia\" \"void *aux\" "
"\"cfprint_t print\"> E<.Ft device_t> E<.Fn config_found \"device_t parent\" "
"\"void *aux\" \"cfprint_t print\"> E<.Ft int> E<.Fn config_match \"device_t "
"parent\" \"cfdata_t cf\" \"void *aux\"> E<.Ft device_t> E<.Fn "
"config_attach_loc \"device_t parent\" \"cfdata_t cf\" \"const int *locs\" "
"\"void *aux\" \"cfprint_t print\"> E<.Ft device_t> E<.Fn config_attach "
"\"device_t parent\" \"cfdata_t cf\" \"void *aux\" \"cfprint_t print\"> E<.Ft "
"device_t> E<.Fn config_attach_pseudo \"cfdata_t cf\"> E<.Ft int> E<.Fn "
"config_detach \"device_t dev\" \"int flags\"> E<.Ft int> E<.Fn "
"config_deactivate \"device_t dev\"> E<.Ft int> E<.Fn config_defer \"device_t "
"dev\" \"void (*func)(device_t)\"> E<.Ft void> E<.Fn config_interrupts "
"\"device_t dev\" \"void (*func)(device_t)\"> E<.Ft void> E<.Fn "
"config_mountroot \"device_t dev\" \"void (*func)(device_t)\"> E<.Ft void> "
"E<.Fn config_pending_incr> E<.Ft void> E<.Fn config_pending_decr> E<.Ft int> "
"E<.Fn config_finalize_register \"device_t dev\" \"int (*func)(device_t)\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:102
msgid ""
"Autoconfiguration is the process of matching hardware devices with an "
"appropriate device driver.  In its most basic form, autoconfiguration "
"consists of the recursive process of finding and attaching all devices on a "
"bus, including other busses."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:111
msgid ""
"The autoconfiguration framework supports E<.Em direct configuration> where "
"the bus driver can determine the devices present.  The autoconfiguration "
"framework also supports E<.Em indirect configuration> where the drivers must "
"probe the bus looking for the presence of a device.  Direct configuration is "
"preferred since it can find hardware regardless of the presence of proper "
"drivers."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:126
msgid ""
"The autoconfiguration process occurs at system bootstrap and is driven by a "
"table generated from a E<.Do> machine description E<.Dc> file by E<.Xr "
"config 1>.  For a description of the E<.Xr config 1> E<.Do> device "
"definition E<.Dc> language, see E<.Xr config 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:132
msgid ""
"Each device must have a name consisting of an alphanumeric string that ends "
"with a unit number.  The unit number identifies an instance of the driver.  "
"Device data structures are allocated dynamically during autoconfiguration, "
"giving a unique address for each instance."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/autoconf.9:132 org_netbsd/src/share/man/man9/bluetooth.9:139 org_netbsd/src/share/man/man9/buffercache.9:170 org_netbsd/src/share/man/man9/bufq.9:74 org_netbsd/src/share/man/man9/bus_dma.9:160 org_netbsd/src/share/man/man9/callback.9:62 org_netbsd/src/share/man/man9/callout.9:95 org_netbsd/src/share/man/man9/cardbus.9:169 org_netbsd/src/share/man/man9/cnmagic.9:99 org_netbsd/src/share/man/man9/condvar.9:93 org_netbsd/src/share/man/man9/cprng.9:141 org_netbsd/src/share/man/man9/cpufreq.9:108 org_netbsd/src/share/man/man9/deviter.9:109 org_netbsd/src/share/man/man9/evcnt.9:147 org_netbsd/src/share/man/man9/file.9:207 org_netbsd/src/share/man/man9/filedesc.9:131 org_netbsd/src/share/man/man9/firmload.9:66 org_netbsd/src/share/man/man9/fstrans.9:113 org_netbsd/src/share/man/man9/iic.9:143 org_netbsd/src/share/man/man9/ioasic.9:117 org_netbsd/src/share/man/man9/ipkdb.9:93 org_netbsd/src/share/man/man9/isa.9:163 org_netbsd/src/share/man/man9/isapnp.9:130 org_netbsd/src/share/man/man9/kcpuset.9:96 org_netbsd/src/share/man/man9/kthread.9:57 org_netbsd/src/share/man/man9/m_tag.9:85 org_netbsd/src/share/man/man9/mb.9:90 org_netbsd/src/share/man/man9/mca.9:103 org_netbsd/src/share/man/man9/module.9:91 org_netbsd/src/share/man/man9/mutex.9:93 org_netbsd/src/share/man/man9/namecache.9:123 org_netbsd/src/share/man/man9/namei.9:223 org_netbsd/src/share/man/man9/npf_ncode.9:47 org_netbsd/src/share/man/man9/optstr.9:53 org_netbsd/src/share/man/man9/pci.9:259 org_netbsd/src/share/man/man9/pcmcia.9:203 org_netbsd/src/share/man/man9/pcq.9:78 org_netbsd/src/share/man/man9/percpu.9:78 org_netbsd/src/share/man/man9/pmc.9:156 org_netbsd/src/share/man/man9/pmf.9:137 org_netbsd/src/share/man/man9/pool_cache.9:147 org_netbsd/src/share/man/man9/pserialize.9:51 org_netbsd/src/share/man/man9/ras.9:79 org_netbsd/src/share/man/man9/rasops.9:165 org_netbsd/src/share/man/man9/rssadapt.9:89 org_netbsd/src/share/man/man9/rwlock.9:115 org_netbsd/src/share/man/man9/secmodel.9:84 org_netbsd/src/share/man/man9/secmodel_securelevel.9:231 org_netbsd/src/share/man/man9/secmodel_suser.9:43 org_netbsd/src/share/man/man9/sockopt.9:87 org_netbsd/src/share/man/man9/sysmon_pswitch.9:105 org_netbsd/src/share/man/man9/sysmon_taskq.9:56 org_netbsd/src/share/man/man9/tc.9:104 org_netbsd/src/share/man/man9/uvm_km.9:51 org_netbsd/src/share/man/man9/uvm_map.9:75 org_netbsd/src/share/man/man9/vattr.9:92 org_netbsd/src/share/man/man9/veriexec.9:88 org_netbsd/src/share/man/man9/vfs_hooks.9:84 org_netbsd/src/share/man/man9/vfsops.9:213 org_netbsd/src/share/man/man9/vfssubr.9:102 org_netbsd/src/share/man/man9/vme.9:161 org_netbsd/src/share/man/man9/vnfileops.9:68 org_netbsd/src/share/man/man9/vnode.9:492 org_netbsd/src/share/man/man9/vnodeops.9:362 org_netbsd/src/share/man/man9/vnsubr.9:83 org_netbsd/src/share/man/man9/wsdisplay.9:309 org_netbsd/src/share/man/man9/wsfont.9:119 org_netbsd/src/share/man/man9/wskbd.9:216 org_netbsd/src/share/man/man9/wsmouse.9:99 org_netbsd/src/share/man/man9/xcall.9:97 org_netbsd/src/share/man/man9/man9.x86/nmi.9:75 org_netbsd/src/share/man/man9/man9.x86/rdmsr.9:74 org_netbsd/src/share/man/man9/man9.x86/tsc.9:88
#, no-wrap
msgid "FUNCTIONS"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/autoconf.9:134
#, no-wrap
msgid "Fn config_search_loc func parent ia locs aux"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:170
msgid ""
"Performs indirect configuration of physical devices.  E<.Fn "
"config_search_loc> iterates over all potential children, calling the given "
"function E<.Fa func> for each one.  If E<.Fa func> is E<.Dv NULL>, E<.Fn "
"config_search_loc> applies each child's match function instead.  The "
"argument E<.Fa parent> is the pointer to the parent's device structure.  The "
"argument E<.Fa ia> is the interface attribute on which the potential "
"children should attach.  It can be E<.Dv NULL>, in which case all children "
"attaching to any attribute are considered.  The E<.Fa locs> argument lists "
"the locator values for the device and are passed to function E<.Fa func>.  "
"The given E<.Fa aux> argument describes the device that has been found and "
"is simply passed on through E<.Fa func> to the child.  E<.Fn "
"config_search_loc> returns a pointer to the best-matched child or E<.Dv "
"NULL> otherwise."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:186
msgid ""
"The role of E<.Fa func> is to call the match function for each device and "
"call E<.Fn config_attach_loc> for any positive matches.  If E<.Fa func> is "
"E<.Dv NULL>, then the parent should record the return value from E<.Fn "
"config_search_loc> and call E<.Fn config_attach_loc> itself."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:190
msgid ""
"Note that this function is designed so that it can be used to apply an "
"arbitrary function to all potential children.  In this case callers may "
"choose to ignore the return value."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/autoconf.9:190
#, no-wrap
msgid "Fn config_search_ia func parent ia aux"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:197
msgid ""
"This function is equivalent to calling E<.Fn config_search_loc \"func\" "
"\"parent\" \"ia\" \"locs\" \"aux\"> with E<.Fa locs> set to E<.Dv NULL>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/autoconf.9:197
#, no-wrap
msgid "Fn config_found_sm_loc parent ia locs aux print submatch"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:250
msgid ""
"Performs direct configuration on a physical device.  E<.Fn "
"config_found_sm_loc> is called by the parent and in turn calls the E<.Fa "
"submatch> function to call the match function as determined by the "
"configuration table.  If E<.Fa submatch> is E<.Dv NULL>, the driver match "
"functions are called directly.  The argument E<.Fa parent> is the pointer to "
"the parent's device structure.  The argument E<.Fa ia> is the name of the "
"interface attribute on which the child will attach, per E<.Xr config 5> "
"syntax.  The argument E<.Fa locs> lists the locator values for the device.  "
"The given E<.Fa aux> argument describes the device that has been found.  "
"E<.Fn config_found_sm_loc> internally uses E<.Fn config_search_loc>, passing "
"on E<.Fa submatch , ia , locs> and E<.Fa aux>.  The E<.Em softc> structure "
"for the matched device will be allocated, and the appropriate driver attach "
"function will be called.  If the device is matched, the system prints the "
"name of the child and parent devices, and then calls the E<.Fa print> "
"function to produce additional information if desired.  If no driver takes a "
"match, the same E<.Fa print> function is called to complain.  The print "
"function is called with the E<.Fa aux> argument and, if the matches failed, "
"the full name (including unit number) of the parent device, otherwise E<.Dv "
"NULL>.  The E<.Fa print> function must return an integer value."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:262
msgid ""
"Two special strings, E<.Do> not configured E<.Dc> and E<.Do> unsupported "
"E<.Dc> will be appended automatically to non-driver reports if the return "
"value is UNCONF or UNSUPP respectively; otherwise the function should return "
"the value QUIET."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:271
msgid ""
"E<.Fn config_found_sm_loc> returns a pointer to the attached device's E<.Em "
"softc> structure if the device is attached, E<.Dv NULL> otherwise.  Most "
"callers can ignore this value, since the system will already have printed a "
"diagnostic."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/autoconf.9:271
#, no-wrap
msgid "Fn config_found_ia parent ia aux print"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:282
msgid ""
"This function is equivalent to calling E<.Fn config_found_sm_loc \"parent\" "
"\"ia\" \"locs\" \"aux\" \"print\" \"submatch\"> with E<.Fa locs> and E<.Fa "
"submatch> set to E<.Dv NULL>.  It is provided for better source code "
"readability with locator-less device buses."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/autoconf.9:282
#, no-wrap
msgid "Fn config_found parent aux print"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:295
msgid ""
"This function is equivalent to calling E<.Fn config_found_sm_loc \"parent\" "
"\"ia\" \"locs\" \"aux\" \"print\" \"submatch\"> with E<.Fa ia , locs> and "
"E<.Fa submatch> set to E<.Dv NULL> and is provided for compatibility with "
"older drivers.  New code should either make the interface attribute explicit "
"or prefer an indirect method based on E<.Fn config_search_loc>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/autoconf.9:295
#, no-wrap
msgid "Fn config_match parent cf aux"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:304
msgid ""
"Match a device.  Invokes the drivers match function according to the "
"configuration table.  The E<.Fn config_match> function returns a nonzero "
"integer indicating the confidence of supporting this device and a value of 0 "
"if the driver doesn't support the device."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/autoconf.9:304
#, no-wrap
msgid "Fn config_attach_loc parent locs cf aux print"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:316
msgid ""
"Attach a found device.  Allocates the memory for the E<.Em softc> structure "
"and calls the drivers attach function according to the configuration table.  "
"If successful, E<.Fn config_attach_loc> returns the E<.Em softc>.  If "
"unsuccessful, it returns E<.Dv NULL>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/autoconf.9:316
#, no-wrap
msgid "Fn config_attach parent cf aux print"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:323
msgid ""
"This function is equivalent to calling E<.Fn config_attach_loc \"parent\" "
"\"cf\" \"locs\" \"aux\" \"print\"> with E<.Fa locs> set to E<.Dv NULL>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/autoconf.9:323
#, no-wrap
msgid "Fn config_attach_pseudo cf"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:331
msgid ""
"Create an instance of a pseudo-device driver.  E<.Xr config 5> syntax allows "
"the creation of pseudo-devices from which regular E<.Ft device_t> instances "
"can be created.  Such objects are similar to the devices that attach at the "
"root of the device tree."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:339
msgid ""
"The caller is expected to allocate and fill the E<.Ft cfdata_t> object and "
"pass it to E<.Fn config_attach_pseudo>.  The content of that object is "
"similar to what is returned by E<.Fn config_search_loc> for regular devices."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/autoconf.9:339
#, no-wrap
msgid "Fn config_detach dev flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:351
msgid ""
"Called by the parent to detach the child device.  The second argument E<.Em "
"flags> contains detachment flags.  Valid values are DETACH_FORCE (force "
"detachment (e.g., because of hardware removal)) and DETACH_QUIET (do not "
"print a notice).  E<.Fn config_detach> returns zero if successful and an "
"error code otherwise.  E<.Fn config_detach> is always called from a thread "
"context, allowing condition variables to be used while the device detaches "
"itself."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/autoconf.9:351
#, no-wrap
msgid "Fn config_deactivate dev"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:361
msgid ""
"Called by the parent to deactivate the child device E<.Fa dev>.  E<.Fn "
"config_deactivate> is called from interrupt context to immediately "
"relinquish resources and notify dependent kernel subsystems that the device "
"is about to be detached.  At some later point E<.Fn config_detach> will be "
"called to finalise the removal of the device."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/autoconf.9:361
#, no-wrap
msgid "Fn config_defer dev func"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:368
msgid ""
"Called by the child to defer the remainder of its configuration until all "
"its parent's devices have been attached.  At this point, the function E<.Fa "
"func> is called with the argument E<.Fa dev>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/autoconf.9:368
#, no-wrap
msgid "Fn config_interrupts dev func"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:375
msgid ""
"Called by the child to defer the remainder of its configuration until "
"interrupts are enabled.  At this point, the function E<.Fa func> is called "
"with the argument E<.Fa dev>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/autoconf.9:375
#, no-wrap
msgid "Fn config_mountroot dev func"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:384
msgid ""
"Called by the child to defer the remainder of its configuration until the "
"root file system is mounted.  At this point, the function E<.Fa func> is "
"called with the argument E<.Fa dev>.  This is used for devices that need to "
"load firmware image from a mounted file system."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/autoconf.9:384
#, no-wrap
msgid "Fn config_pending_incr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:390
msgid ""
"Increment the E<.Va config_pending> semaphore.  It is used to account for "
"deferred configurations before mounting the root file system."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/autoconf.9:390
#, no-wrap
msgid "Fn config_pending_decr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:396
msgid ""
"Decrement the E<.Va config_pending> semaphore.  It is used to account for "
"deferred configurations before mounting the root file system."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/autoconf.9:396
#, no-wrap
msgid "Fn config_finalize_register dev func"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:398
msgid "Register a function to be called after all real devices have been found."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:403
msgid ""
"Registered functions are all executed until all of them return 0.  The "
"callbacks should return 0 to indicate they do not require to be called "
"another time, but they should be aware that they still might be in case one "
"of them returns 1."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:409
msgid ""
"The autoconfiguration framework itself is implemented within the file E<.Pa "
"sys/kern/subr_autoconf.c>.  Data structures and function prototypes for the "
"framework are located in E<.Pa sys/sys/device.h>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:415
msgid ""
"E<.Xr config 1>, E<.Xr config 5>, E<.Xr condvar 9>, E<.Xr config 9>, E<.Xr "
"driver 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/autoconf.9:421
msgid ""
"Autoconfiguration first appeared in E<.Bx 4.1>.  The autoconfiguration "
"framework was completely revised in E<.Bx 4.4>.  The detach and deactivate "
"interfaces appeared in E<.Nx 1.5>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/bcdtobin.9:30
#, no-wrap
msgid "March 11, 2006"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/bcdtobin.9:31
#, no-wrap
msgid "BCDTOBIN 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bcdtobin.9:36
msgid "E<.Nm bcdtobin>, E<.Nm bintobcd>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/bcdtobin.9:36
#, no-wrap
msgid "convert a single byte between (unsigned) packed bcd and binary"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/bcdtobin.9:38 org_netbsd/src/share/man/man9/bcmp.9:40 org_netbsd/src/share/man/man9/bcopy.9:41 org_netbsd/src/share/man/man9/boothowto.9:36 org_netbsd/src/share/man/man9/bzero.9:41 org_netbsd/src/share/man/man9/cnmagic.9:48 org_netbsd/src/share/man/man9/copy.9:48 org_netbsd/src/share/man/man9/cpu_configure.9:37 org_netbsd/src/share/man/man9/cpu_dumpconf.9:41 org_netbsd/src/share/man/man9/cpu_initclocks.9:37 org_netbsd/src/share/man/man9/cpu_rootconf.9:39 org_netbsd/src/share/man/man9/cpu_startup.9:39 org_netbsd/src/share/man/man9/fetch.9:49 org_netbsd/src/share/man/man9/hashinit.9:38 org_netbsd/src/share/man/man9/kcopy.9:37 org_netbsd/src/share/man/man9/kpreempt.9:37 org_netbsd/src/share/man/man9/kprintf.9:45 org_netbsd/src/share/man/man9/memcmp.9:42 org_netbsd/src/share/man/man9/memcpy.9:43 org_netbsd/src/share/man/man9/memmove.9:42 org_netbsd/src/share/man/man9/memset.9:42 org_netbsd/src/share/man/man9/nullop.9:37 org_netbsd/src/share/man/man9/panic.9:38 org_netbsd/src/share/man/man9/pmatch.9:33 org_netbsd/src/share/man/man9/setjmp.9:39 org_netbsd/src/share/man/man9/store.9:49 org_netbsd/src/share/man/man9/ucas.9:37 org_netbsd/src/share/man/man9/uiomove.9:34
#, no-wrap
msgid "sys/systm.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bcdtobin.9:43
msgid ""
"E<.Ft unsigned int> E<.Fn bcdtobin \"unsigned int bcd\"> E<.Ft unsigned int> "
"E<.Fn bintobcd \"unsigned int bin\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bcdtobin.9:51
msgid ""
"The E<.Fn bcdtobin> and E<.Fn bintobcd> functions convert a single byte "
"between (unsigned) packed bcd and binary encodings."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bcdtobin.9:60
msgid ""
"The E<.Fn bcdtobin> function returns the binary value of its BCD-encoded "
"argument, E<.Fa bcd>.  The E<.Fn bintobcd> function returns the BCD encoding "
"of its binary argument, E<.Fa bin>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/bcmp.9:33 org_netbsd/src/share/man/man9/bcopy.9:34 org_netbsd/src/share/man/man9/bzero.9:34 org_netbsd/src/share/man/man9/memcmp.9:35 org_netbsd/src/share/man/man9/memmove.9:35 org_netbsd/src/share/man/man9/memset.9:35
#, no-wrap
msgid "July 7, 2001"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/bcmp.9:34
#, no-wrap
msgid "BCMP 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bcmp.9:38
msgid "E<.Nm bcmp>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/bcmp.9:38 org_netbsd/src/share/man/man9/memcmp.9:40
#, no-wrap
msgid "compare byte string"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bcmp.9:43
msgid "E<.Ft int> E<.Fn bcmp \"const void *b1\" \"const void *b2\" \"size_t len\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bcmp.9:58
msgid ""
"E<.Bf -symbolic> The E<.Fn bcmp> interface is obsolete.  Do not add new code "
"using it.  It will soon be purged.  Use E<.Xr memcmp 9> instead.  (The E<.Fn "
"bcmp> function is now a macro for E<.Xr memcmp 9>.)  E<.Ef>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bcmp.9:71
msgid ""
"The E<.Fn bcmp> function compares byte string E<.Fa b1> against byte string "
"E<.Fa b2>, returning zero if they are identical, non-zero otherwise.  Both "
"strings are assumed to be E<.Fa len> bytes long.  Zero-length strings are "
"always identical."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bcmp.9:73
msgid "The strings may overlap."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bcmp.9:74
msgid "E<.Xr memcmp 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/bcopy.9:35
#, no-wrap
msgid "BCOPY 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bcopy.9:39
msgid "E<.Nm bcopy>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/bcopy.9:39 org_netbsd/src/share/man/man9/memcpy.9:41 org_netbsd/src/share/man/man9/memmove.9:40
#, no-wrap
msgid "copy byte string"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bcopy.9:44
msgid "E<.Ft void> E<.Fn bcopy \"const void *src\" \"void *dst\" \"size_t len\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bcopy.9:59
msgid ""
"E<.Bf -symbolic> The E<.Fn bcopy> interface is obsolete.  Do not add new "
"code using it.  It will soon be purged.  Use E<.Xr memcpy 9> instead.  (The "
"E<.Fn bcopy> function is now a macro for E<.Xr memcpy 9>.)  E<.Ef>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bcopy.9:69
msgid ""
"The E<.Fn bcopy> function copies E<.Fa len> bytes from string E<.Fa src> to "
"string E<.Fa dst>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bcopy.9:82
msgid ""
"E<.Bf -symbolic> Unlike E<.Xr bcopy 3> the two strings must not overlap! "
"E<.Ef> In the traditional E<.Bx> kernel, overlapping copies were handled by "
"the now-purged E<.Fn ovbcopy> function.  If you need to copy overlapping "
"data, see E<.Xr memmove 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bcopy.9:86
msgid "If E<.Fa len> is zero, no bytes are copied."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bcopy.9:89
msgid "E<.Xr bcopy 3>, E<.Xr memcpy 9>, E<.Xr memmove 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/bintime_add.9:30 org_netbsd/src/share/man/man9/bpf.9:27 org_netbsd/src/share/man/man9/cnmagic.9:35 org_netbsd/src/share/man/man9/cons.9:27 org_netbsd/src/share/man/man9/imax.9:27 org_netbsd/src/share/man/man9/microtime.9:56 org_netbsd/src/share/man/man9/microuptime.9:29 org_netbsd/src/share/man/man9/timecounter.9:40
#, no-wrap
msgid "June 8, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/bintime_add.9:31
#, no-wrap
msgid "BINTIME_ADD 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bintime_add.9:35
msgid "E<.Nm bintime_add>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/bintime_add.9:35
#, no-wrap
msgid "operations on"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bintime_add.9:37
msgid "E<.Dq bintime>"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/bintime_add.9:38 org_netbsd/src/share/man/man9/itimerfix.9:37 org_netbsd/src/share/man/man9/microtime.9:68 org_netbsd/src/share/man/man9/microuptime.9:41 org_netbsd/src/share/man/man9/ppsratecheck.9:37 org_netbsd/src/share/man/man9/ratecheck.9:37 org_netbsd/src/share/man/man9/time_second.9:44 org_netbsd/src/share/man/man9/tvtohz.9:36
#, no-wrap
msgid "sys/time.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bintime_add.9:53
msgid ""
"E<.Ft vid> E<.Fn bintime_add \"struct bintime *bt\" \"const struct bintime "
"*bt2\"> E<.Ft void> E<.Fn bintime_addx \"struct bintime *bt\" \"uint64_t "
"x\"> E<.Ft void> E<.Fn bintime_sub \"struct bintime *bt\" \"const struct "
"bintime *bt2\"> E<.Ft void> E<.Fn bintime2timespec \"const struct bintime "
"*bt\" \"struct timespec *ts\"> E<.Ft void> E<.Fn timespec2bintime \"const "
"struct timespec *ts\" \"struct bintime *bt\"> E<.Ft void> E<.Fn "
"bintime2timeval \"const struct bintime *bt\" \"struct timeval *tv\"> E<.Ft "
"void> E<.Fn timeval2bintime \"const struct timeval *tv\" \"struct bintime "
"*bt\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bintime_add.9:60
msgid ""
"These functions are provided for convenience as part of the "
"machine-independent E<.Xr timecounter 9> framework.  All of them operate "
"with the E<.Em bintime> structure."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bintime_add.9:79
msgid ""
"The function E<.Fn bintime_add> adds the time information stored in E<.Fa "
"bt2> to E<.Fa bt>.  Conversely, E<.Fn bintime_sub> subtracts E<.Fa bt2> from "
"E<.Fa bt>.  The E<.Fn bintime_addx> function stores the fraction of a second "
"E<.Fa x> to E<.Fa bt>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bintime_add.9:97
msgid ""
"Like the function names bespeak, E<.Fn bintime2timespec> converts the E<.Em "
"bintime> structure to E<.Em struct timespec> and E<.Fn timespec2bintime> "
"does the opposite.  The functions E<.Fn bintime2timeval> and E<.Fn "
"timeval2bintime> operate with E<.Em struct timeval> instead.  The result is "
"stored to the right-hand side."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bintime_add.9:101
msgid "E<.Xr timeradd 3>, E<.Xr timeval 3>, E<.Xr bintime 9>, E<.Xr timecounter 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/bluetooth.9:33
#, no-wrap
msgid "November 20, 2007"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/bluetooth.9:34
#, no-wrap
msgid "BLUETOOTH 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:38
msgid "E<.Nm BLUETOOTH>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/bluetooth.9:38
#, no-wrap
msgid "Bluetooth Device/Protocol API"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/bluetooth.9:40 org_netbsd/src/share/man/man9/bluetooth.9:124
#, no-wrap
msgid "netbt/bluetooth.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/bluetooth.9:41 org_netbsd/src/share/man/man9/bluetooth.9:89
#, no-wrap
msgid "netbt/hci.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/bluetooth.9:42
#, no-wrap
msgid "netbt/l2cap.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/bluetooth.9:43
#, no-wrap
msgid "netbt/rfcomm.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:78
msgid ""
"E<.Ft struct hci_unit *> E<.Fn hci_attach \"const struct hci_if *hci_if\" "
"\"device_t dev\" \"uint16_t flags\"> E<.Ft void> E<.Fn hci_detach \"struct "
"hci_unit *unit\"> E<.Ft void> E<.Fn hci_input_event \"struct hci_unit "
"*unit\" \"struct mbuf *m\"> E<.Ft void> E<.Fn hci_input_acl \"struct "
"hci_unit *unit\" \"struct mbuf *m\"> E<.Ft void> E<.Fn hci_input_sco "
"\"struct hci_unit *unit\" \"struct mbuf *m\"> E<.Ft int> E<.Fn "
"btproto_attach \"btproto_handle *\" \"const struct btproto *proto\" \"void "
"*ref\"> E<.Ft int> E<.Fn btproto_bind \"btproto_handle\" \"struct "
"sockaddr_bt *addr\"> E<.Ft int> E<.Fn btproto_sockaddr \"btproto_handle\" "
"\"struct sockaddr_bt *addr\"> E<.Ft int> E<.Fn btproto_connect "
"\"btproto_handle\" \"struct sockaddr_bt *addr\"> E<.Ft int> E<.Fn "
"btproto_peeraddr \"btproto_handle\" \"struct sockaddr_bt *addr\"> E<.Ft int> "
"E<.Fn btproto_disconnect \"btproto_handle\" \"int linger\"> E<.Ft int> E<.Fn "
"btproto_detach \"btproto_handle *\"> E<.Ft int> E<.Fn btproto_listen "
"\"btproto_handle\"> E<.Ft int> E<.Fn btproto_send \"btproto_handle\" "
"\"struct mbuf *mbuf\"> E<.Ft int> E<.Fn btproto_rcvd \"btproto_handle\" "
"\"size_t space\"> E<.Ft int> E<.Fn btproto_setopt \"btproto_handle\" \"int "
"optarg\" \"void *arg\"> E<.Ft int> E<.Fn btproto_getopt \"btproto_handle\" "
"\"int optarg\" \"void *arg\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:84
msgid ""
"The Bluetooth Protocol Stack provides socket based access to Bluetooth "
"Devices.  This document describes device driver access to the stack from "
"below, and also the general Bluetooth Protocol/Service API for layering "
"above existing Bluetooth Protocols."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/bluetooth.9:84 org_netbsd/src/share/man/man9/bus_dma.9:112 org_netbsd/src/share/man/man9/cardbus.9:149 org_netbsd/src/share/man/man9/deviter.9:83 org_netbsd/src/share/man/man9/iic.9:105 org_netbsd/src/share/man/man9/ioasic.9:82 org_netbsd/src/share/man/man9/isa.9:138 org_netbsd/src/share/man/man9/isapnp.9:71 org_netbsd/src/share/man/man9/mca.9:83 org_netbsd/src/share/man/man9/pci.9:192 org_netbsd/src/share/man/man9/pcmcia.9:141 org_netbsd/src/share/man/man9/pmc.9:133 org_netbsd/src/share/man/man9/pmf.9:97 org_netbsd/src/share/man/man9/secmodel.9:75 org_netbsd/src/share/man/man9/tc.9:76 org_netbsd/src/share/man/man9/vme.9:116 org_netbsd/src/share/man/man9/wsdisplay.9:93 org_netbsd/src/share/man/man9/wskbd.9:66 org_netbsd/src/share/man/man9/wsmouse.9:55
#, no-wrap
msgid "DATA TYPES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:89
msgid ""
"Device drivers attaching to the Bluetooth Protocol Stack should pass a "
"pointer to a E<.Fa struct hci_if> defined in"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:91
msgid "containing the driver information as follows:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:101
#, no-wrap
msgid ""
"struct hci_if {\n"
"\tint\t(*enable)(device_t);\n"
"\tvoid\t(*disable)(device_t);\n"
"\tvoid\t(*output_cmd)(device_t, struct mbuf *);\n"
"\tvoid\t(*output_acl)(device_t, struct mbuf *);\n"
"\tvoid\t(*output_sco)(device_t, struct mbuf *);\n"
"\tvoid\t(*get_stats)(device_t, struct bt_stats *, int);\n"
"\tint\tipl;\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:105
msgid ""
"Statistics counters should be updated by the device after packets have been "
"transmitted or received, or when errors occur."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:118
#, no-wrap
msgid ""
"struct bt_stats {\n"
"\tuint32_t\terr_tx;\n"
"\tuint32_t\terr_rx;\n"
"\tuint32_t\tcmd_tx;\n"
"\tuint32_t\tevt_rx;\n"
"\tuint32_t\tacl_tx;\n"
"\tuint32_t\tacl_rx;\n"
"\tuint32_t\tsco_tx;\n"
"\tuint32_t\tsco_rx;\n"
"\tuint32_t\tbyte_tx;\n"
"\tuint32_t\tbyte_rx;\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:124
msgid ""
"Bluetooth Protocol layers attaching above the Bluetooth Protocol Stack will "
"make use of the E<.Fa struct btproto> data type, which is defined in"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:128
msgid ""
"and contains the following function callbacks which should be initialized by "
"the protocol layer before attaching to the protocol which it uses:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:138
#, no-wrap
msgid ""
"struct btproto {\n"
"\tvoid (*connecting)(void *);\n"
"\tvoid (*connected)(void *);\n"
"\tvoid (*disconnected)(void *, int);\n"
"\tvoid *(*newconn)(void *, struct sockaddr_bt *, struct sockaddr_bt *);\n"
"\tvoid (*complete)(void *, int);\n"
"\tvoid (*linkmode)(void *, int);\n"
"\tvoid (*input)(void *, struct mbuf *);\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:141
msgid "The following functions are related to the Bluetooth Device API."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:142
#, no-wrap
msgid "Fn hci_attach hci_if dev"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:152
msgid ""
"Attach Bluetooth HCI device E<.Ar dev> to the protocol stack in the manner "
"described by E<.Ar hci_if>.  Driver quirks may be registered by passing the "
"corresponding E<.Dv BTF_xxxx> flag in the E<.Ar flags> argument."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:157
msgid ""
"E<.Fn hci_attach> will return a E<.Fa struct hci_unit> handle to be passed "
"to the protocol stack in other calls."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:157
#, no-wrap
msgid "Fn hci_detach unit"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:161
msgid "Detach Bluetooth HCI E<.Ar unit> from the device."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:161
#, no-wrap
msgid "Fn hci_input_event unit mbuf"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:169
msgid ""
"This function should be called by the device when it has an event packet to "
"present to the protocol stack.  It may be called from an interrupt routine "
"at the E<.Fa ipl> value given in the E<.Ar hci_if> descriptor."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:169
#, no-wrap
msgid "Fn hci_input_acl unit mbuf"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:177
msgid ""
"This function should be called by the device when it has an ACL data packet "
"to present to the protocol stack.  It may be called from an interrupt "
"routine at the E<.Fa ipl> value given in the E<.Ar hci_if> descriptor."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:177
#, no-wrap
msgid "Fn hci_input_sco unit mbuf"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:185
msgid ""
"This function should be called by the device when it has an SCO data packet "
"to present to the protocol stack.  It may be called from an interrupt "
"routine at the E<.Fa ipl> value given in the E<.Ar hci_if> descriptor."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:185
#, no-wrap
msgid "Fn (*enable) dev"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:187
msgid "This will be called when the protocol stack wishes to enable the device."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:187
#, no-wrap
msgid "Fn (*disable) dev"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:189
msgid "This will be called when the protocol stack wishes to disable the device."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:189
#, no-wrap
msgid "Fn (*output_cmd) dev mbuf"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:196
msgid ""
"Will be called to output command packets on the device.  The device is "
"responsible for arbitrating access to the output queue, and output commands "
"should be sent asynchronously.  The device owns the E<.Ar mbuf> and should "
"release it when sent."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:196
#, no-wrap
msgid "Fn (*output_acl) dev mbuf"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:203
msgid ""
"Will be called to output ACL data packets on the device.  The device is "
"responsible for arbitrating access to the output queue, and ACL data packets "
"should be sent asynchronously.  The device owns the E<.Ar mbuf> and should "
"release it when sent."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:203
#, no-wrap
msgid "Fn (*output_sco) dev mbuf"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:213
msgid ""
"Will be called to output SCO data packets on the device.  The device is "
"responsible for arbitrating access to the output queue, and SCO data packets "
"should be sent asynchronously.  When the SCO data packet has been placed on "
"the device and the E<.Ar mbuf> is no longer required, it should be returned "
"to the Bluetooth protocol stack via the E<.Fn hci_complete_sco> call."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:213
#, no-wrap
msgid "Fn (*get_stats) dev dest flush"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:222
msgid ""
"Will be called when IO statistics are requested.  The E<.Fa bt_stats> "
"structure E<.Ar dest> should be filled in, and if the E<.Ar flush> argument "
"is true, statistics should be reset."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:228
msgid ""
"The following function definitions are related to the Bluetooth Protocol "
"API.  Note that the \"btproto\" prefix is representative only, the protocol "
"being used will have a more specific prefix with prototypes being declared "
"in the appropriate"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/bluetooth.9:228
#, no-wrap
msgid "netbt/btproto.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:230
msgid "file."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:231
#, no-wrap
msgid "Fn btproto_attach handle_ptr proto ref"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:241
msgid ""
"Allocate and initialize a new protocol object at the E<.Ar handle_ptr> "
"address that should subsequently be passed into the other functions.  E<.Ar "
"proto> is a pointer to the E<.Fa btproto> structure as described above "
"containing relevant callbacks, and E<.Ar ref> is the argument that will be "
"supplied to those calls."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:241
#, no-wrap
msgid "Fn btproto_bind handle addr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:246
msgid ""
"Set the local address of the protocol object described by E<.Ar handle> to "
"E<.Ar addr>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:246
#, no-wrap
msgid "Fn btproto_sockaddr handle addr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:251
msgid ""
"Copy the local address of the protocol object described by E<.Ar handle> "
"into E<.Ar addr>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:251
#, no-wrap
msgid "Fn btproto_connect handle addr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:264
msgid ""
"Initiate a connection by the protocol object described by E<.Ar handle> to "
"the remote device described by E<.Ar addr>.  This will result in a call to "
"either E<.Fn proto-\\*[Gt]connected> or E<.Fn proto-\\*[Gt]disconnected>, "
"and optionally E<.Fn proto-\\*[Gt]connecting> with the appropriate reference "
"as given to E<.Fn btproto_attach>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:264
#, no-wrap
msgid "Fn btproto_peeraddr handle addr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:269
msgid ""
"Copy the remote address of the protocol object described by E<.Ar handle> "
"into E<.Ar addr>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:269
#, no-wrap
msgid "Fn btproto_disconnect handle linger"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:278
msgid ""
"Schedule a disconnection by the protocol object described by E<.Ar handle>.  "
"This will result in a call to E<.Fn proto-\\*[Gt]disconnected> with the "
"appropriate reference when the connection is torn down.  If linger is zero, "
"the disconnection will be initiated immediately and any outstanding data may "
"be lost."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:278
#, no-wrap
msgid "Fn btproto_detach handle_ptr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:283
msgid ""
"Detach the protocol object described by the value in the location of E<.Ar "
"handle_ptr>, and free any related memory.  The pointer in the location is "
"cleared."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:283
#, no-wrap
msgid "Fn btproto_listen handle"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:290
msgid ""
"Use the protocol object described by E<.Ar handle> as a listening post.  "
"This will result in calls to the E<.Fn proto-\\*[Gt]newconn> function when "
"incoming connections are detected."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:290
#, no-wrap
msgid "Fn btproto_send handle mbuf"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:292
msgid "Send data on the connection described by the protocol object."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:292
#, no-wrap
msgid "Fn btproto_rcvd handle space"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:301
msgid ""
"Indicate to the protocol that E<.Ar space> is now available in the input "
"buffers so that flow control may be deasserted.  This should also be called "
"to indicate initial buffer space.  Note that E<.Ar space> is an absolute "
"value."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:301
#, no-wrap
msgid "Fn btproto_setopt handle optarg arg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:304
msgid "Set options on the protocol object described by E<.Ar handle>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:304
#, no-wrap
msgid "Fn btproto_getopt handle optarg arg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:307
msgid "Get options for the protocol object described by E<.Ar handle>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:307
#, no-wrap
msgid "Fn (*connecting) ref"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:312
msgid ""
"This function will be called when the protocol receives information that the "
"connection described by E<.Ar ref> is pending."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:312
#, no-wrap
msgid "Fn (*connected) ref"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:316
msgid ""
"This function will be called when the connection described by E<.Ar ref> is "
"successful and indicates that data may now be sent."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:316
#, no-wrap
msgid "Fn (*disconnected) ref error"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:320
msgid ""
"This function will be called when the connection described by E<.Ar ref> is "
"disconnected."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:320
#, no-wrap
msgid "Fn *(*newconn) ref laddr raddr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:329
msgid ""
"This function will be called when the protocol receives a new incoming "
"connection on the local device described by E<.Ar laddr> from the remote "
"device described by E<.Ar raddr>.  The protocol should decide if it wishes "
"to accept the connection and should attach and return a new instance of the "
"relevant protocol handle or NULL."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:329
#, no-wrap
msgid "Fn (*complete) ref count"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:341
msgid ""
"This function will be called when the protocol has completed sending data.  "
"Complete will usually mean that the data has successfully left the device "
"though for guaranteed protocols it can mean that the data has arrived at the "
"other end and been acknowledged, and that E<.Ar count> amount of data can be "
"removed from the socket buffer.  The units of the E<.Ar count> value will be "
"dependent on the protocol being used (e.g. RFCOMM is bytes, but L2CAP is "
"packets)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:341
#, no-wrap
msgid "Fn (*linkmode) ref mode"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:346
msgid ""
"This function will be called for established connections, when the link mode "
"of the baseband link has changed.  E<.Ar mode> is the new mode."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bluetooth.9:346
#, no-wrap
msgid "Fn (*input) ref mbuf"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:349
msgid ""
"This function is called to supply new data on the connection described by "
"E<.Ar ref>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:354
msgid "The Bluetooth Protocol Stack is contained in the E<.Pa sys/netbt> directory."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:359
msgid ""
"The Bluetooth Device API as described above is contained in the E<.Pa "
"sys/netbt/hci_unit.c> file."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:369
msgid ""
"For examples of the Bluetooth Protocol API see the interaction between the "
"L2CAP upper layer in E<.Pa sys/netbt/l2cap_upper.c> and either the L2CAP "
"socket layer in E<.Pa sys/netbt/l2cap_socket.c> or the E<.Xr bthidev 4> "
"pseudo-device in E<.Pa sys/dev/bluetooth/bthidev.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:374
msgid ""
"Also, the RFCOMM upper layer in E<.Pa sys/netbt/rfcomm_upper.c> and the "
"RFCOMM socket layer in E<.Pa sys/netbt/rfcomm_socket.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:379
msgid "E<.Xr bluetooth 4>, E<.Xr bt3c 4>, E<.Xr bthidev 4>, E<.Xr ubt 4>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bluetooth.9:384
msgid ""
"This Bluetooth Protocol Stack was written for E<.Nx 4.0> by E<.An Iain "
"Hibbert>, under the sponsorship of Itronix, Inc."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/boothowto.9:27
#, no-wrap
msgid "September 11, 2009"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/boothowto.9:28
#, no-wrap
msgid "BOOTHOWTO 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:33
msgid "E<.Nm boothowto>, E<.Nm BOOT_FLAG>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/boothowto.9:33
#, no-wrap
msgid "flags passed to kernel during boot or shutdown"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/boothowto.9:35 org_netbsd/src/share/man/man9/cpu_reboot.9:42
#, no-wrap
msgid "sys/reboot.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:38
msgid "E<.Vt extern int boothowto;>"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/boothowto.9:38 org_netbsd/src/share/man/man9/boothowto.9:62
#, no-wrap
msgid "sys/boot_flag.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:40
msgid "E<.Vt #define BOOT_FLAG(arg, retval) ...>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:53
msgid ""
"The E<.Va boothowto> variable contains flags passed to the kernel by the "
"boot loader (see E<.Xr boot 8>), or the E<.Xr reboot 2> system call.  The "
"value is interpreted as a bit mask, with bits defined by the E<.Dq Sy RB_ Ns "
"No *> and E<.Dq Sy AB_ Ns No *> symbols in"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/boothowto.9:53
#, no-wrap
msgid "sys/reboot.h ."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:58
msgid ""
"The value is made available via the E<.Xr sysctl 7> variable E<.Va "
"kern.boothowto>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:62
msgid "The E<.Dv BOOT_FLAG> macro defined in"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:68
msgid ""
"is used by many boot loaders to convert command line options into E<.Va "
"boothowto> flags.  Note that not all boot loaders use this macro, and some "
"boot loaders may have incompatible options."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:73
msgid ""
"Where possible, flags set by the E<.Xr reboot 2> system call will be passed "
"to the new kernel after a reboot; the extent to which this is possible is "
"machine dependent."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:78
msgid ""
"In the following tables, each flag is listed with its symbolic name, the "
"corresponding numeric value defined in"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/boothowto.9:78
#, no-wrap
msgid "sys/reboot.h ,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:82
msgid "and the option letter (if any) understood by the E<.Dv BOOT_FLAG> macro."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/boothowto.9:83
#, no-wrap
msgid "Flags that affect booting or shutting down"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:86
msgid "The following flags affect actions taken during system boot or shutdown."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/boothowto.9:87
#, no-wrap
msgid "Dv RB_AUTOBOOT Ta Li 0 Ta Ta"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:90
msgid ""
"The default if no other flags are set.  Causes the system to boot in the "
"normal way."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/boothowto.9:90
#, no-wrap
msgid "Dv RB_ASKNAME Ta Li 0x00000001 Ta Fl a Ta"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:92
msgid "This flag causes various parts of the system to prompt:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:96
msgid ""
"The boot loader may prompt for the name or location of the kernel to be "
"booted."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:98
msgid "The kernel will prompt for the root file system device."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:100
msgid "The kernel will prompt for the root file system type."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:102
msgid "The kernel will prompt for the location of the dump device."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:106
msgid "The kernel will prompt for the path to the E<.Xr init 8> program."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:109
msgid ""
"Some subsystems set this flag when they are unable to automatically make a "
"decision."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/boothowto.9:109
#, no-wrap
msgid "Dv RB_SINGLE Ta Li 0x00000002 Ta Fl s Ta"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:115
msgid ""
"Boot in single-user mode.  If this flag is set, the kernel passes the E<.Fl "
"s> option to E<.Xr init 8>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/boothowto.9:115
#, no-wrap
msgid "Dv RB_NOSYNC Ta Li 0x00000004 Ta Ta"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:118
msgid ""
"If this flag is set, then some parts of the shutdown process will be less "
"graceful than usual:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:125
msgid "Disks will not be synced (see E<.Xr sync 2> and E<.Xr cpu_reboot 9>)."
msgstr ""

#.  actually, see config_detach_all, but that is undocumented
#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:129
msgid "Devices will not be detached (see E<.Xr autoconf 9>)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:134
msgid ""
"File systems will not be unmounted (see E<.Xr cpu_reboot 9>, and E<.Xr "
"vfs_shutdown 9>)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:137
msgid "The time of day clock will not be set (see E<.Xr resettodr 9>)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/boothowto.9:138
#, no-wrap
msgid "Dv RB_HALT Ta Li 0x00000008 Ta Fl b Ta"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:144
msgid ""
"If this flag is set, then E<.Xr reboot 2> will cause the system to halt "
"instead of rebooting.  This flag may be set at boot time, and cannot be "
"cleared by E<.Xr reboot 2>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/boothowto.9:144
#, no-wrap
msgid "Dv RB_INITNAME Ta Li 0x00000010 Ta Ta"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:151
msgid ""
"This flag is obsolete.  It was previously used to cause the kernel to prompt "
"for the name of the E<.Xr init 8> program, but that function is now "
"controlled by the E<.Dv RB_ASKNAME> flag."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/boothowto.9:151
#, no-wrap
msgid "Dv RB_KDB Ta Li 0x00000040 Ta Fl d Ta"
msgstr ""

#.  the kgdb_* functions are undocumented
#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:161
msgid ""
"Gives control to a kernel debugger early in the boot sequence.  See E<.Xr "
"ddb 4>, E<.Dq \"options KGDB\"> in E<.Xr options 4>, and E<.Xr ipkdb 9>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/boothowto.9:161
#, no-wrap
msgid "Dv RB_RDONLY Ta Li 0x00000080 Ta Ta"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:166
msgid ""
"This flag is deprecated.  It previously caused the kernel to mount the root "
"file system in read-only mode, but now that is the default, and this flag "
"has no effect."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/boothowto.9:166
#, no-wrap
msgid "Dv RB_DUMP Ta Li 0x00000100 Ta Ta"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:173
msgid ""
"Causes the kernel to dump memory to the dump device during shutdown.  See "
"E<.Xr savecore 8>, E<.Xr cpu_reboot 9>, and E<.Xr dumpsys 9>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/boothowto.9:173
#, no-wrap
msgid "Dv RB_MINIROOT Ta Li 0x00000200 Ta Fl m Ta"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:180
msgid ""
"This flag informs the kernel that a mini-root file system is present in "
"memory.  See E<.Xr md 4>, and E<.Xr mdsetimage 8>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/boothowto.9:180
#, no-wrap
msgid "Dv RB_STRING Ta Li 0x00000400 Ta Ta"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:185
msgid ""
"This flag indicates that a boot string is present.  The string may be "
"provided by E<.Xr reboot 2> and will be passed to the boot loader if "
"possible."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/boothowto.9:185
#, no-wrap
msgid "Dv RB_POWERDOWN Ta Li (RB_HALT|0x800) Ta Ta"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:190
msgid ""
"This flag is used in conjunction with E<.Dv RB_HALT>.  If this flag is set, "
"then then system will be powered down if possible.  If powerdown is not "
"supported, then the system will halt."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/boothowto.9:190
#, no-wrap
msgid "Dv RB_USERCONF Ta Li 0x00001000 Ta Fl c Ta"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:194
msgid ""
"This flag causes the kernel to invoke the E<.Xr userconf 4> device "
"configuration manager early in the boot sequence."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/boothowto.9:196
#, no-wrap
msgid "Flags that affect verbosity"
msgstr ""

#.  the /dev/log device driver is undocumented
#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:206
msgid ""
"The following flags affect the verbosity of messages printed by the kernel.  "
"These flags are used by several functions described in E<.Xr kprintf 9> to "
"control whether output is sent to the console, the system log, both, or "
"neither.  The use of flags that increase verbosity simultaneously with the "
"use of flags that decrease verbosity, is not well defined."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/boothowto.9:207
#, no-wrap
msgid "Dv AB_NORMAL Ta Li 0 Ta Ta"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:212
msgid ""
"The default, if none of the other E<.Dv AB_*> flags is set, is that ordinary "
"kernel messages are sent both to the console and to the system log."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/boothowto.9:212
#, no-wrap
msgid "Dv AB_QUIET Ta Li 0x00010000 Ta Fl q Ta"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:219
msgid ""
"Boot quietly.  Ordinary kernel messages are sent to the system log, but not "
"to the console.  Messages printed with E<.Xr aprint_naive 9> are sent to the "
"console, but not to the system log."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/boothowto.9:219
#, no-wrap
msgid "Dv AB_VERBOSE Ta Li 0x00020000 Ta Fl v Ta"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:228
msgid ""
"Boot verbosely.  Some messages will be printed that would otherwise not be "
"printed.  Both ordinary kernel messages, and messages printed with E<.Xr "
"aprint_verbose 9>, will be sent both to the console and to the system log.  "
"If this flag is not set, then messages printed with E<.Xr aprint_verbose 9> "
"will be sent only to the system log."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/boothowto.9:228
#, no-wrap
msgid "Dv AB_SILENT Ta Li 0x00040000 Ta Fl z Ta"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:234
msgid ""
"Boot silently.  Most kernel messages will be sent only to the system log, "
"not to the console.  The E<.Fn aprint_*> functions display a spinning symbol "
"on the console."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/boothowto.9:234
#, no-wrap
msgid "Dv AB_DEBUG Ta Li 0x00080000 Ta Fl x Ta"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:236
msgid "Boot with debug messages."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/boothowto.9:238
#, no-wrap
msgid "Machine-dependent flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:240
msgid "The following flags have machine-dependent meanings."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/boothowto.9:241
#, no-wrap
msgid "Dv RB_MD1 Ta Li 0x10000000 Ta Fl 1 Ta"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:245
msgid ""
"Some ports use this flag to disable multiprocessor mode, making them use "
"only a single CPU.  The zaurus port uses this flag to enable the serial "
"console."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/boothowto.9:245
#, no-wrap
msgid "Dv RB_MD2 Ta Li 0x20000000 Ta Fl 2 Ta"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:248
msgid "The i386 and amd64 ports use this flag to disable E<.Xr acpi 4>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/boothowto.9:248
#, no-wrap
msgid "Dv RB_MD3 Ta Li 0x40000000 Ta Fl 3 Ta"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:250 org_netbsd/src/share/man/man9/boothowto.9:252
msgid "This flag is currently not used by any ports."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/boothowto.9:250
#, no-wrap
msgid "Dv RB_MD4 Ta Li 0x80000000 Ta Fl 4 Ta"
msgstr ""

#.  sets boothowto
#.  RB_KDB
#.  RB_USERCONF
#.  sysctl kern.boothowto
#.  sets boothowto
#.  RB_SINGLE, RB_INITNAME
#.  reboot/poweroff/halt calls reboot(2)
#.  useful after RB_DUMP
#.  RB_NOSYNC
#.  RB_NOSYNC, RB_HALT, RB_DUMP
#.  aprint_*() functions use AB_* flags
#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:278
msgid ""
"E<.Xr reboot 2>, E<.Xr ddb 4>, E<.Xr userconf 4>, E<.Xr sysctl 7>, E<.Xr "
"boot 8>, E<.Xr crash 8>, E<.Xr init 8>, E<.Xr reboot 8>, E<.Xr savecore 8>, "
"E<.Xr sync 8>, E<.Xr cpu_reboot 9>, E<.Xr kprintf 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:287
msgid ""
"The E<.Va boothowto> variable appeared in E<.Bx 4.0>.  The E<.Sy BOOT_FLAG> "
"macro appeared in E<.Nx 1.6>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/boothowto.9:291
msgid "The E<.Dv RB_DFLTROOT> option is now E<.Em obsolete>."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/bpf.9:28
#, no-wrap
msgid "BPF 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bpf.9:32
msgid "E<.Nm bpf>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/bpf.9:32
#, no-wrap
msgid "Berkeley Packet Filter kernel interface"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/bpf.9:34 org_netbsd/src/share/man/man9/m_tag.9:49 org_netbsd/src/share/man/man9/mbuf.9:72 org_netbsd/src/share/man/man9/pfil.9:42
#, no-wrap
msgid "sys/mbuf.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/bpf.9:35 org_netbsd/src/share/man/man9/ieee80211_radiotap.9:41
#, no-wrap
msgid "net/bpf.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bpf.9:39
msgid "E<.Nm> is called via an operations vector described by the following struct:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bpf.9:45
#, no-wrap
msgid ""
"struct bpf_ops {\n"
"        void (*bpf_attach)(struct ifnet *, u_int, u_int, struct bpf_if "
"**);\n"
"        void (*bpf_detach)(struct ifnet *);\n"
"        void (*bpf_change_type)(struct ifnet *, u_int, u_int);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bpf.9:54
#, no-wrap
msgid ""
"        void (*bpf_tap)(struct bpf_if *, u_char *, u_int);\n"
"        void (*bpf_mtap)(struct bpf_if *, struct mbuf *);\n"
"        void (*bpf_mtap2)(struct bpf_if *, void *, u_int, struct mbuf *);\n"
"        void (*bpf_mtap_af)(struct bpf_if *, uint32_t, struct mbuf *);\n"
"        void (*bpf_mtap_et)(struct bpf_if *, uint16_t, struct mbuf *);\n"
"        void (*bpf_mtap_sl_in)(struct bpf_if *, u_char *, struct mbuf **);\n"
"        void (*bpf_mtap_sl_out)(struct bpf_if *, u_char *, struct mbuf *);\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bpf.9:64
msgid ""
"This vector is found from E<.Vt struct bpf_ops *> E<.Va bpf_ops>.  It is "
"either a E<.Dq stub> implementation or a real implementation, depending on "
"whether E<.Nm> is absent or present in the kernel, respectively."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bpf.9:73
msgid ""
"The E<.Nm> implementation is located in E<.Pa sys/net/bpf.c>, the stub "
"implementation is in E<.Pa sys/net/bpf_stub.c>, and E<.Pa sys/net/bpf.h> "
"describes the interface."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/buffercache.9:104
#, no-wrap
msgid "November 11, 2009"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/buffercache.9:105
#, no-wrap
msgid "BUFFERCACHE 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/buffercache.9:121
msgid ""
"E<.Nm buffercache>, E<.Nm bread>, E<.Nm breadn>, E<.Nm bwrite>, E<.Nm "
"bawrite>, E<.Nm bdwrite>, E<.Nm getblk>, E<.Nm geteblk>, E<.Nm incore>, "
"E<.Nm allocbuf>, E<.Nm brelse>, E<.Nm biodone>, E<.Nm biowait>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/buffercache.9:121
#, no-wrap
msgid "buffer cache interfaces"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/buffercache.9:124 org_netbsd/src/share/man/man9/getiobuf.9:36 org_netbsd/src/share/man/man9/vnodeops.9:83
#, no-wrap
msgid "sys/buf.h"
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/buffercache.9:154
msgid ""
"E<.Ft int> E<.Fn bread \"struct vnode *vp\" \"daddr_t blkno\" \"int size\" "
"\"struct kauth_cred *cred\" \"int flags\" \"buf_t **bpp\"> E<.Ft int> E<.Fn "
"breadn \"struct vnode *vp\" \"daddr_t blkno\" \"int size\" \"daddr_t "
"rablks[]\" \"int rasizes[]\" \"int nrablks\" \"struct kauth_cred *cred\" "
"\"int flags\" \"buf_t **bpp\"> E<.Ft int> E<.Fn bwrite \"buf_t *bp\"> E<.Ft "
"void> E<.Fn bawrite \"buf_t *bp\"> E<.Ft void> E<.Fn bdwrite \"buf_t *bp\"> "
"E<.Ft buf_t *> E<.Fn getblk \"struct vnode *vp\" \"daddr_t blkno\" \"int "
"size\" \"int slpflag\" \"int slptimeo\"> E<.Ft buf_t *> E<.Fn geteblk \"int "
"size\"> E<.Ft buf_t *> E<.Fn incore \"struct vnode *vp\" \"daddr_t blkno\"> "
"E<.Ft void> E<.Fn allocbuf \"buf_t *bp\" \"int size\" \"int preserve\"> "
"E<.Ft void> E<.Fn brelse \"buf_t *bp\" \"int set\"> E<.Ft void> E<.Fn "
"biodone \"buf_t *bp\"> E<.Ft int> E<.Fn biowait \"buf_t *bp\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/buffercache.9:159
msgid ""
"The E<.Nm> interface is used by each filesystems to improve I/O performance "
"using in-core caches of filesystem blocks."
msgstr ""

#.  XXX buf_t, B_ flags, MP locks, etc
#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/buffercache.9:170
msgid ""
"The kernel memory used to cache a block is called a buffer and described by "
"a E<.Em buf> structure.  In addition to describing a cached block, a E<.Em "
"buf> structure is also used to describe an I/O request as a part of the disk "
"driver interface."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/buffercache.9:172
#, no-wrap
msgid "Fn bread vp blkno size cred flags bpp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/buffercache.9:199
msgid ""
"Read a block corresponding to E<.Fa vp> and E<.Fa blkno>.  The buffer is "
"returned via E<.Fa bpp>.  The units of E<.Fa blkno> are specifically the "
"units used by the E<.Fn VOP_STRATEGY> routine for the E<.Fa vp> vnode.  For "
"device special files, E<.Fa blkno> is in units of E<.Dv DEV_BSIZE> and both "
"E<.Fa blkno> and E<.Fa size> must be multiples of the underlying device's "
"block size.  For other files, E<.Fa blkno> is in units chosen by the file "
"system containing E<.Fa vp>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/buffercache.9:207
msgid ""
"If the buffer is not found (i.e. the block is not cached in memory), E<.Fn "
"bread> allocates a buffer with enough pages for E<.Fa size> and reads the "
"specified disk block into it using credential E<.Fa cred>."
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/buffercache.9:223
msgid ""
"The buffer returned by E<.Fn bread> is marked as busy.  (The E<.Dv B_BUSY> "
"flag is set.)  After manipulation of the buffer returned from E<.Fn bread>, "
"the caller should unbusy it so that another thread can get it.  If the "
"buffer contents are modified and should be written back to disk, it should "
"be unbusied using one of variants of E<.Fn bwrite>.  Otherwise, it should be "
"unbusied using E<.Fn brelse>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/buffercache.9:223
#, no-wrap
msgid "Fn breadn vp blkno size rablks rasizes nrablks cred flags bpp"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/buffercache.9:234
msgid ""
"Get a buffer as E<.Fn bread>.  In addition, E<.Fn breadn> will start "
"read-ahead of blocks specified by E<.Fa rablks>, E<.Fa rasizes>, E<.Fa "
"nrablks>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/buffercache.9:234
#, no-wrap
msgid "Fn breada vp blkno size rablkno rabsize cred flags bpp"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/buffercache.9:241
msgid ""
"Same as E<.Fn breadn> with single block read-ahead.  This function is for "
"compatibility with old filesystem code and shouldn't be used by new ones."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/buffercache.9:241
#, no-wrap
msgid "Fn bwrite bp"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/buffercache.9:252
msgid ""
"Write a block.  Start I/O for write using E<.Fn VOP_STRATEGY>.  Then, unless "
"the E<.Dv B_ASYNC> flag is set in E<.Fa bp>, E<.Fn bwrite> waits for the I/O "
"to complete."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/buffercache.9:252
#, no-wrap
msgid "Fn bawrite bp"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/buffercache.9:264
msgid ""
"Write a block asynchronously.  Set the E<.Dv B_ASYNC> flag in E<.Fa bp> and "
"simply call E<.Fn VOP_BWRITE>, which results in E<.Fn bwrite> for most "
"filesystems."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/buffercache.9:264
#, no-wrap
msgid "Fn bdwrite bp"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/buffercache.9:274
msgid ""
"Delayed write.  Unlike E<.Fn bawrite>, E<.Fn bdwrite> won't start any I/O.  "
"It only marks the buffer as dirty E<.Pq Dv B_DELWRI> and unbusy it."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/buffercache.9:274
#, no-wrap
msgid "Fn getblk vp blkno size slpflag slptimeo"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/buffercache.9:286
msgid ""
"Get a block of requested size E<.Fa size> that is associated with a given "
"vnode and block offset, specified by E<.Fa vp> and E<.Fa blkno>.  If it is "
"found in the block cache, make it busy and return it.  Otherwise, return an "
"empty block of the correct size.  It is up to the caller to ensure that the "
"cached blocks are of the correct size."
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/buffercache.9:296
msgid ""
"If E<.Fn getblk> needs to sleep, E<.Fa slpflag> and E<.Fa slptimeo> are used "
"as arguments for E<.Fn cv_timedwait>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/buffercache.9:296
#, no-wrap
msgid "Fn geteblk size"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/buffercache.9:300
msgid "Allocate an empty, disassociated block of a given size E<.Fa size>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/buffercache.9:300
#, no-wrap
msgid "Fn incore vp blkno"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/buffercache.9:309
msgid ""
"Determine if a block associated to a given vnode and block offset is in the "
"cache.  If it is there, return a pointer to it.  Note that E<.Fn incore> "
"doesn't busy the buffer unlike E<.Fn getblk>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/buffercache.9:309
#, no-wrap
msgid "Fn allocbuf bp size preserve"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/buffercache.9:322
msgid ""
"Expand or contract the actual memory allocated to a buffer.  If E<.Fa "
"preserve> is zero, the entire data in the buffer will be lost.  Otherwise, "
"if the buffer shrinks, the truncated part of the data is lost, so it is up "
"to the caller to have written it out E<.Em first> if needed; this routine "
"will not start a write.  If the buffer grows, it is the callers "
"responsibility to fill out the buffer's additional contents."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/buffercache.9:322
#, no-wrap
msgid "Fn brelse bp set"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/buffercache.9:325
msgid "Unbusy a buffer and release it to the free lists."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/buffercache.9:325
#, no-wrap
msgid "Fn biodone bp"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/buffercache.9:332
msgid ""
"Mark I/O complete on a buffer.  If a callback has been requested by E<.Dv "
"B_CALL>, do so.  Otherwise, wakeup waiters."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/buffercache.9:332
#, no-wrap
msgid "Fn biowait bp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/buffercache.9:335
msgid ""
"Wait for operations on the buffer to complete.  When they do, extract and "
"return the I/O's error value."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/buffercache.9:340
msgid ""
"The buffer cache subsystem is implemented within the file E<.Pa "
"sys/kern/vfs_bio.c>."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/buffercache.9:359
msgid ""
"E<.Xr intro 9>, E<.Xr vnode 9> E<.Rs> E<.%A Maurice J. Bach> E<.%B \"The "
"Design of the UNIX Operating System\"> E<.%I \"Prentice Hall\"> E<.%D 1986> "
"E<.Re> E<.Rs> E<.%A Marshall Kirk McKusick> E<.%A Keith Bostic> E<.%A "
"Michael J. Karels> E<.%A John S. Quarterman> E<.%B \"The Design and "
"Implementation of the 4.4BSD Operating System\"> E<.%I \"Addison Wesley\"> "
"E<.%D 1996> E<.Re>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/buffercache.9:364
msgid ""
"In the current implementation, E<.Fn bread> and its variants don't use a "
"specified credential."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/buffercache.9:371
msgid ""
"Because E<.Fn biodone> and E<.Fn biowait> do not really belong to E<.Nm>, "
"they shouldn't be documented here."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/bufq.9:30
#, no-wrap
msgid "January 24, 2009"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/bufq.9:31
#, no-wrap
msgid "BUFQ 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bufq.9:45
msgid ""
"E<.Nm bufq>, E<.Nm bufq_state>, E<.Nm bufq_alloc>, E<.Nm bufq_drain>, E<.Nm "
"bufq_free>, E<.Nm bufq_getstrategyname>, E<.Nm bufq_move>, E<.Nm bufq_put>, "
"E<.Nm bufq_get>, E<.Nm bufq_peek>, E<.Nm bufq_cancel>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/bufq.9:45
#, no-wrap
msgid "device buffer queues"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/bufq.9:47
#, no-wrap
msgid "sys/bufq.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bufq.9:66
msgid ""
"E<.Ft int> E<.Fn bufq_alloc \"struct bufq_state **bufq\" \"const char "
"*strategy\" \"int flags\"> E<.Ft void> E<.Fn bufq_drain \"struct bufq_state "
"*bufq\"> E<.Ft void> E<.Fn bufq_free \"struct bufq_state *bufq\"> E<.Ft "
"\"const char *\"> E<.Fn bufq_getstrategyname \"struct bufq_state *bufq\"> "
"E<.Ft void> E<.Fn bufq_move \"struct bufq_state *dst\" \"struct bufq_state "
"*src\"> E<.Ft void> E<.Fn bufq_put \"struct bufq_state *bufq\" \"struct buf "
"*bp\"> E<.Ft \"struct buf *\"> E<.Fn bufq_get \"struct bufq_state *bufq\"> "
"E<.Ft \"struct buf *\"> E<.Fn bufq_peek \"struct bufq_state *bufq\"> E<.Ft "
"\"struct buf *\"> E<.Fn bufq_cancel \"struct bufq_state *bufq\" \"struct buf "
"*bp\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bufq.9:70
msgid ""
"The E<.Nm> subsystem is a set of operations for the management of device "
"buffer queues."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bufq.9:74
msgid ""
"The primary data type for using the operations is the E<.Em bufq_state> "
"structure, which is opaque for users."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bufq.9:76
#, no-wrap
msgid "Fn bufq_alloc bufq strategy flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bufq.9:80
msgid "Allocate and initialize a E<.Em bufq_state> descriptor."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bufq.9:85
msgid ""
"The argument E<.Fa strategy> specifies a buffer queue strategy to be used "
"for this buffer queue.  The following special values can be used:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bufq.9:87
#, no-wrap
msgid "Dv BUFQ_STRAT_ANY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bufq.9:91
msgid "Let E<.Fn bufq_alloc> select a strategy."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bufq.9:91
#, no-wrap
msgid "Dv BUFQ_DISK_DEFAULT_STRAT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bufq.9:95
msgid ""
"Let E<.Fn bufq_alloc> select a strategy, assuming it will be used for a "
"normal disk device."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bufq.9:100
msgid "Valid bits for the E<.Fa flags> are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bufq.9:102
#, no-wrap
msgid "Dv BUFQ_SORT_RAWBLOCK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bufq.9:105
msgid "sort by E<.Em b_rawblkno>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bufq.9:105
#, no-wrap
msgid "Dv BUFQ_SORT_CYLINDER"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bufq.9:110
msgid "sort by E<.Em b_cylinder> and then by E<.Em b_rawblkno>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bufq.9:110
#, no-wrap
msgid "Dv BUFQ_EXACT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bufq.9:121
msgid ""
"Fail if a strategy specified by E<.Fa strategy> is not available.  In that "
"case, E<.Fa bufq_alloc> returns E<.Dv ENOENT>.  If this flag is not "
"specified, E<.Fn bufq_alloc> will silently use one of available strategies."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bufq.9:122
#, no-wrap
msgid "Fn bufq_drain bufq"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bufq.9:126
msgid "Drain a E<.Em bufq_state> descriptor."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bufq.9:126
#, no-wrap
msgid "Fn bufq_free bufq"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bufq.9:130
msgid "Destroy a E<.Em bufq_state> descriptor."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bufq.9:130
#, no-wrap
msgid "Fn bufq_getstrategyname bufq"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bufq.9:134
msgid ""
"Get a strategy identifier of a buffer queue, the string returned will be "
"NUL-terminated and it always will be a valid strategy name."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bufq.9:134
#, no-wrap
msgid "Fn bufq_move dst src"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bufq.9:139
msgid ""
"Move all requests from the buffer queue E<.Fa src> to the buffer queue E<.Fa "
"dst>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bufq.9:139
#, no-wrap
msgid "Fn bufq_put bufq bp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bufq.9:143
msgid "Put the buf E<.Fa bp> in the queue."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bufq.9:143
#, no-wrap
msgid "Fn bufq_get bufq"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bufq.9:148
msgid ""
"Get the next buf from the queue and remove it from the queue.  Returns E<.Dv "
"NULL> if the queue is empty."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bufq.9:148
#, no-wrap
msgid "Fn bufq_peek bufq"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bufq.9:159
msgid ""
"Get the next buf from the queue without removal.  The next buf will remain "
"the same until E<.Fn bufq_get>, E<.Fn bufq_put>, or E<.Fn bufq_drain> is "
"called.  Returns E<.Dv NULL> if the queue is empty."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bufq.9:159
#, no-wrap
msgid "Fn bufq_cancel bufq bp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bufq.9:170
msgid ""
"Cancel the buf E<.Fa bp> issued earlier on the queue.  Returns E<.Dv NULL> "
"if the element can not be found on the queue or E<.Fa bp> if it has been "
"found and removed.  This operation can be computationally expensive if there "
"are a lot of buffers queued."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bufq.9:175
msgid ""
"The actual code implementing the device buffer queues can be found in the "
"file E<.Pa sys/kern/subr_bufq.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bufq.9:180
msgid "The E<.Nm> subsystem appeared in E<.Nx 2.0>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bufq.9:185 org_netbsd/src/share/man/man9/fstrans.9:232
msgid ""
"The E<.Nm> subsystem was written by E<.An J\\(:urgen Hannken-Illjes> E<.Aq "
"hannken@NetBSD.org>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/bus_dma.9:31
#, no-wrap
msgid "July 8, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/bus_dma.9:32
#, no-wrap
msgid "BUS_DMA 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:51
msgid ""
"E<.Nm bus_dma>, E<.Nm bus_dmamap_create>, E<.Nm bus_dmamap_destroy>, E<.Nm "
"bus_dmamap_load>, E<.Nm bus_dmamap_load_mbuf>, E<.Nm bus_dmamap_load_uio>, "
"E<.Nm bus_dmamap_load_raw>, E<.Nm bus_dmamap_unload>, E<.Nm "
"bus_dmamap_sync>, E<.Nm bus_dmamem_alloc>, E<.Nm bus_dmamem_free>, E<.Nm "
"bus_dmamem_map>, E<.Nm bus_dmamem_unmap>, E<.Nm bus_dmamem_mmap>, E<.Nm "
"bus_dmatag_subregion>, E<.Nm bus_dmatag_destroy>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/bus_dma.9:51
#, no-wrap
msgid "Bus and Machine Independent DMA Mapping Interface"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/bus_dma.9:53 org_netbsd/src/share/man/man9/bus_space.9:120 org_netbsd/src/share/man/man9/bus_space.9:394 org_netbsd/src/share/man/man9/cardbus.9:58 org_netbsd/src/share/man/man9/ioasic.9:42 org_netbsd/src/share/man/man9/isa.9:59 org_netbsd/src/share/man/man9/isapnp.9:40 org_netbsd/src/share/man/man9/mca.9:42 org_netbsd/src/share/man/man9/pci.9:67 org_netbsd/src/share/man/man9/pcmcia.9:56 org_netbsd/src/share/man/man9/tc.9:46 org_netbsd/src/share/man/man9/vme.9:51
#, no-wrap
msgid "sys/bus.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:95
msgid ""
"E<.Ft int> E<.Fn bus_dmamap_create \"bus_dma_tag_t tag\" \"bus_size_t size\" "
"\"int nsegments\" \"bus_size_t maxsegsz\" \"bus_size_t boundary\" \"int "
"flags\" \"bus_dmamap_t *dmamp\"> E<.Ft void> E<.Fn bus_dmamap_destroy "
"\"bus_dma_tag_t tag\" \"bus_dmamap_t dmam\"> E<.Ft int> E<.Fn "
"bus_dmamap_load \"bus_dma_tag_t tag\" \"bus_dmamap_t dmam\" \"void *buf\" "
"\"bus_size_t buflen\" \"struct lwp *l\" \"int flags\"> E<.Ft int> E<.Fn "
"bus_dmamap_load_mbuf \"bus_dma_tag_t tag\" \"bus_dmamap_t dmam\" \"struct "
"mbuf *chain\" \"int flags\"> E<.Ft int> E<.Fn bus_dmamap_load_uio "
"\"bus_dma_tag_t tag\" \"bus_dmamap_t dmam\" \"struct uio *uio\" \"int "
"flags\"> E<.Ft int> E<.Fn bus_dmamap_load_raw \"bus_dma_tag_t tag\" "
"\"bus_dmamap_t dmam\" \"bus_dma_segment_t *segs\" \"int nsegs\" \"bus_size_t "
"size\" \"int flags\"> E<.Ft void> E<.Fn bus_dmamap_unload \"bus_dma_tag_t "
"tag\" \"bus_dmamap_t dmam\"> E<.Ft void> E<.Fn bus_dmamap_sync "
"\"bus_dma_tag_t tag\" \"bus_dmamap_t dmam\" \"bus_addr_t offset\" "
"\"bus_size_t len\" \"int ops\"> E<.Ft int> E<.Fn bus_dmamem_alloc "
"\"bus_dma_tag_t tag\" \"bus_size_t size\" \"bus_size_t alignment\" "
"\"bus_size_t boundary\" \"bus_dma_segment_t *segs\" \"int nsegs\" \"int "
"*rsegs\" \"int flags\"> E<.Ft void> E<.Fn bus_dmamem_free \"bus_dma_tag_t "
"tag\" \"bus_dma_segment_t *segs\" \"int nsegs\"> E<.Ft int> E<.Fn "
"bus_dmamem_map \"bus_dma_tag_t tag\" \"bus_dma_segment_t *segs\" \"int "
"nsegs\" \"size_t size\" \"void **kvap\" \"int flags\"> E<.Ft void> E<.Fn "
"bus_dmamem_unmap \"bus_dma_tag_t tag\" \"void *kva\" \"size_t size\"> E<.Ft "
"paddr_t> E<.Fn bus_dmamem_mmap \"bus_dma_tag_t tag\" \"bus_dma_segment_t "
"*segs\" \"int nsegs\" \"off_t off\" \"int prot\" \"int flags\"> E<.Ft int> "
"E<.Fn bus_dmatag_subregion \"bus_dma_tag_t tag\" \"bus_addr_t min_addr\" "
"\"bus_addr_t max_addr\" \"bus_dma_tag_t *newtag\" \"int flags\"> E<.Ft void> "
"E<.Fn bus_dmatag_destroy \"bus_dma_tag_t tag\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:97
msgid "Provide a bus- and machine-independent \"DMA mapping interface.\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:100
msgid "All data types and constants will be defined by the port-specific header"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/bus_dma.9:100
#, no-wrap
msgid "machine/bus_defs.h ."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:103
msgid "All functions will be defined by the port-specific header"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/bus_dma.9:103
#, no-wrap
msgid "machine/bus_funcs.h ."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:107
msgid ""
"Note that this document assumes the existence of types already defined by "
"the current \"bus.h\" interface."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:112
msgid ""
"Unless otherwise noted, all function calls in this interface may be defined "
"as E<.Xr cpp 1> macros."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:115
msgid ""
"Individual implementations may name these structures whatever they wish, "
"providing that the external representations are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:116
#, no-wrap
msgid "Fa bus_dma_tag_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:119
msgid ""
"A machine-dependent opaque type describing the implementation of DMA for a "
"given bus."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:119
#, no-wrap
msgid "Fa bus_dma_segment_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:121
msgid "A structure with at least the following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:124
#, no-wrap
msgid ""
"\tbus_addr_t\tds_addr;\n"
"\tbus_size_t\tds_len;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:133
msgid ""
"The structure may have machine-dependent members and arbitrary layout.  The "
"values in E<.Fa ds_addr> and E<.Fa ds_len> are suitable for programming into "
"DMA controller address and length registers."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:133
#, no-wrap
msgid "Fa bus_dmamap_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:135
msgid "A pointer to a structure with at least the following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:140
#, no-wrap
msgid ""
"\tbus_size_t\tdm_maxsegsz;\n"
"\tbus_size_t\tdm_mapsize;\n"
"\tint\t\tdm_nsegs;\n"
"\tbus_dma_segment_t *dm_segs;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:159
msgid ""
"The structure may have machine-dependent members and arbitrary layout.  The "
"E<.Fa dm_maxsegsz> member indicates the maximum number of bytes that may be "
"transferred by any given DMA segment.  The E<.Fa dm_mapsize> member "
"indicates the size of the mapping.  A value of 0 indicates the mapping is "
"invalid.  The E<.Fa dm_segs> member may be an array of segments or a pointer "
"to an array of segments.  The E<.Fa dm_nsegs> member indicates the number of "
"segments in E<.Fa dm_segs>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:162
#, no-wrap
msgid "Fn bus_dmamap_create tag size nsegments maxsegsz boundary flags dmamp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:166
msgid ""
"Allocates a DMA handle and initializes it according to the parameters "
"provided.  Arguments are as follows:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:167 org_netbsd/src/share/man/man9/bus_dma.9:229 org_netbsd/src/share/man/man9/bus_dma.9:251 org_netbsd/src/share/man/man9/bus_dma.9:383 org_netbsd/src/share/man/man9/bus_dma.9:423 org_netbsd/src/share/man/man9/bus_dma.9:559 org_netbsd/src/share/man/man9/bus_dma.9:629 org_netbsd/src/share/man/man9/bus_dma.9:652 org_netbsd/src/share/man/man9/bus_dma.9:730 org_netbsd/src/share/man/man9/bus_dma.9:753 org_netbsd/src/share/man/man9/bus_dma.9:803
#, no-wrap
msgid "Fa tag"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:170 org_netbsd/src/share/man/man9/bus_dma.9:232 org_netbsd/src/share/man/man9/bus_dma.9:254 org_netbsd/src/share/man/man9/bus_dma.9:386 org_netbsd/src/share/man/man9/bus_dma.9:426 org_netbsd/src/share/man/man9/bus_dma.9:562 org_netbsd/src/share/man/man9/bus_dma.9:632 org_netbsd/src/share/man/man9/bus_dma.9:655 org_netbsd/src/share/man/man9/bus_dma.9:733 org_netbsd/src/share/man/man9/bus_dma.9:756
msgid ""
"This is the bus_dma_tag_t passed down from the parent driver via E<.Fa "
"\\*[Lt]bus\\*[Gt]_attach_args>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:170 org_netbsd/src/share/man/man9/bus_dma.9:562 org_netbsd/src/share/man/man9/bus_dma.9:662 org_netbsd/src/share/man/man9/bus_dma.9:735 org_netbsd/src/share/man/man9/kmem.9:59 org_netbsd/src/share/man/man9/kmem.9:124 org_netbsd/src/share/man/man9/pool.9:89 org_netbsd/src/share/man/man9/pool_cache.9:157 org_netbsd/src/share/man/man9/video.9:101 org_netbsd/src/share/man/man9/vmem.9:87 org_netbsd/src/share/man/man9/vmem.9:211 org_netbsd/src/share/man/man9/vmem.9:291 org_netbsd/src/share/man/man9/vmem.9:306 org_netbsd/src/share/man/man9/vmem.9:354
#, no-wrap
msgid "Fa size"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:172
msgid "This is the maximum DMA transfer that can be mapped by the handle."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:172
#, no-wrap
msgid "Fa nsegments"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:176
msgid ""
"Number of segments the device can support in a single DMA transaction.  This "
"may be the number of scatter-gather descriptors supported by the device."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:176
#, no-wrap
msgid "Fa maxsegsz"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:181
msgid ""
"The maximum number of bytes that may be transferred by any given DMA segment "
"and will be assigned to the E<.Fa dm_maxsegsz> member."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:181 org_netbsd/src/share/man/man9/bus_dma.9:569
#, no-wrap
msgid "Fa boundary"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:193
msgid ""
"Some DMA controllers are not able to transfer data that crosses a particular "
"boundary.  This argument allows this boundary to be specified.  The boundary "
"lines begin at 0, and occur every E<.Fa boundary> bytes.  Mappings may begin "
"on a boundary line but may not end on or cross a boundary line.  If no "
"boundary condition needs to be observed, a E<.Fa boundary> argument of 0 "
"should be used."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:193 org_netbsd/src/share/man/man9/bus_dma.9:268 org_netbsd/src/share/man/man9/bus_dma.9:584 org_netbsd/src/share/man/man9/bus_dma.9:666 org_netbsd/src/share/man/man9/bus_dma.9:769 org_netbsd/src/share/man/man9/bus_dma.9:811 org_netbsd/src/share/man/man9/kthread.9:70 org_netbsd/src/share/man/man9/physio.9:103 org_netbsd/src/share/man/man9/pool.9:101 org_netbsd/src/share/man/man9/pool.9:153 org_netbsd/src/share/man/man9/pool_cache.9:172 org_netbsd/src/share/man/man9/sysmon_envsys.9:355 org_netbsd/src/share/man/man9/vmem.9:165 org_netbsd/src/share/man/man9/vmem.9:245 org_netbsd/src/share/man/man9/vmem.9:308 org_netbsd/src/share/man/man9/workqueue.9:78 org_netbsd/src/share/man/man9/wsmouse.9:141
#, no-wrap
msgid "Fa flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:195 org_netbsd/src/share/man/man9/bus_dma.9:586 org_netbsd/src/share/man/man9/bus_dma.9:668 org_netbsd/src/share/man/man9/bus_dma.9:771 org_netbsd/src/share/man/man9/bus_dma.9:813
msgid "Flags are defined as follows:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:196 org_netbsd/src/share/man/man9/bus_dma.9:271 org_netbsd/src/share/man/man9/bus_dma.9:587 org_netbsd/src/share/man/man9/bus_dma.9:669 org_netbsd/src/share/man/man9/bus_dma.9:772 org_netbsd/src/share/man/man9/bus_dma.9:814
#, no-wrap
msgid "Dv BUS_DMA_WAITOK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:198 org_netbsd/src/share/man/man9/bus_dma.9:273 org_netbsd/src/share/man/man9/bus_dma.9:589 org_netbsd/src/share/man/man9/bus_dma.9:671 org_netbsd/src/share/man/man9/bus_dma.9:774 org_netbsd/src/share/man/man9/bus_dma.9:816
msgid "It is safe to wait (sleep) for resources during this call."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:198 org_netbsd/src/share/man/man9/bus_dma.9:273 org_netbsd/src/share/man/man9/bus_dma.9:589 org_netbsd/src/share/man/man9/bus_dma.9:671 org_netbsd/src/share/man/man9/bus_dma.9:774 org_netbsd/src/share/man/man9/bus_dma.9:816
#, no-wrap
msgid "Dv BUS_DMA_NOWAIT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:200 org_netbsd/src/share/man/man9/bus_dma.9:275 org_netbsd/src/share/man/man9/bus_dma.9:591 org_netbsd/src/share/man/man9/bus_dma.9:673 org_netbsd/src/share/man/man9/bus_dma.9:776 org_netbsd/src/share/man/man9/bus_dma.9:818
msgid "It is not safe to wait (sleep) for resources during this call."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:200
#, no-wrap
msgid "Dv BUS_DMA_ALLOCNOW"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:208
msgid ""
"Perform any resource allocation this handle may need now.  If this is not "
"specified, the allocation may be deferred to E<.Fn bus_dmamap_load>.  If "
"this flag is specified, E<.Fn bus_dmamap_load> will not block on resource "
"allocation."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:208 org_netbsd/src/share/man/man9/bus_dma.9:308 org_netbsd/src/share/man/man9/bus_dma.9:606 org_netbsd/src/share/man/man9/bus_dma.9:673 org_netbsd/src/share/man/man9/bus_dma.9:776
#, no-wrap
msgid "Dv BUS_DMA_BUS[1-4]"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:211 org_netbsd/src/share/man/man9/bus_dma.9:311 org_netbsd/src/share/man/man9/bus_dma.9:609 org_netbsd/src/share/man/man9/bus_dma.9:676 org_netbsd/src/share/man/man9/bus_dma.9:779
msgid ""
"These flags are placeholders, and may be used by busses to provide "
"bus-dependent functionality."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:212
#, no-wrap
msgid "Fa dmamp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:219
msgid ""
"This is a pointer to a bus_dmamap_t.  A DMA map will be allocated and "
"pointed to by E<.Fa dmamp> upon successful completion of this routine.  "
"E<.Fa dmamp> is undefined if this routine fails."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:223
msgid ""
"Behavior is not defined if invalid arguments are passed to E<.Fn "
"bus_dmamap_create>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:225
msgid "Returns 0 on success, or an error code to indicate mode of failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:225
#, no-wrap
msgid "Fn bus_dmamap_destroy tag dmam"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:228
msgid ""
"Frees all resources associated with a given DMA handle.  Arguments are as "
"follows:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:232 org_netbsd/src/share/man/man9/bus_dma.9:254 org_netbsd/src/share/man/man9/bus_dma.9:386 org_netbsd/src/share/man/man9/bus_dma.9:426
#, no-wrap
msgid "Fa dmam"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:234
msgid "The DMA handle to destroy."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:239
msgid ""
"In the event that the DMA handle contains a valid mapping, the mapping will "
"be unloaded via the same mechanism used by E<.Fn bus_dmamap_unload>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:242
msgid ""
"Behavior is not defined if invalid arguments are passed to E<.Fn "
"bus_dmamap_destroy>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:246
msgid "If given valid arguments, E<.Fn bus_dmamap_destroy> always succeeds."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:246
#, no-wrap
msgid "Fn bus_dmamap_load tag dmam buf buflen l flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:250
msgid ""
"Loads a DMA handle with mappings for a DMA transfer.  It assumes that all "
"pages involved in a DMA transfer are wired.  Arguments are as follows:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:256
msgid "The DMA handle with which to map the transfer."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:256
#, no-wrap
msgid "Fa buf"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:258
msgid "The buffer to be used for the DMA transfer."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:258
#, no-wrap
msgid "Fa buflen"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:260
msgid "The size of the buffer."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:268
msgid ""
"Used to indicate the address space in which the buffer is located.  If E<.Dv "
"NULL>, the buffer is assumed to be in kernel space.  Otherwise, the buffer "
"is assumed to be in lwp E<.Fa l Ap s> address space."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:270
msgid "are defined as follows:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:275 org_netbsd/src/share/man/man9/bus_dma.9:591
#, no-wrap
msgid "Dv BUS_DMA_STREAMING"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:296
msgid ""
"By default, the E<.Nm> API assumes that there is coherency between memory "
"and the device performing the DMA transaction.  Some platforms, however, "
"have special hardware, such as an E<.Dq I/O cache>, which may improve "
"performance of some types of DMA transactions, but which break the "
"assumption that there is coherency between memory and the device performing "
"the DMA transaction.  This flag allows the use of this special hardware, "
"provided that the device is doing sequential, unidirectional transfers which "
"conform to certain alignment and size constraints defined by the platform.  "
"If the platform does not support the feature, or if the buffer being loaded "
"into the DMA map does not conform to the constraints required for use of the "
"feature, then this flag will be silently ignored.  Also refer to the use of "
"this flag with the E<.Fn bus_dmamem_alloc> function."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:296
#, no-wrap
msgid "Dv BUS_DMA_READ"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:302
msgid ""
"This is a hint to the machine-dependent back-end that indicates the mapping "
"will be used only for a E<.Em \"device -\\*[Gt] memory\"> transaction.  The "
"back-end may perform optimizations based on this information."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:302
#, no-wrap
msgid "Dv BUS_DMA_WRITE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:308
msgid ""
"This is a hint to the machine-dependent back-end that indicates the mapping "
"will be used only for a E<.Em \"memory -\\*[Gt] device\"> transaction.  The "
"back-end may perform optimizations based on this information."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:318
msgid ""
"As noted above, if a DMA handle is created with E<.Dv BUS_DMA_ALLOCNOW>, "
"E<.Fn bus_dmamap_load> will never block."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:325
msgid ""
"If a call to E<.Fn bus_dmamap_load> fails, the mapping in the DMA handle "
"will be invalid.  It is the responsibility of the caller to clean up any "
"inconsistent device state resulting from incomplete iteration through the "
"uio."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:328
msgid ""
"Behavior is not defined if invalid arguments are passed to E<.Fn "
"bus_dmamap_load>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:331
msgid ""
"Returns 0 on success, or an error code to indicate mode of failure.  "
"Possible error codes include the following:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:333
#, no-wrap
msgid "Er EFBIG"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:335
msgid "Too many segments."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:335
#, no-wrap
msgid "Er EINVAL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:338
msgid "E<.Fa buflen> is too large for the DMA map."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:338 org_netbsd/src/share/man/man9/bus_space.9:1055 org_netbsd/src/share/man/man9/bus_space.9:1099
#, no-wrap
msgid "Er ENOMEM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:340
msgid "Could not allocate memory for, e.g., a bounce buffer."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:341
#, no-wrap
msgid "Fn bus_dmamap_load_mbuf tag dmam chain flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:347
msgid ""
"This is a variation of E<.Fn bus_dmamap_load> which maps mbuf chains for DMA "
"transfers.  Mbuf chains are assumed to be in kernel virtual address space."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:347
#, no-wrap
msgid "Fn bus_dmamap_load_uio tag dmam uio flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:361
msgid ""
"This is a variation of E<.Fn bus_dmamap_load> which maps buffers pointed to "
"by E<.Fa uio> for DMA transfers.  Determination if the buffers are in user "
"or kernel virtual address space is done internally, according to E<.Fa "
"\"uio-\\*[Gt]uio_vmspace\">.  See E<.Xr uiomove 9> for details of the E<.Dv "
"uio> structure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:361
#, no-wrap
msgid "Fn bus_dmamap_load_raw tag dmam segs nsegs size flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:379
msgid ""
"This is a variation of E<.Fn bus_dmamap_load> which maps buffers allocated "
"by E<.Fn bus_dmamem_alloc> (see below).  The E<.Fa segs> argument is an "
"array of bus_dma_segment_t's filled in by E<.Fn bus_dmamem_alloc>.  The "
"E<.Fa nsegs> argument is the number of segments in the array.  The E<.Fa "
"size> argument is the size of the DMA transfer."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:379
#, no-wrap
msgid "Fn bus_dmamap_unload tag dmam"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:382
msgid "Deletes the mappings for a given DMA handle.  Arguments are as follows:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:388
msgid "The DMA handle containing the mappings which are to be deleted."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:401
msgid ""
"If the DMA handle was created with E<.Dv BUS_DMA_ALLOCNOW>, E<.Fn "
"bus_dmamap_unload> will not free the corresponding resources which were "
"allocated by E<.Fn bus_dmamap_create>.  This is to ensure that E<.Fn "
"bus_dmamap_load> will never block on resources if the handle was created "
"with E<.Dv BUS_DMA_ALLOCNOW>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:406
msgid ""
"E<.Fn bus_dmamap_unload> will not perform any implicit synchronization of "
"DMA buffers.  This must be done explicitly by E<.Fn bus_dmamap_sync>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:412
msgid ""
"E<.Fn bus_dmamap_unload> will restore the E<.Fa dm_maxsegsz> member to its "
"initial value assigned by E<.Fn bus_dmamap_create>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:415
msgid ""
"Behavior is not defined if invalid arguments are passed to E<.Fn "
"bus_dmamap_unload>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:419
msgid "If given valid arguments, E<.Fn bus_dmamap_unload> always succeeds."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:419
#, no-wrap
msgid "Fn bus_dmamap_sync tag dmam offset len ops"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:422
msgid ""
"Performs pre- and post-DMA operation cache and/or buffer synchronization.  "
"Arguments are as follows:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:428
msgid "The DMA mapping to be synchronized."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:428
#, no-wrap
msgid "Fa offset"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:430
msgid "The offset into the DMA mapping to synchronize."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:430 org_netbsd/src/share/man/man9/rssadapt.9:106
#, no-wrap
msgid "Fa len"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:434
msgid "The length of the mapping from E<.Fa offset> to synchronize."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:434
#, no-wrap
msgid "Fa ops"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:437
msgid ""
"One or more synchronization operation to perform.  The following DMA "
"synchronization operations are defined:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:438
#, no-wrap
msgid "Dv BUS_DMASYNC_PREREAD"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:440
msgid "Perform any pre-read DMA cache and/or bounce operations."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:440
#, no-wrap
msgid "Dv BUS_DMASYNC_POSTREAD"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:442
msgid "Perform any post-read DMA cache and/or bounce operations."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:442
#, no-wrap
msgid "Dv BUS_DMASYNC_PREWRITE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:444
msgid "Perform any pre-write DMA cache and/or bounce operations."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:444
#, no-wrap
msgid "Dv BUS_DMASYNC_POSTWRITE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:446
msgid "Perform any post-write DMA cache and/or bounce operations."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:454
msgid ""
"More than one operation may performed in a given synchronization call.  "
"Mixing of E<.Em PRE> and E<.Em POST> operations is not allowed, and behavior "
"is undefined if this is attempted."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:465
msgid ""
"Synchronization operations are expressed from the perspective of the host "
"RAM, e.g., a E<.Em \"device -\\*[Gt] memory\"> operation is a E<.Em READ> "
"and a E<.Em \"memory -\\*[Gt] device\"> operation is a E<.Em WRITE>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:476
msgid ""
"E<.Fn bus_dmamap_sync> may consult state kept within the DMA map to "
"determine if the memory is mapped in a DMA coherent fashion.  If so, E<.Fn "
"bus_dmamap_sync> may elect to skip certain expensive operations, such as "
"flushing of the data cache.  See E<.Fn bus_dmamem_map> for more information "
"on this subject."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:480
msgid ""
"On platforms which implement a weak memory access ordering model, E<.Fn "
"bus_dmamap_sync> will always cause the appropriate memory barriers to be "
"issued."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:484
msgid ""
"This function exists to ensure that the host and the device have a "
"consistent view of a range of DMA memory, before and after a DMA operation."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:489
msgid ""
"An example of using E<.Fn bus_dmamap_sync>, involving multiple read-write "
"use of a single mapping might look like this:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:491
#, no-wrap
msgid "bus_dmamap_load(...);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:495
#, no-wrap
msgid ""
"while (not done) {\n"
"\t/* invalidate soon-to-be-stale cache blocks */\n"
"\tbus_dmamap_sync(..., BUS_DMASYNC_PREREAD);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:497
#, no-wrap
msgid "\t[ do read DMA ]\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:500
#, no-wrap
msgid ""
"\t/* copy from bounce */\n"
"\tbus_dmamap_sync(..., BUS_DMASYNC_POSTREAD);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:502
#, no-wrap
msgid "\t/* read data now in driver-provided buffer */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:504
#, no-wrap
msgid "\t[ computation ]\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:506
#, no-wrap
msgid "\t/* data to be written now in driver-provided buffer */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:509
#, no-wrap
msgid ""
"\t/* flush write buffers and writeback, copy to bounce */\n"
"\tbus_dmamap_sync(..., BUS_DMASYNC_PREWRITE);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:511
#, no-wrap
msgid "\t[ do write DMA ]\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:515
#, no-wrap
msgid ""
"\t/* probably a no-op, but provided for consistency */\n"
"\tbus_dmamap_sync(..., BUS_DMASYNC_POSTWRITE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:517
#, no-wrap
msgid "bus_dmamap_unload(...);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:529
msgid ""
"This function E<.Em must> be called to synchronize DMA buffers before and "
"after a DMA operation.  Other E<.Nm> functions can E<.Em not> be relied on "
"to do this synchronization implicitly.  If DMA read and write operations are "
"not preceded and followed by the appropriate synchronization operations, "
"behavior is undefined."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:532
msgid ""
"Behavior is not defined if invalid arguments are passed to E<.Fn "
"bus_dmamap_sync>."
msgstr ""

#.  XXX: This does not work with all the arguments.
#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:537
msgid "If given valid arguments, E<.Fn bus_dmamap_sync> always succeeds."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:537
#, no-wrap
msgid "Fn bus_dmamem_alloc tag size alignment boundary segs ..."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:540
msgid ""
"Allocates memory that is \"DMA safe\" for the bus corresponding to the given "
"tag."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:553
msgid ""
"The mapping of this memory is machine-dependent (or \"opaque\"); "
"machine-independent code is not to assume that the addresses returned are "
"valid in kernel virtual address space, or that the addresses returned are "
"system physical addresses.  The address value returned as part of E<.Fa "
"segs> can thus not be used to program DMA controller address registers.  "
"Only the values in the E<.Fa dm_segs> array of a successfully loaded DMA map "
"(using E<.Fn bus_dmamap_load>)  can be used for this purpose."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:558
msgid ""
"Allocations will always be rounded to the hardware page size.  Callers may "
"wish to take advantage of this, and cluster allocation of small data "
"structures.  Arguments are as follows:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:564
msgid "The amount of memory to allocate."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:564
#, no-wrap
msgid "Fa alignment"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:569
msgid ""
"Each segment in the allocated memory will be aligned to this value.  If the "
"alignment is less than a hardware page size, it will be rounded up to the "
"hardware page size.  This value must be a power of two."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:574
msgid ""
"Each segment in the allocated memory must not cross this boundary (relative "
"to zero).  This value must be a power of two.  A boundary value less than "
"the size of the allocation is invalid."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:574 org_netbsd/src/share/man/man9/bus_dma.9:632 org_netbsd/src/share/man/man9/bus_dma.9:655 org_netbsd/src/share/man/man9/bus_dma.9:756
#, no-wrap
msgid "Fa segs"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:577
msgid ""
"An array of bus_dma_segment_t's, filled in as memory is allocated, "
"representing the opaque addresses of the memory chunks."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:577 org_netbsd/src/share/man/man9/bus_dma.9:635 org_netbsd/src/share/man/man9/bus_dma.9:659 org_netbsd/src/share/man/man9/bus_dma.9:761
#, no-wrap
msgid "Fa nsegs"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:582
msgid ""
"Specifies the number of segments in E<.Fa segs>, and this is the maximum "
"number of segments that the allocated memory may contain."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:582
#, no-wrap
msgid "Fa rsegs"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:584
msgid "Used to return the actual number of segments the memory contains."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:606
msgid ""
"Adjusts, if necessary, the size, alignment, and boundary constrains to "
"conform to the platform-dependent requirements for the use of the E<.Dv "
"BUS_DMA_STREAMING> flag with the E<.Fn bus_dmamap_load> function.  If the "
"platform does not support the E<.Dv BUS_DMA_STREAMING> feature, or if the "
"size, alignment, and boundary constraints would already satisfy the "
"platform's requirements, this flag is silently ignored.  The E<.Dv "
"BUS_DMA_STREAMING> flag will never relax the constraints specified in the "
"call."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:617
msgid ""
"All pages allocated by E<.Fn bus_dmamem_alloc> will be wired down until they "
"are freed by E<.Fn bus_dmamem_free>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:620
msgid ""
"Behavior is undefined if invalid arguments are passed to E<.Fn "
"bus_dmamem_alloc>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:622 org_netbsd/src/share/man/man9/bus_dma.9:723
msgid "Returns 0 on success, or an error code indicating mode of failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:622
#, no-wrap
msgid "Fn bus_dmamem_free tag segs nsegs"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:628
msgid ""
"Frees memory previously allocated by E<.Fn bus_dmamem_alloc>.  Any mappings "
"will be invalidated.  Arguments are as follows:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:635
msgid "The array of bus_dma_segment_t's filled in by E<.Fn bus_dmamem_alloc>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:638 org_netbsd/src/share/man/man9/bus_dma.9:662
msgid "The number of segments in E<.Fa segs>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:642
msgid ""
"Behavior is undefined if invalid arguments are passed to E<.Fn "
"bus_dmamem_free>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:646
msgid "If given valid arguments, E<.Fn bus_dmamem_free> always succeeds."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:646
#, no-wrap
msgid "Fn bus_dmamem_map tag segs nsegs size kvap flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:651
msgid ""
"Maps memory allocated with E<.Fn bus_dmamem_alloc> into kernel virtual "
"address space.  Arguments are as follows:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:659
msgid ""
"The array of bus_dma_segment_t's filled in by E<.Fn bus_dmamem_alloc>, "
"representing the memory regions to map."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:664 org_netbsd/src/share/man/man9/bus_dma.9:737
msgid "The size of the mapping."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:664
#, no-wrap
msgid "Fa kvap"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:666
msgid "Filled in to specify the kernel virtual address where the memory is mapped."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:676 org_netbsd/src/share/man/man9/bus_dma.9:779
#, no-wrap
msgid "Dv BUS_DMA_COHERENT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:684
msgid ""
"This flag is a E<.Em hint> to machine-dependent code.  If possible, map the "
"memory in such a way as it will be DMA coherent.  This may include mapping "
"the pages into uncached address space or setting the cache-inhibit bits in "
"page table entries.  If DMA coherent mappings are impossible, this flag is "
"silently ignored."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:694
msgid ""
"Later, when this memory is loaded into a DMA map, machine-dependent code "
"will take whatever steps are necessary to determine if the memory was mapped "
"in a DMA coherent fashion.  This may include checking if the kernel virtual "
"address lies within uncached address space or if the cache-inhibit bits are "
"set in page table entries.  If it is determined that the mapping is DMA "
"coherent, state may be placed into the DMA map for use by later calls to "
"E<.Fn bus_dmamap_sync>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:702
msgid ""
"Note that a device driver must not rely on E<.Dv BUS_DMA_COHERENT> for "
"correct operation.  All calls to E<.Fn bus_dmamap_sync> must still be made.  "
"This flag is provided only as an optimization hint to machine-dependent "
"code."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:709
msgid ""
"Also note that this flag only applies to coherency between the CPU and "
"memory.  Coherency between memory and the device is controlled with a "
"different flag.  See the description of the E<.Fn bus_dmamap_load> function."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:709 org_netbsd/src/share/man/man9/bus_dma.9:783
#, no-wrap
msgid "Dv BUS_DMA_NOCACHE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:716
msgid ""
"This flag is a E<.Em hint> to machine-dependent code.  If possible, map the "
"uncached memory.  This flag may be useful in the case that the memory cache "
"causes unexpected behavior of the device."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:721
msgid ""
"Behavior is undefined if invalid arguments are passed to E<.Fn "
"bus_dmamem_map>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:723
#, no-wrap
msgid "Fn bus_dmamem_unmap tag kva size"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:729
msgid ""
"Unmaps memory previously mapped with E<.Fn bus_dmamem_map>, freeing the "
"kernel virtual address space used by the mapping.  The arguments are as "
"follows:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:733
#, no-wrap
msgid "Fa kva"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:735
msgid "The kernel virtual address of the mapped memory."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:741
msgid ""
"Behavior is undefined if invalid arguments are passed to E<.Fn "
"bus_dmamem_unmap>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:745
msgid "If given valid arguments, E<.Fn bus_dmamem_unmap> always succeeds."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:745
#, no-wrap
msgid "Fn bus_dmamem_mmap tag segs nsegs off prot flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:752
msgid ""
"Provides support for user E<.Xr mmap 2 Ap ing> of DMA-safe memory.  This "
"function is to be called by a device driver's (*d_mmap)() entry point, which "
"is called by the device pager for each page to be mapped.  The arguments are "
"as follows:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:761
msgid ""
"The array of bus_dma_segment_t's filled in by E<.Fn bus_dmamem_alloc>, "
"representing the memory to be E<.Xr mmap 2 Ap ed>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:765
msgid "The number of elements in the E<.Fa segs> array."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:765
#, no-wrap
msgid "Fa off"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:767
msgid "The offset of the page in DMA memory which is to be mapped."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:767
#, no-wrap
msgid "Fa prot"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:769
msgid "The protection codes for the mapping."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:783 org_netbsd/src/share/man/man9/bus_dma.9:787
msgid "See E<.Fn bus_dmamem_map> above for a description of this flag."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:793
msgid ""
"Behavior is undefined if invalid arguments are passed to E<.Fn "
"bus_dmamem_mmap>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:796
msgid ""
"Returns -1 to indicate failure.  Otherwise, returns an opaque value to be "
"interpreted by the device pager."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:796
#, no-wrap
msgid "Fn bus_dmatag_subregion tag min_addr max_addr newtag flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:802
msgid ""
"Given a bus_dma_tag_t create a new bus_dma_tag_t with a limited bus address "
"space.  This function should not normally be used, but is useful for devices "
"that do not support the full address space of the parent bus.  The arguments "
"are as follows:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:805
msgid "This is the bus_dma_tag_t to subregion."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:805
#, no-wrap
msgid "Fa min_addr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:807
msgid "The smallest address this new tag can address."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:807
#, no-wrap
msgid "Fa max_addr ."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:809
msgid "The largest address this new tag can address."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:809
#, no-wrap
msgid "Fa newtag"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:811
msgid "Pointer filled in with the address of the new bus_dma_tag_t."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_dma.9:820
#, no-wrap
msgid "Fn bus_dmatag_destroy tag"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:823
msgid "Free a tag created by E<.Fn bus_dmatag_subregion>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:836
msgid ""
"E<.Xr bus_space 9>, E<.Xr mb 9> E<.Rs> E<.%A Jason Thorpe> E<.%T \"A "
"Machine-Independent DMA Framework for NetBSD\"> E<.%I USENIX Association> "
"E<.%B Proceedings of the FREENIX Track: 1998 USENIX Annual Technical "
"Conference> E<.%P 1-12> E<.%D June 15-19, 1998> E<.%U "
"http://www.usenix.org/publications/library/proceedings/usenix98/freenix/thorpe_dma.pdf> "
"E<.Re>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:841
msgid "The E<.Nm> interface appeared in E<.Nx 1.3>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_dma.9:849
msgid ""
"The E<.Nm> interface was designed and implemented by Jason R. Thorpe of the "
"Numerical Aerospace Simulation Facility, NASA Ames Research Center.  "
"Additional input on the E<.Nm> design was provided by Chris Demetriou, "
"Charles Hannum, Ross Harvey, Matthew Jacob, Jonathan Stone, and Matt Thomas."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/bus_space.9:30
#, no-wrap
msgid "July 6, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/bus_space.9:31
#, no-wrap
msgid "BUS_SPACE 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:118
msgid ""
"E<.Nm bus_space>, E<.Nm bus_space_barrier>, E<.Nm bus_space_copy_region_1>, "
"E<.Nm bus_space_copy_region_2>, E<.Nm bus_space_copy_region_4>, E<.Nm "
"bus_space_copy_region_8>, E<.Nm bus_space_free>, E<.Nm "
"bus_space_handle_is_equal>, E<.Nm bus_space_is_equal>, E<.Nm bus_space_map>, "
"E<.Nm bus_space_mmap>, E<.Nm bus_space_peek_1>, E<.Nm bus_space_peek_2>, "
"E<.Nm bus_space_peek_4>, E<.Nm bus_space_peek_8>, E<.Nm bus_space_poke_1>, "
"E<.Nm bus_space_poke_2>, E<.Nm bus_space_poke_4>, E<.Nm bus_space_poke_8>, "
"E<.Nm bus_space_read_1>, E<.Nm bus_space_read_2>, E<.Nm bus_space_read_4>, "
"E<.Nm bus_space_read_8>, E<.Nm bus_space_read_multi_1>, E<.Nm "
"bus_space_read_multi_2>, E<.Nm bus_space_read_multi_4>, E<.Nm "
"bus_space_read_multi_8>, E<.Nm bus_space_read_multi_stream_1>, E<.Nm "
"bus_space_read_multi_stream_2>, E<.Nm bus_space_read_multi_stream_4>, E<.Nm "
"bus_space_read_multi_stream_8>, E<.Nm bus_space_read_region_1>, E<.Nm "
"bus_space_read_region_2>, E<.Nm bus_space_read_region_4>, E<.Nm "
"bus_space_read_region_8>, E<.Nm bus_space_read_region_stream_1>, E<.Nm "
"bus_space_read_region_stream_2>, E<.Nm bus_space_read_region_stream_4>, "
"E<.Nm bus_space_read_region_stream_8>, E<.Nm bus_space_read_stream_1>, E<.Nm "
"bus_space_read_stream_2>, E<.Nm bus_space_read_stream_4>, E<.Nm "
"bus_space_read_stream_8>, E<.Nm bus_space_release>, E<.Nm "
"bus_space_reservation_addr>, E<.Nm bus_space_reservation_init>, E<.Nm "
"bus_space_reservation_size>, E<.Nm bus_space_reservation_map>, E<.Nm "
"bus_space_reservation_unmap>, E<.Nm bus_space_reserve>, E<.Nm "
"bus_space_reserve_subregion>, E<.Nm bus_space_set_region_1>, E<.Nm "
"bus_space_set_region_2>, E<.Nm bus_space_set_region_4>, E<.Nm "
"bus_space_set_region_8>, E<.Nm bus_space_subregion>, E<.Nm "
"bus_space_tag_create>, E<.Nm bus_space_tag_destroy>, E<.Nm bus_space_unmap>, "
"E<.Nm bus_space_vaddr>, E<.Nm bus_space_write_1>, E<.Nm bus_space_write_2>, "
"E<.Nm bus_space_write_4>, E<.Nm bus_space_write_8>, E<.Nm "
"bus_space_write_multi_1>, E<.Nm bus_space_write_multi_2>, E<.Nm "
"bus_space_write_multi_4>, E<.Nm bus_space_write_multi_8>, E<.Nm "
"bus_space_write_multi_stream_1>, E<.Nm bus_space_write_multi_stream_2>, "
"E<.Nm bus_space_write_multi_stream_4>, E<.Nm "
"bus_space_write_multi_stream_8>, E<.Nm bus_space_write_region_1>, E<.Nm "
"bus_space_write_region_2>, E<.Nm bus_space_write_region_4>, E<.Nm "
"bus_space_write_region_8>, E<.Nm bus_space_write_region_stream_1>, E<.Nm "
"bus_space_write_region_stream_2>, E<.Nm bus_space_write_region_stream_4>, "
"E<.Nm bus_space_write_region_stream_8>, E<.Nm bus_space_write_stream_1>, "
"E<.Nm bus_space_write_stream_2>, E<.Nm bus_space_write_stream_4>, E<.Nm "
"bus_space_write_stream_8>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/bus_space.9:118
#, no-wrap
msgid "bus space manipulation functions"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:387
msgid ""
"E<.Ft bool> E<.Fn bus_space_handle_is_equal \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle1\" \"bus_space_handle_t handle2\"> E<.Ft bool> "
"E<.Fn bus_space_is_equal \"bus_space_tag_t space1\" \"bus_space_tag_t "
"space2\"> E<.Ft void> E<.Fn bus_space_release \"bus_space_tag_t t\" "
"\"bus_space_reservation_t *bsr\"> E<.Ft int> E<.Fn bus_space_reserve "
"\"bus_space_tag_t t\" \"bus_addr_t bpa\" \"bus_size_t size\" \"int flags\" "
"\"bus_space_reservation_t *bsrp\"> E<.Ft int> E<.Fn "
"bus_space_reserve_subregion \"bus_space_tag_t t\" \"bus_addr_t reg_start\" "
"\"bus_addr_t reg_end\" \"bus_size_t size\" \"bus_size_t alignment\" "
"\"bus_size_t boundary\" \"int flags\" \"bus_space_reservation_t *bsrp\"> "
"E<.Ft void> E<.Fn bus_space_reservation_init \"bus_space_reservation_t "
"*bsr\" \"bus_addr_t addr\" \"bus_size_t size\"> E<.Ft bus_size_t> E<.Fn "
"bus_space_reservation_size \"bus_space_reservation_t *bsr\"> E<.Ft int> "
"E<.Fn bus_space_reservation_map \"bus_space_tag_t t\" "
"\"bus_space_reservation_t *bsr\" \"int flags\" \"bus_space_handle_t *bshp\"> "
"E<.Ft void> E<.Fn bus_space_reservation_unmap \"bus_space_tag_t t\" "
"\"bus_space_handle_t bsh\" \"bus_size_t size\"> E<.Ft int> E<.Fn "
"bus_space_map \"bus_space_tag_t space\" \"bus_addr_t address\" \"bus_size_t "
"size\" \"int flags\" \"bus_space_handle_t *handlep\"> E<.Ft void> E<.Fn "
"bus_space_unmap \"bus_space_tag_t space\" \"bus_space_handle_t handle\" "
"\"bus_size_t size\"> E<.Ft int> E<.Fn bus_space_subregion \"bus_space_tag_t "
"space\" \"bus_space_handle_t handle\" \"bus_size_t offset\" \"bus_size_t "
"size\" \"bus_space_handle_t *nhandlep\"> E<.Ft int> E<.Fo bus_space_alloc> "
"E<.Fa \"bus_space_tag_t space\" \"bus_addr_t reg_start\" \"bus_addr_t "
"reg_end\"> E<.Fa \"bus_size_t size\" \"bus_size_t alignment\" \"bus_size_t "
"boundary\"> E<.Fa \"int flags\" \"bus_addr_t *addrp\" \"bus_space_handle_t "
"*handlep\"> E<.Fc> E<.Ft void> E<.Fn bus_space_free \"bus_space_tag_t "
"space\" \"bus_space_handle_t handle\" \"bus_size_t size\"> E<.Ft void *> "
"E<.Fn bus_space_vaddr \"bus_space_tag_t space\" \"bus_space_handle_t "
"handle\"> E<.Ft paddr_t> E<.Fn bus_space_mmap \"bus_space_tag_t space\" "
"\"bus_addr_t addr\" \"off_t off\" \"int prot\" \"int flags\"> E<.Ft int> "
"E<.Fn bus_space_tag_create \"bus_space_tag_t obst\" \"uint64_t present\" "
"\"uint64_t extpresent\" \"const struct bus_space_overrides *ov\" \"void "
"*ctx\" \"bus_space_tag_t *bstp\"> E<.Ft void> E<.Fn bus_space_tag_destroy "
"\"bus_space_tag_t bst\"> E<.Ft int> E<.Fn bus_space_peek_1 \"bus_space_tag_t "
"space\" \"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint8_t "
"*datap\"> E<.Ft int> E<.Fn bus_space_peek_2 \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint16_t *datap\"> "
"E<.Ft int> E<.Fn bus_space_peek_4 \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint32_t *datap\"> "
"E<.Ft int> E<.Fn bus_space_peek_8 \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint64_t *datap\"> "
"E<.Ft int> E<.Fn bus_space_poke_1 \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint8_t data\"> E<.Ft "
"int> E<.Fn bus_space_poke_2 \"bus_space_tag_t space\" \"bus_space_handle_t "
"handle\" \"bus_size_t offset\" \"uint16_t data\"> E<.Ft int> E<.Fn "
"bus_space_poke_4 \"bus_space_tag_t space\" \"bus_space_handle_t handle\" "
"\"bus_size_t offset\" \"uint32_t data\"> E<.Ft int> E<.Fn bus_space_poke_8 "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\" \"bus_size_t "
"offset\" \"uint64_t data\"> E<.Ft uint8_t> E<.Fn bus_space_read_1 "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\" \"bus_size_t "
"offset\"> E<.Ft uint16_t> E<.Fn bus_space_read_2 \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle\" \"bus_size_t offset\"> E<.Ft uint32_t> E<.Fn "
"bus_space_read_4 \"bus_space_tag_t space\" \"bus_space_handle_t handle\" "
"\"bus_size_t offset\"> E<.Ft uint64_t> E<.Fn bus_space_read_8 "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\" \"bus_size_t "
"offset\"> E<.Ft void> E<.Fn bus_space_write_1 \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint8_t value\"> E<.Ft "
"void> E<.Fn bus_space_write_2 \"bus_space_tag_t space\" \"bus_space_handle_t "
"handle\" \"bus_size_t offset\" \"uint16_t value\"> E<.Ft void> E<.Fn "
"bus_space_write_4 \"bus_space_tag_t space\" \"bus_space_handle_t handle\" "
"\"bus_size_t offset\" \"uint32_t value\"> E<.Ft void> E<.Fn "
"bus_space_write_8 \"bus_space_tag_t space\" \"bus_space_handle_t handle\" "
"\"bus_size_t offset\" \"uint64_t value\"> E<.Ft void> E<.Fn "
"bus_space_barrier \"bus_space_tag_t space\" \"bus_space_handle_t handle\" "
"\"bus_size_t offset\" \"bus_size_t length\" \"int flags\"> E<.Ft void> E<.Fn "
"bus_space_read_region_1 \"bus_space_tag_t space\" \"bus_space_handle_t "
"handle\" \"bus_size_t offset\" \"uint8_t *datap\" \"bus_size_t count\"> "
"E<.Ft void> E<.Fn bus_space_read_region_2 \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint16_t *datap\" "
"\"bus_size_t count\"> E<.Ft void> E<.Fn bus_space_read_region_4 "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\" \"bus_size_t "
"offset\" \"uint32_t *datap\" \"bus_size_t count\"> E<.Ft void> E<.Fn "
"bus_space_read_region_8 \"bus_space_tag_t space\" \"bus_space_handle_t "
"handle\" \"bus_size_t offset\" \"uint64_t *datap\" \"bus_size_t count\"> "
"E<.Ft void> E<.Fn bus_space_read_region_stream_1 \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint8_t *datap\" "
"\"bus_size_t count\"> E<.Ft void> E<.Fn bus_space_read_region_stream_2 "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\" \"bus_size_t "
"offset\" \"uint16_t *datap\" \"bus_size_t count\"> E<.Ft void> E<.Fn "
"bus_space_read_region_stream_4 \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint32_t *datap\" "
"\"bus_size_t count\"> E<.Ft void> E<.Fn bus_space_read_region_stream_8 "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\" \"bus_size_t "
"offset\" \"uint64_t *datap\" \"bus_size_t count\"> E<.Ft void> E<.Fn "
"bus_space_write_region_1 \"bus_space_tag_t space\" \"bus_space_handle_t "
"handle\" \"bus_size_t offset\" \"const uint8_t *datap\" \"bus_size_t "
"count\"> E<.Ft void> E<.Fn bus_space_write_region_2 \"bus_space_tag_t "
"space\" \"bus_space_handle_t handle\" \"bus_size_t offset\" \"const uint16_t "
"*datap\" \"bus_size_t count\"> E<.Ft void> E<.Fn bus_space_write_region_4 "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\" \"bus_size_t "
"offset\" \"const uint32_t *datap\" \"bus_size_t count\"> E<.Ft void> E<.Fn "
"bus_space_write_region_8 \"bus_space_tag_t space\" \"bus_space_handle_t "
"handle\" \"bus_size_t offset\" \"const uint64_t *datap\" \"bus_size_t "
"count\"> E<.Ft void> E<.Fn bus_space_write_region_stream_1 \"bus_space_tag_t "
"space\" \"bus_space_handle_t handle\" \"bus_size_t offset\" \"const uint8_t "
"*datap\" \"bus_size_t count\"> E<.Ft void> E<.Fn "
"bus_space_write_region_stream_2 \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"const uint16_t "
"*datap\" \"bus_size_t count\"> E<.Ft void> E<.Fn "
"bus_space_write_region_stream_4 \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"const uint32_t "
"*datap\" \"bus_size_t count\"> E<.Ft void> E<.Fn "
"bus_space_write_region_stream_8 \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"const uint64_t "
"*datap\" \"bus_size_t count\"> E<.Ft void> E<.Fn bus_space_copy_region_1 "
"\"bus_space_tag_t space\" \"bus_space_handle_t srchandle\" \"bus_size_t "
"srcoffset\" \"bus_space_handle_t dsthandle\" \"bus_size_t dstoffset\" "
"\"bus_size_t count\"> E<.Ft void> E<.Fn bus_space_copy_region_2 "
"\"bus_space_tag_t space\" \"bus_space_handle_t srchandle\" \"bus_size_t "
"srcoffset\" \"bus_space_handle_t dsthandle\" \"bus_size_t dstoffset\" "
"\"bus_size_t count\"> E<.Ft void> E<.Fn bus_space_copy_region_4 "
"\"bus_space_tag_t space\" \"bus_space_handle_t srchandle\" \"bus_size_t "
"srcoffset\" \"bus_space_handle_t dsthandle\" \"bus_size_t dstoffset\" "
"\"bus_size_t count\"> E<.Ft void> E<.Fn bus_space_copy_region_8 "
"\"bus_space_tag_t space\" \"bus_space_handle_t srchandle\" \"bus_size_t "
"srcoffset\" \"bus_space_handle_t dsthandle\" \"bus_size_t dstoffset\" "
"\"bus_size_t count\"> E<.Ft void> E<.Fn bus_space_set_region_1 "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\" \"bus_size_t "
"offset\" \"uint8_t value\" \"bus_size_t count\"> E<.Ft void> E<.Fn "
"bus_space_set_region_2 \"bus_space_tag_t space\" \"bus_space_handle_t "
"handle\" \"bus_size_t offset\" \"uint16_t value\" \"bus_size_t count\"> "
"E<.Ft void> E<.Fn bus_space_set_region_4 \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint32_t value\" "
"\"bus_size_t count\"> E<.Ft void> E<.Fn bus_space_set_region_8 "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\" \"bus_size_t "
"offset\" \"uint64_t value\" \"bus_size_t count\"> E<.Ft void> E<.Fn "
"bus_space_read_multi_1 \"bus_space_tag_t space\" \"bus_space_handle_t "
"handle\" \"bus_size_t offset\" \"uint8_t *datap\" \"bus_size_t count\"> "
"E<.Ft void> E<.Fn bus_space_read_multi_2 \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint16_t *datap\" "
"\"bus_size_t count\"> E<.Ft void> E<.Fn bus_space_read_multi_4 "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\" \"bus_size_t "
"offset\" \"uint32_t *datap\" \"bus_size_t count\"> E<.Ft void> E<.Fn "
"bus_space_read_multi_8 \"bus_space_tag_t space\" \"bus_space_handle_t "
"handle\" \"bus_size_t offset\" \"uint64_t *datap\" \"bus_size_t count\"> "
"E<.Ft void> E<.Fn bus_space_read_multi_stream_1 \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint8_t *datap\" "
"\"bus_size_t count\"> E<.Ft void> E<.Fn bus_space_read_multi_stream_2 "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\" \"bus_size_t "
"offset\" \"uint16_t *datap\" \"bus_size_t count\"> E<.Ft void> E<.Fn "
"bus_space_read_multi_stream_4 \"bus_space_tag_t space\" \"bus_space_handle_t "
"handle\" \"bus_size_t offset\" \"uint32_t *datap\" \"bus_size_t count\"> "
"E<.Ft void> E<.Fn bus_space_read_multi_stream_8 \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"uint64_t *datap\" "
"\"bus_size_t count\"> E<.Ft void> E<.Fn bus_space_write_multi_1 "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\" \"bus_size_t "
"offset\" \"const uint8_t *datap\" \"bus_size_t count\"> E<.Ft void> E<.Fn "
"bus_space_write_multi_2 \"bus_space_tag_t space\" \"bus_space_handle_t "
"handle\" \"bus_size_t offset\" \"const uint16_t *datap\" \"bus_size_t "
"count\"> E<.Ft void> E<.Fn bus_space_write_multi_4 \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"const uint32_t "
"*datap\" \"bus_size_t count\"> E<.Ft void> E<.Fn bus_space_write_multi_8 "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\" \"bus_size_t "
"offset\" \"const uint64_t *datap\" \"bus_size_t count\"> E<.Ft void> E<.Fn "
"bus_space_write_multi_stream_1 \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"const uint8_t *datap\" "
"\"bus_size_t count\"> E<.Ft void> E<.Fn bus_space_write_multi_stream_2 "
"\"bus_space_tag_t space\" \"bus_space_handle_t handle\" \"bus_size_t "
"offset\" \"const uint16_t *datap\" \"bus_size_t count\"> E<.Ft void> E<.Fn "
"bus_space_write_multi_stream_4 \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"const uint32_t "
"*datap\" \"bus_size_t count\"> E<.Ft void> E<.Fn "
"bus_space_write_multi_stream_8 \"bus_space_tag_t space\" "
"\"bus_space_handle_t handle\" \"bus_size_t offset\" \"const uint64_t "
"*datap\" \"bus_size_t count\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:394
msgid ""
"The E<.Nm> functions exist to allow device drivers machine-independent "
"access to bus memory and register areas.  All of the functions and types "
"described in this document can be used by including the"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:396
msgid "header file."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:412
msgid ""
"Many common devices are used on multiple architectures, but are accessed "
"differently on each because of architectural constraints.  For instance, a "
"device which is mapped in one system's I/O space may be mapped in memory "
"space on a second system.  On a third system, architectural limitations "
"might change the way registers need to be accessed (e.g., creating a "
"non-linear register space).  In some cases, a single driver may need to "
"access the same type of device in multiple ways in a single system or "
"architecture.  The goal of the E<.Nm> functions is to allow a single driver "
"source file to manipulate a set of devices on different system "
"architectures, and to allow a single driver object file to manipulate a set "
"of devices on multiple bus types on a single architecture."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:417
msgid ""
"Not all busses have to implement all functions described in this document, "
"though that is encouraged if the operations are logically supported by the "
"bus.  Unimplemented functions should cause compile-time errors if possible."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:424
msgid ""
"All of the interface definitions described in this document are shown as "
"function prototypes and discussed as if they were required to be functions.  "
"Implementations are encouraged to implement prototyped (type-checked)  "
"versions of these interfaces, but may implement them as macros if "
"appropriate.  Machine-dependent types, variables, and functions should be "
"marked clearly in"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/bus_space.9:424 org_netbsd/src/share/man/man9/bus_space.9:542
#, no-wrap
msgid "machine/bus_defs.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:426
msgid "and in"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/bus_space.9:426
#, no-wrap
msgid "machine/bus_funcs.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:430
msgid ""
"to avoid confusion with the machine-independent types and functions, and, if "
"possible, should be given names which make the machine-dependence clear."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/bus_space.9:430
#, no-wrap
msgid "CONCEPTS AND GUIDELINES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:443
msgid ""
"Bus spaces are described by bus space tags, which can be created only by "
"machine-dependent code.  A given machine may have several different types of "
"bus space (e.g., memory space and I/O space), and thus may provide multiple "
"different bus space tags.  Individual busses or devices on a machine may use "
"more than one bus space tag.  For instance, ISA devices are given an ISA "
"memory space tag and an ISA I/O space tag.  Architectures may have several "
"different tags which represent the same type of space, for instance because "
"of multiple different host bus interface chipsets."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:449
msgid ""
"A range in bus space is described by a bus address and a bus size.  The bus "
"address describes the start of the range in bus space.  The bus size "
"describes the size of the range in bytes.  Busses which are not byte "
"addressable may require use of bus space ranges with appropriately aligned "
"addresses and properly rounded sizes."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:456
msgid ""
"Access to regions of bus space is facilitated by use of bus space handles, "
"which are usually created by mapping a specific range of a bus space.  "
"Handles may also be created by allocating and mapping a range of bus space, "
"the actual location of which is picked by the implementation within bounds "
"specified by the caller of the allocation function."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:468
msgid ""
"All of the bus space access functions require one bus space tag argument, at "
"least one handle argument, and at least one offset argument (a bus size).  "
"The bus space tag specifies the space, each handle specifies a region in the "
"space, and each offset specifies the offset into the region of the actual "
"location(s) to be accessed.  Offsets are given in bytes, though busses may "
"impose alignment constraints.  The offset used to access data relative to a "
"given handle must be such that all of the data being accessed is in the "
"mapped region that the handle describes.  Trying to access data outside that "
"region is an error."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:474
msgid ""
"Because some architectures' memory systems use buffering to improve memory "
"and device access performance, there is a mechanism which can be used to "
"create E<.Dq barriers> in the bus space read and write stream."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:477
msgid "There are two types of barriers: ordering barriers and completion barriers."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:488
msgid ""
"Ordering barriers prevent some operations from bypassing other operations.  "
"They are relatively light weight and described in terms of the operations "
"they are intended to order.  The important thing to note is that they create "
"specific ordering constraint surrounding bus accesses but do not necessarily "
"force any synchronization themselves.  So, if there is enough distance "
"between the memory operations being ordered, the preceding ones could "
"complete by themselves resulting in no performance penalty."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:494
msgid ""
"For instance, a write before read barrier will force any writes issued "
"before the barrier instruction to complete before any reads after the "
"barrier are issued.  This forces processors with write buffers to read data "
"from memory rather than from the pending write in the write buffer."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:500
msgid ""
"Ordering barriers are usually sufficient for most circumstances, and can be "
"combined together.  For instance a read before write barrier can be combined "
"with a write before write barrier to force all memory operations to complete "
"before the next write is started."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:508
msgid ""
"Completion barriers force all memory operations and any pending exceptions "
"to be completed before any instructions after the barrier may be issued.  "
"Completion barriers are extremely expensive and almost never required in "
"device driver code.  A single completion barrier can force the processor to "
"stall on memory for hundreds of cycles on some machines."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:512
msgid ""
"Correctly-written drivers will include all appropriate barriers, and assume "
"only the read/write ordering imposed by the barrier operations."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:522
msgid ""
"People trying to write portable drivers with the E<.Nm> functions should try "
"to make minimal assumptions about what the system allows.  In particular, "
"they should expect that the system requires bus space addresses being "
"accessed to be naturally aligned (i.e., base address of handle added to "
"offset is a multiple of the access size), and that the system does alignment "
"checking on pointers (i.e., pointer to objects being read and written must "
"point to properly-aligned data)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:540
msgid ""
"The descriptions of the E<.Nm> functions given below all assume that they "
"are called with proper arguments.  If called with invalid arguments or "
"arguments that are out of range (e.g., trying to access data outside of the "
"region mapped when a given handle was created), undefined behaviour "
"results.  In that case, they may cause the system to halt, either "
"intentionally (via panic) or unintentionally (by causing a fatal trap or by "
"some other means) or may cause improper operation which is not immediately "
"fatal.  Functions which return void or which return data read from bus space "
"(i.e., functions which don't obviously return an error code) do not fail.  "
"They could only fail if given invalid arguments, and in that case their "
"behaviour is undefined.  Functions which take a count of bytes have "
"undefined results if the specified E<.Fa count> is zero."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/bus_space.9:540
#, no-wrap
msgid "TYPES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:542
msgid "Several types are defined in"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:546
msgid "to facilitate use of the E<.Nm> functions by drivers."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:548
#, no-wrap
msgid "Fa bus_addr_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:556
msgid ""
"The E<.Fa bus_addr_t> type is used to describe bus addresses.  It must be an "
"unsigned integral type capable of holding the largest bus address usable by "
"the architecture.  This type is primarily used when mapping and unmapping "
"bus space."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:557
#, no-wrap
msgid "Fa bus_size_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:568
msgid ""
"The E<.Fa bus_size_t> type is used to describe sizes of ranges in bus "
"space.  It must be an unsigned integral type capable of holding the size of "
"the largest bus address range usable on the architecture.  This type is used "
"by virtually all of the E<.Nm> functions, describing sizes when mapping "
"regions and offsets into regions when performing space access operations."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:569
#, no-wrap
msgid "Fa bus_space_tag_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:579
msgid ""
"The E<.Fa bus_space_tag_t> type is used to describe a particular bus space "
"on a machine.  Its contents are machine-dependent and should be considered "
"opaque by machine-independent code.  This type is used by all E<.Nm> "
"functions to name the space on which they're operating."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:580
#, no-wrap
msgid "Fa bus_space_handle_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:588
msgid ""
"The E<.Fa bus_space_handle_t> type is used to describe a mapping of a range "
"of bus space.  Its contents are machine-dependent and should be considered "
"opaque by machine-independent code.  This type is used when performing bus "
"space access operations."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:588
#, no-wrap
msgid "Fa bus_space_reservation_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:607
msgid ""
"The E<.Fa bus_space_reservation_t> type is used to describe a range of bus "
"space.  It logically consists of a E<.Fa bus_addr_t>, the first address in "
"the range, and a E<.Fa bus_size_t>, the length in bytes of the range.  "
"Machine-independent code creates and interrogates a E<.Fa "
"bus_space_reservation_t> using a constructor, E<.Fn "
"bus_space_reservation_init>, and accessor functions, E<.Fn "
"bus_space_reservation_addr> and E<.Fn bus_space_reservation_size>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/bus_space.9:608
#, no-wrap
msgid "COMPARING BUS SPACE TAGS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:622
msgid ""
"To check whether or not one E<.Fa bus_space_tag_t> refers to the same space "
"as another in machine-independent code, do not use either E<.Xr memcmp 9> or "
"the C equals E<.Po> == E<.Pc> operator.  Use E<.Fn bus_space_is_equal>, "
"instead."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/bus_space.9:622
#, no-wrap
msgid "MAPPING AND UNMAPPING BUS SPACE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:632
msgid ""
"Bus space must be mapped before it can be used, and should be unmapped when "
"it is no longer needed.  The E<.Fn bus_space_map>, E<.Fn "
"bus_space_reservation_map>, E<.Fn bus_space_reservation_unmap>, and E<.Fn "
"bus_space_unmap> functions provide these capabilities."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:638
msgid ""
"Some drivers need to be able to pass a subregion of already-mapped bus space "
"to another driver or module within a driver.  The E<.Fn bus_space_subregion> "
"function allows such subregions to be created."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:640
#, no-wrap
msgid "Fn bus_space_map space address size flags handlep"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:659
msgid ""
"The E<.Fn bus_space_map> function exclusively reserves and maps the region "
"of bus space named by the E<.Fa space>, E<.Fa address>, and E<.Fa size> "
"arguments.  If successful, it returns zero and fills in the bus space handle "
"pointed to by E<.Fa handlep> with the handle that can be used to access the "
"mapped region.  If unsuccessful, it will return non-zero and leave the bus "
"space handle pointed to by E<.Fa handlep> in an undefined state."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:664
msgid ""
"The E<.Fa flags> argument controls how the space is to be mapped.  Supported "
"flags include:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:665
#, no-wrap
msgid "Dv BUS_SPACE_MAP_CACHEABLE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:671
msgid ""
"Try to map the space so that accesses can be cached by the system cache.  If "
"this flag is not specified, the implementation should map the space so that "
"it will not be cached.  This mapping method will only be useful in very rare "
"occasions."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:674
msgid ""
"This flag must have a value of 1 on all implementations for backward "
"compatibility."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:674
#, no-wrap
msgid "Dv BUS_SPACE_MAP_PREFETCHABLE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:684
msgid ""
"Try to map the space so that accesses can be prefetched by the system, and "
"writes can be buffered.  This means, accesses should be side effect free "
"(idempotent).  The E<.Fn bus_space_barrier> methods will flush the write "
"buffer or force actual read accesses.  If this flag is not specified, the "
"implementation should map the space so that it will not be prefetched or "
"delayed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:684
#, no-wrap
msgid "Dv BUS_SPACE_MAP_LINEAR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:702
msgid ""
"Try to map the space so that its contents can be accessed linearly via "
"normal memory access methods (e.g., pointer dereferencing and structure "
"accesses).  The E<.Fn bus_space_vaddr> method can be used to obtain the "
"kernel virtual address of the mapped range.  This is useful when software "
"wants to do direct access to a memory device, e.g., a frame buffer.  If this "
"flag is specified and linear mapping is not possible, the E<.Fn "
"bus_space_map> call should fail.  If this flag is not specified, the system "
"may map the space in whatever way is most convenient.  Use of this mapping "
"method is not encouraged for normal device access; where linear access is "
"not essential, use of the E<.Fn bus_space_read/write> methods is strongly "
"recommended."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:720
msgid ""
"Not all combinations of flags make sense or are supported with all spaces.  "
"For instance, E<.Dv BUS_SPACE_MAP_CACHEABLE> may be meaningless when used on "
"many systems' I/O port spaces, and on some systems E<.Dv "
"BUS_SPACE_MAP_LINEAR> without E<.Dv BUS_SPACE_MAP_PREFETCHABLE> may never "
"work.  When the system hardware or firmware provides hints as to how spaces "
"should be mapped (e.g., the PCI memory mapping registers' \"prefetchable\" "
"bit), those hints should be followed for maximum compatibility.  On some "
"systems, requesting a mapping that cannot be satisfied (e.g., requesting a "
"non-prefetchable mapping when the system can only provide a prefetchable "
"one) will cause the request to fail."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:727
msgid ""
"Some implementations may keep track of use of bus space for some or all bus "
"spaces and refuse to allow duplicate allocations.  This is encouraged for "
"bus spaces which have no notion of slot-specific space addressing, such as "
"ISA and VME, and for spaces which coexist with those spaces (e.g., EISA and "
"PCI memory and I/O spaces co-existing with ISA memory and I/O spaces)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:730
msgid ""
"Mapped regions may contain areas for which there is no device on the bus.  "
"If space in those areas is accessed, the results are bus-dependent."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:731
#, no-wrap
msgid "Fn bus_space_reservation_map space bsr flags handlep"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:755
msgid ""
"The E<.Fn bus_space_reservation_map> function is similar to E<.Fn "
"bus_space_map> but it maps a region of bus space that was previously "
"reserved by a call to E<.Fn bus_space_reserve> or E<.Fn "
"bus_space_reserve_subregion>.  The region is given by the E<.Fa space> and "
"E<.Fa bsr> arguments.  If successful, it returns zero and fills in the bus "
"space handle pointed to by E<.Fa handlep> with the handle that can be used "
"to access the mapped region.  If unsuccessful, it will return non-zero and "
"leave the bus space handle pointed to by E<.Fa handlep> in an undefined "
"state."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:760
msgid ""
"A region mapped by E<.Fn bus_space_reservation_map> may only be unmapped by "
"a call to E<.Fn bus_space_reservation_unmap>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:763
msgid "For more details, see the description of E<.Fn bus_space_map>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:764
#, no-wrap
msgid "Fn bus_space_unmap space handle size"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:777
msgid ""
"The E<.Fn bus_space_unmap> function unmaps and relinquishes a region of bus "
"space reserved and mapped with E<.Fn bus_space_map>.  When unmapping a "
"region, the E<.Fa size> specified should be the same as the size given to "
"E<.Fn bus_space_map> when mapping that region."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:782
msgid ""
"After E<.Fn bus_space_unmap> is called on a handle, that handle is no longer "
"valid.  (If copies were made of the handle they are no longer valid, "
"either.)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:789
msgid ""
"This function will never fail.  If it would fail (e.g., because of an "
"argument error), that indicates a software bug which should cause a panic.  "
"In that case, E<.Fn bus_space_unmap> will never return."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:790
#, no-wrap
msgid "Fn bus_space_reservation_unmap space handle size"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:809
msgid ""
"The E<.Fn bus_space_reservation_unmap> function is similar to E<.Fn "
"bus_space_unmap> but it should be called on handles mapped by E<.Fn "
"bus_space_reservation_map> and only on such handles.  Unlike E<.Fn "
"bus_space_unmap>, E<.Fn bus_space_reservation_unmap> does not relinquish "
"exclusive use of the bus space named by E<.Fa handle> and E<.Fa size>; that "
"is the job of E<.Fn bus_space_release>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:810
#, no-wrap
msgid "Fn bus_space_subregion space handle offset size nhandlep"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:823
msgid ""
"The E<.Fn bus_space_subregion> function is a convenience function which "
"makes a new handle to some subregion of an already-mapped region of bus "
"space.  The subregion described by the new handle starts at byte offset "
"E<.Fa offset> into the region described by E<.Fa handle>, with the size "
"given by E<.Fa size>, and must be wholly contained within the original "
"region."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:837
msgid ""
"If successful, E<.Fn bus_space_subregion> returns zero and fills in the bus "
"space handle pointed to by E<.Fa nhandlep>.  If unsuccessful, it returns "
"non-zero and leaves the bus space handle pointed to by E<.Fa nhandlep> in an "
"undefined state.  In either case, the handle described by E<.Fa handle> "
"remains valid and is unmodified."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:852
msgid ""
"When done with a handle created by E<.Fn bus_space_subregion>, the handle "
"should be thrown away.  Under no circumstances should E<.Fn bus_space_unmap> "
"be used on the handle.  Doing so may confuse any resource management being "
"done on the space, and will result in undefined behaviour.  When E<.Fn "
"bus_space_unmap> or E<.Fn bus_space_free> is called on a handle, all "
"subregions of that handle become invalid."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:853
#, no-wrap
msgid "Fn bus_space_vaddr tag handle"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:865
msgid ""
"This method returns the kernel virtual address of a mapped bus space if and "
"only if it was mapped with the E<.Dv BUS_SPACE_MAP_LINEAR> flag.  The range "
"can be accessed by normal (volatile) pointer dereferences.  If mapped with "
"the E<.Dv BUS_SPACE_MAP_PREFETCHABLE> flag, the E<.Fn bus_space_barrier> "
"method must be used to force a particular access order."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:866
#, no-wrap
msgid "Fn bus_space_mmap tag addr off prot flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:890
msgid ""
"This method is used to provide support for memory mapping bus space into "
"user applications.  If an address space is addressable via volatile pointer "
"dereferences, E<.Fn bus_space_mmap> will return the physical address "
"(possibly encoded as a machine-dependent cookie) of the bus space indicated "
"by E<.Fa addr> and E<.Fa off>.  E<.Fa addr> is the base address of the "
"device or device region, and E<.Fa off> is the offset into that region that "
"is being requested.  If the request is made with E<.Dv BUS_SPACE_MAP_LINEAR> "
"as a flag, then a linear region must be returned to the caller.  If the "
"region cannot be mapped (either the address does not exist, or the "
"constraints can not be met), E<.Fn bus_space_mmap> returns E<.Dv -1> to "
"indicate failure."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:895
msgid ""
"Note that it is not necessary that the region being requested by a E<.Fn "
"bus_space_mmap> call be mapped into a E<.Fa bus_space_handle_t>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:904
msgid ""
"E<.Fn bus_space_mmap> is called once per E<.Dv PAGE_SIZE> page in the "
"range.  The E<.Fa prot> argument indicates the memory protection requested "
"by the user application for the range."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:905
#, no-wrap
msgid "Fn bus_space_handle_is_equal space handle1 handle2"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:914
msgid ""
"Use E<.Fn bus_space_handle_is_equal> to check whether or not E<.Fa handle1> "
"and E<.Fa handle2> refer to regions starting at the same address in the bus "
"space E<.Fa space>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/bus_space.9:915
#, no-wrap
msgid "ALLOCATING AND FREEING BUS SPACE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:934
msgid ""
"Some devices require or allow bus space to be allocated by the operating "
"system for device use.  When the devices no longer need the space, the "
"operating system should free it for use by other devices.  The E<.Fn "
"bus_space_alloc>, E<.Fn bus_space_free>, E<.Fn bus_space_reserve>, E<.Fn "
"bus_space_reserve_subregion>, and E<.Fn bus_space_release> functions provide "
"these capabilities.  The functions E<.Fn bus_space_reserve>, E<.Fn "
"bus_space_reserve_subregion>, and E<.Fn bus_space_release> are not yet "
"available on all architectures."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:936
#, no-wrap
msgid ""
"Fn bus_space_alloc space reg_start reg_end size alignment boundary flags "
"addrp handlep"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:955
msgid ""
"The E<.Fn bus_space_alloc> function allocates and maps a region of bus space "
"with the size given by E<.Fa size>, corresponding to the given constraints.  "
"If successful, it returns zero, fills in the bus address pointed to by E<.Fa "
"addrp> with the bus space address of the allocated region, and fills in the "
"bus space handle pointed to by E<.Fa handlep> with the handle that can be "
"used to access that region.  If unsuccessful, it returns non-zero and leaves "
"the bus address pointed to by E<.Fa addrp> and the bus space handle pointed "
"to by E<.Fa handlep> in an undefined state."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:991
msgid ""
"Constraints on the allocation are given by the E<.Fa reg_start>, E<.Fa "
"reg_end>, E<.Fa alignment>, and E<.Fa boundary> parameters.  The allocated "
"region will start at or after E<.Fa reg_start> and end before or at E<.Fa "
"reg_end>.  The E<.Fa alignment> constraint must be a power of two, and the "
"allocated region will start at an address that is an even multiple of that "
"power of two.  The E<.Fa boundary> constraint, if non-zero, ensures that the "
"region is allocated so that E<.Fa \"first address in region\"> / E<.Fa "
"boundary> has the same value as E<.Fa \"last address in region\"> / E<.Fa "
"boundary>.  If the constraints cannot be met, E<.Fn bus_space_alloc> will "
"fail.  It is an error to specify a set of constraints that can never be met "
"E<.Po> for example, E<.Fa size> greater than E<.Fa boundary> E<.Pc>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:998
msgid ""
"The E<.Fa flags> parameter is the same as the like-named parameter to E<.Fa "
"bus_space_map>, the same flag values should be used, and they have the same "
"meanings."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1010
msgid ""
"Handles created by E<.Fn bus_space_alloc> should only be freed with E<.Fn "
"bus_space_free>.  Trying to use E<.Fn bus_space_unmap> on them causes "
"undefined behaviour.  The E<.Fn bus_space_subregion> function can be used on "
"handles created by E<.Fn bus_space_alloc>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1011
#, no-wrap
msgid "Fn bus_space_reserve t bpa size flags bsrp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1021
msgid ""
"The E<.Fn bus_space_reserve> function reserves, for the caller's exclusive "
"use, E<.Fa size> bytes starting at the address E<.Fa bpa> in the space "
"referenced by E<.Fa t>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1036
msgid ""
"E<.Fn bus_space_reserve> does E<.Em not> map the space.  The caller should "
"use E<.Fn bus_space_reservation_map> to map the reservation.  E<.Fa flags> "
"contains a hint how the caller may map the reservation, later.  Whenever "
"possible, callers should pass the same flags to E<.Fn bus_space_reserve> as "
"they will pass to E<.Fn bus_space_reservation_map> to map the reservation."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1048
msgid ""
"On success, E<.Fn bus_space_reserve> records the reservation at E<.Fa bsrp> "
"and returns 0.  On failure, E<.Fa bsrp> is undefined, and E<.Fn "
"bus_space_reserve> returns a non-zero error code.  Possible error codes "
"include"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1049 org_netbsd/src/share/man/man9/bus_space.9:1093
#, no-wrap
msgid "Er EOPNOTSUPP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1055 org_netbsd/src/share/man/man9/bus_space.9:1099
msgid ""
"E<.Fn bus_space_reserve> is not supported on this architecture, or E<.Fa "
"flags> was incompatible with the bus space represented by E<.Fa t>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1059 org_netbsd/src/share/man/man9/bus_space.9:1103
msgid "There was not sufficient bus space at E<.Fa bpa> to satisfy the request."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1061
#, no-wrap
msgid ""
"Fn bus_space_reserve_subregion t reg_start reg_end size alignment boundary "
"flags bsrp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1080
msgid ""
"The E<.Fn bus_space_reserve_subregion> function reserves, for the caller's "
"exclusive use, E<.Fa size> bytes in the space referenced by E<.Fa t>.  The "
"parameters E<.Fa reg_start>, E<.Fa reg_end>, E<.Fa alignment>, E<.Fa "
"boundary>, and E<.Fa flags> each work alike to the E<.Fn bus_space_alloc> "
"parameters of the same names."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1092
msgid ""
"On success, E<.Fn bus_space_reserve_subregion> records the reservation at "
"E<.Fa bsrp> and returns 0.  On failure, E<.Fa bsrp> is undefined, and E<.Fn "
"bus_space_reserve_subregion> returns a non-zero error code.  Possible error "
"codes include"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1105
#, no-wrap
msgid "Fn bus_space_release t bsr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1117
msgid ""
"The E<.Fn bus_space_release> function releases the bus space E<.Fa bsr> in "
"E<.Fa t> that was previously reserved by E<.Fn bus_space_reserve> or E<.Fn "
"bus_space_reserve_subregion>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1124
msgid ""
"If E<.Fn bus_space_release> is called on a reservation that has been mapped "
"by E<.Fn bus_space_reservation_map> without subsequently being unmapped, the "
"behavior of the system is undefined."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1125
#, no-wrap
msgid "Fn bus_space_free space handle size"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1137
msgid ""
"The E<.Fn bus_space_free> function unmaps and frees a region of bus space "
"mapped and allocated with E<.Fn bus_space_alloc>.  When unmapping a region, "
"the E<.Fa size> specified should be the same as the size given to E<.Fn "
"bus_space_alloc> when allocating the region."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1142
msgid ""
"After E<.Fn bus_space_free> is called on a handle, that handle is no longer "
"valid.  (If copies were made of the handle, they are no longer valid, "
"either.)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1149
msgid ""
"This function will never fail.  If it would fail (e.g., because of an "
"argument error), that indicates a software bug which should cause a panic.  "
"In that case, E<.Fn bus_space_free> will never return."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/bus_space.9:1150
#, no-wrap
msgid "READING AND WRITING SINGLE DATA ITEMS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1160
msgid ""
"The simplest way to access bus space is to read or write a single data "
"item.  The E<.Fn bus_space_read_N> and E<.Fn bus_space_write_N> families of "
"functions provide the ability to read and write 1, 2, 4, and 8 byte data "
"items on busses which support those access sizes."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1162
#, no-wrap
msgid "Fn bus_space_read_1 space handle offset"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1163
#, no-wrap
msgid "Fn bus_space_read_2 space handle offset"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1164
#, no-wrap
msgid "Fn bus_space_read_4 space handle offset"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1165
#, no-wrap
msgid "Fn bus_space_read_8 space handle offset"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1178
msgid ""
"The E<.Fn bus_space_read_N> family of functions reads a 1, 2, 4, or 8 byte "
"data item from the offset specified by E<.Fa offset> into the region "
"specified by E<.Fa handle> of the bus space specified by E<.Fa space>.  The "
"location being read must lie within the bus space region specified by E<.Fa "
"handle>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1184
msgid ""
"For portability, the starting address of the region specified by E<.Fa "
"handle> plus the offset should be a multiple of the size of data item being "
"read.  On some systems, not obeying this requirement may cause incorrect "
"data to be read, on others it may cause a system crash."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1192
msgid ""
"Read operations done by the E<.Fn bus_space_read_N> functions may be "
"executed out of order with respect to other pending read and write "
"operations unless order is enforced by use of the E<.Fn bus_space_barrier> "
"function."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1197 org_netbsd/src/share/man/man9/bus_space.9:1235 org_netbsd/src/share/man/man9/bus_space.9:1509 org_netbsd/src/share/man/man9/bus_space.9:1559 org_netbsd/src/share/man/man9/bus_space.9:1616 org_netbsd/src/share/man/man9/bus_space.9:1665 org_netbsd/src/share/man/man9/bus_space.9:1725 org_netbsd/src/share/man/man9/bus_space.9:1772
msgid ""
"These functions will never fail.  If they would fail (e.g., because of an "
"argument error), that indicates a software bug which should cause a panic.  "
"In that case, they will never return."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1198
#, no-wrap
msgid "Fn bus_space_write_1 space handle offset value"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1199
#, no-wrap
msgid "Fn bus_space_write_2 space handle offset value"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1200
#, no-wrap
msgid "Fn bus_space_write_4 space handle offset value"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1201
#, no-wrap
msgid "Fn bus_space_write_8 space handle offset value"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1215
msgid ""
"The E<.Fn bus_space_write_N> family of functions writes a 1, 2, 4, or 8 byte "
"data item to the offset specified by E<.Fa offset> into the region specified "
"by E<.Fa handle> of the bus space specified by E<.Fa space>.  The location "
"being written must lie within the bus space region specified by E<.Fa "
"handle>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1222
msgid ""
"For portability, the starting address of the region specified by E<.Fa "
"handle> plus the offset should be a multiple of the size of data item being "
"written.  On some systems, not obeying this requirement may cause incorrect "
"data to be written, on others it may cause a system crash."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1230
msgid ""
"Write operations done by the E<.Fn bus_space_write_N> functions may be "
"executed out of order with respect to other pending read and write "
"operations unless order is enforced by use of the E<.Fn bus_space_barrier> "
"function."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/bus_space.9:1236
#, no-wrap
msgid "PROBING BUS SPACE FOR HARDWARE WHICH MAY NOT RESPOND"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1252
msgid ""
"One problem with the E<.Fn bus_space_read_N> and E<.Fn bus_space_write_N> "
"family of functions is that they provide no protection against exceptions "
"which can occur when no physical hardware or device responds to the read or "
"write cycles.  In such a situation, the system typically would panic due to "
"a kernel-mode bus error.  The E<.Fn bus_space_peek_N> and E<.Fn "
"bus_space_poke_N> family of functions provide a mechanism to handle these "
"exceptions gracefully without the risk of crashing the system."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1268
msgid ""
"As with E<.Fn bus_space_read_N> and E<.Fn bus_space_write_N>, the peek and "
"poke functions provide the ability to read and write 1, 2, 4, and 8 byte "
"data items on busses which support those access sizes.  All of the "
"constraints specified in the descriptions of the E<.Fn bus_space_read_N> and "
"E<.Fn bus_space_write_N> functions also apply to E<.Fn bus_space_peek_N> and "
"E<.Fn bus_space_poke_N>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1275
msgid ""
"In addition, explicit calls to the E<.Fn bus_space_barrier> function are not "
"required as the implementation will ensure all pending operations complete "
"before the peek or poke operation starts.  The implementation will also "
"ensure that the peek or poke operations complete before returning."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1288
msgid ""
"The return value indicates the outcome of the peek or poke operation.  A "
"return value of zero implies that a hardware device is responding to the "
"operation at the specified offset in the bus space.  A non-zero return value "
"indicates that the kernel intercepted a hardware exception (e.g., bus error) "
"when the peek or poke operation was attempted.  Note that some busses are "
"incapable of generating exceptions when non-existent hardware is accessed.  "
"In such cases, these functions will always return zero and the value of the "
"data read by E<.Fn bus_space_peek_N> will be unspecified."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1296
msgid ""
"Finally, it should be noted that at this time the E<.Fn bus_space_peek_N> "
"and E<.Fn bus_space_poke_N> functions are not re-entrant and should not, "
"therefore, be used from within an interrupt service routine.  This "
"constraint may be removed at some point in the future."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1298
#, no-wrap
msgid "Fn bus_space_peek_1 space handle offset datap"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1299
#, no-wrap
msgid "Fn bus_space_peek_2 space handle offset datap"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1300
#, no-wrap
msgid "Fn bus_space_peek_4 space handle offset datap"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1301
#, no-wrap
msgid "Fn bus_space_peek_8 space handle offset datap"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1317
msgid ""
"The E<.Fn bus_space_peek_N> family of functions cautiously read a 1, 2, 4, "
"or 8 byte data item from the offset specified by E<.Fa offset> in the region "
"specified by E<.Fa handle> of the bus space specified by E<.Fa space>.  The "
"data item read is stored in the location pointed to by E<.Fa datap>.  It is "
"permissible for E<.Fa datap> to be NULL, in which case the data item will be "
"discarded after being read."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1318
#, no-wrap
msgid "Fn bus_space_poke_1 space handle offset value"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1319
#, no-wrap
msgid "Fn bus_space_poke_2 space handle offset value"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1320
#, no-wrap
msgid "Fn bus_space_poke_4 space handle offset value"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1321
#, no-wrap
msgid "Fn bus_space_poke_8 space handle offset value"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1334
msgid ""
"The E<.Fn bus_space_poke_N> family of functions cautiously write a 1, 2, 4, "
"or 8 byte data item specified by E<.Fa value> to the offset specified by "
"E<.Fa offset> in the region specified by E<.Fa handle> of the bus space "
"specified by E<.Fa space>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/bus_space.9:1335
#, no-wrap
msgid "BARRIERS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1342
msgid ""
"In order to allow high-performance buffering implementations to avoid bus "
"activity on every operation, read and write ordering should be specified "
"explicitly by drivers when necessary.  The E<.Fn bus_space_barrier> function "
"provides that ability."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1344
#, no-wrap
msgid "Fn bus_space_barrier space handle offset length flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1357
msgid ""
"The E<.Fn bus_space_barrier> function enforces ordering of bus space read "
"and write operations for the specified subregion (described by the E<.Fa "
"offset> and E<.Fa length> parameters) of the region named by E<.Fa handle> "
"in the space named by E<.Fa space>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1362
msgid ""
"The E<.Fa flags> argument controls what types of operations are to be "
"ordered.  Supported flags are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1363
#, no-wrap
msgid "Dv BUS_SPACE_BARRIER_READ_BEFORE_READ"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1366
msgid ""
"Force all reads before the barrier to complete before any reads after the "
"barrier may be issued."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1366
#, no-wrap
msgid "Dv BUS_SPACE_BARRIER_READ_BEFORE_WRITE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1369
msgid ""
"Force all reads before the barrier to complete before any writes after the "
"barrier may be issued."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1369
#, no-wrap
msgid "Dv BUS_SPACE_BARRIER_WRITE_BEFORE_READ"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1372
msgid ""
"Force all writes before the barrier to complete before any reads after the "
"barrier may be issued."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1372
#, no-wrap
msgid "Dv BUS_SPACE_BARRIER_WRITE_BEFORE_WRITE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1375
msgid ""
"Force all writes before the barrier to complete before any writes after the "
"barrier may be issued."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1375
#, no-wrap
msgid "Dv BUS_SPACE_BARRIER_SYNC"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1378
msgid ""
"Force all memory operations and any pending exceptions to be completed "
"before any instructions after the barrier may be issued."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1382
msgid ""
"Those flags can be combined (or-ed together) to enforce ordering on "
"different combinations of read and write operations."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1386
msgid ""
"All of the specified type(s) of operation which are done to the region "
"before the barrier operation are guaranteed to complete before any of the "
"specified type(s) of operation done after the barrier."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1395
msgid ""
"Example: Consider a hypothetical device with two single-byte ports, one "
"write-only input port (at offset 0) and a read-only output port (at offset "
"1).  Operation of the device is as follows: data bytes are written to the "
"input port, and are placed by the device on a stack, the top of which is "
"read by reading from the output port.  The sequence to correctly write two "
"data bytes to the device then read those two data bytes back would be:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1409
#, no-wrap
msgid ""
"/*\n"
" * t and h are the tag and handle for the mapped device's\n"
" * space.\n"
" */\n"
"bus_space_write_1(t, h, 0, data0);\n"
"bus_space_barrier(t, h, 0, 1, BUS_SPACE_BARRIER_WRITE_BEFORE_WRITE); /* 1 "
"*/\n"
"bus_space_write_1(t, h, 0, data1);\n"
"bus_space_barrier(t, h, 0, 2, BUS_SPACE_BARRIER_WRITE_BEFORE_READ);  /* 2 "
"*/\n"
"ndata1 = bus_space_read_1(t, h, 1);\n"
"bus_space_barrier(t, h, 1, 1, BUS_SPACE_BARRIER_READ_BEFORE_READ);   /* 3 "
"*/\n"
"ndata0 = bus_space_read_1(t, h, 1);\n"
"/* data0 == ndata0, data1 == ndata1 */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1416
msgid ""
"The first barrier makes sure that the first write finishes before the second "
"write is issued, so that two writes to the input port are done in order and "
"are not collapsed into a single write.  This ensures that the data bytes are "
"written to the device correctly and in order."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1422
msgid ""
"The second barrier forces the writes to the output port finish before any of "
"the reads to the input port are issued, thereby making sure that all of the "
"writes are finished before data is read.  This ensures that the first byte "
"read from the device really is the last one that was written."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1425
msgid ""
"The third barrier makes sure that the first read finishes before the second "
"read is issued, ensuring that data is read correctly and in order."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1431
msgid ""
"The barriers in the example above are specified to cover the absolute "
"minimum number of bus space locations.  It is correct (and often easier) to "
"make barrier operations cover the device's whole range of bus space, that "
"is, to specify an offset of zero and the size of the whole region."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1434
msgid ""
"The following barrier operations are obsolete and should be removed from "
"existing code:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1435
#, no-wrap
msgid "Dv BUS_SPACE_BARRIER_READ"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1437
msgid "Synchronize read operations."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1437
#, no-wrap
msgid "Dv BUS_SPACE_BARRIER_WRITE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1439
msgid "Synchronize write operations."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/bus_space.9:1441
#, no-wrap
msgid "REGION OPERATIONS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1451
msgid ""
"Some devices use buffers which are mapped as regions in bus space.  Often, "
"drivers want to copy the contents of those buffers to or from memory, e.g., "
"into mbufs which can be passed to higher levels of the system or from mbufs "
"to be output to a network.  In order to allow drivers to do this as "
"efficiently as possible, the E<.Fn bus_space_read_region_N> and E<.Fn "
"bus_space_write_region_N> families of functions are provided."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1460
msgid ""
"Drivers occasionally need to copy one region of a bus space to another, or "
"to set all locations in a region of bus space to contain a single value.  "
"The E<.Fn bus_space_copy_region_N> family of functions and the E<.Fn "
"bus_space_set_region_N> family of functions allow drivers to perform these "
"operations."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1462
#, no-wrap
msgid "Fn bus_space_read_region_1 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1463
#, no-wrap
msgid "Fn bus_space_read_region_2 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1464
#, no-wrap
msgid "Fn bus_space_read_region_4 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1465
#, no-wrap
msgid "Fn bus_space_read_region_8 space handle offset datap count"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1485
msgid ""
"The E<.Fn bus_space_read_region_N> family of functions reads E<.Fa count> 1, "
"2, 4, or 8 byte data items from bus space starting at byte offset E<.Fa "
"offset> in the region specified by E<.Fa handle> of the bus space specified "
"by E<.Fa space> and writes them into the array specified by E<.Fa datap>.  "
"Each successive data item is read from an offset 1, 2, 4, or 8 bytes after "
"the previous data item (depending on which function is used).  All locations "
"being read must lie within the bus space region specified by E<.Fa handle>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1492 org_netbsd/src/share/man/man9/bus_space.9:1707
msgid ""
"For portability, the starting address of the region specified by E<.Fa "
"handle> plus the offset should be a multiple of the size of data items being "
"read and the data array pointer should be properly aligned.  On some "
"systems, not obeying these requirements may cause incorrect data to be read, "
"on others it may cause a system crash."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1504
msgid ""
"Read operations done by the E<.Fn bus_space_read_region_N> functions may be "
"executed in any order.  They may also be executed out of order with respect "
"to other pending read and write operations unless order is enforced by use "
"of the E<.Fn bus_space_barrier> function.  There is no way to insert "
"barriers between reads of individual bus space locations executed by the "
"E<.Fn bus_space_read_region_N> functions."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1510
#, no-wrap
msgid "Fn bus_space_write_region_1 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1511
#, no-wrap
msgid "Fn bus_space_write_region_2 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1512
#, no-wrap
msgid "Fn bus_space_write_region_4 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1513
#, no-wrap
msgid "Fn bus_space_write_region_8 space handle offset datap count"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1534
msgid ""
"The E<.Fn bus_space_write_region_N> family of functions reads E<.Fa count> "
"1, 2, 4, or 8 byte data items from the array specified by E<.Fa datap> and "
"writes them to bus space starting at byte offset E<.Fa offset> in the region "
"specified by E<.Fa handle> of the bus space specified by E<.Fa space>.  Each "
"successive data item is written to an offset 1, 2, 4, or 8 bytes after the "
"previous data item (depending on which function is used).  All locations "
"being written must lie within the bus space region specified by E<.Fa "
"handle>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1541 org_netbsd/src/share/man/man9/bus_space.9:1755
msgid ""
"For portability, the starting address of the region specified by E<.Fa "
"handle> plus the offset should be a multiple of the size of data items being "
"written and the data array pointer should be properly aligned.  On some "
"systems, not obeying these requirements may cause incorrect data to be "
"written, on others it may cause a system crash."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1554
msgid ""
"Write operations done by the E<.Fn bus_space_write_region_N> functions may "
"be executed in any order.  They may also be executed out of order with "
"respect to other pending read and write operations unless order is enforced "
"by use of the E<.Fn bus_space_barrier> function.  There is no way to insert "
"barriers between writes of individual bus space locations executed by the "
"E<.Fn bus_space_write_region_N> functions."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1560
#, no-wrap
msgid ""
"Fn bus_space_copy_region_1 space srchandle srcoffset dsthandle dstoffset "
"count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1562
#, no-wrap
msgid ""
"Fn bus_space_copy_region_2 space srchandle srcoffset dsthandle dstoffset "
"count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1564
#, no-wrap
msgid ""
"Fn bus_space_copy_region_4 space srchandle srcoffset dsthandle dstoffset "
"count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1566
#, no-wrap
msgid ""
"Fn bus_space_copy_region_8 space srchandle srcoffset dsthandle dstoffset "
"count"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1589
msgid ""
"The E<.Fn bus_space_copy_region_N> family of functions copies E<.Fa count> "
"1, 2, 4, or 8 byte data items in bus space from the area starting at byte "
"offset E<.Fa srcoffset> in the region specified by E<.Fa srchandle> of the "
"bus space specified by E<.Fa space> to the area starting at byte offset "
"E<.Fa dstoffset> in the region specified by E<.Fa dsthandle> in the same bus "
"space.  Each successive data item read or written has an offset 1, 2, 4, or "
"8 bytes after the previous data item (depending on which function is used).  "
"All locations being read and written must lie within the bus space region "
"specified by their respective handles."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1595
msgid ""
"For portability, the starting addresses of the regions specified by each "
"handle plus its respective offset should be a multiple of the size of data "
"items being copied.  On some systems, not obeying this requirement may cause "
"incorrect data to be copied, on others it may cause a system crash."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1606
msgid ""
"Read and write operations done by the E<.Fn bus_space_copy_region_N> "
"functions may be executed in any order.  They may also be executed out of "
"order with respect to other pending read and write operations unless order "
"is enforced by use of the E<.Fn bus_space_barrier function>.  There is no "
"way to insert barriers between reads or writes of individual bus space "
"locations executed by the E<.Fn bus_space_copy_region_N> functions."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1611
msgid ""
"Overlapping copies between different subregions of a single region of bus "
"space are handled correctly by the E<.Fn bus_space_copy_region_N> functions."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1617
#, no-wrap
msgid "Fn bus_space_set_region_1 space handle offset value count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1618
#, no-wrap
msgid "Fn bus_space_set_region_2 space handle offset value count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1619
#, no-wrap
msgid "Fn bus_space_set_region_4 space handle offset value count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1620
#, no-wrap
msgid "Fn bus_space_set_region_8 space handle offset value count"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1640
msgid ""
"The E<.Fn bus_space_set_region_N> family of functions writes the given E<.Fa "
"value> to E<.Fa count> 1, 2, 4, or 8 byte data items in bus space starting "
"at byte offset E<.Fa offset> in the region specified by E<.Fa handle> of the "
"bus space specified by E<.Fa space>.  Each successive data item has an "
"offset 1, 2, 4, or 8 bytes after the previous data item (depending on which "
"function is used).  All locations being written must lie within the bus "
"space region specified by E<.Fa handle>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1647
msgid ""
"For portability, the starting address of the region specified by E<.Fa "
"handle> plus the offset should be a multiple of the size of data items being "
"written.  On some systems, not obeying this requirement may cause incorrect "
"data to be written, on others it may cause a system crash."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1660
msgid ""
"Write operations done by the E<.Fn bus_space_set_region_N> functions may be "
"executed in any order.  They may also be executed out of order with respect "
"to other pending read and write operations unless order is enforced by use "
"of the E<.Fn bus_space_barrier> function.  There is no way to insert "
"barriers between writes of individual bus space locations executed by the "
"E<.Fn bus_space_set_region_N> functions."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/bus_space.9:1666
#, no-wrap
msgid "READING AND WRITING A SINGLE LOCATION MULTIPLE TIMES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1676
msgid ""
"Some devices implement single locations in bus space which are to be read or "
"written multiple times to communicate data, e.g., some ethernet devices' "
"packet buffer FIFOs.  In order to allow drivers to manipulate these types of "
"devices as efficiently as possible, the E<.Fn bus_space_read_multi_N> and "
"E<.Fn bus_space_write_multi_N> families of functions are provided."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1678
#, no-wrap
msgid "Fn bus_space_read_multi_1 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1679
#, no-wrap
msgid "Fn bus_space_read_multi_2 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1680
#, no-wrap
msgid "Fn bus_space_read_multi_4 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1681
#, no-wrap
msgid "Fn bus_space_read_multi_8 space handle offset datap count"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1700
msgid ""
"The E<.Fn bus_space_read_multi_N> family of functions reads E<.Fa count> 1, "
"2, 4, or 8 byte data items from bus space at byte offset E<.Fa offset> in "
"the region specified by E<.Fa handle> of the bus space specified by E<.Fa "
"space> and writes them into the array specified by E<.Fa datap>.  Each "
"successive data item is read from the same location in bus space.  The "
"location being read must lie within the bus space region specified by E<.Fa "
"handle>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1720
msgid ""
"Read operations done by the E<.Fn bus_space_read_multi_N> functions may be "
"executed out of order with respect to other pending read and write "
"operations unless order is enforced by use of the E<.Fn bus_space_barrier> "
"function.  Because the E<.Fn bus_space_read_multi_N> functions read the same "
"bus space location multiple times, they place an implicit read barrier "
"between each successive read of that bus space location."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1726
#, no-wrap
msgid "Fn bus_space_write_multi_1 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1727
#, no-wrap
msgid "Fn bus_space_write_multi_2 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1728
#, no-wrap
msgid "Fn bus_space_write_multi_4 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1729
#, no-wrap
msgid "Fn bus_space_write_multi_8 space handle offset datap count"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1748
msgid ""
"The E<.Fn bus_space_write_multi_N> family of functions reads E<.Fa count> 1, "
"2, 4, or 8 byte data items from the array specified by E<.Fa datap> and "
"writes them into bus space at byte offset E<.Fa offset> in the region "
"specified by E<.Fa handle> of the bus space specified by E<.Fa space>.  Each "
"successive data item is written to the same location in bus space.  The "
"location being written must lie within the bus space region specified by "
"E<.Fa handle>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1767
msgid ""
"Write operations done by the E<.Fn bus_space_write_multi_N> functions may be "
"executed out of order with respect to other pending read and write "
"operations unless order is enforced by use of the E<.Fn bus_space_barrier> "
"function.  Because the E<.Fn bus_space_write_multi_N> functions write the "
"same bus space location multiple times, they place an implicit write barrier "
"between each successive write of that bus space location."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/bus_space.9:1773
#, no-wrap
msgid "STREAM FUNCTIONS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1783
msgid ""
"Most of the E<.Nm> functions imply a host byte-order and a bus byte-order "
"and take care of any translation for the caller.  In some cases, however, "
"hardware may map a FIFO or some other memory region for which the caller may "
"want to use multi-word, yet untranslated access.  Access to these types of "
"memory regions should be with the E<.Fn bus_space_*_stream_N> functions."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1785
#, no-wrap
msgid "Fn bus_space_read_stream_1 space handle offset"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1786
#, no-wrap
msgid "Fn bus_space_read_stream_2 space handle offset"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1787
#, no-wrap
msgid "Fn bus_space_read_stream_4 space handle offset"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1788
#, no-wrap
msgid "Fn bus_space_read_stream_8 space handle offset"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1789
#, no-wrap
msgid "Fn bus_space_read_multi_stream_1 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1790
#, no-wrap
msgid "Fn bus_space_read_multi_stream_2 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1791
#, no-wrap
msgid "Fn bus_space_read_multi_stream_4 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1792
#, no-wrap
msgid "Fn bus_space_read_multi_stream_8 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1793
#, no-wrap
msgid "Fn bus_space_read_region_stream_1 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1794
#, no-wrap
msgid "Fn bus_space_read_region_stream_2 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1795
#, no-wrap
msgid "Fn bus_space_read_region_stream_4 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1796
#, no-wrap
msgid "Fn bus_space_read_region_stream_8 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1797
#, no-wrap
msgid "Fn bus_space_write_stream_1 space handle offset value"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1798
#, no-wrap
msgid "Fn bus_space_write_stream_2 space handle offset value"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1799
#, no-wrap
msgid "Fn bus_space_write_stream_4 space handle offset value"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1800
#, no-wrap
msgid "Fn bus_space_write_stream_8 space handle offset value"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1801
#, no-wrap
msgid "Fn bus_space_write_multi_stream_1 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1802
#, no-wrap
msgid "Fn bus_space_write_multi_stream_2 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1803
#, no-wrap
msgid "Fn bus_space_write_multi_stream_4 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1804
#, no-wrap
msgid "Fn bus_space_write_multi_stream_8 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1805
#, no-wrap
msgid "Fn bus_space_write_region_stream_1 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1806
#, no-wrap
msgid "Fn bus_space_write_region_stream_2 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1807
#, no-wrap
msgid "Fn bus_space_write_region_stream_4 space handle offset datap count"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1808
#, no-wrap
msgid "Fn bus_space_write_region_stream_8 space handle offset datap count"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1813
msgid ""
"These functions are defined just as their non-stream counterparts, except "
"that they provide no byte-order translation."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/bus_space.9:1813
#, no-wrap
msgid "IMPLEMENTING BUS SPACES IN MACHINE-INDEPENDENT CODE"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1815
#, no-wrap
msgid "Fn bus_space_tag_create obst present extpresent ov ctx bstp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1829
msgid ""
"Create a copy of the tag E<.Fa obst> at E<.Fa *bstp>.  Except for the "
"behavior overridden by E<.Fa ov>, E<.Fa *bstp> inherits the behavior of "
"E<.Fa obst> under E<.Nm> calls."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1843
msgid ""
"E<.Fa ov> contains function pointers corresponding to E<.Nm> routines.  Each "
"function pointer has a corresponding bit in E<.Fa present> or E<.Fa "
"extpresent>, and if that bit is 1, the function pointer overrides the "
"corresponding E<.Nm> call for the new tag.  Any combination of these bits "
"may be set in E<.Fa present>:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1845
#, no-wrap
msgid "Dv BUS_SPACE_OVERRIDE_MAP"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1846
#, no-wrap
msgid "Dv BUS_SPACE_OVERRIDE_UNMAP"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1847
#, no-wrap
msgid "Dv BUS_SPACE_OVERRIDE_ALLOC"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1848
#, no-wrap
msgid "Dv BUS_SPACE_OVERRIDE_FREE"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1849
#, no-wrap
msgid "Dv BUS_SPACE_OVERRIDE_RESERVE"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1850
#, no-wrap
msgid "Dv BUS_SPACE_OVERRIDE_RELEASE"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1851
#, no-wrap
msgid "Dv BUS_SPACE_OVERRIDE_RESERVATION_MAP"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1852
#, no-wrap
msgid "Dv BUS_SPACE_OVERRIDE_RESERVATION_UNMAP"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1853
#, no-wrap
msgid "Dv BUS_SPACE_OVERRIDE_RESERVE_SUBREGION"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1865
msgid ""
"E<.Fn bus_space_tag_create> does not copy E<.Fa ov>.  After a new tag is "
"created by E<.Fn bus_space_tag_create>, E<.Fa ov> must not be destroyed "
"until after the tag is destroyed by E<.Fn bus_space_tag_destroy>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1871 org_netbsd/src/share/man/man9/pci.9:347
msgid ""
"The first argument of every override-function is a E<.Vt \"void *\">, and "
"E<.Fa ctx> is passed in that argument."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1891
msgid ""
"Return 0 if the call succeeds.  Return E<.Er EOPNOTSUPP> if the architecture "
"does not support overrides.  Return E<.Er EINVAL> if E<.Fa present> is 0, if "
"E<.Fa ov> is E<.Dv NULL>, or if E<.Fa present> indicates that an override is "
"present, but the corresponding override in E<.Fa ov> is E<.Dv NULL>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1895
msgid "If the call does not succeed, E<.Fa *bstp> is undefined."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/bus_space.9:1895
#, no-wrap
msgid "Fn bus_space_tag_destroy bst"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1908
msgid ""
"Destroy a tag, E<.Fa bst>, created by a prior call to E<.Fn "
"bus_space_tag_create>.  If E<.Fa bst> was not created by E<.Fn "
"bus_space_tag_create>, results are undefined.  If E<.Fa bst> was already "
"destroyed, results are undefined."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/bus_space.9:1909
#, no-wrap
msgid "EXPECTED CHANGES TO THE BUS_SPACE FUNCTIONS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1915
msgid ""
"The definition of the E<.Nm> functions should not yet be considered "
"finalized.  There are several changes and improvements which should be "
"explored, including:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1933
msgid ""
"Providing a mechanism by which incorrectly-written drivers will be "
"automatically given barriers and properly-written drivers won't be forced to "
"use more barriers than they need.  This should probably be done via a E<.Li "
"#define> in the incorrectly-written drivers.  Unfortunately, at this time, "
"few drivers actually use barriers correctly (or at all).  Because of that, "
"E<.Nm> implementations on architectures which do buffering must always do "
"the barriers inside the E<.Nm> calls, to be safe.  That has a potentially "
"significant performance impact."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1938
msgid ""
"Exporting the E<.Nm> functions to user-land so that applications (such as X "
"servers) have easier, more portable access to device space."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1944
msgid ""
"Redefining bus space tags and handles so that machine-independent bus "
"interface drivers (for example PCI to VME bridges) could define and "
"implement bus spaces without requiring machine-dependent code.  If this is "
"done, it should be done in such a way that machine-dependent optimizations "
"should remain possible."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1949
msgid ""
"Converting bus spaces (such as PCI configuration space) which currently use "
"space-specific access methods to use the E<.Nm> functions where that is "
"appropriate."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1958
msgid ""
"Redefining the way bus space is mapped and allocated, so that mapping and "
"allocation are done with bus specific functions which return bus space "
"tags.  This would allow further optimization than is currently possible, and "
"would also ease translation of the E<.Nm> functions into user space (since "
"mapping in user space would look like it just used a different bus-specific "
"mapping function)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1970
msgid ""
"The current version of the E<.Nm> interface specification differs slightly "
"from the original specification that came into wide use.  A few of the "
"function names and arguments have changed for consistency and increased "
"functionality.  Drivers that were written to the old, deprecated "
"specification can be compiled by defining the E<.Dv "
"__BUS_SPACE_COMPAT_OLDDEFS> preprocessor symbol before including"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/bus_space.9:1970
#, no-wrap
msgid "sys/bus.h ."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1974
msgid "E<.Xr bus_dma 9>, E<.Xr mb 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:1989
msgid ""
"The E<.Nm> functions were introduced in a different form (memory and I/O "
"spaces were accessed via different sets of functions) in E<.Nx 1.2>.  The "
"functions were merged to work on generic E<.Dq spaces> early in the E<.Nx "
"1.3> development cycle, and many drivers were converted to use them.  This "
"document was written later during the E<.Nx 1.3> development cycle and the "
"specification was updated to fix some consistency problems and to add some "
"missing functionality."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:2000
msgid ""
"The E<.Nm> interfaces were designed and implemented by the E<.Nx> developer "
"community.  Primary contributors and implementors were Chris Demetriou, "
"Jason Thorpe, and Charles Hannum, but the rest of the E<.Nx> developers and "
"the user community played a significant role in development."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bus_space.9:2001
msgid "Chris Demetriou wrote this manual page."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/byteorder.9:29 org_netbsd/src/share/man/man9/man9.i386/bioscall.9:30 org_netbsd/src/share/man/man9/man9.i386/return_address.9:30
#, no-wrap
msgid "May 5, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/byteorder.9:30
#, no-wrap
msgid "BYTEORDER 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/byteorder.9:60
msgid ""
"E<.Nm bswap16>, E<.Nm bswap32>, E<.Nm bswap64>, E<.Nm be16toh>, E<.Nm "
"be32toh>, E<.Nm be64toh>, E<.Nm htobe16>, E<.Nm htobe32>, E<.Nm htobe64>, "
"E<.Nm htole16>, E<.Nm htole32>, E<.Nm htole64>, E<.Nm le16toh>, E<.Nm "
"le32toh>, E<.Nm le64toh>, E<.Nm be16enc>, E<.Nm be16dec>, E<.Nm be32enc>, "
"E<.Nm be32dec>, E<.Nm be64enc>, E<.Nm be64dec>, E<.Nm le16enc>, E<.Nm "
"le16dec>, E<.Nm le32enc>, E<.Nm le32dec>, E<.Nm le64enc>, E<.Nm le64dec>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/byteorder.9:60
#, no-wrap
msgid "byte order operations"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/byteorder.9:62
#, no-wrap
msgid "sys/endian.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/byteorder.9:117
msgid ""
"E<.Ft uint16_t> E<.Fn bswap16 \"uint16_t int16\"> E<.Ft uint32_t> E<.Fn "
"bswap32 \"uint32_t int32\"> E<.Ft uint64_t> E<.Fn bswap64 \"uint64_t "
"int64\"> E<.Ft uint16_t> E<.Fn be16toh \"uint16_t big16\"> E<.Ft uint32_t> "
"E<.Fn be32toh \"uint32_t big32\"> E<.Ft uint64_t> E<.Fn be64toh \"uint64_t "
"big64\"> E<.Ft uint16_t> E<.Fn htobe16 \"uint16_t host16\"> E<.Ft uint32_t> "
"E<.Fn htobe32 \"uint32_t host32\"> E<.Ft uint64_t> E<.Fn htobe64 \"uint64_t "
"host64\"> E<.Ft uint16_t> E<.Fn htole16 \"uint16_t host16\"> E<.Ft uint32_t> "
"E<.Fn htole32 \"uint32_t host32\"> E<.Ft uint64_t> E<.Fn htole64 \"uint64_t "
"host64\"> E<.Ft uint16_t> E<.Fn le16toh \"uint16_t little16\"> E<.Ft "
"uint32_t> E<.Fn le32toh \"uint32_t little32\"> E<.Ft uint64_t> E<.Fn le64toh "
"\"uint64_t little64\"> E<.Ft uint16_t> E<.Fn be16dec \"const void *stream\"> "
"E<.Ft uint32_t> E<.Fn be32dec \"const void *stream\"> E<.Ft uint64_t> E<.Fn "
"be64dec \"const void *stream\"> E<.Ft uint16_t> E<.Fn le16dec \"const void "
"*stream\"> E<.Ft uint32_t> E<.Fn le32dec \"const void *stream\"> E<.Ft "
"uint64_t> E<.Fn le64dec \"const void *stream\"> E<.Ft void> E<.Fn be16enc "
"\"void *stream\" \"uint16_t host16\"> E<.Ft void> E<.Fn be32enc \"void "
"*stream\" \"uint32_t host32\"> E<.Ft void> E<.Fn be64enc \"void *stream\" "
"\"uint64_t host64\"> E<.Ft void> E<.Fn le16enc \"void *stream\" \"uint16_t "
"host16\"> E<.Ft void> E<.Fn le32enc \"void *stream\" \"uint32_t host32\"> "
"E<.Ft void> E<.Fn le64enc \"void *stream\" \"uint64_t host64\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/byteorder.9:126
msgid ""
"The E<.Fn bswap16>, E<.Fn bswap32>, and E<.Fn bswap64> functions return a "
"byte order swapped integer.  On big endian systems, the number is converted "
"to little endian byte order.  On little endian systems, the number is "
"converted to big endian byte order."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/byteorder.9:135
msgid ""
"The E<.Fn be16toh>, E<.Fn be32toh>, and E<.Fn be64toh> functions return a "
"big endian byte ordered integer converted to the system's native byte "
"order.  The return value will be the same as the argument on big endian "
"systems."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/byteorder.9:144
msgid ""
"The E<.Fn le16toh>, E<.Fn le32toh>, and E<.Fn le64toh> functions return a "
"little endian byte ordered integer converted to the system's native byte "
"order.  The return value will be the same as the argument on little endian "
"systems."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/byteorder.9:153
msgid ""
"The E<.Fn htobe16>, E<.Fn htobe32>, and E<.Fn htobe64> functions return an "
"integer in the system's native byte order converted to big endian byte "
"order.  The return value will be the same as the argument on big endian "
"systems."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/byteorder.9:162
msgid ""
"The E<.Fn htole16>, E<.Fn htole32>, and E<.Fn htole64> functions return an "
"integer in the system's native byte order converted to little endian byte "
"order.  The return value will be the same as the argument on little endian "
"systems."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/byteorder.9:179
msgid ""
"The E<.Fn be16enc>, E<.Fn be16dec>, E<.Fn be32enc>, E<.Fn be32dec>, E<.Fn "
"be64enc>, E<.Fn be64dec>, E<.Fn le16enc>, E<.Fn le16dec>, E<.Fn le32enc>, "
"E<.Fn le32dec>, E<.Fn le64enc>, and E<.Fn le64dec> functions encode and "
"decode integers to/from octet stream on any alignment in big/little endian "
"format."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/byteorder.9:182
msgid "E<.Xr bswap 3>, E<.Xr byteorder 3>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/byteorder.9:196
msgid ""
"The E<.Fn hto*> and E<.Fn *toh> functions first appeared in E<.Nx 1.5>.  "
"These were later ported to E<.Fx 5.0>.  These functions were originally "
"introduced to handle E<.Tn PCI> bus master devices that E<.Pq via Tn DMA> "
"transfer little endian data even on big endian systems."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/byteorder.9:203
msgid ""
"The encode/decode functions first appeared in E<.Fx 5.1>.  These were later "
"ported to E<.Nx 3.0> as a part of the E<.Xr uuidgen 2> support."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/bzero.9:35
#, no-wrap
msgid "BZERO 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bzero.9:39
msgid "E<.Nm bzero>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/bzero.9:39
#, no-wrap
msgid "write zeroes to a byte string"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bzero.9:44
msgid "E<.Ft void> E<.Fn bzero \"void *b\" \"size_t len\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bzero.9:59
msgid ""
"E<.Bf -symbolic> The E<.Fn bzero> interface is obsolete.  Do not add new "
"code using it.  It will soon be purged.  Use E<.Xr memset 9> instead.  (The "
"E<.Fn bzero> function is now a macro for E<.Xr memset 9>.)  E<.Ef>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bzero.9:72
msgid ""
"The E<.Fn bzero> function writes E<.Fa len> zero bytes to the string E<.Fa "
"b>.  If E<.Fa len> is zero, E<.Fn bzero> does nothing."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/bzero.9:73
msgid "E<.Xr memset 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/callback.9:27
#, no-wrap
msgid "October 28, 2009"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/callback.9:28
#, no-wrap
msgid "CALLBACK 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callback.9:32
msgid "E<.Nm callback>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/callback.9:32
#, no-wrap
msgid "generic callback interface"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/callback.9:34
#, no-wrap
msgid "sys/callback.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callback.9:47
msgid ""
"E<.Ft void> E<.Fn callback_head_init \"struct callback_head *ch\" \"int "
"ipl\"> E<.Ft void> E<.Fn callback_head_destroy \"struct callback_head *ch\"> "
"E<.Ft void> E<.Fn callback_register \"struct callback_head *ch\" \"struct "
"callback_entry *ce\" \"void *obj\" \"int (*fn)(struct callback_entry *, void "
"*, void *)\"> E<.Ft void> E<.Fn callback_unregister \"struct callback_head "
"*ch\" \"struct callback_entry *ce\"> E<.Ft int> E<.Fn "
"callback_run_roundrobin \"struct callback_head *ch\" \"void *arg\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callback.9:52
msgid ""
"The generic E<.Nm callback> interface allows lower-level layer code to "
"execute a registered function, or set of functions, from the higher-level "
"layer."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callback.9:54
msgid "Registered functions must return one of these constants:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/callback.9:55
#, no-wrap
msgid "Dv CALLBACK_CHAIN_CONTINUE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callback.9:58
msgid ""
"Indicates that the function call was successful.  The following functions in "
"the chain will be called."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/callback.9:58
#, no-wrap
msgid "Dv CALLBACK_CHAIN_ABORT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callback.9:61
msgid ""
"Indicates a failure case in the function call.  Any following functions in "
"the chain will not be executed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callback.9:67
msgid ""
"The callback structure E<.Vt callback_head> should be initialized and "
"destroyed using the functions described below.  This structure contains the "
"list of callback entries and other internal data."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callback.9:72
msgid ""
"The E<.Vt callback_entry> structure is an entry, normally associated with "
"the higher-level object.  It contains the internal data of the callback "
"interface."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/callback.9:73
#, no-wrap
msgid "Fn callback_head_init ch ipl"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callback.9:78
msgid ""
"Initialize the callback structure specified by E<.Fa ch>.  The highest IPL "
"at which this callback can be used is specified by E<.Fa ipl>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/callback.9:78
#, no-wrap
msgid "Fn callback_head_destroy ch"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callback.9:82
msgid ""
"Destroy the callback structure specified by E<.Fa ch>.  The caller must "
"unregister all functions before destroying the callback structure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/callback.9:82
#, no-wrap
msgid "Fn callback_register ch ce obj fn"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callback.9:91
msgid ""
"Register the callback function in the callback structure specified by E<.Fa "
"ch>.  E<.Fa ce> should point to the entry structure of the callback object.  "
"The callback object itself is specified by E<.Fa obj>.  The function pointer "
"is specified by E<.Fa fn>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/callback.9:91
#, no-wrap
msgid "Fn callback_unregister ch ce"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callback.9:97
msgid ""
"Unregister the callback function from the structure specified by E<.Fa ch>.  "
"The entry should be passed as E<.Fa ce>.  This function may block."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/callback.9:97
#, no-wrap
msgid "Fn callback_run_roundrobin ch arg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callback.9:105
msgid ""
"Executes all functions registered in the callback structure, specified by "
"E<.Fa ch>.  The functions are executed in round-robin fashion.  The value of "
"E<.Fa arg> will be passed to the callback functions."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callback.9:111
msgid ""
"The E<.Nm> interface is implemented within the file E<.Pa "
"sys/kern/subr_callback.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callback.9:112
msgid "E<.Xr intro 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/callout.9:30 org_netbsd/src/share/man/man9/memoryallocators.9:28 org_netbsd/src/share/man/man9/softintr.9:62
#, no-wrap
msgid "August 3, 2009"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/callout.9:31
#, no-wrap
msgid "CALLOUT 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callout.9:45
msgid ""
"E<.Nm callout_init>, E<.Nm callout_destroy>, E<.Nm callout_halt>, E<.Nm "
"callout_reset>, E<.Nm callout_schedule>, E<.Nm callout_setfunc>, E<.Nm "
"callout_stop>, E<.Nm callout_pending>, E<.Nm callout_expired>, E<.Nm "
"callout_invoking>, E<.Nm callout_ack>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/callout.9:45
#, no-wrap
msgid "execute a function after a specified length of time"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/callout.9:47
#, no-wrap
msgid "sys/callout.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callout.9:73
msgid ""
"E<.Ft void> E<.Fn \"callout_init\" \"callout_t *c\" \"u_int flags\"> E<.Ft "
"void> E<.Fn \"callout_destroy\" \"callout_t *c\"> E<.Ft void> E<.Fn "
"\"callout_reset\" \"callout_t *c\" \"int ticks\" \"void (*func)(void *)\" "
"\"void *arg\"> E<.Ft void> E<.Fn \"callout_schedule\" \"callout_t *c\" \"int "
"ticks\"> E<.Ft void> E<.Fn \"callout_setfunc\" \"callout_t *c\" \"void "
"(*func)(void *)\" \"void *arg\"> E<.Ft bool> E<.Fn \"callout_stop\" "
"\"callout_t *c\"> E<.Ft bool> E<.Fn \"callout_halt\" \"callout_t *c\" "
"\"kmutex_t *interlock\"> E<.Ft bool> E<.Fn \"callout_pending\" \"callout_t "
"*c\"> E<.Ft bool> E<.Fn \"callout_expired\" \"callout_t *c\"> E<.Ft bool> "
"E<.Fn \"callout_active\" \"callout_t *c\"> E<.Ft bool> E<.Fn "
"\"callout_invoking\" \"callout_t *c\"> E<.Ft bool> E<.Fn \"callout_ack\" "
"\"callout_t *c\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callout.9:81
msgid ""
"The E<.Nm callout> facility provides a mechanism to execute a function at a "
"given time.  The timer is based on the hardclock timer which ticks E<.Dv hz> "
"times per second.  The function is called at softclock interrupt level."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callout.9:95
msgid ""
"Clients of the E<.Nm callout> facility are responsible for providing "
"pre-allocated callout structures, or E<.Dq handles>.  The E<.Nm callout> "
"facility replaces the historic E<.Ux> functions E<.Fn timeout> and E<.Fn "
"untimeout>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callout.9:109
msgid ""
"The E<.Fn callout_init> function initializes the callout handle E<.Fa c> for "
"use.  No operations can be performed on the callout before it is "
"initialized.  If the E<.Fa flags> argument is E<.Dv CALLOUT_MPSAFE>, the "
"handler will be called without getting the global kernel lock.  In this case "
"it should only use functions that are multiprocessor safe."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callout.9:117
msgid ""
"E<.Fn callout_destroy> destroys the callout, preventing further use.  It is "
"provided as a diagnostic facility intended to catch bugs.  To ensure future "
"compatibility, E<.Fn callout_destroy> should always be called when the "
"callout is no longer required (for instance, when a device is being "
"detached)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callout.9:141
msgid ""
"The E<.Fn callout_reset> function resets and starts the timer associated "
"with the callout handle E<.Fa c>.  When the timer expires after E<.Fa ticks "
"Ns No /hz> seconds, the function specified by E<.Fa func> will be called "
"with the argument E<.Fa arg>.  If the timer associated with the callout "
"handle is already running, the callout will simply be rescheduled to execute "
"at the newly specified time.  Once the timer is started, the callout handle "
"is marked as E<.Em PENDING>.  Once the timer expires, the handle is marked "
"as E<.Em EXPIRED> and E<.Em INVOKING>, and the E<.Em PENDING> status is "
"cleared."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callout.9:159
msgid ""
"The E<.Fn callout_setfunc> function sets the function and argument of the "
"callout handle E<.Fa c> to E<.Fa func> and E<.Fa arg> respectively.  The "
"callout handle must already be initialized.  If a callout will always be "
"used with the same function and argument, then E<.Fn callout_setfunc> used "
"in conjunction with E<.Fn callout_schedule> is slightly more efficient than "
"using E<.Fn callout_reset>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callout.9:184
msgid ""
"The E<.Fn callout_stop> function requests that the timer associated with the "
"callout handle E<.Fa c> be stopped.  The E<.Em PENDING> and E<.Em EXPIRED> "
"status for the callout handle is cleared.  It is safe to call E<.Fn "
"callout_stop> on a callout handle that is not pending, so long as it is "
"initialized.  E<.Fn callout_stop> will return a non-zero value if the "
"callout was E<.Em EXPIRED>.  Note that E<.Fn callout_stop> can return while "
"the callout is running on a different CPU or at a different interrupt "
"priority level on the current CPU.  It can only be said to prevent the "
"callout from firing in the future, unless explicitly re-scheduled.  To stop "
"a callout and wait for completion, use E<.Fn callout_halt>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callout.9:213
msgid ""
"E<.Fn callout_halt> acts much like E<.Fn callout_stop>, but waits for the "
"callout to complete if it is currently in-flight.  E<.Fn callout_halt> may "
"not be called from a hard interrupt handler as it will sleep if the callout "
"is currently executing.  If the callout can take locks (such as mutexes or "
"RW locks), the caller of E<.Fn callout_halt> must not hold any of those "
"locks, otherwise the two could deadlock.  To facilitate this, E<.Fn "
"callout_halt> can optionally release a single mutex specified by the E<.Fa "
"interlock> parameter.  If E<.Fa interlock> is not E<.Dv NULL> and the "
"calling thread must wait for the callout to complete, E<.Fa interlock> will "
"be released before waiting and re-acquired before returning.  If no wait is "
"required, E<.Fa interlock> will not be released.  However, to avoid race "
"conditions the caller should always assume that E<.Fa interlock> has been "
"released and reacquired, and act accordingly."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callout.9:230
msgid ""
"The E<.Fn callout_pending> function tests the E<.Em PENDING> status of the "
"callout handle E<.Fa c>.  A E<.Em PENDING> callout is one that has been "
"started and whose function has not yet been called.  Note that it is "
"possible for a callout's timer to have expired without its function being "
"called if interrupt level has not dropped low enough to let softclock "
"interrupts through.  Note that it is only safe to test E<.Em PENDING> status "
"when at softclock interrupt level or higher."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callout.9:235
msgid ""
"The E<.Fn callout_expired> function tests to see if the callout's timer has "
"expired and its function called."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callout.9:250
msgid ""
"The E<.Fn callout_active> function returns true if a timer has been started "
"but not explicitly stopped, even if it has already fired.  E<.Fn "
"callout_active foo> is logically the same as E<.Fn callout_pending foo> || "
"E<.Fn callout_expired foo>; it is implemented as a separate function for "
"compatibility with E<.Fx> and for the special case of E<.Fn "
"TCP_TIMER_ISARMED>.  Its use is not recommended."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callout.9:275
msgid ""
"The E<.Fn callout_invoking> function tests the E<.Em INVOKING> status of the "
"callout handle E<.Fa c>.  This flag is set just before a callout's function "
"is being called.  Since the priority level is lowered prior to invocation of "
"the callout function, other pending higher-priority code may run before the "
"callout function is allowed to run.  This may create a race condition if "
"this higher-priority code deallocates storage containing one or more callout "
"structures whose callout functions are about to be run.  In such cases, one "
"technique to prevent references to deallocated storage would be to test "
"whether any callout functions are in the E<.Em INVOKING> state using E<.Fn "
"callout_invoking>, and if so, to mark the data structure and defer storage "
"deallocation until the callout function is allowed to run.  For this "
"handshake protocol to work, the callout function will have to use the E<.Fn "
"callout_ack> function to clear this flag."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callout.9:285
msgid ""
"The E<.Fn callout_ack> function clears the E<.Em INVOKING> state in the "
"callout handle E<.Fa c>.  This is used in situations where it is necessary "
"to protect against the race condition described under E<.Fn "
"callout_invoking>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/callout.9:285
#, no-wrap
msgid "CONCURRENCY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callout.9:293
msgid ""
"The callout facility performs locking internally in order to guarantee the "
"atomicity of individual operations performed on callouts.  It does not "
"provide life cycle management of user-provided callout data structures, nor "
"does it ensure that groups of operations (multiple function calls) are "
"performed atomically.  These aspects of callout management are the "
"responsibility of the user of the callout facility."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callout.9:299
msgid ""
"Scheduled callouts may be active concurrently in a context different to the "
"user of the callout facility: on another CPU, or at a different interrupt "
"priority level or thread on the current CPU.  The callout facility provides "
"only one guarantee in this regard: any given callout will never have "
"multiple concurrent invocations."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callout.9:304
msgid "E<.Xr condvar 9>, E<.Xr hz 9>, E<.Xr softint 9>, E<.Xr workqueue 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/callout.9:315
msgid ""
"The E<.Nm callout> facility was implemented by Artur Grabowski and Thomas "
"Nordin, based on the work of G. Varghese and A. Lauck, described in the "
"paper Hashed and Hierarchical Timing Wheels: Data Structures for the "
"Efficient Implementation of a Timer Facility in the Proceedings of the 11th "
"ACM Annual Symposium on Operating System Principles, Austin, Texas, November "
"1987.  It was adapted to the E<.Nx> kernel by Jason R. Thorpe."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/cardbus.9:30 org_netbsd/src/share/man/man9/pcmcia.9:30
#, no-wrap
msgid "April 15, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/cardbus.9:31
#, no-wrap
msgid "CARDBUS 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:56
msgid ""
"E<.Nm Cardbus>, E<.Nm cardbus_attach_card>, E<.Nm cardbus_detach_card>, "
"E<.Nm cardbus_function_enable>, E<.Nm cardbus_function_disable>, E<.Nm "
"cardbus_mapreg_map>, E<.Nm cardbus_mapreg_unmap>, E<.Nm "
"cardbus_get_capability>, E<.Nm cardbus_make_tag>, E<.Nm cardbus_conf_read>, "
"E<.Nm cardbus_conf_write>, E<.Nm cardbus_intr_establish>, E<.Nm "
"cardbus_intr_disestablish>, E<.Nm CARDBUS_VENDOR>, E<.Nm CARDBUS_PRODUCT>, "
"E<.Nm Cardbus_function_enable>, E<.Nm Cardbus_function_disable>, E<.Nm "
"Cardbus_mapreg_map>, E<.Nm Cardbus_mapreg_unmap>, E<.Nm Cardbus_make_tag>, "
"E<.Nm Cardbus_conf_read>, E<.Nm Cardbus_conf_write>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/cardbus.9:56
#, no-wrap
msgid "support for CardBus PC-Card devices"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/cardbus.9:59
#, no-wrap
msgid "dev/cardbus/cardbusvar.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/cardbus.9:60
#, no-wrap
msgid "dev/cardbus/cardbusreg.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/cardbus.9:61
#, no-wrap
msgid "dev/cardbus/cardbusdevs.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:124
msgid ""
"E<.Ft int> E<.Fn cardbus_attach_card \"struct cardbus_softc *csc\"> E<.Ft "
"void> E<.Fn cardbus_detach_card \"struct cardbus_softc *csc\"> E<.Ft int> "
"E<.Fn cardbus_function_enable \"struct cardbus_softc *csc\" \"int "
"function\"> E<.Ft int> E<.Fn cardbus_function_disable \"struct cardbus_softc "
"*csc\" \"int function\"> E<.Ft int> E<.Fo cardbus_mapreg_map> E<.Fa \"struct "
"cardbus_softc *csc\" \"int cf\" \"int reg\"> E<.Fa \"pcireg_t type\" \"int "
"busflags\" \"bus_space_tag_t *tagp\"> E<.Fa \"bus_space_handle_t *handlep\" "
"\"bus_addr_t *basep\" \"bus_size_t *sizep\"> E<.Fc> E<.Ft int> E<.Fn "
"cardbus_mapreg_unmap \"struct cardbus_softc *csc\" \"int cf\" \"int reg\" "
"\"bus_space_tag_t tag\" \"bus_space_handle_t handle\" \"bus_size_t size\"> "
"E<.Ft int> E<.Fn cardbus_get_capability \"cardbus_chipset_tag_t cc\" "
"\"cardbus_function_tag_t cf\" \"pcitag_t tag\" \"int capid\" \"int "
"*offsetp\" \"pcireg_t *valuep\"> E<.Ft pcitag_t> E<.Fn cardbus_make_tag "
"\"cardbus_chipset_tag_t cc\" \"int cf\" \"int bus\" \"int device\" \"int "
"function\"> E<.Ft pcireg_t> E<.Fn cardbus_conf_read \"cardbus_chipset_tag_t "
"cc\" \"int cf\" \"pcitag_t tag\" \"int offs\"> E<.Ft void> E<.Fn "
"cardbus_conf_write \"cardbus_chipset_tag_t cc\" \"int cf\" \"pcitag_t tag\" "
"\"int offs\" \"busreg_t val\"> E<.Ft void *> E<.Fn cardbus_intr_establish "
"\"cardbus_chipset_tag_t cc\" \"cardbus_function_tag_t cf\" "
"\"cardbus_intr_handle_t irq\" \"int level\" \"int (*handler)(void *)\" "
"\"void *arg\"> E<.Ft void> E<.Fn cardbus_intr_disestablish "
"\"cardbus_chipset_tag_t cc\" \"cardbus_function_tag_t cf\" \"void *ih\"> "
"E<.Ft int> E<.Fn CARDBUS_VENDOR \"pcireg_t id\"> E<.Ft int> E<.Fn "
"CARDBUS_PRODUCT \"pcireg_t id\"> E<.Ft int> E<.Fn Cardbus_function_enable "
"\"cardbus_devfunc_t ct\"> E<.Ft int> E<.Fn Cardbus_function_disable "
"\"cardbus_devfunc_t ct\"> E<.Ft int> E<.Fn Cardbus_mapreg_map "
"\"cardbus_devfunc_t ct\" \"int reg\" \"pcireg_t type\" \"int busflags\" "
"\"bus_space_tag_t *tagp\" \"bus_space_handle_t *handlep\" \"bus_addr_t "
"*basep\" \"bus_size_t *sizep\"> E<.Ft int> E<.Fn Cardbus_mapreg_unmap "
"\"cardbus_devfunc_t ct\" \"int reg\" \"bus_space_tag_t tag\" "
"\"bus_space_handle_t handle\" \"bus_size_t size\"> E<.Ft pcitag_t> E<.Fn "
"Cardbus_make_tag \"cardbus_devfunc_t ct \"> E<.Ft pcireg_t> E<.Fn "
"Cardbus_conf_read \"cardbus_devfunc_t ct\" \"pcitag_t tag\" \"int offs\"> "
"E<.Ft void> E<.Fn Cardbus_conf_write \"cardbus_devfunc_t ct\" \"pcitag_t "
"tag\" \"int offs\" \"busreg_t val\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:128
msgid ""
"The machine-independent E<.Nm> subsystem provides support for CardBus "
"devices."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:135
msgid ""
"The CardBus interface is an improvement to the PC-Card interface supported "
"by E<.Xr pcmcia 9>.  It introduces several new capabilities such as 32-bit "
"addressing, 33MHz operation, busmaster operation and 3.3 volt low-voltage "
"power.  It remains compatible with all features of the PC-Card standard."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:149
msgid ""
"The CardBus interface signaling protocol is derived from the PCI signaling "
"protocol.  There are some differences between PCI and CardBus, however "
"operations are identical for most functions implemented.  Since a 32-bit "
"CardBus interface is also defined for 16-bit PC-Cards, the same Card "
"Services client to be used to manage both CardBus and PCMCIA PC-Cards.  By "
"interrogating the card upon detection of an insertion event, E<.Nx> "
"determines whether the card requires E<.Nm> support or not, and then applies "
"the appropriate power and signaling protocol requirements."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:152
msgid "Drivers attached to the CardBus will make use of the following data types:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cardbus.9:153
#, no-wrap
msgid "struct cardbus_attach_args"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:156 org_netbsd/src/share/man/man9/pci.9:213
msgid ""
"Devices have their identity recorded in this structure.  It contains the "
"following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:167
#, no-wrap
msgid ""
"\tcardbus_devfunc_t ca_ct;\n"
"\tbus_space_tag_t ca_iot;       /* CardBus I/O space tag */\n"
"\tbus_space_tag_t ca_memt;      /* CardBus MEM space tag */\n"
"\tbus_dma_tag_t ca_dmat;        /* DMA tag */\n"
"\tu_int ca_device;\n"
"\tpcitag_t ca_tag;\n"
"\tpcireg_t ca_id;\n"
"\tpcireg_t ca_class;\n"
"\tcardbus_intr_line_t ca_intrline; /* interrupt info */\n"
"\tstruct cardbus_cis_info ca_cis;\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cardbus.9:171
#, no-wrap
msgid "Fn cardbus_attach_card csc"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:176
msgid ""
"Attaches the card on the slot by turning on the power, read and analyse the "
"tuple and sets configuration index.  This function returns the number of "
"recognised device functions.  If no device functions are recognised it "
"returns zero."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cardbus.9:176
#, no-wrap
msgid "Fn cardbus_detach_card csc"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:180
msgid ""
"Detaches the card on the slot by release resources and turning off the "
"power.  This function must not be called under interrupt context."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cardbus.9:180
#, no-wrap
msgid "Fn cardbus_function_enable csc function"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:185
msgid ""
"Enables device function E<.Fa function> on the card.  Power will be applied "
"if it hasn't already."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cardbus.9:185
#, no-wrap
msgid "Fn cardbus_function_disable csc function"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:190
msgid ""
"Disables device function E<.Fa function> on the card.  When no device "
"functions are enabled, the turn is turned off."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cardbus.9:190
#, no-wrap
msgid "Fn cardbus_mapreg_map csc cf reg type busflags tagp handlep basep sizep"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:201
msgid ""
"Maps bus-space on the value of Base Address Register (BAR) indexed by E<.Fa "
"reg> for device function E<.Fa cf>.  The bus-space configuration is returned "
"in E<.Fa tagp>, E<.Fa handlep>, E<.Fa basep>, and E<.Fa sizep>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cardbus.9:201
#, no-wrap
msgid "Fn cardbus_mapreg_unmap csc cf reg tag handle \"bus_size_t size\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:211
msgid ""
"Releases bus-space region for device function E<.Fa cf> specified by E<.Fa "
"tag>, E<.Fa handle> and E<.Fa size>.  E<.Fa reg> is the offset of the BAR "
"register."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cardbus.9:211
#, no-wrap
msgid "Fn cardbus_get_capability cc cf tag capid offsetp valuep"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:220
msgid ""
"Find the PCI capability for the device function E<.Fa cf> specified by E<.Fa "
"capid>.  Returns the capability in E<.Fa offsetp> and E<.Fa valuep>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cardbus.9:220
#, no-wrap
msgid "Fn cardbus_make_tag cc cf bus device function"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:224
msgid ""
"Make a tag to access config space of a CardBus card.  It works the same as "
"E<.Fn pci_make_tag>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cardbus.9:224
#, no-wrap
msgid "Fn cardbus_conf_read cc cf tag offs"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:228
msgid ""
"Read the config space of a CardBus card.  It works the same as E<.Fn "
"pci_conf_read>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cardbus.9:228
#, no-wrap
msgid "Fn cardbus_conf_write cc cf tag offs val"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:232
msgid ""
"Write to the config space of a CardBus card.  It works same as E<.Fn "
"pci_conf_write>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cardbus.9:232
#, no-wrap
msgid "Fn cardbus_intr_establish cc cf irq level handler arg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:245
msgid ""
"Establish an interrupt handler for device function E<.Fa cf>.  The priority "
"of the interrupt is specified by E<.Fa level>.  When the interrupt occurs "
"the function E<.Fa handler> is called with argument E<.Fa arg>.  The return "
"value is a handle for the interrupt handler.  E<.Fn cardbus_intr_establish> "
"returns an opaque handle to an event descriptor if it succeeds, and returns "
"NULL on failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cardbus.9:245
#, no-wrap
msgid "Fn cardbus_intr_disestablish cc cf ih"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:252
msgid ""
"Dis-establish the interrupt handler for device function E<.Fa cf> with "
"handle E<.Fa ih>.  The handle was returned from E<.Fn "
"cardbus_intr_establish>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cardbus.9:252
#, no-wrap
msgid "Fn CARDBUS_VENDOR id"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:255
msgid "Return the CardBus vendor ID for device E<.Fa id>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cardbus.9:255
#, no-wrap
msgid "Fn CARDBUS_PRODUCT id"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:258
msgid "Return the CardBus product ID for device E<.Fa id>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:266
msgid ""
"The E<.Fn Cardbus_*> functions are convenience functions taking a E<.Fa "
"cardbus_devfunc_t> argument and perform the same operation as their namesake "
"described above."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/cardbus.9:266 org_netbsd/src/share/man/man9/ioasic.9:162 org_netbsd/src/share/man/man9/isa.9:389 org_netbsd/src/share/man/man9/isapnp.9:168 org_netbsd/src/share/man/man9/mca.9:143 org_netbsd/src/share/man/man9/pci.9:702 org_netbsd/src/share/man/man9/pcmcia.9:362 org_netbsd/src/share/man/man9/tc.9:158 org_netbsd/src/share/man/man9/vme.9:306 org_netbsd/src/share/man/man9/wsdisplay.9:345 org_netbsd/src/share/man/man9/wskbd.9:262 org_netbsd/src/share/man/man9/wsmouse.9:180
#, no-wrap
msgid "AUTOCONFIGURATION"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:278
msgid ""
"During autoconfiguration, a E<.Nm> driver will receive a pointer to E<.Fa "
"struct isapnp_attach_args> describing the device attaches to the CardBus.  "
"Drivers match the device using the E<.Fa ca_id> member using E<.Fn "
"CARDBUS_VENDOR> and E<.Fn CARDBUS_PRODUCT>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:294
msgid ""
"During the driver attach step, drivers should initially map the device I/O "
"and memory resources using E<.Fn cardbus_mapreg_map> or E<.Fn "
"Cardbus_mapreg_map>.  Upon successful allocation of resources, power can be "
"applied to the device with E<.Fn cardbus_function_enable> or E<.Fn "
"Cardbus_function_enable>.  so that device-specific interrogation can be "
"performed.  Finally, power should be removed from the device using E<.Fn "
"cardbus_function_disable> or E<.Fn Cardbus_function_disable>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:301
msgid ""
"Since CardBus devices support dynamic configuration, drivers should make use "
"of E<.Fn pmf 9> framework.  Power can be applied and the interrupt handler "
"should be established through this interface."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/cardbus.9:301 org_netbsd/src/share/man/man9/ioasic.9:181 org_netbsd/src/share/man/man9/isa.9:418 org_netbsd/src/share/man/man9/isapnp.9:208 org_netbsd/src/share/man/man9/mca.9:160 org_netbsd/src/share/man/man9/pci.9:742 org_netbsd/src/share/man/man9/pcmcia.9:404 org_netbsd/src/share/man/man9/tc.9:167 org_netbsd/src/share/man/man9/vme.9:329
#, no-wrap
msgid "DMA SUPPORT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:306
msgid ""
"No additional support is provided for CardBus DMA beyond the facilities "
"provided by the E<.Xr bus_dma 9> interface."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:319
msgid ""
"The CardBus subsystem itself is implemented within the files E<.Pa "
"sys/dev/cardbus/cardbus.c>, E<.Pa sys/dev/cardbus/cardbus_map.c> and E<.Pa "
"sys/dev/cardbus/cardslot.c>.  The database of known devices exists within "
"the file E<.Pa sys/dev/cardbus/cardbus_data.h> and is generated "
"automatically from the file E<.Pa sys/dev/cardbus/cardbusdevs>.  New vendor "
"and product identifiers should be added to this file.  The database can be "
"regenerated using the Makefile E<.Pa sys/dev/cardbus/Makefile.cardbusdevs>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:328
msgid ""
"E<.Xr cardbus 4>, E<.Xr pcmcia 4>, E<.Xr autoconf 9>, E<.Xr bus_dma 9>, "
"E<.Xr bus_space 9>, E<.Xr driver 9>, E<.Xr pci 9>, E<.Xr pcmcia 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cardbus.9:332
msgid "The machine-independent E<.Nm> subsystem appeared in E<.Nx 1.5>."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/cnmagic.9:36
#, no-wrap
msgid "CNMAGIC 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cnmagic.9:46
msgid ""
"E<.Nm cn_init_magic>, E<.Nm cn_trap>, E<.Nm cn_isconsole>, E<.Nm "
"cn_check_magic>, E<.Nm cn_destroy_magic>, E<.Nm cn_set_magic>, E<.Nm "
"cn_get_magic>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/cnmagic.9:46
#, no-wrap
msgid "console magic key sequence management"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cnmagic.9:63
msgid ""
"E<.Ft void> E<.Fn cn_init_magic \"cnm_state_t *cnms\"> E<.Ft void> E<.Fn "
"cn_trap> E<.Ft int> E<.Fn cn_isconsole \"dev_t dev\"> E<.Ft void> E<.Fn "
"cn_check_magic \"dev_t dev\" \"int k\" \"cnm_state_t *cnms\"> E<.Ft void> "
"E<.Fn cn_destroy_magic \"cnm_state_t *cnms\"> E<.Ft int> E<.Fn cn_set_magic "
"\"char *magic\"> E<.Ft int> E<.Fn cn_get_magic \"char *magic\" \"int len\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cnmagic.9:70
msgid ""
"The E<.Nx> console magic key sequence management framework is designed to "
"provide flexible methods to set, change, and detect magic key sequences on "
"console devices and break into the debugger or ROM monitor with a minimum of "
"interrupt latency."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cnmagic.9:92
msgid ""
"Drivers that generate console input should make use of these routines.  A "
"different E<.Va cnm_state_t> should be used for each separate input stream.  "
"Multiple devices that share the same input stream, such as USB keyboards can "
"share the same E<.Va cnm_state_t>.  Once a E<.Va cnm_state_t> is allocated, "
"it should be initialized with E<.Fn cn_init_magic> so it can be used by "
"E<.Fn cn_check_magic>.  If a driver thinks it might be the console input "
"device it can set the magic sequence with E<.Fn cn_set_magic> to any "
"arbitrary string.  Whenever the driver receives input, it should call E<.Fn "
"cn_check_magic> to process the data and determine whether the magic sequence "
"has been hit."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cnmagic.9:99
msgid ""
"The magic key sequence can be accessed through the E<.Va hw.cnmagic> E<.Ic "
"sysctl> variable.  This is the raw data and may be keycodes rather than "
"processed characters, depending on the console device."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cnmagic.9:101
msgid "The following functions describe the console magic interface."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cnmagic.9:102
#, no-wrap
msgid "Fn cn_init_magic cnm"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cnmagic.9:106
msgid ""
"Initialize the console magic state pointed to by E<.Fa cnm> to a usable "
"state."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cnmagic.9:106
#, no-wrap
msgid "Fn cn_trap"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cnmagic.9:111
msgid ""
"Trap into the kernel debugger or ROM monitor.  By default this routine is "
"defined to be E<.Fn console_debugger> but can be overridden in MI header "
"files."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cnmagic.9:111
#, no-wrap
msgid "Fn cn_isconsole dev"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cnmagic.9:120
msgid ""
"Determine whether a given E<.Fa dev> is the system console.  This macro "
"tests to see if E<.Fa dev> is the same as E<.Va cn_tab-\\*[Gt]cn_dev> but "
"can be overridden in MI header files."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cnmagic.9:120
#, no-wrap
msgid "Fn cn_check_magic dev k cnms"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cnmagic.9:140
msgid ""
"All input should be passed through E<.Fn cn_check_magic> so the state "
"machine remains in a consistent state.  E<.Fn cn_check_magic> calls E<.Fn "
"cn_isconsole> with E<.Fa dev> to determine if this is the console.  If that "
"returns true then it runs the input value E<.Fa k> through the state "
"machine.  If the state machine completes a match of the current console "
"magic sequence E<.Fn cn_trap> is called.  Some input may need to be "
"translated to state machine values such as the serial line E<.Li BREAK> "
"sequence."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cnmagic.9:140
#, no-wrap
msgid "Fn cn_destroy_magic cnms"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cnmagic.9:144
msgid "This should be called once what E<.Fa cnms> points to is no longer needed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cnmagic.9:144
#, no-wrap
msgid "Fn cn_set_magic magic"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cnmagic.9:153
msgid ""
"E<.Fn cn_set_magic> encodes a E<.Li nul> terminated string arbitrary string "
"into values that can be used by the state machine and installs it as the "
"global magic sequence.  The escape sequence is character value E<.Li 0x27> "
"and can be used to encode special values:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cnmagic.9:155
#, no-wrap
msgid "0x27"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cnmagic.9:158
msgid "The literal value E<.Li 0x27>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cnmagic.9:158
#, no-wrap
msgid "0x01"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cnmagic.9:162
msgid "Serial E<.Li BREAK> sequence."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cnmagic.9:162
#, no-wrap
msgid "0x02"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cnmagic.9:165
msgid "E<.Li Nul> character."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cnmagic.9:170
msgid "Returns E<.Li 0> on success or a non-zero error value."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cnmagic.9:170
#, no-wrap
msgid "Fn cn_get_magic magic len"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cnmagic.9:181
msgid ""
"Extract the current magic sequence from the state machine and return up to "
"E<.Fa len> bytes of it in the buffer pointed to by E<.Fa magic>.  It uses "
"the same encoding accepted by E<.Fn cn_set_magic>.  Returns E<.Li 0> on "
"success or a non-zero error value."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cnmagic.9:185
msgid "E<.Xr sysctl 8>, E<.Xr cons 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cnmagic.9:191
msgid ""
"The E<.Nx> console magic key sequence management framework first appeared in "
"E<.Nx 1.6>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cnmagic.9:197
msgid ""
"The E<.Nx> console magic key sequence management framework was designed and "
"implemented by E<.An Eduardo Horvath> E<.Aq eeh@NetBSD.org>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/condvar.9:30
#, no-wrap
msgid "June 4, 2008"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/condvar.9:31
#, no-wrap
msgid "CONDVAR 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:45
msgid ""
"E<.Nm cv>, E<.Nm condvar>, E<.Nm cv_init>, E<.Nm cv_destroy>, E<.Nm "
"cv_wait>, E<.Nm cv_wait_sig>, E<.Nm cv_timedwait>, E<.Nm cv_timedwait_sig>, "
"E<.Nm cv_signal>, E<.Nm cv_broadcast>, E<.Nm cv_has_waiters>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/condvar.9:45
#, no-wrap
msgid "condition variables"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/condvar.9:47
#, no-wrap
msgid "sys/condvar.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:66
msgid ""
"E<.Ft void> E<.Fn cv_init \"kcondvar_t *cv\" \"const char *wmesg\"> E<.Ft "
"void> E<.Fn cv_destroy \"kcondvar_t *cv\"> E<.Ft void> E<.Fn cv_wait "
"\"kcondvar_t *cv\" \"kmutex_t *mtx\"> E<.Ft int> E<.Fn cv_wait_sig "
"\"kcondvar_t *cv\" \"kmutex_t *mtx\"> E<.Ft int> E<.Fn cv_timedwait "
"\"kcondvar_t *cv\" \"kmutex_t *mtx\" \"int ticks\"> E<.Ft int> E<.Fn "
"cv_timedwait_sig \"kcondvar_t *cv\" \"kmutex_t *mtx\" \"int ticks\"> E<.Ft "
"void> E<.Fn cv_signal \"kcondvar_t *cv\"> E<.Ft void> E<.Fn cv_broadcast "
"\"kcondvar_t *cv\"> E<.Ft bool> E<.Fn cv_has_waiters \"kcondvar_t *cv\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:69 org_netbsd/src/share/man/man9/mutex.9:65 org_netbsd/src/share/man/man9/rwlock.9:71
msgid "E<.Cd \"options DIAGNOSTIC\"> E<.Cd \"options LOCKDEBUG\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:73
msgid ""
"Condition variables (CVs) are used in the kernel to synchronize access to "
"resources that are limited (for example, memory) and to wait for pending I/O "
"operations to complete."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:79
msgid ""
"The E<.Vt kcondvar_t> type provides storage for the CV object.  This should "
"be treated as an opaque object and not examined directly by consumers."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/condvar.9:79 org_netbsd/src/share/man/man9/kmem.9:183 org_netbsd/src/share/man/man9/mutex.9:79 org_netbsd/src/share/man/man9/sockopt.9:80
#, no-wrap
msgid "OPTIONS"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/condvar.9:81 org_netbsd/src/share/man/man9/mutex.9:81 org_netbsd/src/share/man/man9/sockopt.9:82
#, no-wrap
msgid "Cd \"options DIAGNOSTIC\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:86
msgid ""
"Kernels compiled with the E<.Dv DIAGNOSTIC> option perform basic sanity "
"checks on CV operations."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/condvar.9:86 org_netbsd/src/share/man/man9/mutex.9:86 org_netbsd/src/share/man/man9/rwlock.9:108
#, no-wrap
msgid "Cd \"options LOCKDEBUG\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:92
msgid ""
"Kernels compiled with the E<.Dv LOCKDEBUG> option perform potentially CPU "
"intensive sanity checks on CV operations."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/condvar.9:95
#, no-wrap
msgid "Fn cv_init cv wmesg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:99
msgid ""
"Initialize a CV for use.  No other operations can be performed on the CV "
"until it has been initialized."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:108
msgid ""
"The E<.Fa wmesg> argument specifies a string of no more than 8 characters "
"that describes the resource or condition associated with the CV.  The kernel "
"does not use this argument directly but makes it available for utilities "
"such as E<.Xr ps 1> to display."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/condvar.9:108
#, no-wrap
msgid "Fn cv_destroy cv"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:112
msgid ""
"Release resources used by a CV.  The CV must not be in use when it is "
"destroyed, and must not be used afterwards."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/condvar.9:112
#, no-wrap
msgid "Fn cv_wait cv mtx"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:120
msgid ""
"Cause the current LWP to wait non-interruptably for access to a resource, or "
"for an I/O operation to complete.  The LWP will resume execution when awoken "
"by another thread using E<.Fn cv_signal> or E<.Fn cv_broadcast>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:129
msgid ""
"E<.Fa mtx> specifies a kernel mutex to be used as an interlock, and must be "
"held by the calling LWP on entry to E<.Fn cv_wait>.  It will be released "
"once the LWP has prepared to sleep, and will be reacquired before E<.Fn "
"cv_wait> returns."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:136
msgid ""
"A small window exists between testing for availability of a resource and "
"waiting for the resource with E<.Fn cv_wait>, in which the resource may "
"become available again.  The interlock is used to guarantee that the "
"resource will not be signalled as available until the calling LWP has begun "
"to wait for it."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:139
msgid ""
"Non-interruptable waits have the potential to deadlock the system, and so "
"must be kept short (typically, under one second)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/condvar.9:139
#, no-wrap
msgid "Fn cv_wait_sig cv mtx"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:147
msgid ""
"As per E<.Fn cv_wait>, but causes the current LWP to wait interruptably.  If "
"the LWP receives a signal, or is interrupted by another condition such as "
"its containing process exiting, the wait is ended early and an error code "
"returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:159
msgid ""
"If E<.Fn cv_wait_sig> returns as a result of a signal, the return value is "
"E<.Er ERESTART> if the signal has the E<.Dv SA_RESTART> property.  If awoken "
"normally, the value is zero, and E<.Er EINTR> under all other conditions."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/condvar.9:159
#, no-wrap
msgid "Fn cv_timedwait cv mtx ticks"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:166
msgid ""
"As per E<.Fn cv_wait>, but will return early if a timeout specified by the "
"E<.Fa ticks> argument expires."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:184
msgid ""
"E<.Fa ticks> is an architecture and system dependent value related to the "
"number of clock interrupts per second.  See E<.Xr hz 9> for details.  The "
"E<.Xr mstohz 9> macro can be used to convert a timeout expressed in "
"milliseconds to one suitable for E<.Fn cv_timedwait>.  If the E<.Fa ticks> "
"argument is zero, E<.Fn cv_timedwait> behaves exactly like E<.Fn cv_wait>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:188
msgid ""
"If the timeout expires before the LWP is awoken, the return value is E<.Er "
"EWOULDBLOCK>.  If awoken normally, the return value is zero."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/condvar.9:188
#, no-wrap
msgid "Fn cv_timedwait_sig cv mtx ticks"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:195
msgid ""
"As per E<.Fn cv_wait_sig>, but also accepts a timeout value and will return "
"E<.Er EWOULDBLOCK> if the timeout expires."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/condvar.9:195
#, no-wrap
msgid "Fn cv_signal cv"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:203
msgid ""
"Awaken one LWP (potentially among many) that is waiting on the specified "
"condition variable.  The mutex passed to the wait function E<.Po Fa mtx Pc> "
"must also be held when calling E<.Fn cv_signal>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:208
msgid ""
"(Note that E<.Fn cv_signal> is erroneously named in that it does not send a "
"signal in the traditional sense to LWPs waiting on a CV.)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/condvar.9:208
#, no-wrap
msgid "Fn cv_broadcast cv"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:215
msgid ""
"Awaken all LWPs waiting on the specified condition variable.  The mutex "
"passed to the wait function E<.Po Fa mtx Pc> must also be held when calling "
"E<.Fn cv_broadcast>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/condvar.9:215
#, no-wrap
msgid "Fn cv_has_waiters cv"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:220
msgid ""
"Return E<.Dv true> if one or more LWPs are waiting on the specified "
"condition variable."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:226
msgid ""
"E<.Fn cv_has_waiters> cannot test reliably for interruptable waits.  It "
"should only be used to test for non-interruptable waits made using E<.Fn "
"cv_wait>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:231
msgid ""
"E<.Fn cv_has_waiters> should only be used when making diagnostic assertions, "
"and must be called while holding the interlocking mutex passed to E<.Fn "
"cv_wait>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:235
#, no-wrap
msgid "Consuming a resource:\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:241
#, no-wrap
msgid ""
"\t/*\n"
"\t * Lock the resource.  Its mutex will also serve as the\n"
"\t * interlock.\n"
"\t */\n"
"\tmutex_enter(\\*[Am]res-\\*[Gt]mutex);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:247
#, no-wrap
msgid ""
"\t/*\n"
"\t * Wait for the resource to become available.\n"
"\t */\n"
"\twhile (res-\\*[Gt]state == BUSY)\n"
"\t\tcv_wait(\\*[Am]res-\\*[Gt]condvar, \\*[Am]res-\\*[Gt]mutex);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:255
#, no-wrap
msgid ""
"\t/*\n"
"\t * It's now available to us.  Take ownership of the\n"
"\t * resource, and consume it.\n"
"\t */\n"
"\tres-\\*[Gt]state = BUSY;\n"
"\tmutex_exit(\\*[Am]res-\\*[Gt]mutex);\n"
"\tconsume(res);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:257
#, no-wrap
msgid "Releasing a resource for the next consumer to use:\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:262
#, no-wrap
msgid ""
"\tmutex_enter(\\*[Am]res-\\*[Gt]mutex);\n"
"\tres-\\*[Gt]state = IDLE;\n"
"\tcv_signal(\\*[Am]res-\\*[Gt]condvar);\n"
"\tmutex_exit(\\*[Am]res-\\*[Gt]mutex);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:266
msgid "The core of the CV implementation is in E<.Pa sys/kern/kern_condvar.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:270
msgid "The header file E<.Pa sys/sys/condvar.h> describes the public interface."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:277
msgid ""
"E<.Xr sigaction 2>, E<.Xr errno 9>, E<.Xr mb 9>, E<.Xr mstohz 9>, E<.Xr "
"mutex 9>, E<.Xr rwlock 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:286 org_netbsd/src/share/man/man9/mutex.9:265
msgid ""
"E<.Rs> E<.%A Jim Mauro> E<.%A Richard McDougall> E<.%T Solaris Internals: "
"Core Kernel Architecture> E<.%I Prentice Hall> E<.%D 2001> E<.%O ISBN "
"0-13-022496-0> E<.Re>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/condvar.9:288
msgid "The CV primitives first appeared in E<.Nx 5.0>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/config.9:30
#, no-wrap
msgid "March 3, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/config.9:31
#, no-wrap
msgid "CONFIG 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:35
msgid "E<.Nm config>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/config.9:35
#, no-wrap
msgid "the autoconfiguration framework"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:40
msgid "E<.Do> device definition E<.Dc> language"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:54
msgid ""
"In E<.Nx>, the E<.Xr config 1> program reads and verifies a machine "
"description file (documented in E<.Xr config 5>)  that specifies the devices "
"to include in the kernel.  A table is produced by E<.Xr config 1> which is "
"used by the kernel during autoconfiguration (see E<.Xr autoconf 9>)  giving "
"needed hints and details on matching hardware devices with device drivers."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:56
msgid "Each device in the machine description file has:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/config.9:57
#, no-wrap
msgid "A Name"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:63
msgid ""
"The name is simply an alphanumeric string that ends in a unit number (e.g., "
"\"sd0\", \"sd1\", and so forth).  These unit numbers identify particular "
"instances of a base device name; the base name in turn maps directly to a "
"device driver.  Device unit numbers are independent of hardware features."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/config.9:63
#, no-wrap
msgid "A Parent"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:68
msgid ""
"Every device must have a parent.  The pairing is denoted by \"child at "
"parent\".  These pairings form the links in a directed graph.  The root "
"device is the only exception, as it does not have a parent."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/config.9:68
#, no-wrap
msgid "Locators"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:77
msgid ""
"Locators are used to augment the parent/child pairings that locate specific "
"devices.  Each locator value is simply an integer that represents some sort "
"of device address on the parent bus or controller.  This can be a memory "
"address, an I/O port, a driver number, or any other value.  Locators can "
"sometimes be wildcarded on devices that support direct connection."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/config.9:77
#, no-wrap
msgid "Attributes"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:92
msgid ""
"An attribute describes the device's relationship with the code; it then "
"serves to constrain the device graph.  A E<.Em plain attribute> describes "
"some attribute of a device.  An E<.Em interface attribute> describes a kind "
"of E<.Do> software interface E<.Dc> and declares the device's ability to "
"support other devices that use that interface.  In addition, an interface "
"attribute usually identifies additional locators."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:98
msgid ""
"During autoconfiguration, the directed graph is turned into a tree by "
"nominating one device as the root node and matching drivers with devices by "
"doing a depth-first traversal through the graph starting at this root node."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:113
msgid ""
"However, there must be constraints on the parent/child pairings that are "
"possible.  These constraints are embedded in the E<.Do> device definition "
"E<.Dc> files.  The remainder of this page describes the E<.Do> device "
"definition E<.Dc> language and how to use this language to add new "
"functionality to the E<.Nx> kernel."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/config.9:113
#, no-wrap
msgid "DEVICE DEFINITION FILES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:127
msgid ""
"The device definition files are separated into machine-dependent and "
"machine-independent files.  The machine-dependent file is located in E<.Pa "
"sys/arch/\\*[Lt]arch\\*[Gt]/conf/files.\\*[Lt]arch\\*[Gt]>, where "
"\\*[Lt]arch\\*[Gt] is the name of E<.Nx> architecture.  The "
"machine-independent file is located in E<.Pa sys/conf/files>.  It in turn "
"includes files for the machine-independent drivers located in E<.Pa "
"sys/dev/\\*[Lt]bus\\*[Gt]/files.\\*[Lt]bus\\*[Gt]>, where \\*[Lt]bus\\*[Gt] "
"is the name of the machine-independent bus."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:132
msgid ""
"These files define all legal devices and pseudo-devices.  They also define "
"all attributes and interfaces, establishing the rules that determine "
"allowable machine descriptions, and list the source files that make up the "
"kernel."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:142
msgid ""
"Each device definition file consists of a list of statements, typically one "
"per line.  Comments may be inserted anywhere using the E<.Do> # E<.Dc> "
"character, and any line that begins with white space continues the previous "
"line.  Valid statements are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/config.9:143
#, no-wrap
msgid "cinclude filename"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:151
msgid ""
"Conditionally include contents of file E<.Ar filename> to currently "
"processed configuration.  If the specified E<.Ar filename> doesn't exist, a "
"warning is printed, but the error ignored."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/config.9:151
#, no-wrap
msgid "defflag [filename] {options}"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:165
msgid ""
"The space-separated list of pre-processor macros E<.Em options> are defined "
"in file E<.Em filename>.  This statement permits ``options FOO'' for FOO "
"(i.e, without a value)  in the machine description file.  E<.Xr config 1> "
"will generate an error if a value is given.  If the filename field is not "
"specified, it will be constructed based upon the lower-case of the option "
"name, ``opt_foo.h'' for example.  The E<.Em option> is case-sensitive."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/config.9:165
#, no-wrap
msgid "defparam [filename] {options}"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:179
msgid ""
"The space-separated list of pre-processor macros E<.Em options> are defined "
"in file E<.Em filename>.  This statement permits ``options FOO=bar'' or "
"``option FOO=\"\\e\"com\\e\"\"'' in the machine description file.  E<.Xr "
"config 1> will generate an error if a value is not given.  If the filename "
"field is not specified, it will be constructed based upon the lower-case of "
"the option name, ``opt_foo.h'' for example.  The E<.Em option> is "
"case-sensitive."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/config.9:179
#, no-wrap
msgid "defopt [filename] {options}"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:196
msgid ""
"The space-separated list of pre-processor macros E<.Em options> are defined "
"in file E<.Em filename>.  This statement permits the syntax of either the "
"defflag and defparam statements and E<.Xr config 1> does not perform any "
"checking of whether ``options FOO'' takes a value.  Therefore, the use of "
"the defopt statement is deprecated in favour of the defflag and defparam "
"statements.  If the filename field is not specified, it will be constructed "
"based upon the lower-case of the option name, ``opt_foo.h'' for example.  "
"The E<.Em option> is case-sensitive."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/config.9:196
#, no-wrap
msgid "deffs name [[name] ...]"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:199
msgid "Define a filesystem E<.Em name>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/config.9:199
#, no-wrap
msgid "devclass name"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:203
msgid ""
"Define a device class E<.Em name>.  A device class is similar to an "
"attribute."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/config.9:203
#, no-wrap
msgid "define name [{locators}]"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:212
msgid ""
"The attribute E<.Em name> is defined and device definitions can then refer "
"to it.  If the attribute is an interface attribute and defines optional "
"E<.Em locators>, device attributes that refer to E<.Em name> are assumed to "
"share the interface and require the same locators."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/config.9:212
#, no-wrap
msgid "device name [{locators}]: [attributes]"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:220
msgid ""
"The device E<.Em name> is defined and requires the optional comma-separated "
"list of locators E<.Em locators>.  The optional E<.Em attributes> define "
"attribute dependencies."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/config.9:220
#, no-wrap
msgid "attach name at interface [with ifname]: [attributes]"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:236
msgid ""
"The device E<.Em name> is defined and supports the interface E<.Em "
"interface>.  If E<.Em ifname> is specified, it is used to specify the "
"interface to the driver for device E<.Em name> (see E<.Xr driver 9> for "
"details).  The optional E<.Em attributes> define attribute dependencies."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/config.9:236
#, no-wrap
msgid "defpseudo name: [{locators}]"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:244
msgid ""
"The pseudo-device E<.Em name> is defined.  The optional E<.Em locators> may "
"be defined, but are largely pointless since no device can attach to a "
"pseudo-device."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/config.9:244
#, no-wrap
msgid "file pathname [attributes [flags]] [rule]"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:254
msgid ""
"The file E<.Em pathname> is added to the list of files used to build the "
"kernel.  If no attributes are specified, the file is always added to the "
"kernel compilation.  If any of the attributes are specified by other devices "
"in the machine description file, then the file is included in compilation, "
"otherwise it is omitted.  Valid values for the optional flags are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/config.9:255
#, no-wrap
msgid "needs-count"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:261
msgid ""
"Specify that config should generate a file for each of the attributes "
"notifying the driver how many of some particular device or set of devices "
"are configured in the kernel.  This flag allows drivers to make calculations "
"of driver used at compile time.  This option prevents autoconfiguration "
"cloning."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/config.9:261
#, no-wrap
msgid "needs-flag"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:268
msgid ""
"This flag performs the same operation as E<.Em needs-count> but only records "
"if the number is nonzero.  Since the count is not exact, E<.Em needs-flag> "
"does not prevent autoconfiguration cloning."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/config.9:269
#, no-wrap
msgid "device-major name char [block] [attributes]"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:281
msgid ""
"The character device switch E<.Em name> associated with a character major "
"device number is added to the list of device switches used to build the "
"kernel.  If E<.Em block> is specified, the block device switch associated "
"with a block major device number is also added.  If all of attributes are "
"specified by devices in the machine description files, then device switches "
"are added into the device switches' table of the kernel in compilation, "
"otherwise they are omitted."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/config.9:281
#, no-wrap
msgid "include Ar filename"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:290
msgid ""
"Include contents of file E<.Ar filename> to currently processed "
"configuration.  If the specified E<.Ar filename> doesn't exist, E<.Xr config "
"1> exits with error."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/config.9:290
#, no-wrap
msgid "package Ar filename"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:297
msgid ""
"Changes prefix to directory of E<.Ar filename>, processes contents of E<.Ar "
"filename>, and switches back to previous prefix.  This is syntactic sugar "
"for:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:301
#, no-wrap
msgid ""
"E<.Li prefix Ar dirname(filename)>\n"
"E<.Li include Ar basename(filename)>\n"
"E<.Li prefix>\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/config.9:302
#, no-wrap
msgid "prefix Op Ar dirname"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:313
msgid ""
"If E<.Ar dirname> is specified, it is pushed on top of prefix stack.  Any "
"further files specified via option E<.Ar file> would have the prefix "
"implicitly prepended before its E<.Ar filename>.  If E<.Ar dirname> is not "
"specified, pops (removes) a prefix from prefix stack."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:321
msgid ""
"To allow locators to be wildcarded in the machine description file, their "
"default value must be defined in the attribute definition.  To allow "
"locators to be omitted entirely in the machine description file, enclose the "
"locator in square brackets.  This can be used when some locators do not make "
"sense for some devices, but the software interface requires them."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:327
msgid ""
"The device definition files are in E<.Pa sys/conf/files>, E<.Pa "
"sys/arch/\\*[Lt]arch\\*[Gt]/conf/files.\\*[Lt]arch\\*[Gt]>, and E<.Pa "
"sys/dev/\\*[Lt]bus\\*[Gt]/files.\\*[Lt]bus\\*[Gt]>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:332
msgid ""
"The grammar for machine description files can be found in E<.Xr config 1>, "
"in E<.Pa usr.bin/config/gram.y>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:345
msgid ""
"E<.Xr config 1>, E<.Xr config 5>, E<.Xr autoconf 9>, E<.Xr driver 9> E<.Rs> "
"E<.%T \"Building 4.4 BSD Systems with Config\"> E<.Re> E<.Rs> E<.%A Chris "
"Torek> E<.%T \"Device Configuration in 4.4BSD\"> E<.%D 1992> E<.Re>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/config.9:352
msgid ""
"Autoconfiguration first appeared in E<.Bx 4.1>.  The autoconfiguration "
"framework was completely revised in E<.Bx 4.4>.  It has been modified within "
"E<.Nx> to support bus-independent drivers and bus-dependent attachments."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/cons.9:28
#, no-wrap
msgid "CONS 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cons.9:38
msgid ""
"E<.Nm cnbell>, E<.Nm cnflush>, E<.Nm cngetc>, E<.Nm cngetsn>, E<.Nm cnhalt>, "
"E<.Nm cnpollc>, E<.Nm cnputc>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/cons.9:38
#, no-wrap
msgid "console access interface"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/cons.9:40
#, no-wrap
msgid "dev/cons.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cons.9:55
msgid ""
"E<.Ft void> E<.Fn cnbell \"u_int pitch\" \"u_int period\" \"u_int volume\"> "
"E<.Ft void> E<.Fn cnflush \"void\"> E<.Ft int> E<.Fn cngetc \"void\"> E<.Ft "
"int> E<.Fn cngetsn \"char *cp\" \"int size\"> E<.Ft void> E<.Fn cnhalt "
"\"void\"> E<.Ft void> E<.Fn cnpollc \"int on\"> E<.Ft void> E<.Fn cnputc "
"\"int c\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cons.9:58
msgid ""
"These functions operate over the current console device.  The console must "
"be initialized before these functions can be used."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cons.9:70
msgid ""
"Console input polling functions E<.Fn cngetc>, E<.Fn cngetsn> and E<.Fn "
"cnpollc> are only to be used during initial system boot, e.g., when asking "
"for root and dump device or to get necessary user input within "
"mountroothooks.  Once the system boots, user input is read via standard "
"E<.Xr tty 4> facilities."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cons.9:72
msgid "The following is a brief description of each function:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cons.9:73
#, no-wrap
msgid "Fn cnbell"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cons.9:83
msgid ""
"Ring a bell at appropriate E<.Fa pitch>, for duration of E<.Fa period> "
"milliseconds at given E<.Fa volume>.  Note that the E<.Fa volume> value is "
"ignored commonly."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cons.9:83
#, no-wrap
msgid "Fn cnflush"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cons.9:85
msgid "Waits for all pending output to finish."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cons.9:85
#, no-wrap
msgid "Fn cngetc"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cons.9:95
msgid ""
"Poll (busy wait) for an input and return the input key.  Returns 0 if there "
"is no console input device.  E<.Fn cnpollc> E<.Em must> be called before "
"E<.Fn cngetc> could be used.  E<.Fn cngetc> should be used during kernel "
"startup only."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cons.9:95
#, no-wrap
msgid "Fn cngetsn"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cons.9:121
msgid ""
"Read one line of user input, stop reading once the newline key is input.  "
"Input is echoed back.  This uses E<.Fn cnpollc> and E<.Fn cngetc>.  Number "
"of read characters is E<.Fa size> at maximum, user is notified by console "
"bell when the end of input buffer is reached.  \\*[Lt]Backspace\\*[Gt] key "
"works as expected.  \\*[Lt]@\\*[Gt] or \\*[Lt]CTRL\\*[Gt]-u make E<.Fn "
"cngetsn> discard input read so far, print newline and wait for next input.  "
"E<.Fn cngetsn> returns number of characters actually read, excluding the "
"final newline.  E<.Fa cp> is E<.Em not> zero-ended before return.  E<.Fn "
"cngetsn> should be used during kernel startup only."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cons.9:121
#, no-wrap
msgid "Fn cnhalt"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cons.9:123
msgid ""
"Terminates the console device (i.e. cleanly shuts down the console "
"hardware.)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cons.9:123
#, no-wrap
msgid "Fn cnpollc"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cons.9:131
msgid ""
"Switch the console driver to polling mode if E<.Fa on> is nonzero, or back "
"to interrupt driven mode if E<.Fa on> is zero.  E<.Fn cnpollc> should be "
"used during kernel startup only."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cons.9:131
#, no-wrap
msgid "Fn cnputc"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cons.9:136
msgid ""
"Console kernel output character routine.  Commonly, kernel code uses E<.Xr "
"printf 9> rather than using this low-level interface."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cons.9:139
msgid "This waits until a \\*[Lt]Enter\\*[Gt] key is pressed:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cons.9:142
#, no-wrap
msgid "int c;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cons.9:152
#, no-wrap
msgid ""
"cnpollc(1);\n"
"for(;;) {\n"
"\tc = cngetc();\n"
"\tif ((c == '\\er' || (c == '\\en')) {\n"
"\t\tprintf(\"\\en\");\n"
"\t\tbreak;\n"
"\t}\n"
"}\n"
"cnpollc(0);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cons.9:161
msgid ""
"E<.Xr pckbd 4>, E<.Xr pcppi 4>, E<.Xr tty 4>, E<.Xr wscons 4>, E<.Xr wskbd "
"4>, E<.Xr printf 9>, E<.Xr spl 9>, E<.Xr wscons 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/copy.9:35
#, no-wrap
msgid "August 28, 2005"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/copy.9:36
#, no-wrap
msgid "COPY 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/copy.9:45
msgid ""
"E<.Nm copy>, E<.Nm copyin>, E<.Nm copyout>, E<.Nm copystr>, E<.Nm "
"copyinstr>, E<.Nm copyoutstr>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/copy.9:45
#, no-wrap
msgid "kernel space to/from user space copy functions"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/copy.9:67
msgid ""
"E<.Ft int> E<.Fn copyin \"const void *uaddr\" \"void *kaddr\" \"size_t "
"len\"> E<.Ft int> E<.Fn copyout \"const void *kaddr\" \"void *uaddr\" "
"\"size_t len\"> E<.Ft int> E<.Fn copystr \"const void *kfaddr\" \"void "
"*kdaddr\" \"size_t len\" \"size_t *done\"> E<.Ft int> E<.Fn copyinstr "
"\"const void *uaddr\" \"void *kaddr\" \"size_t len\" \"size_t *done\"> E<.Ft "
"int> E<.Fn copyoutstr \"const void *kaddr\" \"void *uaddr\" \"size_t len\" "
"\"size_t *done\"> E<.Ft int> E<.Fn copyin_proc \"struct proc *p\" \"const "
"void *uaddr\" \"void *kaddr\" \"size_t len\"> E<.Ft int> E<.Fn copyout_proc "
"\"struct proc *p\" \"const void *kaddr\" \"void *uaddr\" \"size_t len\"> "
"E<.Ft int> E<.Fn ioctl_copyin \"int ioctlflags\" \"const void *src\" \"void "
"*dst\" \"size_t len\"> E<.Ft int> E<.Fn ioctl_copyout \"int ioctlflags\" "
"\"const void *src\" \"void *dst\" \"size_t len\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/copy.9:75
msgid ""
"The E<.Nm> functions are designed to copy contiguous data from one address "
"to another.  All but E<.Fn copystr> copy data from user-space to "
"kernel-space or vice-versa."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/copy.9:79 org_netbsd/src/share/man/man9/fetch.9:66 org_netbsd/src/share/man/man9/store.9:67
msgid "The E<.Nm> routines provide the following functionality:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/copy.9:80
#, no-wrap
msgid "Fn copyin"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/copy.9:87
msgid ""
"Copies E<.Fa len> bytes of data from the user-space address E<.Fa uaddr> in "
"the current process to the kernel-space address E<.Fa kaddr>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/copy.9:87
#, no-wrap
msgid "Fn copyout"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/copy.9:95
msgid ""
"Copies E<.Fa len> bytes of data from the kernel-space address E<.Fa kaddr> "
"to the user-space address E<.Fa uaddr> in the current process."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/copy.9:95
#, no-wrap
msgid "Fn copystr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/copy.9:108
msgid ""
"Copies a NUL-terminated string, at most E<.Fa len> bytes long, from "
"kernel-space address E<.Fa kfaddr> to kernel-space address E<.Fa kdaddr>.  "
"If the E<.Fa done> argument is non-NULL, the number of bytes actually "
"copied, including the terminating NUL, is returned in E<.Fa *done>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/copy.9:108
#, no-wrap
msgid "Fn copyinstr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/copy.9:121
msgid ""
"Copies a NUL-terminated string, at most E<.Fa len> bytes long, from "
"user-space address E<.Fa uaddr> in the current process to kernel-space "
"address E<.Fa kaddr>.  If the E<.Fa done> argument is non-NULL, the number "
"of bytes actually copied, including the terminating NUL, is returned in "
"E<.Fa *done>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/copy.9:121
#, no-wrap
msgid "Fn copyoutstr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/copy.9:135
msgid ""
"Copies a NUL-terminated string, at most E<.Fa len> bytes long, from "
"kernel-space address E<.Fa kaddr> to user-space address E<.Fa uaddr> in the "
"current process.  If the E<.Fa done> argument is non-NULL, the number of "
"bytes actually copied, including the terminating NUL, is returned in E<.Fa "
"*done>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/copy.9:135
#, no-wrap
msgid "Fn copyin_proc"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/copy.9:140
msgid ""
"Like E<.Fn copyin>, except it operates on the address space of the process "
"E<.Fa p>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/copy.9:140
#, no-wrap
msgid "Fn copyout_proc"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/copy.9:145
msgid ""
"Like E<.Fn copyout>, except it operates on the address space of the process "
"E<.Fa p>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/copy.9:145
#, no-wrap
msgid "Fn ioctl_copyin"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/copy.9:153
msgid ""
"Like E<.Fn copyin>, except it operates on kernel adresses when the E<.Dv "
"FKIOCTL> flag is passed in E<.Fa ioctlflags> from the ioctl call."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/copy.9:153
#, no-wrap
msgid "Fn ioctl_copyout"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/copy.9:161
msgid ""
"Like E<.Fn copyout>, except it operates on kernel adresses when the E<.Dv "
"FKIOCTL> flag is passed in E<.Fa ioctlflags> from the ioctl call."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/copy.9:178
msgid ""
"The E<.Nm> functions return 0 on success or E<.Er EFAULT> if a bad address "
"is encountered.  In addition, the E<.Fn copystr>, E<.Fn copyinstr>, and "
"E<.Fn copyoutstr> functions return E<.Er ENAMETOOLONG> if the string is "
"longer than E<.Fa len> bytes."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/copy.9:180
msgid "E<.Xr fetch 9>, E<.Xr store 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/coredump_write.9:30 org_netbsd/src/share/man/man9/cpu_coredump.9:30
#, no-wrap
msgid "December 24, 2005"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/coredump_write.9:31
#, no-wrap
msgid "COREDUMP_WRITE 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/coredump_write.9:35
msgid "E<.Nm coredump_write>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/coredump_write.9:35
#, no-wrap
msgid "common coredump write routine"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/coredump_write.9:41
msgid ""
"E<.Ft int> E<.Fn coredump_write \"void *iocookie\" \"enum uio_seg segflg\" "
"\"const void *data\" \"size_t len\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/coredump_write.9:56
msgid ""
"E<.Fn coredump_write> is used by both machine-dependent and "
"machine-independent components to write information to a coredump.  E<.Fa "
"iocookie> is an opaque pointer that was supplied to the caller of E<.Fn "
"coredump_write>.  E<.Fa segflg> indicates where the E<.Fa data> is located, "
"system space or user space.  E<.Fa data> points to the information to be "
"written to the coredump.  E<.Fa len> is the amount of data to be written."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/coredump_write.9:59
msgid ""
"E<.Fn coredump_write> returns 0 on success and an appropriate error code on "
"failure."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/coredump_write.9:72 org_netbsd/src/share/man/man9/cpu_coredump.9:72
msgid ""
"Process core dumps are initiated within the file E<.Pa "
"sys/kern/kern_sig.c>.  Process core dumps for ELF E<.Nx> binaries are "
"performed within the files E<.Pa sys/kern/core_elf32.c> or E<.Pa "
"sys/kern/core_elf64.c>.  Process core dumps for other E<.Nx> binaries are "
"performed within the file E<.Pa sys/kern/core_netbsd.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/coredump_write.9:73
msgid "E<.Xr cpu_coredump 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/cprng.9:30 org_netbsd/src/share/man/man9/rnd.9:30
#, no-wrap
msgid "December 17, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/cprng.9:31
#, no-wrap
msgid "CPRNG 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:46
msgid ""
"E<.Nm cprng>, E<.Nm cprng_strong_create>, E<.Nm cprng_strong>, E<.Nm "
"cprng_strong32>, E<.Nm cprng_strong64>, E<.Nm cprng_strong_getflags>, E<.Nm "
"cprng_strong_setflags>, E<.Nm cprng_strong_ready>, E<.Nm "
"cprng_strong_destroy>, E<.Nm cprng_fast>, E<.Nm cprng_fast32>, E<.Nm "
"cprng_fast64>,"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/cprng.9:46
#, no-wrap
msgid "cryptographic pseudo-random number generators"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/cprng.9:48
#, no-wrap
msgid "sys/cprng.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:69
msgid ""
"E<.Ft cprng_strong_t> E<.Fn cprng_strong_create \"const char *const name\" "
"\"int ipl\" \"int flags\"> E<.Ft void> E<.Fn cprng_strong_destroy "
"\"cprng_strong_t *cprng\"> E<.Ft size_t> E<.Fn cprng_strong \"cprng_strong_t "
"*const cprng\" \"void *buf\" \"size_t len\" \"int blocking\"> E<.Ft size_t> "
"E<.Fn cprng_fast \"void *buf\" \"size_t len\"> E<.Ft uint32_t> E<.Fn "
"cprng_strong32 \"void\"> E<.Ft uint64_t> E<.Fn cprng_strong64 \"void\"> "
"E<.Ft uint32_t> E<.Fn cprng_fast32 \"void\"> E<.Ft uint32_t> E<.Fn "
"cprng_fast64 \"void\"> E<.Ft int> E<.Fn cprng_strong_getflags "
"\"cprng_strong_t *const cprng\"> E<.Ft void> E<.Fn cprng_strong_setflags "
"\"cprng_strong_t *const cprng\" \"int flags\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:71
#, no-wrap
msgid "#define CPRNG_MAX_LEN   524288\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:82
#, no-wrap
msgid ""
"typedef struct _cprng_strong {\n"
"        kmutex_t\tmtx;\n"
"        kcondvar_t\tcv;\n"
"\tstruct selinfo\tselq;\n"
"        NIST_CTR_DRBG\tdrbg;\n"
"        int\t\tflags;\n"
"        char\t\tname[16];\n"
"        int\t\treseed_pending;\n"
"        rndsink_t\treseed;\n"
"} cprng_strong_t;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:104
msgid ""
"The E<.Nm> family of functions supply randomness to callers within the "
"E<.Nx> kernel.  They replace the E<.Xr arc4random 9> and E<.Xr "
"rnd_extract_data 9> functions for this purpose.  The E<.Nm> functions "
"provide stream generators automatically keyed (and if necessary rekeyed) "
"from the kernel entropy pool.  The E<.Nx> kernel no longer supports direct "
"reading from the kernel entropy pool; all access is mediated by the E<.Nm> "
"functions."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:113
msgid ""
"The E<.Dq strong> family of functions supply cryptographically strong random "
"numbers suitable for keying crypto systems and similar purposes.  Calls to "
"E<.Xr rnd_extract_data 9> should be replaced with calls to E<.Nm "
"cprng_strong>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:128
msgid ""
"The E<.Dq fast> family of functions supply less strong random numbers, "
"suitable for initialization vectors, nonces in certain protocols, and other "
"similar purposes, using a faster but less secure stream-cipher generator.  "
"stream-cipher generator.  Calls to E<.Xr arc4random 9> should be replaced "
"with calls to E<.Nm cprng_fast32>, and calls to E<.Xr arc4randbytes 9> "
"should be replaced with calls to E<.Nm cprng_fast>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:141
msgid ""
"A single instance of the E<.Nm cprng_fast> generator serves the entire "
"kernel.  A single, well-known instance of the E<.Nm cprng_strong> generator, "
"E<.Dv kern_cprng>, may be used by any in-kernel caller, but new "
"separately-keyed instances of the E<.Nm cprng_strong> generator can also be "
"created by calling E<.Nm cprng_strong_create>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cprng.9:143
#, no-wrap
msgid "Fn cprng_strong_create name ipl flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:161
msgid ""
"Create an instance of the cprng_strong generator.  This generator implements "
"the NIST SP 800-90 CTR_DRBG with AES128 as the block transform.  The E<.Fa "
"name> argument is used to \"personalize\" the CTR_DRBG according to the "
"standard, so that its initial state will depend both on keying material from "
"the entropy pool and also on the personalization string (name).  The E<.Fa "
"ipl> argument specifies the interrupt priority level for the mutex which "
"will serialize access to the new instance of the generator (see E<.Xr spl "
"9>).  The E<.Fa flags> argument controls the behavior of the generator:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cprng.9:162
#, no-wrap
msgid "Dv CPRNG_INIT_ANY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:166
msgid ""
"Perform initial keying of the generator from the entropy pool even if the "
"current estimate of entropy in the pool is less than the required number of "
"key bits for the generator."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cprng.9:166
#, no-wrap
msgid "Dv CPRNG_REKEY_ANY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:170
msgid ""
"When rekeying of the generator is required, key the generator from the "
"entropy pool even if the current estimate of entropy in the pool is less "
"than the required number of key bits for the generator."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cprng.9:170
#, no-wrap
msgid "Dv CPRNG_USE_CV"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:177
msgid ""
"Perform a E<.Xr cv_broadcast 9> operation on the \"cv\" member of the "
"returned cprng_strong_t each time the generator is successfully rekeyed.  "
"E<.Em If this flag is set, the generator will sleep when rekeying is "
"needed,> E<.Em and will therefore always return the requested number of "
"bytes.>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:183
msgid ""
"Creation will succeed even if key material for the generator is not "
"available.  In this case, the first request to read from the generator may "
"cause rekeying."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cprng.9:183
#, no-wrap
msgid "Fn cprng_strong_destroy cprng"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:186
msgid "Destroy an instance of the cprng_strong generator."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cprng.9:186
#, no-wrap
msgid "Fn cprng_strong cprng buf len blocking"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:211
msgid ""
"Fill memory location E<.Fa buf> with E<.Fa len> bytes from the generator "
"E<.Fa cprng>.  The E<.Fa blocking> argument controls the "
"blocking/non-blocking behavior of the generator: if it is set to E<.Dv "
"FNONBLOCK>, the generator may return less than E<.Fa len> bytes if it "
"requires rekeying.  If the E<.Dv CPRNG_USE_CV> flag is set on the generator, "
"the caller can wait on E<.Dv cprng-E<gt>cv> for notification that the "
"generator can again supply bytes.  A maximum of E<.Dv CPRNG_MAX_LEN> bytes "
"may be requested at once; this is a restriction of the CTR_DRBG "
"specification."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cprng.9:211
#, no-wrap
msgid "Fn cprng_strong32 cprng"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:215
msgid "Generate 32 bits using cprng_strong generator E<.Fa cprng>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cprng.9:215
#, no-wrap
msgid "Fn cprng_strong64 cprng"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:219
msgid "Generate 64 bits using cprng_strong generator E<.Fa cprng>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cprng.9:219
#, no-wrap
msgid "Fn cprng_strong_getflags cprng"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:223
msgid "Get the flags currently in use by generator E<.Fa cprng>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cprng.9:223
#, no-wrap
msgid "Fn cprng_strong_setflags cprng flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:228
msgid "Set the flags on generator E<.Fa cprng> to E<.Fa flags>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cprng.9:228
#, no-wrap
msgid "Fn cprng_fast buf len"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:234
msgid ""
"Fill memory location E<.Fa buf> with E<.Fa len> bytes from the fast "
"generator."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cprng.9:234
#, no-wrap
msgid "Fn cprng_fast32"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:236
msgid "Generate 32 bits using the fast generator."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cprng.9:236
#, no-wrap
msgid "Fn cprng_fast64"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:238
msgid "Generate 64 bits using the fast generator."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:252
msgid ""
"The cprng API is implemented by E<.Pa sys/kern/subr_cprng.c> and E<.Pa "
"sys/sys/cprng.h>.  The E<.Dq strong> generator uses the CTR_DRBG "
"implementation in E<.Pa sys/crypto/nist_ctr_drbg>.  The E<.Dq fast> "
"generator uses the arc4random implementation in E<.Pa "
"sys/lib/libkern/arc4random.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:256
msgid "E<.Xr condvar 9>, E<.Xr rnd 9>, E<.Xr spl 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:265
msgid ""
"E<.Rs> E<.%A Elaine Barker> E<.%A John Kelsey> E<.%T Recommendation for "
"Random Number Generation Using Deterministic Random Bit Generators "
"(Revised)> E<.%I National Institute of Standards and Technology> E<.%D 2011> "
"E<.%O NIST Special Publication 800-90A, Rev 1> E<.Re>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cprng.9:267
msgid "The cprng family of functions first appeared in E<.Nx 6.0>."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/cpu_configure.9:31
#, no-wrap
msgid "CPU_CONFIGURE 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_configure.9:35
msgid "E<.Nm cpu_configure>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/cpu_configure.9:35
#, no-wrap
msgid "machine-dependent device autoconfiguration"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_configure.9:40
msgid "E<.Ft void> E<.Fn cpu_configure \"void\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_configure.9:48
msgid ""
"The machine-dependent E<.Fn cpu_configure> is called during system bootstrap "
"to perform the machine-dependent portion of device autoconfiguration.  It "
"sets the configuration machinery in motion by finding the root bus E<.Pq Dq "
"mainbus>.  When this function returns, interrupts must be enabled."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_configure.9:51
msgid "The following tasks are performed by E<.Fn cpu_configure>:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_configure.9:55
msgid "initialize soft interrupts (see E<.Xr softintr 9>);"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_configure.9:62
msgid "initialize E<.Tn CPU> interrupts and E<.Tn SPLs> (see E<.Xr spl 9>);"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_configure.9:68
msgid "call E<.Fn config_rootfound> for E<.Dq mainbus>; and"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_configure.9:71
msgid "complete any initialization deferred from E<.Xr cpu_startup 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_configure.9:74
msgid "E<.Xr autoconf 9>, E<.Xr cpu_startup 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/cpu_coredump.9:31
#, no-wrap
msgid "CPU_COREDUMP 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_coredump.9:35
msgid "E<.Nm cpu_coredump>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/cpu_coredump.9:35
#, no-wrap
msgid "machine-dependent process core dump interface"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_coredump.9:42
msgid ""
"E<.Ft int> E<.Fn cpu_coredump \"struct lwp *l\" \"void *iocookie\" \"struct "
"core *chdr\"> E<.Ft int> E<.Fn cpu_coredump32 \"struct lwp *l\" \"void "
"*iocookie\" \"struct core32 *chdr\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_coredump.9:56
msgid ""
"E<.Fn cpu_coredump> is the machine-dependent interface invoked by "
"machine-independent code to dump the machine-dependent header information at "
"the start of a process core dump.  The header information primarily consists "
"of the CPU and floating-point registers.  E<.Fa l> is the lwp structure of "
"the thread being dumped.  E<.Fa iocookie> is an opaque pointer to be passed "
"to E<.Fn coredump_write>.  Information about the machine-dependent header "
"sections are returned in E<.Fa chdr>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_coredump.9:59
msgid ""
"E<.Fn cpu_coredump> returns 0 on success and an appropriate error code on "
"failure."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_coredump.9:73
msgid "E<.Xr coredump_write 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/cpu_dumpconf.9:30 org_netbsd/src/share/man/man9/cpu_initclocks.9:30
#, no-wrap
msgid "May 24, 2002"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/cpu_dumpconf.9:31
#, no-wrap
msgid "CPU_DUMPCONF 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_dumpconf.9:38
msgid "E<.Nm cpu_dumpconf>, E<.Nm cpu_dump>, E<.Nm cpu_dumpsize>, E<.Nm dumpsys>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/cpu_dumpconf.9:38
#, no-wrap
msgid "machine-dependent kernel core dumps"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_dumpconf.9:50
msgid ""
"E<.Ft void> E<.Fn cpu_dumpconf \"void\"> E<.Ft int> E<.Fn cpu_dump \"int "
"(*dump)(dev_t, daddr_t, void *, size_t)\" \"daddr_t *blknop\"> E<.Ft int> "
"E<.Fn cpu_dumpsize \"void\"> E<.Ft void> E<.Fn dumpsys \"void\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_dumpconf.9:60
msgid ""
"E<.Fn cpu_dumpconf> is the machine-dependent interface invoked during system "
"bootstrap to determine the dump device and initialize machine-dependent "
"kernel core dump state.  Internally, E<.Fn cpu_dumpconf> will invoke E<.Fn "
"cpu_dumpsize> to calculate the size of machine-dependent kernel core dump "
"headers."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_dumpconf.9:73
msgid ""
"E<.Fn dumpsys> is invoked by E<.Fn cpu_reboot> to dump kernel physical "
"memory onto the dump device.  E<.Fn dumpsys> invokes E<.Fn cpu_dump> to "
"write the machine-dependent header to the dump device at block number E<.Fa "
"*blknop> using the dump device's PIO dump routine specified by the E<.Fa "
"dump> argument."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_dumpconf.9:80
msgid ""
"E<.Fn cpu_dumpsize>, E<.Fn cpu_dump>, and E<.Fn dumpsys> are parts of the "
"machine-dependent interface, however they are not exported to "
"machine-independent code."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_dumpconf.9:81
msgid "E<.Xr cpu_reboot 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/cpu_idle.9:28
#, no-wrap
msgid "April 20, 2007"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/cpu_idle.9:29
#, no-wrap
msgid "CPU_IDLE 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_idle.9:34
msgid "E<.Nm cpu_idle>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/cpu_idle.9:34
#, no-wrap
msgid "machine-dependent processor idling interface"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/cpu_idle.9:37 org_netbsd/src/share/man/man9/cpu_need_resched.9:37 org_netbsd/src/share/man/man9/cpu_switchto.9:39
#, no-wrap
msgid "sys/cpu.h"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_idle.9:43
msgid "E<.Ft void> E<.Fn cpu_idle \"void\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_idle.9:48
msgid ""
"E<.Fn cpu_idle> is called by machine-independent code when the processor has "
"nothing to do.  It can be used to conserve the processor power, for example."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_idle.9:63
msgid ""
"E<.Fn cpu_idle> returns immediately if E<.Fn cpu_need_resched> has been "
"called for the processor after the last call of E<.Fn cpu_idle> or E<.Fn "
"cpu_did_resched> on the processor.  E<.Fn cpu_idle> returns as soon as "
"possible when E<.Fn cpu_need_resched> is called for the processor.  "
"Otherwise, it returns whenever it likes."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_idle.9:69
msgid "E<.Fn cpu_idle> is called at E<.Dv IPL_NONE>, without any locks held."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_idle.9:73
msgid ""
"The simplest (and, in some cases, the best) implementation of E<.Fn "
"cpu_idle> is the following."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_idle.9:79
#, no-wrap
msgid ""
"\tvoid\n"
"\tcpu_idle(void)\n"
"\t{\n"
"\t\t/* nothing */\n"
"\t}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_idle.9:85
msgid ""
"E<.Xr cpu_need_resched 9>, E<.Xr cpu_switchto 9>, E<.Xr intro 9>, E<.Xr spl "
"9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/cpu_initclocks.9:31
#, no-wrap
msgid "CPU_INITCLOCKS 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_initclocks.9:35
msgid "E<.Nm cpu_initclocks>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/cpu_initclocks.9:35
#, no-wrap
msgid "machine-dependent clock setup interface"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_initclocks.9:40
msgid "E<.Ft void> E<.Fn cpu_initclocks \"void\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_initclocks.9:47
msgid ""
"E<.Fn cpu_initclocks> is invoked by E<.Fn initclocks> during system "
"bootstrap, immediately after autoconfiguration, to perform the "
"machine-dependent initialization of clock frequencies and start the "
"real-time and statistic clocks running."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_initclocks.9:51
msgid ""
"Machine-independent clock interface operations are performed within the file "
"E<.Pa sys/kern/kern_clock.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_initclocks.9:52
msgid "E<.Xr autoconf 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/cpu_lwp_fork.9:31
#, no-wrap
msgid "CPU_LWP_FORK 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_lwp_fork.9:37
msgid "E<.Nm cpu_lwp_fork>, E<.Nm child_return>, E<.Nm proc_trampoline>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/cpu_lwp_fork.9:37
#, no-wrap
msgid "finish a fork operation"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/cpu_lwp_fork.9:39 org_netbsd/src/share/man/man9/curproc.9:40 org_netbsd/src/share/man/man9/fork1.9:39 org_netbsd/src/share/man/man9/kpause.9:40 org_netbsd/src/share/man/man9/ltsleep.9:39 org_netbsd/src/share/man/man9/namecache.9:44 org_netbsd/src/share/man/man9/preempt.9:41 org_netbsd/src/share/man/man9/proc_find.9:38 org_netbsd/src/share/man/man9/ras.9:40 org_netbsd/src/share/man/man9/suspendsched.9:37
#, no-wrap
msgid "sys/proc.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_lwp_fork.9:45
msgid ""
"E<.Ft void> E<.Fn cpu_lwp_fork \"struct lwp *l1\" \"struct lwp *l2\" \"void "
"*stack\" \"size_t stacksize\" \"void (*func)(void *)\" \"void *arg\"> E<.Ft "
"void> E<.Fn child_return \"void *arg\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_lwp_fork.9:55
msgid ""
"E<.Fn cpu_lwp_fork> is the machine-dependent portion of E<.Fn fork1> which "
"finishes a fork operation, with child lwp E<.Fa l2> nearly set up.  It "
"copies and updates the PCB and trap frame from the parent E<.Fa l1>, making "
"the child ready to run."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_lwp_fork.9:68
msgid ""
"E<.Fn cpu_lwp_fork> rigs the child's kernel stack so that it will start in "
"E<.Fn proc_trampoline>.  E<.Fn proc_trampoline> does not have a normal "
"calling sequence and is entered by E<.Fn cpu_switch>.  If an alternate "
"user-level stack is requested (with non-zero values in both the E<.Fa stack> "
"and E<.Fa stacksize> arguments), the user stack pointer is set up "
"accordingly."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_lwp_fork.9:99
msgid ""
"After being entered by E<.Fn cpu_switch> and while running in user context "
"(within the kernel)  E<.Fn proc_trampoline> will invoke the function E<.Fa "
"func> with the argument E<.Fa arg>.  If a kernel thread is being created, "
"the return path and argument are specified with E<.Fa func> and E<.Fa arg>.  "
"If a user process is being created, E<.Fn fork1> will pass E<.Fn "
"child_return> and E<.Fa l2> to E<.Fn cpu_lwp_fork> as E<.Fa func> and E<.Fa "
"arg> respectively.  This causes the newly-created child process to go "
"directly to user level with an apparent return value of 0 from E<.Xr fork "
"2>, while the parent process returns normally."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_lwp_fork.9:102
msgid "E<.Xr fork 2>, E<.Xr cpu_switchto 9>, E<.Xr fork1 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/cpu_need_resched.9:30
#, no-wrap
msgid "July 31, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/cpu_need_resched.9:31
#, no-wrap
msgid "CPU_NEED_RESCHED 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_need_resched.9:35
msgid "E<.Nm cpu_need_resched>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/cpu_need_resched.9:35
#, no-wrap
msgid "context switch notification"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_need_resched.9:40
msgid "E<.Ft void> E<.Fn cpu_need_resched \"struct cpu_info *ci\" \"int flags\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_need_resched.9:50
msgid ""
"The E<.Fn cpu_need_resched> function is the machine-independent interface "
"for the scheduler to notify machine-dependent code that a context switch "
"from the current LWP, on the cpu E<.Fa ci>, is required.  This event may "
"occur if a higher priority LWP appears on the run queue or if the current "
"LWP has exceeded its time slice."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_need_resched.9:58
msgid ""
"If E<.Dv RESCHED_KPREEMPT> flag is specified in E<.Fa flags> and E<.Dv "
"__HAVE_PREEMPTION> C pre-processor macro is defined in"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/cpu_need_resched.9:58
#, no-wrap
msgid "machine/intr.h ,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_need_resched.9:61
msgid ""
"machine-dependent code should make a context switch happen as soon as "
"possible even if the cpu is running the kernel code."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_need_resched.9:73
msgid ""
"If E<.Dv RESCHED_IMMED> flag is specified in E<.Fa flags>, machine-dependent "
"code should make a context switch happen as soon as possible.  In that case, "
"for example, if E<.Fa ci> is not the current processor, E<.Fn "
"cpu_need_resched> typically issues an inter processor call to the processor "
"to make it notice the need of a context switch as soon as possible."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_need_resched.9:77
msgid ""
"Typically, the E<.Fn cpu_need_resched> function will perform the following "
"operations:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_need_resched.9:82
msgid ""
"Set a per-processor flag which is checked by E<.Xr userret 9> when returning "
"to user-mode execution."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_need_resched.9:85
msgid "Post an asynchronous software trap E<.Pq Tn AST>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_need_resched.9:88
msgid "Send an inter processor interrupt to wake up E<.Xr cpu_idle 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_need_resched.9:91
msgid "E<.Xr sched_4bsd 9>, E<.Xr userret 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/cpu_number.9:31
#, no-wrap
msgid "CPU_NUMBER 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_number.9:35
msgid "E<.Nm cpu_number>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/cpu_number.9:35
#, no-wrap
msgid "unique"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_number.9:38
msgid "E<.Tn CPU> identification number"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/cpu_number.9:40 org_netbsd/src/share/man/man9/curproc.9:75
#, no-wrap
msgid "machine/cpu.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_number.9:43
msgid "E<.Ft cpuid_t> E<.Fn cpu_number \"void\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_number.9:52
msgid ""
"The E<.Fn cpu_number> function returns an unique E<.Tn CPU> identification "
"number for the E<.Tn CPU> that this thread is running on.  It may also be "
"implemented as a macro."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_number.9:53
msgid "E<.Xr curcpu 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/cpu_reboot.9:35 org_netbsd/src/share/man/man9/dopowerhooks.9:30 org_netbsd/src/share/man/man9/doshutdownhooks.9:35
#, no-wrap
msgid "February 11, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/cpu_reboot.9:36
#, no-wrap
msgid "CPU_REBOOT 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_reboot.9:40
msgid "E<.Nm cpu_reboot>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/cpu_reboot.9:40
#, no-wrap
msgid "halt or reboot the system"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_reboot.9:45
msgid "E<.Ft void> E<.Fn cpu_reboot \"int howto\" \"char *bootstr\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_reboot.9:53
msgid ""
"The E<.Fn cpu_reboot> function handles final system shutdown, and either "
"halts or reboots the system.  The exact action to be taken is determined by "
"the flags passed in E<.Fa howto> and by whether or not the system has "
"finished autoconfiguration."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_reboot.9:57
msgid ""
"If the system has finished autoconfiguration, E<.Fn cpu_reboot> does the "
"following:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_reboot.9:66
msgid ""
"Sets the E<.Va boothowto> system variable (see E<.Xr boothowto 9>)  from the "
"E<.Fa howto> argument."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_reboot.9:77
msgid ""
"If this is the first invocation of E<.Fn cpu_reboot> and the E<.Dv "
"RB_NOSYNC> flag is not set in E<.Fa howto>, syncs and unmounts the system "
"disks by calling E<.Xr vfs_shutdown 9> and sets the time of day clock by "
"calling E<.Xr resettodr 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_reboot.9:79
msgid "Disables interrupts."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_reboot.9:87
msgid ""
"If rebooting after a crash (i.e., if E<.Dv RB_DUMP> is set in E<.Fa howto>, "
"but E<.Dv RB_HALT> is not), saves a system crash dump."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_reboot.9:90
msgid "Runs any shutdown hooks by calling E<.Xr pmf_system_shutdown 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_reboot.9:93
msgid ""
"Prints a message indicating that the system is about to be halted or "
"rebooted."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_reboot.9:100
msgid ""
"If E<.Dv RB_HALT> is set in E<.Fa howto>, halts the system.  Otherwise, "
"reboots the system."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_reboot.9:107
msgid ""
"If the system has not finished autoconfiguration, E<.Fn cpu_reboot> runs any "
"shutdown hooks by calling E<.Xr pmf_system_shutdown 9>, prints a message, "
"and halts the system."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_reboot.9:115
msgid ""
"If E<.Dv RB_STRING> is set in E<.Pa howto>, then the parameter E<.Fa "
"bootstr> is passed to the system boot loader on some ports."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_reboot.9:120
msgid ""
"E<.Xr boothowto 9>, E<.Xr dumpsys 9>, E<.Xr pmf_system_shutdown 9>, E<.Xr "
"resettodr 9>, E<.Xr vfs_shutdown 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/cpu_rootconf.9:31
#, no-wrap
msgid "CPU_ROOTCONF 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_rootconf.9:36
msgid "E<.Nm cpu_rootconf>, E<.Nm setroot>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/cpu_rootconf.9:36
#, no-wrap
msgid "root file system setup"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_rootconf.9:44
msgid ""
"E<.Ft void> E<.Fn cpu_rootconf \"void\"> E<.Ft void> E<.Fn setroot "
"\"device_t bootdv\" \"int bootpartition\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_rootconf.9:50
msgid ""
"The E<.Fn cpu_rootconf> is a machine-dependent interface invoked during "
"system bootstrap to determine the root file system device and initialize "
"machine-dependent file system state."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_rootconf.9:60
msgid ""
"The E<.Fn cpu_rootconf> function invokes the machine-independent E<.Fn "
"setroot> function to record the boot/root device E<.Fa bootdv> and the boot "
"partition information E<.Fa bootpartition> for use in machine-independent "
"code."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_rootconf.9:62
msgid "E<.Xr boot 8>, E<.Xr boothowto 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/cpu_startup.9:31
#, no-wrap
msgid "CPU_STARTUP 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_startup.9:35
msgid "E<.Nm cpu_startup>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/cpu_startup.9:35 org_netbsd/src/share/man/man9/cpu_switchto.9:34
#, no-wrap
msgid "machine-dependent"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_startup.9:38
msgid "E<.Tn CPU> startup"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_startup.9:42
msgid "E<.Ft void> E<.Fn cpu_startup \"void\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_startup.9:49
msgid ""
"The machine-dependent E<.Fn cpu_startup> is invoked early during system "
"bootstrap, after the console has been set up and immediately after E<.Xr uvm "
"9> has been initialized."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_startup.9:52
msgid "The following tasks are performed by E<.Fn cpu_startup>:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_startup.9:55
msgid "print the initial copyright message;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_startup.9:57
msgid "allocate memory and buffers for kernel tables; and"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_startup.9:60
msgid "initialize the E<.Tn CPU>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_startup.9:63
msgid "E<.Xr autoconf 9>, E<.Xr uvm 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/cpu_switchto.9:28
#, no-wrap
msgid "June 2, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/cpu_switchto.9:29
#, no-wrap
msgid "CPU_SWITCHTO 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_switchto.9:34
msgid "E<.Nm cpu_switchto>"
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_switchto.9:38
msgid "E<.Tn LWP> context switching interface"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_switchto.9:45
msgid ""
"E<.Ft lwp_t *> E<.Fn cpu_switchto \"lwp_t *oldlwp\" \"lwp_t *newlwp\" \"bool "
"returning\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_switchto.9:55
msgid ""
"The E<.Fn cpu_switchto> function saves the context of the E<.Tn LWP> which "
"is currently running on the processor, and restores the context of the E<.Tn "
"LWP> specified by E<.Fa newlwp>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_switchto.9:57
msgid "Remarks:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_switchto.9:61
msgid "E<.Fn cpu_switchto> does not switch address spaces."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_switchto.9:73
msgid ""
"E<.Fn cpu_switchto> sets E<.Xr curlwp 9> to E<.Fa newlwp>.  If the "
"architecture does non-interlocked adaptive mutex release, E<.Fn "
"cpu_switchto> does an equivalent of E<.Xr membar_producer 3>, before and "
"after the modification of E<.Xr curlwp 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_switchto.9:79
msgid ""
"E<.Fn cpu_switchto> should be called at E<.Dv IPL_SCHED>.  When the function "
"returns, the caller should lower the priority level as soon as possible."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_switchto.9:82
msgid "E<.Fn cpu_switchto> might be called with spin mutexes held."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_switchto.9:85
msgid "The function takes the following arguments."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cpu_switchto.9:86
#, no-wrap
msgid "Fa oldlwp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_switchto.9:96
msgid ""
"Specify the E<.Tn LWP> from which the switch is going to be made, i.e., the "
"calling E<.Tn LWP>.  If it was E<.Dv NULL>, the context of the E<.Tn LWP> "
"currently running on this processor is not saved."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cpu_switchto.9:96
#, no-wrap
msgid "Fa newlwp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_switchto.9:102
msgid "Specify the E<.Tn LWP> to which to switch.  It must not be E<.Dv NULL>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cpu_switchto.9:102
#, no-wrap
msgid "Fa returning"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_switchto.9:119
msgid ""
"Only meaningful if the architecture implements fast software interrupts.  If "
"true, it indicates that E<.Fa oldlwp> is a soft interrupt E<.Tn LWP> that is "
"blocking.  It is a good indication that any kind of address space or user "
"activity can be completely ignored.  For example: E<.Xr ras_lookup 9>, cache "
"flushes, TLB wirings, adjusting lazy E<.Tn FPU> state.  All that is required "
"is to restore the register state and stack, and return to the interrupted "
"E<.Tn LWP>."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_switchto.9:144
msgid ""
"The E<.Fn cpu_switchto> function does not return until another E<.Tn LWP> "
"calls E<.Fn cpu_switchto>.  It returns the E<.Vt oldlwp> argument of the "
"E<.Fn cpu_switchto> which is called to switch back to our E<.Tn LWP>.  It is "
"either a E<.Tn LWP> which called E<.Fn cpu_switchto> to switch to us or "
"E<.Dv NULL> in case the E<.Tn LWP> was exiting."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpu_switchto.9:149
msgid ""
"E<.Xr membar_producer 3>, E<.Xr swapcontext 3>, E<.Xr intro 9>, E<.Xr mutex "
"9>, E<.Xr spl 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/cpufreq.9:28
#, no-wrap
msgid "October 27, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/cpufreq.9:29
#, no-wrap
msgid "CPUFREQ 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:43
msgid ""
"E<.Nm cpufreq>, E<.Nm cpufreq_register>, E<.Nm cpufreq_deregister>, E<.Nm "
"cpufreq_suspend>, E<.Nm cpufreq_resume>, E<.Nm cpufreq_get>, E<.Nm "
"cpufreq_get_backend>, E<.Nm cpufreq_get_state>, E<.Nm "
"cpufreq_get_state_index>, E<.Nm cpufreq_set>, E<.Nm cpufreq_set_all>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/cpufreq.9:43
#, no-wrap
msgid "interface for CPU frequency scaling"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/cpufreq.9:45
#, no-wrap
msgid "sys/cpufreq.h"
msgstr ""

#.  .Ft void
#.  .Fn cpufreq_set_higher "struct cpu_info *ci"
#.  .Ft void
#.  .Fn cpufreq_set_lower "struct cpu_info *ci"
#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:70
msgid ""
"E<.Ft int> E<.Fn cpufreq_register \"struct cpufreq *cf\"> E<.Ft void> E<.Fn "
"cpufreq_deregister \"void\"> E<.Ft void> E<.Fn cpufreq_suspend \"struct "
"cpu_info *ci\"> E<.Ft void> E<.Fn cpufreq_resume \"struct cpu_info *ci\"> "
"E<.Ft uint32_t> E<.Fn cpufreq_get \"struct cpu_info *ci\"> E<.Ft int> E<.Fn "
"cpufreq_get_backend \"struct cpufreq *cf\"> E<.Ft int> E<.Fn "
"cpufreq_get_state \"uint32_t freq\" \"struct cpufreq_state *cfs\"> E<.Ft "
"int> E<.Fn cpufreq_get_state_index \"uint32_t index\" \"struct cpufreq_state "
"*cfs\"> E<.Ft void> E<.Fn cpufreq_set \"struct cpu_info *ci\" \"uint32_t "
"freq\"> E<.Ft void> E<.Fn cpufreq_set_all \"uint32_t freq\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:78
msgid ""
"The machine-independent E<.Nm> interface provides a framework for E<.Tn CPU> "
"frequency scaling done by a machine-dependent backend implementation.  User "
"space control is available via E<.Xr cpuctl 8>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:95
msgid ""
"The E<.Nm> interface is a per-CPU framework.  It is implicitly assumed that "
"the frequency can be set independently for all processors in the system.  "
"However, E<.Nm> does not imply any restrictions upon whether this "
"information is utilized by the actual machine-dependent implementation.  It "
"is possible to use E<.Nm> with frequency scaling implemented via E<.Xr pci "
"4>.  In addition, it assumed that the available frequency levels are shared "
"uniformly by all processors in the system, even when it is possible to "
"control the frequency of individual processors."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:108
msgid ""
"It should be noted that the E<.Nm> interface is generally stateless.  This "
"implies for instance that possible caching should be done in the "
"machine-dependent backend.  The E<.Fn cpufreq_suspend> and E<.Fn "
"cpufreq_resume> functions are exceptions.  These can be integrated with "
"E<.Xr pmf 9>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cpufreq.9:110
#, no-wrap
msgid "Fn cpufreq_register cf"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:123
msgid ""
"The E<.Fn cpufreq_register> function initializes the interface by "
"associating a machine-dependent backend with the framework.  Only one "
"backend can be registered.  Upon successful completion, E<.Fn "
"cpufreq_register> returns 0 and sets the frequency of all processors to the "
"maximum available level.  Note that the registration can be done only after "
"interrupts have been enabled; cf.  E<.Xr config_interrupts 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:127
msgid ""
"The following elements in E<.Vt struct cpufreq> should be filled prior to "
"the call:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:135
#, no-wrap
msgid ""
"char\t\t\t cf_name[CPUFREQ_NAME_MAX];\n"
"struct cpufreq_state     cf_state[CPUFREQ_STATE_MAX];\n"
"uint32_t                 cf_state_count;\n"
"bool\t\t\t cf_mp;\n"
"void                    *cf_cookie;\n"
"xcfunc_t                 cf_get_freq;\n"
"xcfunc_t                 cf_set_freq;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:141
msgid "The name of the backend should be given in E<.Vt cf_name>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:146
msgid ""
"The E<.Vt cpufreq_state> structure conveys descriptive information about the "
"frequency states.  The following fields can be used for the registration:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:149
#, no-wrap
msgid ""
"uint32_t\t\t cfs_freq;\n"
"uint32_t\t\t cfs_power;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:160
msgid ""
"From these E<.Vt cfs_freq> (the clock frequency in MHz) is mandatory, "
"whereas the optional E<.Vt cfs_power> can be filled to describe the power "
"consumption (in mW) of each state.  The E<.Fa cf_state> array must be filled "
"in descending order, that is, the highest frequency should be at the zero "
"index."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:170
msgid ""
"If the backend operates with a simple boolean switch without knowing the "
"clock frequencies, the E<.Fa cfs_freq> field should be set to E<.Dv "
"CPUFREQ_STATE_ENABLED> or E<.Dv CPUFREQ_STATE_DISABLED>.  The first constant "
"should precede the latter one in E<.Vt cf_state>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:176
msgid ""
"The E<.Vt cf_state_count> field defines the number of states that the "
"backend has filled in the E<.Vt cf_state> array."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:183
msgid ""
"The E<.Vt cf_mp> boolean should be set to false if it is known that the "
"backend can not handle per-CPU frequency states; changes should always be "
"propagated to all processors in the system."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:192
msgid ""
"The E<.Vt cf_cookie> field is an opaque pointer passed to the backend when "
"E<.Fn cpufreq_get>, E<.Fn cpufreq_set>, or E<.Fn cpufreq_set_all> is called."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:209
msgid ""
"The E<.Vt cf_get_freq> and E<.Vt cf_set_freq> are function pointers that "
"should be associated with the machine-dependent functions to get and set a "
"frequency, respectively.  The E<.Vt xcfunc_t> type is part of E<.Xr xcall "
"9>.  When the function pointers are invoked by E<.Nm>, the first parameter "
"is always the E<.Vt cf_cookie> and the second parameter is the frequency, "
"defined as E<.Vt uint32_t *>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cpufreq.9:210
#, no-wrap
msgid "Fn cpufreq_deregister"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:212
msgid "Deregisters any possible backend in use."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cpufreq.9:212
#, no-wrap
msgid "Fn cpufreq_suspend ci"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:219
msgid ""
"The E<.Fn cpufreq_suspend> can be called when the processor suspends.  The "
"function saves the current frequency of E<.Fa ci> and sets the minimum "
"available frequency."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cpufreq.9:219
#, no-wrap
msgid "Fn cpufreq_resume ci"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:223
msgid "Resumes the frequency of E<.Fa ci> that was used before suspend."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cpufreq.9:223
#, no-wrap
msgid "Fn cpufreq_get ci"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:227
msgid ""
"Returns the current frequency of the processor E<.Fa ci>.  A value zero is "
"returned upon failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cpufreq.9:227
#, no-wrap
msgid "Fn cpufreq_get_backend cf"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:233
msgid ""
"Upon successful completion, E<.Fn cpufreq_get_backend> returns 0 and fills "
"E<.Fa cf> with the data related to the currently used backend."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cpufreq.9:233
#, no-wrap
msgid "Fn cpufreq_get_state freq cfs"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:244
msgid ""
"The E<.Fn cpufreq_get_state> function looks for the given frequency from the "
"array of known frequency states.  If E<.Fa freq> is not found, the closest "
"match is returned.  Upon successful completion, the function returns zero "
"and stores the state information to E<.Fa cfs>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cpufreq.9:244
#, no-wrap
msgid "Fn cpufreq_get_state_index index cfs"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:250
msgid ""
"Stores the frequency state with the given E<.Fa index> to E<.Fa cfs>, "
"returning zero upon successful completion."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cpufreq.9:250
#, no-wrap
msgid "Fn cpufreq_set ci freq"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:257
msgid ""
"The E<.Fn cpufreq_set> function sets the frequency of E<.Fa ci> to E<.Fa "
"freq>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/cpufreq.9:257
#, no-wrap
msgid "Fn cpufreq_set_all freq"
msgstr ""

#.  .It Fn cpufreq_set_higher "ci"
#.  Decrements the current frequency level of
#.  .Fa ci
#.  by one state.
#.  .It Fn cpufreq_set_lower "ci"
#.  Increases the current frequency state of
#.  .Fa ci
#.  by one state.
#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:269
msgid "Sets E<.Fa freq> for all processors in the system."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:285
msgid ""
"The three functions E<.Fn cpufreq_get>, E<.Fn cpufreq_set>, and E<.Fn "
"cpufreq_set_all> guarantee that the call will be made in E<.Xr curcpu 9>.  "
"The interface holds a E<.Xr mutex 9> while calling the functions.  This, and "
"the use of E<.Xr xcall 9>, implies that no memory can be allocated in the "
"backend during the calls.  Nor should the functions be called from interrupt "
"context."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:290
msgid "The E<.Nm> interface is implemented within E<.Pa sys/kern/subr_cpufreq.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:303
msgid ""
"E<.Xr cpuctl 8>, E<.Xr pmf 9>, E<.Xr xcall 9> E<.Rs> E<.%A Venkatesh "
"Pallipadi> E<.%A Alexey Starikovskiy> E<.%T The Ondemand Governor. Past, "
"Present, and Future> E<.%I Intel Open Source Technology Center> E<.%O "
"Proceedings of the Linux Symposium> E<.%D July, 2006> E<.%U "
"http://www.kernel.org/doc/ols/2006/ols2006v2-pages-223-238.pdf> E<.Re>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:308 org_netbsd/src/share/man/man9/pcq.9:134 org_netbsd/src/share/man/man9/percpu.9:161 org_netbsd/src/share/man/man9/man9.x86/nmi.9:131
msgid "The E<.Nm> interface first appeared in E<.Nx 6.0>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:311
msgid "E<.An Jukka Ruohonen> E<.Aq jruohonen@iki.fi>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/cpufreq.9:314
msgid "The interface does not support different E<.Dq governors> and policies."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/csf.9:30
#, no-wrap
msgid "September 2, 2009"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/csf.9:31
#, no-wrap
msgid "CSF 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:35
msgid "E<.Nm CSF>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/csf.9:35
#, no-wrap
msgid "The"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:38
msgid "E<.Nx> common scheduler framework"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/csf.9:39 org_netbsd/src/share/man/man9/preempt.9:38 org_netbsd/src/share/man/man9/sched_4bsd.9:37 org_netbsd/src/share/man/man9/sched_m2.9:37 org_netbsd/src/share/man/man9/suspendsched.9:38 org_netbsd/src/share/man/man9/userret.9:38
#, no-wrap
msgid "sys/sched.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:86
msgid ""
"E<.Ft void> E<.Fn sched_rqinit \"void\"> E<.Ft void> E<.Fn sched_setup "
"\"void\"> E<.Ft void> E<.Fn sched_cpuattach \"struct cpu_info *\"> E<.Ft "
"void> E<.Fn sched_tick \"struct cpu_info *\"> E<.Ft void> E<.Fn "
"sched_schedclock \"lwp_t *\"> E<.Ft bool> E<.Fn sched_curcpu_runnable_p "
"\"void\"> E<.Ft lwp_t *> E<.Fn sched_nextlwp \"void\"> E<.Ft void> E<.Fn "
"sched_enqueue \"lwp_t *\" \"bool\"> E<.Ft void> E<.Fn sched_dequeue \"lwp_t "
"*\"> E<.Ft void> E<.Fn sched_nice \"struct proc *\" \"int\"> E<.Ft void> "
"E<.Fn sched_proc_fork \"struct proc *\" \"struct proc *\"> E<.Ft void> E<.Fn "
"sched_proc_exit \"struct proc *\" \"struct proc *\"> E<.Ft void> E<.Fn "
"sched_lwp_fork \"lwp_t *\"> E<.Ft void> E<.Fn sched_lwp_exit \"lwp_t *\"> "
"E<.Ft void> E<.Fn sched_setrunnable \"lwp_t *\"> E<.Ft void> E<.Fn "
"sched_print_runqueue \"void (*pr)(const char *, ...)\"> E<.Ft void> E<.Fn "
"sched_pstats_hook \"struct proc *\" \"int\"> E<.Ft void> E<.Fn sched_pstats "
"\"void *arg\"> E<.Ft pri_t> E<.Fn sched_kpri \"lwp_t *\"> E<.Ft void> E<.Fn "
"resched_cpu \"lwp_t *\"> E<.Ft void> E<.Fn setrunnable> E<.Ft void> E<.Fn "
"schedclock \"lwp_t *\"> E<.Ft void> E<.Fn sched_init \"void\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:96
msgid ""
"E<.Nm> provides a modular and self-contained interface for implementing "
"different thread scheduling algorithms.  The different schedulers can be "
"selected at compile-time.  Currently, the schedulers available are E<.Xr "
"sched_4bsd 9>, the traditional 4.4BSD thread scheduler, and E<.Xr sched_m2 "
"9> which implements a SVR4/Solaris like apporach."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:100
msgid ""
"The interface is divided into two parts: A set of functions each scheduler "
"needs to implement and common functions used by all schedulers."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/csf.9:100
#, no-wrap
msgid "Scheduler-specific functions"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:103
msgid "The following functions have to be implemented by the individual scheduler."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/csf.9:103
#, no-wrap
msgid "Scheduler initialization"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/csf.9:105
#, no-wrap
msgid "Ft void Fn sched_cpuattach \"struct cpu_info *\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:107
msgid "Per-CPU scheduler initialization routine."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/csf.9:107
#, no-wrap
msgid "Ft void Fn sched_rqinit void"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:109
msgid "Initialize the scheduler's runqueue data structures."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/csf.9:109
#, no-wrap
msgid "Ft void Fn sched_setup void"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:112
msgid "Setup initial scheduling parameters and kick off timeout driven events."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/csf.9:113
#, no-wrap
msgid "Runqueue handling"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:117
msgid ""
"Runqueue handling is completely internal to the scheduler.  Other parts of "
"the kernel should access runqueues only through the following functions:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/csf.9:118
#, no-wrap
msgid "Ft void Fn sched_enqueue \"lwp_t *\" bool"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:120
msgid "Place an LWP within the scheduler's runqueue structures."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/csf.9:120
#, no-wrap
msgid "Ft void Fn sched_dequeue \"lwp_t *\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:122
msgid "Remove an LWP from the scheduler's runqueue structures."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/csf.9:122
#, no-wrap
msgid "Ft lwp_t * Fn sched_nextlwp void"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:124
msgid "Return the LWP that should run the CPU next."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/csf.9:124
#, no-wrap
msgid "Ft bool Fn sched_curcpu_runnable_p void"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:126
msgid "Indicate if there is a runnable LWP for the current CPU."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/csf.9:126
#, no-wrap
msgid "Ft void Fn sched_print_runqueue \"void (*pr)(const char *, ...)\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:128
msgid "Print runqueues in DDB."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/csf.9:129
#, no-wrap
msgid "Core scheduler functions"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/csf.9:131
#, no-wrap
msgid "Ft void Fn sched_tick \"struct cpu_info *\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:136
msgid ""
"Periodically called from E<.Xr hardclock 9>.  Determines if a reschedule is "
"necessary, if the running LWP has used up its quantum."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/csf.9:136
#, no-wrap
msgid "Ft void Fn sched_schedclock \"lwp_t *\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:140
msgid ""
"Periodically called from E<.Fn schedclock> in order to handle priority "
"adjustment."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/csf.9:141
#, no-wrap
msgid "Priority adjustment"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/csf.9:143
#, no-wrap
msgid "Ft void Fn sched_nice \"struct proc *, int\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:145
msgid "Recalculate the process priority according to its nice value."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/csf.9:146
#, no-wrap
msgid "General helper functions"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/csf.9:148
#, no-wrap
msgid "Ft void Fn sched_proc_fork \"struct proc *\" \"struct proc *\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:151
msgid "Inherit the scheduling history of the parent process after E<.Fn fork>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/csf.9:151
#, no-wrap
msgid "Ft void Fn sched_proc_exit \"struct proc *\" \"struct proc *\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:153
msgid "Charge back a processes parent for its resource usage."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/csf.9:153
#, no-wrap
msgid "Ft void Fn sched_lwp_fork \"lwp_t *\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:155 org_netbsd/src/share/man/man9/csf.9:157
msgid "LWP-specific version of the above"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/csf.9:155
#, no-wrap
msgid "Ft void Fn sched_lwp_exit \"lwp_t *\""
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/csf.9:157
#, no-wrap
msgid "Ft void Fn sched_setrunnable \"lwp_t *\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:160
msgid "Scheduler-specific actions for E<.Fn setrunnable>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/csf.9:160
#, no-wrap
msgid "Ft void Fn sched_pstats_hook \"struct proc *\" int"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:163
msgid "Scheduler-specific actions for E<.Fn sched_pstats>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/csf.9:164
#, no-wrap
msgid "Common scheduler functions"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/csf.9:166
#, no-wrap
msgid "Ft pri_t Fn sched_kpri \"lwp_t *\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:169
msgid ""
"Scale a priority level to a kernel priority level, usually for an LWP that "
"is about to sleep."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/csf.9:169
#, no-wrap
msgid "Ft void Fn sched_pstats \"void *\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:171
msgid "Update process statistics and check CPU resource allocation."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/csf.9:171
#, no-wrap
msgid "Ft inline void Fn resched_cpu \"lwp_t *\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:173
msgid "Arrange for a reschedule."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/csf.9:173
#, no-wrap
msgid "Ft void Fn setrunnable \"lwp_t *\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:176
msgid ""
"Change process state to be runnable, placing it on a runqueue if it is in "
"memory, awakening the swapper otherwise."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/csf.9:176
#, no-wrap
msgid "Ft void Fn schedclock \"lwp_t *\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:180
msgid "Scheduler clock.  Periodically called from E<.Fn statclock>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/csf.9:180
#, no-wrap
msgid "Ft void Fn sched_init void"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:186
msgid ""
"Initialize callout for E<.Fn sched_pstats> and call E<.Fn sched_setup> to "
"initialize any other scheduler-specific data."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:192
msgid ""
"The E<.Nm> programming interface is defined within the file E<.Pa "
"sys/sys/sched.h>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:195
msgid ""
"Functions common to all scheduler implementations are in E<.Pa "
"sys/kern/kern_synch.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:198
msgid ""
"The traditional 4.4BSD scheduler is implemented in E<.Pa "
"sys/kern/sched_4bsd.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:201
msgid "The M2 scheduler is implemented in E<.Pa sys/kern/sched_m2.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:206
msgid "E<.Xr mi_switch 9>, E<.Xr preempt 9>, E<.Xr sched_4bsd 9>, E<.Xr sched_m2 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:211
msgid "The E<.Nm> appeared in E<.Nx 5.0>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/csf.9:216
msgid "The E<.Nm> was written by E<.An Daniel Sieger> E<.Aq dsieger@NetBSD.org>."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/ctod.9:31
#, no-wrap
msgid "CTOD 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ctod.9:35
msgid "E<.Nm ctod>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/ctod.9:35
#, no-wrap
msgid "macros related to bytes, pages, and disk blocks"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ctod.9:50
msgid ""
"E<.Ft size> E<.Fn ctod \"size x\"> E<.Ft size> E<.Fn dtoc \"size x\"> E<.Ft "
"size> E<.Fn ctob \"size x\"> E<.Ft size> E<.Fn btoc \"size x\"> E<.Ft size> "
"E<.Fn dbtob \"size x\"> E<.Ft size> E<.Fn btodb \"size x\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ctod.9:56
msgid ""
"The E<.Nm> family of macros can be used to convert between bytes, pages "
"E<.Pq Dq clicks>, and disk blocks."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ctod.9:58
msgid "The following table lists the possible conversions:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ctod.9:59
#, no-wrap
msgid "Sy Macro Ta Sy From Ta Sy To"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ctod.9:60
#, no-wrap
msgid "Fn ctod Ta pages Ta disk blocks"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ctod.9:61
#, no-wrap
msgid "Fn dtoc Ta disk blocks Ta pages"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ctod.9:62
#, no-wrap
msgid "Fn ctob Ta pages Ta bytes"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ctod.9:63
#, no-wrap
msgid "Fn btoc Ta bytes Ta pages"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ctod.9:64
#, no-wrap
msgid "Fn dbtob Ta disk blocks Ta bytes"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ctod.9:65
#, no-wrap
msgid "Fn btodb Ta bytes Ta disk blocks"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ctod.9:75
msgid ""
"These are typical macros that may appear with different names in other "
"operating systems.  Examples include E<.Fn btop> and E<.Fn btopr> in "
"Solaris."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ctod.9:77
msgid "E<.Xr param 3>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ctod.9:80
msgid "Some of these macros appeared in E<.At v7>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/ctod.9:80 org_netbsd/src/share/man/man9/kmem.9:260 org_netbsd/src/share/man/man9/roundup.9:100 org_netbsd/src/share/man/man9/setbit.9:79 org_netbsd/src/share/man/man9/veriexec.9:314
#, no-wrap
msgid "CAVEATS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ctod.9:84
msgid ""
"The described macros make no assumptions about the type of the input "
"parameter.  A caller should ensure that neither integer overflow nor integer "
"underflow are possible."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/curproc.9:30 org_netbsd/src/share/man/man9/proc_find.9:30
#, no-wrap
msgid "July 1, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/curproc.9:31
#, no-wrap
msgid "CURPROC 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/curproc.9:37
msgid "E<.Nm curproc>, E<.Nm curcpu>, E<.Nm curlwp>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/curproc.9:37
#, no-wrap
msgid "current process, processor, and"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/curproc.9:39
msgid "E<.Tn LWP>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/curproc.9:47
msgid ""
"E<.Ft struct cpu_info *> E<.Fn curcpu \"void\"> E<.Ft struct proc *> E<.Fn "
"curproc \"void\"> E<.Ft struct lwp *> E<.Fn curlwp \"void\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/curproc.9:52
msgid ""
"The following macros can be used to retrieve the current processor, process, "
"and light-weight process E<.Pq Tn LWP>, respectively:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/curproc.9:61
msgid ""
"The machine-dependent E<.Fn curcpu> macro returns a pointer to a E<.Em "
"cpu_info> structure containing information of the E<.Tn CPU> that this "
"thread is running on."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/curproc.9:66
msgid ""
"The machine-independent E<.Fn curproc> macro refers to a pointer to the "
"process currently running on this E<.Tn CPU>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/curproc.9:75
msgid ""
"The E<.Fn curlwp> macro expands to a pointer to E<.Em lwp> structure, "
"containing information about the current E<.Tn LWP>.  This macro is "
"machine-independent, but machine-dependent"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/curproc.9:77
msgid "may redefine it."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/curproc.9:80
msgid "E<.Xr cpu_number 9>, E<.Xr proc_find 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/ddc.9:32 org_netbsd/src/share/man/man9/edid.9:32
#, no-wrap
msgid "May 11, 2006"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/ddc.9:33
#, no-wrap
msgid "DDC 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ddc.9:37
msgid "E<.Nm ddc>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/ddc.9:37
#, no-wrap
msgid "VESA Display Data Channel V2"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/ddc.9:39
#, no-wrap
msgid "dev/i2c/ddcvar.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ddc.9:46
msgid ""
"E<.Ft int> E<.Fo ddc_read_edid> E<.Fa \"i2c_tag_t tag\"> E<.Fa \"uint8_t "
"*dest\"> E<.Fa \"size_t len\"> E<.Fc>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ddc.9:53
msgid ""
"The E<.Fn ddc_read_edid> reads a VESA Extended Display Identification Data "
"block (EDID) via VESA Display Data Channel (DDCv2).  DDCv2 is a protocol for "
"data exchange between display devices (such as monitors and flat panels) and "
"host machines using an I2C bus."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ddc.9:66
msgid ""
"The E<.Fa tag> argument is a machine-dependent tag used to specify the I2C "
"bus on which the DDCv2 device is located.  The E<.Fa dest> argument is a "
"pointer to a buffer where the EDID data will be stored.  The E<.Fa len> "
"argument is the amount of data to read into the buffer.  (The buffer must be "
"large enough.)  Typically, this value will be 128, which is the size of a "
"normal EDID data block."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ddc.9:70
msgid ""
"Normally the EDID data block will be post-processed with the E<.Fn "
"edid_parse> function."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ddc.9:74
msgid ""
"The E<.Fn ddc_read_edid> function returns zero on success, and non-zero "
"otherwise."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/ddc.9:74 org_netbsd/src/share/man/man9/pci_configure_bus.9:204
#, no-wrap
msgid "ENVIRONMENT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ddc.9:80
msgid ""
"The E<.Fn ddc_read_edid> function is part of the E<.Xr ddc 4> driver, and is "
"only included in the kernel if that driver is also included."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ddc.9:84
msgid ""
"The following code uses E<.Fn ddc_read_edid> to retrieve and print "
"information about a monitor:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ddc.9:89 org_netbsd/src/share/man/man9/edid.9:114
#, no-wrap
msgid ""
"\tstruct edid_info info;\n"
"\ti2c_tag_t        tag;\n"
"\tchar\t\t buffer[128];\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ddc.9:97
#, no-wrap
msgid ""
"\t...\n"
"\t/* initialize i2c tag... */\n"
"\t...\n"
"\tif ((ddc_read_edid(tag, buffer, 128) == 0) \\*[Am]\\*[Am] \n"
"\t    (edid_parse(buffer, \\*[Am]info) == 0))\n"
"\t\tedid_print(info);\n"
"\t...\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ddc.9:101 org_netbsd/src/share/man/man9/pci_configure_bus.9:274
msgid ""
"Note that this must be called before the PCI bus is attached during "
"autoconfiguration."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ddc.9:105
msgid "E<.Xr ddc 4>, E<.Xr edid 9>, E<.Xr iic 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ddc.9:108
msgid "DDCv2 support was added in E<.Nx 4.0>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ddc.9:109 org_netbsd/src/share/man/man9/edid.9:130
msgid "E<.An Garrett D'Amore Aq gdamore@NetBSD.org>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/delay.9:30 org_netbsd/src/share/man/man9/kpause.9:31
#, no-wrap
msgid "July 20, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/delay.9:31
#, no-wrap
msgid "DELAY 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/delay.9:36
msgid "E<.Nm delay>, E<.Nm DELAY>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/delay.9:36
#, no-wrap
msgid "microsecond delay"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/delay.9:38
#, no-wrap
msgid "machine/param.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/delay.9:43
msgid ""
"E<.Ft void> E<.Fn delay \"unsigned int us\"> E<.Ft void> E<.Fn DELAY "
"\"unsigned int us\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/delay.9:47
msgid "Wait approximately E<.Fa us> microseconds."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/delay.9:53
msgid ""
"The delay is implemented as a machine loop, preventing events other than "
"interrupt handlers for unmasked interrupts to run.  E<.Fn DELAY> is "
"reentrant (doesn't modify any global kernel or machine state) and is safe to "
"use in interrupt or process context."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/delay.9:57
msgid ""
"For long delays, condition variables should be considered, however they can "
"only be used from process context and their resolution is limited by the "
"system clock frequency."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/delay.9:60
msgid "E<.Xr condvar 9>, E<.Xr hz 9>, E<.Xr kpause 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/deviter.9:53 org_netbsd/src/share/man/man9/pmap.9:30
#, no-wrap
msgid "November 4, 2009"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/deviter.9:54
#, no-wrap
msgid "DEVITER 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/deviter.9:62
msgid ""
"E<.Nm deviter>, E<.Nm deviter_first>, E<.Nm deviter_init>, E<.Nm "
"deviter_next>, E<.Nm deviter_release>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/deviter.9:62
#, no-wrap
msgid "machine-independent device iteration API"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/deviter.9:73
msgid ""
"E<.Ft void> E<.Fn deviter_init \"deviter_t *di\" \"deviter_flags_t flags\"> "
"E<.Ft device_t> E<.Fn deviter_first \"deviter_t *di\" \"deviter_flags_t "
"flags\"> E<.Ft device_t> E<.Fn deviter_next \"deviter_t *di\"> E<.Ft void> "
"E<.Fn deviter_release \"deviter_t *di\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/deviter.9:83
msgid ""
"The machine-independent E<.Nm> API lets interrupt handlers running at any "
"priority level and kernel threads iterate over the devices attached to the "
"kernel.  Using E<.Nm>, it is safe for an interrupt handler or a thread to "
"iterate over devices attached to the kernel while another thread attaches or "
"detaches the devices."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/deviter.9:87
msgid "Kernel subsystems using E<.Nm> may make use of the following data types:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/deviter.9:88
#, no-wrap
msgid "Fa deviter_flags_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/deviter.9:92
msgid ""
"The kernel can iterate over devices for different purposes and in different "
"orders.  The following flags affect device iteration:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/deviter.9:95
msgid "E<.Dv DEVITER_F_RW>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/deviter.9:97
msgid "E<.Dv DEVITER_F_SHUTDOWN>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/deviter.9:99
msgid "E<.Dv DEVITER_F_LEAVES_FIRST>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/deviter.9:101
msgid "E<.Dv DEVITER_F_ROOT_FIRST>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/deviter.9:102
#, no-wrap
msgid "Fa deviter_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/deviter.9:108
msgid ""
"This is a device iteration E<.Dq cursor> or E<.Dq iterator>.  It holds "
"iteration state such as the next device to visit."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/deviter.9:111
#, no-wrap
msgid "Fn deviter_init di flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/deviter.9:131
msgid ""
"Initialize the device iterator, E<.Fa di>.  Set bits in E<.Fa flags> to "
"affect the order of iteration.  Set E<.Dv DEVITER_F_LEAVES_FIRST> to visit "
"each device only after visiting its children (visit the leaves of the device "
"tree, first).  Set E<.Dv DEVITER_F_ROOT_FIRST> to visit each device before "
"visiting its children (visit the root of the device tree, first).  If you "
"set neither E<.Dv DEVITER_F_LEAVES_FIRST> nor E<.Dv DEVITER_F_ROOT_FIRST>, "
"E<.Nm> returns devices in an arbitrary order."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/deviter.9:143
msgid ""
"Set E<.Dv DEVITER_F_RW> if your purpose for iterating over devices is to "
"modify the device tree by attaching or detaching devices.  Set E<.Dv "
"DEVITER_F_SHUTDOWN> if your purpose for iterating over devices is to detach "
"all of the devices during system shutdown.  E<.Dv DEVITER_F_SHUTDOWN> "
"implies E<.Dv DEVITER_F_RW>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/deviter.9:143
#, no-wrap
msgid "Fn deviter_next di"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/deviter.9:158
msgid ""
"Advance the iterator E<.Fa di> to the next device.  E<.Fn deviter_next> "
"returns the current device or E<.Dv NULL> if there are no more devices.  "
"E<.Fn deviter_next> is undefined if E<.Fa di> has not been initialized using "
"E<.Fn deviter_init> or E<.Fn deviter_first>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/deviter.9:158
#, no-wrap
msgid "Fn deviter_first di flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/deviter.9:176
msgid ""
"Initialize the iterator E<.Fa di> with E<.Fa flags>.  Return the first "
"device according to the ordering indicated by E<.Fa flags> and advance E<.Fa "
"di> to the second device, or return E<.Dv NULL> if there are no devices.  "
"This is equivalent to calling E<.Fn deviter_init \"di\" \"flags\"> and then "
"E<.Fn deviter_next \"di\">."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/deviter.9:176
#, no-wrap
msgid "Fn deviter_release di"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/deviter.9:184
msgid ""
"Release all resources held by the iterator E<.Fa di>.  Every iterator that "
"is initialized with E<.Fn deviter_first> or E<.Fn deviter_init> MUST be "
"released."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/deviter.9:190
msgid ""
"Device iteration is implemented within the files E<.Pa sys/sys/device.h> and "
"E<.Pa sys/kern/subr_autoconf.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/deviter.9:193 org_netbsd/src/share/man/man9/pmf.9:289
msgid "E<.Xr autoconf 9>, E<.Xr driver 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/deviter.9:197
msgid "E<.Nm> appeared in E<.Nx 5.0>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/deviter.9:198 org_netbsd/src/share/man/man9/in_getifa.9:230 org_netbsd/src/share/man/man9/rssadapt.9:381
msgid "E<.An David Young Aq dyoung@NetBSD.org>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/disk.9:33
#, no-wrap
msgid "December 30, 2009"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/disk.9:34
#, no-wrap
msgid "DISK 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:48
msgid ""
"E<.Nm disk>, E<.Nm disk_init>, E<.Nm disk_attach>, E<.Nm disk_begindetach>, "
"E<.Nm disk_detach>, E<.Nm disk_destroy>, E<.Nm disk_busy>, E<.Nm "
"disk_unbusy>, E<.Nm disk_isbusy>, E<.Nm disk_find>, E<.Nm disk_blocksize>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/disk.9:48
#, no-wrap
msgid "generic disk framework"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/disk.9:51
#, no-wrap
msgid "sys/disklabel.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/disk.9:52
#, no-wrap
msgid "sys/disk.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:73
msgid ""
"E<.Ft void> E<.Fn disk_init \"struct disk *\" \"const char *name\" \"const "
"struct dkdriver *driver\"> E<.Ft void> E<.Fn disk_attach \"struct disk *\"> "
"E<.Ft void> E<.Fn disk_begindetach \"struct disk *\" \"int "
"(*lastclose)(device_t)\" \"device_t self\" \"int flags\"> E<.Ft void> E<.Fn "
"disk_detach \"struct disk *\"> E<.Ft void> E<.Fn disk_destroy \"struct disk "
"*\"> E<.Ft void> E<.Fn disk_busy \"struct disk *\"> E<.Ft void> E<.Fn "
"disk_unbusy \"struct disk *\" \"long bcount\" \"int read\"> E<.Ft bool> "
"E<.Fn disk_isbusy \"struct disk *\"> E<.Ft struct disk *> E<.Fn disk_find "
"\"const char *\"> E<.Ft void> E<.Fn disk_blocksize \"struct disk *\" \"int "
"blocksize\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:81
msgid ""
"The E<.Nx> generic disk framework is designed to provide flexible, scalable, "
"and consistent handling of disk state and metrics information.  The "
"fundamental component of this framework is the E<.Nm disk> structure, which "
"is defined as follows:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:92
#, no-wrap
msgid ""
"struct disk {\n"
"\tTAILQ_ENTRY(disk) dk_link;\t/* link in global disklist */\n"
"\tconst char\t*dk_name;\t/* disk name */\n"
"\tprop_dictionary_t dk_info;\t/* reference to disk-info dictionary */\n"
"\tint\t\tdk_bopenmask;\t/* block devices open */\n"
"\tint\t\tdk_copenmask;\t/* character devices open */\n"
"\tint\t\tdk_openmask;\t/* composite (bopen|copen) */\n"
"\tint\t\tdk_state;\t/* label state   ### */\n"
"\tint\t\tdk_blkshift;\t/* shift to convert DEV_BSIZE to blks */\n"
"\tint\t\tdk_byteshift;\t/* shift to convert bytes to blks */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:98
#, no-wrap
msgid ""
"\t/*\n"
"\t * Metrics data; note that some metrics may have no meaning\n"
"\t * on certain types of disks.\n"
"\t */\n"
"\tstruct io_stats\t*dk_stats;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:100
#, no-wrap
msgid "\tconst struct dkdriver *dk_driver;\t/* pointer to driver */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:107
#, no-wrap
msgid ""
"\t/*\n"
"\t * Information required to be the parent of a disk wedge.\n"
"\t */\n"
"\tkmutex_t\tdk_rawlock;\t/* lock on these fields */\n"
"\tu_int\t\tdk_rawopens;\t/* # of openes of rawvp */\n"
"\tstruct vnode\t*dk_rawvp;\t/* vnode for the RAW_PART bdev */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:112
#, no-wrap
msgid ""
"\tkmutex_t\tdk_openlock;\t/* lock on these and openmask */\n"
"\tu_int\t\tdk_nwedges;\t/* # of configured wedges */\n"
"\t\t\t\t\t/* all wedges on this disk */\n"
"\tLIST_HEAD(, dkwedge_softc) dk_wedges;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:122
#, no-wrap
msgid ""
"\t/*\n"
"\t * Disk label information.  Storage for the in-core disk label\n"
"\t * must be dynamically allocated, otherwise the size of this\n"
"\t * structure becomes machine-dependent.\n"
"\t */\n"
"\tdaddr_t\t\tdk_labelsector;\t\t/* sector containing label */\n"
"\tstruct disklabel *dk_label;\t/* label */\n"
"\tstruct cpu_disklabel *dk_cpulabel;\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:137
msgid ""
"The system maintains a global linked-list of all disks attached to the "
"system.  This list, called E<.Nm disklist>, may grow or shrink over time as "
"disks are dynamically added and removed from the system.  Drivers which "
"currently make use of the detachment capability of the framework are the "
"E<.Nm ccd>, E<.Nm dm>, and E<.Nm vnd> pseudo-device drivers."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:139 org_netbsd/src/share/man/man9/evcnt.9:149 org_netbsd/src/share/man/man9/linedisc.9:68 org_netbsd/src/share/man/man9/softintr.9:129
msgid "The following is a brief description of each function in the framework:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:140
#, no-wrap
msgid "Fn disk_init"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:142
msgid "Initialize the disk structure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:142
#, no-wrap
msgid "Fn disk_attach"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:147
msgid ""
"Attach a disk; allocate storage for the disklabel, set the E<.Dq attached "
"time> timestamp, insert the disk into the disklist, and increment the system "
"disk count."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:147
#, no-wrap
msgid "Fn disk_begindetach"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:163
msgid ""
"Check whether the disk is open, and if not, return 0.  If the disk is open, "
"and E<.Dv DETACH_FORCE> is not set in E<.Fa flags>, return E<.Dv EBUSY>.  "
"Otherwise, call the provided E<.Fa lastclose> routine E<.Po> if not E<.Dv "
"NULL> E<.Pc> and return its exit code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:163
#, no-wrap
msgid "Fn disk_detach"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:167
msgid ""
"Detach a disk; free storage for the disklabel, remove the disk from the "
"disklist, and decrement the system disk count.  If the count drops below "
"zero, panic."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:167
#, no-wrap
msgid "Fn disk_destroy"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:170
msgid "Release resources used by the disk structure when it is no longer required."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:170
#, no-wrap
msgid "Fn disk_busy"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:175
msgid ""
"Increment the disk's E<.Dq busy counter>.  If this counter goes from 0 to 1, "
"set the timestamp corresponding to this transfer."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:175
#, no-wrap
msgid "Fn disk_unbusy"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:188
msgid ""
"Decrement a disk's busy counter.  If the count drops below zero, panic.  Get "
"the current time, subtract it from the disk's timestamp, and add the "
"difference to the disk's running total.  Set the disk's timestamp to the "
"current time.  If the provided byte count is greater than 0, add it to the "
"disk's running total and increment the number of transfers performed by the "
"disk.  The third argument E<.Ar read> specifies the direction of I/O; if "
"non-zero it means reading from the disk, otherwise it means writing to the "
"disk."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:188
#, no-wrap
msgid "Fn disk_isbusy"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:192
msgid "Returns E<.Ar true> if disk is marked as busy and false if it is not."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:192
#, no-wrap
msgid "Fn disk_find"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:195
msgid ""
"Return a pointer to the disk structure corresponding to the name provided, "
"or NULL if the disk does not exist."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:195
#, no-wrap
msgid "Fn disk_blocksize"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:206
msgid ""
"Initialize E<.Fa dk_blkshift> and E<.Fa dk_byteshift> members of E<.Fa "
"struct disk> with suitable values derived from the supplied physical "
"blocksize.  It is only necessary to call this function if the device's "
"physical blocksize is not E<.Dv DEV_BSIZE>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:221
msgid ""
"The functions typically called by device drivers are E<.Fn disk_init> E<.Fn "
"disk_attach>, E<.Fn disk_begindetach>, E<.Fn disk_detach>, E<.Fn "
"disk_destroy>, E<.Fn disk_busy>, E<.Fn disk_unbusy>, and E<.Fn "
"disk_blocksize>.  The function E<.Fn disk_find> is provided as a utility "
"function."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/disk.9:221
#, no-wrap
msgid "DISK IOCTLS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:223
msgid "The following ioctls should be implemented by disk drivers:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:224
#, no-wrap
msgid "Dv DIOCGDINFO \"struct disklabel\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:226
msgid "Get disklabel."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:226
#, no-wrap
msgid "Dv DIOCSDINFO \"struct disklabel\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:228
msgid "Set in-memory disklabel."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:228
#, no-wrap
msgid "Dv DIOCWDINFO \"struct disklabel\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:230
msgid "Set in-memory disklabel and write on-disk disklabel."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:230
#, no-wrap
msgid "Dv DIOCGPART \"struct partinfo\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:233
msgid "Get partition information.  This is used internally."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:233
#, no-wrap
msgid "Dv DIOCRFORMAT \"struct format_op\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:235
msgid "Read format."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:235
#, no-wrap
msgid "Dv DIOCWFORMAT \"struct format_op\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:237
msgid "Write format."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:237
#, no-wrap
msgid "Dv DIOCSSTEP int"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:239
msgid "Set step rate."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:239
#, no-wrap
msgid "Dv DIOCSRETRIES int"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:241
msgid "Set number of retries."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:241
#, no-wrap
msgid "Dv DIOCKLABEL int"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:244
msgid ""
"Specify whether to keep or drop the in-memory disklabel when the device is "
"closed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:244
#, no-wrap
msgid "Dv DIOCWLABEL int"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:246
msgid "Enable or disable writing to the part of the disk that contains the label."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:246
#, no-wrap
msgid "Dv DIOCSBAD \"struct dkbad\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:248
msgid "Set kernel dkbad."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:248
#, no-wrap
msgid "Dv DIOCEJECT int"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:250
msgid "Eject removable disk."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:250
#, no-wrap
msgid "Dv DIOCLOCK int"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:254
msgid ""
"Lock or unlock disk pack.  For devices with removable media, locking is "
"intended to prevent the operator from removing the media."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:254
#, no-wrap
msgid "Dv DIOCGDEFLABEL \"struct disklabel\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:256
msgid "Get default label."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:256
#, no-wrap
msgid "Dv DIOCCLRLABEL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:258
msgid "Clear disk label."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:258
#, no-wrap
msgid "Dv DIOCGCACHE int"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:261
msgid ""
"Get status of disk read and write caches.  The result is a bitmask "
"containing the following values:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:262
#, no-wrap
msgid "Dv DKCACHE_READ"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:264
msgid "Read cache enabled."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:264
#, no-wrap
msgid "Dv DKCACHE_WRITE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:266
msgid "Write(back) cache enabled."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:266
#, no-wrap
msgid "Dv DKCACHE_RCHANGE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:268
msgid "Read cache enable is changeable."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:268
#, no-wrap
msgid "Dv DKCACHE_WCHANGE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:270
msgid "Write cache enable is changeable."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:270
#, no-wrap
msgid "Dv DKCACHE_SAVE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:273
msgid ""
"Cache parameters may be saved, so that they persist across reboots or device "
"detach/attach cycles."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:274
#, no-wrap
msgid "Dv DIOCSCACHE int"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:278
msgid ""
"Set status of disk read and write caches.  The input is a bitmask in the "
"same format as used for E<.Dv DIOCGCACHE>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:278
#, no-wrap
msgid "Dv DIOCCACHESYNC int"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:284
msgid ""
"Synchronise the disk cache.  This causes information in the disk's write "
"cache (if any)  to be flushed to stable storage.  The argument specifies "
"whether or not to force a flush even if the kernel believes that there is no "
"outstanding data."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:284
#, no-wrap
msgid "Dv DIOCBSLIST \"struct disk_badsecinfo\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:286
msgid "Get bad sector list."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:286
#, no-wrap
msgid "Dv DIOCBSFLUSH"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:288
msgid "Flush bad sector list."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:288
#, no-wrap
msgid "Dv DIOCAWEDGE \"struct dkwedge_info\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:290
msgid "Add wedge."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:290
#, no-wrap
msgid "Dv DIOCGWEDGEINFO \"struct dkwedge_info\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:292
msgid "Get wedge information."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:292
#, no-wrap
msgid "Dv DIOCDWEDGE \"struct dkwedge_info\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:294
msgid "Delete wedge."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:294
#, no-wrap
msgid "Dv DIOCLWEDGES \"struct dkwedge_list\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:296
msgid "List wedges."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:296
#, no-wrap
msgid "Dv DIOCGSTRATEGY \"struct disk_strategy\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:298
msgid "Get disk buffer queue strategy."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:298
#, no-wrap
msgid "Dv DIOCSSTRATEGY \"struct disk_strategy\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:300
msgid "Set disk buffer queue strategy."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/disk.9:300
#, no-wrap
msgid "Dv DIOCGDISKINFO \"struct plistref\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:302
msgid "Get disk-info dictionary."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/disk.9:303
#, no-wrap
msgid "USING THE FRAMEWORK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:308
msgid ""
"This section includes a description on basic use of the framework and "
"example usage of its functions.  Actual implementation of a device driver "
"which uses the framework may vary."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:315
msgid ""
"Each device in the system uses a E<.Dq softc> structure which contains "
"autoconfiguration and state information for that device.  In the case of "
"disks, the softc should also contain one instance of the disk structure, "
"e.g.:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:321
#, no-wrap
msgid ""
"struct foo_softc {\n"
"\tdevice_t\tsc_dev;\t\t/* generic device information */\n"
"\tstruct\tdisk\tsc_dk;\t\t/* generic disk information */\n"
"\t[ . . . more . . . ]\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:343
msgid ""
"In order for the system to gather metrics data about a disk, the disk must "
"be registered with the system.  The E<.Fn disk_attach> routine performs all "
"of the functions currently required to register a disk with the system "
"including allocation of disklabel storage space, recording of the time since "
"boot that the disk was attached, and insertion into the disklist.  Note that "
"since this function allocates storage space for the disklabel, it must be "
"called before the disklabel is read from the media or used in any other "
"way.  Before E<.Fn disk_attach> is called, a portions of the disk structure "
"must be initialized with data specific to that disk.  For example, in the "
"E<.Dq foo> disk driver, the following would be performed in the "
"autoconfiguration E<.Dq attach> routine:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:349
#, no-wrap
msgid ""
"void\n"
"fooattach(device_t parent, device_t self, void *aux)\n"
"{\n"
"\tstruct foo_softc *sc = device_private(self);\n"
"\t[ . . . ]\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:353
#, no-wrap
msgid ""
"\t/* Initialize and attach the disk structure. */\n"
"\tdisk_init(\\*[Am]sc-\\*[Gt]sc_dk, device_xname(self), "
"\\*[Am]foodkdriver);\n"
"\tdisk_attach(\\*[Am]sc-\\*[Gt]sc_dk);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:358
#, no-wrap
msgid ""
"\t/* Read geometry and fill in pertinent parts of disklabel. */\n"
"\t[ . . . ]\n"
"\tdisk_blocksize(\\*[Am]sc-\\*[Gt]sc_dk, bytes_per_sector);\n"
"}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:369
msgid ""
"The E<.Nm foodkdriver> above is the disk's E<.Dq driver> switch.  This "
"switch currently includes a pointer to the disk's E<.Dq strategy> routine.  "
"This switch needs to have global scope and should be initialized as follows:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:371
#, no-wrap
msgid "void foostrategy(struct buf *);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:375
#, no-wrap
msgid ""
"const struct dkdriver foodkdriver = {\n"
"\t.d_strategy = foostrategy,\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:397
msgid ""
"Once the disk is attached, metrics may be gathered on that disk.  In order "
"to gather metrics data, the driver must tell the framework when the disk "
"starts and stops operations.  This functionality is provided by the E<.Fn "
"disk_busy> and E<.Fn disk_unbusy> routines.  Because E<.Nm struct disk> is "
"part of device driver private data it needs to be guarded.  Mutual exclusion "
"must be done by driver E<.Fn disk_busy> and E<.Fn disk_unbusy> are not "
"thread safe.  The E<.Fn disk_busy> routine should be called immediately "
"before a command to the disk is sent, e.g.:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:403
#, no-wrap
msgid ""
"void\n"
"foostart(sc)\n"
"\tstruct foo_softc *sc;\n"
"{\n"
"\t[ . . . ]\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:406
#, no-wrap
msgid ""
"\t/* Get buffer from drive's transfer queue. */\n"
"\t[ . . . ]\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:409
#, no-wrap
msgid ""
"\t/* Build command to send to drive. */\n"
"\t[ . . . ]\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:414
#, no-wrap
msgid ""
"\t/* Tell the disk framework we're going busy. */\n"
"\tmutex_enter(\\*[Am]sc-\\*[Gt]sc_dk_mtx);\n"
"\tdisk_busy(\\*[Am]sc-\\*[Gt]sc_dk);\n"
"\tmutex_exit(\\*[Am]sc-\\*[Gt]sc_dk_mtx);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:418
#, no-wrap
msgid ""
"\t/* Send command to the drive. */\n"
"\t[ . . . ]\n"
"}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:446
msgid ""
"When E<.Fn disk_busy> is called, a timestamp is taken if the disk's busy "
"counter moves from 0 to 1, indicating the disk has gone from an idle to "
"non-idle state.  At the end of a transaction, the E<.Fn disk_unbusy> routine "
"should be called.  This routine performs some consistency checks, such as "
"ensuring that the calls to E<.Fn disk_busy> and E<.Fn disk_unbusy> are "
"balanced.  This routine also performs the actual metrics calculation.  A "
"timestamp is taken and the difference from the timestamp taken in E<.Fn "
"disk_busy> is added to the disk's total running time.  The disk's timestamp "
"is then updated in case there is more than one pending transfer on the "
"disk.  A byte count is also added to the disk's running total, and if "
"greater than zero, the number of transfers the disk has performed is "
"incremented.  The third argument E<.Ar read> specifies the direction of I/O; "
"if non-zero it means reading from the disk, otherwise it means writing to "
"the disk."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:455
#, no-wrap
msgid ""
"void\n"
"foodone(xfer)\n"
"\tstruct foo_xfer *xfer;\n"
"{\n"
"\tstruct foo_softc = (struct foo_softc *)xfer-\\*[Gt]xf_softc;\n"
"\tstruct buf *bp = xfer-\\*[Gt]xf_buf;\n"
"\tlong nbytes;\n"
"\t[ . . . ]\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:465
#, no-wrap
msgid ""
"\t/*\n"
"\t * Get number of bytes transferred.  If there is no buf\n"
"\t * associated with the xfer, we are being called at the\n"
"\t * end of a non-I/O command.\n"
"\t */\n"
"\tif (bp == NULL)\n"
"\t\tnbytes = 0;\n"
"\telse\n"
"\t\tnbytes = bp-\\*[Gt]b_bcount - bp-\\*[Gt]b_resid;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:467 org_netbsd/src/share/man/man9/evcnt.9:248
#, no-wrap
msgid "\t[ . . . ]\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:473
#, no-wrap
msgid ""
"\tmutex_enter(\\*[Am]sc-\\*[Gt]sc_dk_mtx);\n"
"\t/* Notify the disk framework that we've completed the transfer. */\n"
"\tdisk_unbusy(\\*[Am]sc-\\*[Gt]sc_dk, nbytes,\n"
"\t    bp != NULL ? bp-\\*[Gt]b_flags \\*[Am] B_READ : 0);\n"
"\tmutex_exit(\\*[Am]sc-\\*[Gt]sc_dk_mtx);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:476 org_netbsd/src/share/man/man9/evcnt.9:259
#, no-wrap
msgid ""
"\t[ . . . ]\n"
"}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:486
msgid ""
"E<.Fn disk_isbusy> is used to get status of disk device it returns true if "
"device is currently busy and false if it is not.  Like E<.Fn disk_busy> and "
"E<.Fn disk_unbusy> it requires explicit locking from user side."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:491
msgid ""
"The disk framework itself is implemented within the file E<.Pa "
"sys/kern/subr_disk.c>.  Data structures and function prototypes for the "
"framework are located in E<.Pa sys/sys/disk.h>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:500
msgid ""
"The E<.Nx> machine-independent SCSI disk and CD-ROM drivers use the disk "
"framework.  They are located in E<.Pa sys/scsi/sd.c> and E<.Pa "
"sys/scsi/cd.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:513
msgid ""
"The E<.Nx> E<.Nm ccd>, E<.Nm dm>, and E<.Nm vnd> drivers use the detachment "
"capability of the framework.  They are located in E<.Pa sys/dev/ccd.c>, "
"E<.Pa sys/dev/vnd.c>, and E<.Pa sys/dev/dm/device-mapper.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:517
msgid "E<.Xr ccd 4>, E<.Xr dm 4>, E<.Xr vnd 4>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:522
msgid "The E<.Nx> generic disk framework appeared in E<.Nx 1.2>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disk.9:527
msgid ""
"The E<.Nx> generic disk framework was architected and implemented by E<.An "
"Jason R. Thorpe> E<.Aq thorpej@NetBSD.org>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/disklabel.9:30
#, no-wrap
msgid "December 26, 1996"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/disklabel.9:31
#, no-wrap
msgid "DISKLABEL 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disklabel.9:39
msgid ""
"E<.Nm disklabel>, E<.Nm readdisklabel>, E<.Nm writedisklabel>, E<.Nm "
"setdisklabel>, E<.Nm bounds_check_with_label>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/disklabel.9:39
#, no-wrap
msgid "disk label management routines"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disklabel.9:49
msgid ""
"E<.Ft char *> E<.Fn readdisklabel \"dev_t dev\" \"void (*strat)(struct buf "
"*)\" \"struct disklabel *lp\" \"struct cpu_disklabel *clp\"> E<.Ft int> "
"E<.Fn writedisklabel \"dev_t dev\" \"void (*strat)(struct buf *)\" \"struct "
"disklabel *lp\" \"struct cpu_disklabel *clp\"> E<.Ft int> E<.Fn setdisklabel "
"\"struct disklabel *olp\" \"struct disklabel *nlp\" \"u_long openmask\" "
"\"struct cpu_disklabel *clp\"> E<.Ft int> E<.Fn bounds_check_with_label "
"\"struct buf *bp\" \"struct disklabel *lp\" \"int wlabel\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disklabel.9:56
msgid ""
"This collection of routines provides a disklabel management interface to "
"kernel device drivers.  These routines are classified as machine- or "
"architecture-dependent because of restrictions imposed by the machine "
"architecture and boot-strapping code on the location of the label, or "
"because cooperation with other operating systems requires specialized "
"conversion code."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disklabel.9:89
msgid ""
"E<.Fn readdisklabel> attempts to read a disklabel from the device identified "
"by E<.Fa dev>, using the device strategy routine passed in E<.Fa strat>.  "
"Note that a buffer structure is required to pass to the strategy routine; it "
"needs to be acquired and parameterized for the intended I/O operation, and "
"disposed of when the operation has completed.  Some fields in the disklabel "
"passed in E<.Fa lp> may be pre-initialized by the caller in order to meet "
"device driver requirements for the I/O operation initiated to get to the "
"disklabel data on the medium.  In particular, the field E<.Dq d_secsize>, if "
"non-zero, is used by E<.Fn readdisklabel> to get an appropriately sized "
"buffer to pass to the device strategy routine.  Unspecified fields in E<.Fa "
"lp> should be set to zero.  If the medium does not contain a native "
"disklabel that can be read in directly, E<.Fn readdisklabel> may resort to "
"constructing a label from other machine-dependent information using the "
"provided buffer passed in the E<.Fa clp> argument.  If a disk label can not "
"be found or constructed, a string containing an approximated description of "
"the failure mode is returned.  Otherwise the E<.Dv NULL> string is returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disklabel.9:116
msgid ""
"E<.Fn writedisklabel> stores disk label information contained in the disk "
"label structure given by E<.Fa lp> on the device identified by E<.Fa dev>.  "
"Like E<.Fn readdisklabel>, it acquires and sets up an I/O buffer to pass to "
"the strategy routine E<.Fa strat>.  E<.Fn writedisklabel> may elect to do a "
"machine-dependent conversion of the native disk label structure E<.Po> using "
"the buffer pointed at by E<.Fa clp> E<.Pc>, to store the disk label onto the "
"medium in a format complying with architectural constraints.  E<.Fn "
"writedisklabel> returns 0 on success and E<.Dv EINVAL> if the disk label "
"specifies invalid or inconvertible values.  Otherwise, any error condition "
"reported by the device strategy routine in the buffer's E<.Dq Va b_error> "
"field is returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disklabel.9:138
msgid ""
"E<.Fn setdisklabel> checks a proposed new disk label passed in E<.Fa nlp> "
"for some amount of basic sanity.  This includes a check on attempts to "
"change the location, or reduce the size, of an existing disk partition that "
"is currently in use by the system.  The current disposition of the disk "
"partitions is made available through E<.Fa olp> and E<.Fa openmask>, which "
"provide, respectively, the existing disk label and a bit mask identifying "
"the partitions that are currently in use.  Failure to pass on E<.Dq basic "
"sanity>, results in a E<.Dv EINVAL> return value, while a vetoed update of "
"the partition layout is signaled by a E<.Dv EBUSY> return value.  Otherwise, "
"0 is returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disklabel.9:180
msgid ""
"E<.Fn bounds_check_with_label> is used to check whether a device transfer "
"described by E<.Fa bp> to the device identified by E<.Fa dev>, is properly "
"contained within a disk partition of the disk with label E<.Fa lp>.  If this "
"check fails, E<.Fn bounds_check_with_label> sets the buffer's E<.Dq Va "
"b_error> field to E<.Dv EINVAL>, sets the E<.Dv B_ERROR> flag in E<.Dq Va "
"b_flags>, and returns -1.  If the argument E<.Fa wlabel> is zero, and the "
"transfer is a write operation, a check is done if the transfer would "
"overwrite E<.Pq a portion of> the disklabel area on the medium.  If that is "
"the case, E<.Dv EROFS> is set in E<.Dq Va b_error>, the E<.Dv B_ERROR> flag "
"is set in E<.Dq Va b_flags>, and -1 is returned.  Note that E<.Fa wlabel> "
"should be set to a non-zero value if the intended operation is expected to "
"install or update the disk label.  Programs that intend to do so using the "
"raw device interface should notify the driver by using a E<.Dv DIOCWLABEL> "
"ioctl function."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/disklabel.9:182
msgid "E<.Xr disklabel 5>, E<.Xr disklabel 8>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/dmover.9:36
#, no-wrap
msgid "December 4, 2007"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/dmover.9:37
#, no-wrap
msgid "DMOVER 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:48
msgid ""
"E<.Nm dmover_backend_register>, E<.Nm dmover_backend_unregister>, E<.Nm "
"dmover_session_create>, E<.Nm dmover_session_destroy>, E<.Nm "
"dmover_request_alloc>, E<.Nm dmover_request_free>, E<.Nm dmover_process>, "
"E<.Nm dmover_done>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/dmover.9:48
#, no-wrap
msgid "hardware-assisted data mover interface"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/dmover.9:50
#, no-wrap
msgid "dev/dmover/dmovervar.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:53
msgid "Client interface routines:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:64
msgid ""
"E<.Ft int> E<.Fn \"dmover_session_create\" \"const char *\" \"struct "
"dmover_session **\"> E<.Ft void> E<.Fn \"dmover_session_destroy\" \"struct "
"dmover_session *\"> E<.Ft \"struct dmover_request *\"> E<.Fn "
"\"dmover_request_alloc\" \"struct dmover_session *\" \"dmover_buffer *\"> "
"E<.Ft void> E<.Fn \"dmover_request_free\" \"struct dmover_request *\"> E<.Ft "
"void> E<.Fn \"dmover_process\" \"struct dmover_request *\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:66
msgid "Back-end interface routines:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:73
msgid ""
"E<.Ft void> E<.Fn \"dmover_backend_register\" \"struct dmover_backend *\"> "
"E<.Ft void> E<.Fn \"dmover_backend_unregister\" \"struct dmover_backend *\"> "
"E<.Ft void> E<.Fn \"dmover_done\" \"struct dmover_request *\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:81
msgid ""
"The E<.Nm dmover> facility provides an interface to hardware-assisted data "
"movers.  This can be used to copy data from one location in memory to "
"another, clear a region of memory, fill a region of memory with a pattern, "
"and perform simple operations on multiple regions of memory, such as an XOR, "
"without intervention by the CPU."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:93
msgid ""
"The drivers for hardware-assisted data movers present themselves to E<.Nm "
"dmover> by registering their capabilities.  When a client wishes to use a "
"E<.Nm dmover> function, it creates a session for that function, which "
"identifies back-ends capable of performing that function.  The client then "
"enqueues requests on that session, which the back-ends process "
"asynchronously.  The client may choose to block until the request is "
"completed, or may have a call-back invoked once the request has been "
"completed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:103
msgid ""
"When a client creates a session, the E<.Nm dmover> facility identifies "
"back-ends which are capable of handling the requested function.  When a "
"request is scheduled for processing, the E<.Nm dmover> scheduler will "
"identify the best back-end to process the request from the list of candidate "
"back-ends, in an effort to provide load balancing, while considering the "
"relative performance of each back-end."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:116
msgid ""
"A E<.Nm dmover> function always has one output region.  A function may have "
"zero or more input regions, or may use an immediate value as an input.  For "
"functions which use input regions, the lengths of each input region and the "
"output region must be the same.  All E<.Nm dmover> functions with the same "
"name will have the same number of and type inputs.  If a back-end attempts "
"to register a function which violates this invariant, behavior is undefined."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:123
msgid ""
"The E<.Nm dmover> facility supports several types of buffer descriptors.  "
"For functions which use input regions, each input buffer descriptor and the "
"output buffer descriptor must be of the same type.  This restriction may be "
"removed in a future revision of the interface."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:132
msgid ""
"The E<.Nm dmover> facility may need to interrupt request processing and "
"restart it.  Clients of the E<.Nm dmover> facility should take care to avoid "
"unwanted side-effects should this occur.  In particular, for functions which "
"use input regions, no input region may overlap with the output region."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/dmover.9:132 org_netbsd/src/share/man/man9/rssadapt.9:265
#, no-wrap
msgid "DATA STRUCTURES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:137
msgid ""
"The E<.Nm dmover> facility shares several data structures between the client "
"and back-end in order to describe sessions and requests."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:142
#, no-wrap
msgid ""
"typedef enum {\n"
"\tDMOVER_BUF_LINEAR,\n"
"\tDMOVER_BUF_UIO\n"
"} dmover_buffer_type;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:147
#, no-wrap
msgid ""
"typedef struct {\n"
"\tvoid *l_addr;\n"
"\tsize_t l_len;\n"
"} dmover_buf_linear;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:152
#, no-wrap
msgid ""
"typedef union {\n"
"\tdmover_buf_linear dmbuf_linear;\n"
"\tstruct uio *dmbuf_uio;\n"
"} dmover_buffer;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:161
msgid ""
"Together, these data types are used to describe buffer data structures which "
"the E<.Nm dmover> facility understands.  Additional buffer types may be "
"added in future revisions of the E<.Nm dmover> interface."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:167
msgid ""
"The E<.Fa dmover_assignment> structure contains the information about the "
"back-end to which a request is currently assigned.  It contains the "
"following public members:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:168
#, no-wrap
msgid "struct dmover_backend *das_backend"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:170
msgid "This is a pointer to the back-end."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:170
#, no-wrap
msgid "const struct dmover_algdesc *das_algdesc"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:173
msgid ""
"This is a pointer to the algorithm description provided by the back-end for "
"the request's function."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:178
msgid "The E<.Fa dmover_session> structure contains the following public members:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:179
#, no-wrap
msgid "void *dses_cookie"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:181
msgid "This is a pointer to client private data."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:181
#, no-wrap
msgid "int dses_ninputs"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:183
msgid "This is the number of inputs used by the selected function."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:188
msgid "The E<.Fa dmover_request> structure contains the following public members:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:189
#, no-wrap
msgid "TAILQ_ENTRY(dmover_request) dreq_dmbq"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:191
msgid "Linkage on the back-end's queue of pending requests."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:191
#, no-wrap
msgid "struct dmover_session *dreq_session"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:194
msgid ""
"Pointer to the session with which this request is associated.  This is "
"intended for use by the back-end."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:194
#, no-wrap
msgid "struct dmover_assignment *dreq_assignment"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:201
msgid ""
"Pointer to the E<.Fa dmover_assignment> structure which describes the "
"back-end to which the request is currently assigned.  The back-end is "
"assigned when the request is scheduled with E<.Fn dmover_process>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:201
#, no-wrap
msgid "void (*dreq_callback)(struct dmover_request *)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:211
msgid ""
"This is a pointer to an optional call-back function provided by the client.  "
"If provided, the call-back is invoked when the request is complete.  This "
"field must be E<.Dv NULL> if E<.Em DMOVER_REQ_WAIT> is set in E<.Em "
"dreq_flags>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:211
#, no-wrap
msgid "void *dreq_cookie"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:213
msgid "This is a pointer to client private data specific to the request."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:213
#, no-wrap
msgid "void *dreq_dmbcookie"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:216
msgid ""
"This is a pointer to back-end private data, for use while the back-end is "
"actively processing a request."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:216
#, no-wrap
msgid "volatile int dreq_flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:218
msgid "The following flags are defined:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:219
#, no-wrap
msgid "DMOVER_REQ_DONE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:223
msgid ""
"The request has been completed.  If not using a call-back, the client may "
"poll this bit to determine if a request has been processed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:223
#, no-wrap
msgid "DMOVER_REQ_ERROR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:225
msgid "An error has occurred while processing the request."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:225
#, no-wrap
msgid "DMOVER_REQ_RUNNING"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:228
msgid ""
"The request is currently being executed by the back-end.  Once a command is "
"running, it cannot be cancelled, and must run to completion."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:228
#, no-wrap
msgid "DMOVER_REQ_WAIT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:235
msgid ""
"If set by the client, E<.Fn dmover_process> will wait for the request to "
"complete using E<.Xr cv_wait 9>.  This flag may only be used if the caller "
"has a valid thread context.  If this flag is set, a callback may not be "
"used."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:236
#, no-wrap
msgid "int dreq_error"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:242
msgid ""
"If the E<.Em DMOVER_REQ_ERROR> bit is set, this contains the E<.Xr errno 2> "
"value indicating the error that occurred during processing."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:242
#, no-wrap
msgid "dmover_buffer_type dreq_outbuf_type"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:244
msgid "The type of the output buffer."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:244
#, no-wrap
msgid "dmover_buffer dreq_outbuf"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:246
msgid "The output buffer."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:246
#, no-wrap
msgid "uint8_t dreq_immediate[8]"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:250
msgid ""
"This is the input for algorithms which use an immediate value.  Values "
"smaller than 8 bytes should use the least-significant bytes first.  For "
"example, a 32-bit integer would occupy bytes 0, 1, 2, and 3."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:250
#, no-wrap
msgid "dmover_buffer_type dreq_inbuf_type"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:255
msgid ""
"The type of the input buffer.  This is only used if the E<.Nm dmover> "
"function has one or more inputs."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:255
#, no-wrap
msgid "dmover_buffer *dreq_inbuf"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:262
msgid ""
"A pointer to an array of input buffers.  This is only used if the E<.Nm "
"dmover> function has one or more inputs.  The number of inputs, and thus the "
"number of valid elements in the array, is specified by the algorithm "
"description for the session."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/dmover.9:263
#, no-wrap
msgid "CLIENT INTERFACE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:265
msgid "The following functions are provided to the client:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:266
#, no-wrap
msgid "Fn dmover_session_create function sessionp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:275
msgid ""
"The E<.Fn dmover_session_create> function creates a data mover session for "
"the specified data movement function E<.Fa function>.  A handle to the new "
"session is returned in E<.Fa sessionp>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:277
msgid "The following are valid data movement function names:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:278
#, no-wrap
msgid "Dq zero"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:281
msgid "Fill a memory region with zeros.  This algorithm has an input count of 0."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:281
#, no-wrap
msgid "Dq fill8"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:289
msgid ""
"Fill a memory region with an 8-bit pattern.  This algorithm has an input "
"count of 0.  The pattern is provided in the E<.Em dreq_imm8> member of the "
"E<.Fa dmover_request> structure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:289
#, no-wrap
msgid "Dq copy"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:292
msgid ""
"Copy a memory region from one location to another.  This algorithm has an "
"input count of 1."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:292
#, no-wrap
msgid "Dq xor2"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:295
msgid ""
"Perform an XOR operation on 2 inputs.  This algorithm has an input count of "
"2."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:295
#, no-wrap
msgid "Dq xor3"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:298
msgid ""
"Perform an XOR operation on 3 inputs.  This algorithm has an input count of "
"3."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:298
#, no-wrap
msgid "Dq xor4"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:301
msgid ""
"Perform an XOR operation on 4 inputs.  This algorithm has an input count of "
"4."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:301
#, no-wrap
msgid "Dq xor5"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:304
msgid ""
"Perform an XOR operation on 5 inputs.  This algorithm has an input count of "
"5."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:304
#, no-wrap
msgid "Dq xor6"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:307
msgid ""
"Perform an XOR operation on 6 inputs.  This algorithm has an input count of "
"6."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:307
#, no-wrap
msgid "Dq xor7"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:310
msgid ""
"Perform an XOR operation on 7 inputs.  This algorithm has an input count of "
"7."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:310
#, no-wrap
msgid "Dq xor8"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:313
msgid ""
"Perform an XOR operation on 8 inputs.  This algorithm has an input count of "
"8."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:320
msgid ""
"Users of the E<.Nm dmover> facility are encouraged to use the following "
"aliases for the well-known function names, as doing so saves space and "
"reduces the chance of programming errors:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:321
#, no-wrap
msgid "DMOVER_FUNC_ZERO"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:324
msgid "E<.Dq zero> E<.Pq Va dmover_funcname_zero>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:324
#, no-wrap
msgid "DMOVER_FUNC_FILL8"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:327
msgid "E<.Dq fill8> E<.Pq Va dmover_funcname_fill8>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:327
#, no-wrap
msgid "DMOVER_FUNC_COPY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:330
msgid "E<.Dq copy> E<.Pq Va dmover_funcname_copy>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:330
#, no-wrap
msgid "DMOVER_FUNC_XOR2"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:333
msgid "E<.Dq xor2> E<.Pq Va dmover_funcname_xor2>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:333
#, no-wrap
msgid "DMOVER_FUNC_XOR3"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:336
msgid "E<.Dq xor3> E<.Pq Va dmover_funcname_xor3>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:336
#, no-wrap
msgid "DMOVER_FUNC_XOR4"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:339
msgid "E<.Dq xor4> E<.Pq Va dmover_funcname_xor4>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:339
#, no-wrap
msgid "DMOVER_FUNC_XOR5"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:342
msgid "E<.Dq xor5> E<.Pq Va dmover_funcname_xor5>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:342
#, no-wrap
msgid "DMOVER_FUNC_XOR6"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:345
msgid "E<.Dq xor6> E<.Pq Va dmover_funcname_xor6>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:345
#, no-wrap
msgid "DMOVER_FUNC_XOR7"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:348
msgid "E<.Dq xor7> E<.Pq Va dmover_funcname_xor7>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:348
#, no-wrap
msgid "DMOVER_FUNC_XOR8"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:351
msgid "E<.Dq xor8> E<.Pq Va dmover_funcname_xor8>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:352
#, no-wrap
msgid "Fn dmover_session_destroy session"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:358
msgid ""
"The E<.Fn dmover_session_destroy> function tears down a data mover session "
"and releases all resources associated with it."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:358
#, no-wrap
msgid "Fn dmover_request_alloc session inbuf"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:380
msgid ""
"The E<.Fn dmover_request_alloc> function allocates a E<.Nm dmover> request "
"structure and associates it with the specified session.  If the E<.Fa inbuf> "
"argument is not E<.Dv NULL>, E<.Fa inbuf> is used as the array of input "
"buffer descriptors in the request.  Otherwise, if E<.Fa inbuf> is E<.Dv "
"NULL> and the E<.Nm dmover> function requires input buffers, the input "
"buffer descriptors will be allocated automatically using E<.Xr malloc 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:386
msgid ""
"If the request structure or input buffer descriptors cannot be allocated, "
"E<.Fn dmover_request_alloc> return E<.Dv NULL> to indicate failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:386
#, no-wrap
msgid "Fn dmover_request_free req"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:401
msgid ""
"The E<.Fn dmover_request_free> function frees a E<.Nm dmover> request "
"structure.  If the E<.Nm dmover> function requires input buffers, and the "
"input buffer descriptors associated with E<.Fa req> were allocated by E<.Fn "
"dmover_request_alloc>, then the input buffer descriptors will also be freed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:401
#, no-wrap
msgid "Fn dmover_process req"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:412
msgid ""
"The E<.Fn dmover_process> function submits the E<.Nm dmover> request E<.Fa "
"req> for processing.  The call-back specified by the request is invoked when "
"processing is complete."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:419
msgid ""
"The E<.Fn dmover_session_create> and E<.Fn dmover_session_destroy> functions "
"must not be called from interrupt context."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:431
msgid ""
"The E<.Fn dmover_request_alloc>, E<.Fn dmover_request_free>, and E<.Fn "
"dmover_process> functions may be called from interrupt handlers at levels "
"E<.Em IPL_VM>, E<.Em IPL_SOFTCLOCK>, and E<.Em IPL_SOFTNET>, or in "
"non-interrupt context."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:435
msgid ""
"The request completion call-back is called from a software interrupt handler "
"at E<.Em IPL_SOFTCLOCK>."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/dmover.9:435
#, no-wrap
msgid "BACK-END INTERFACE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:441
msgid ""
"A back-end describes the E<.Nm dmover> functions it can perform using an "
"array of E<.Fa dmover_algdesc> structures:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:447
#, no-wrap
msgid ""
"struct dmover_algdesc {\n"
"\tconst char *dad_name;\t/* algorithm name */\n"
"\tvoid *dad_data;\t\t/* opaque algorithm description */\n"
"\tint dad_ninputs;\t/* number of inputs */\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:457
msgid ""
"The E<.Em dad_name> member points to a valid E<.Nm dmover> function name "
"which the client may specify.  The E<.Em dad_data> member points to a "
"back-end-specific description of the algorithm."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:464
msgid ""
"A back-end presents itself to the E<.Nm dmover> facility using the E<.Fa "
"dmover_backend> structure.  The back-end must initialize the following "
"members of the structure:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:465
#, no-wrap
msgid "const char *dmb_name"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:467
msgid "This is the name of the back-end."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:467
#, no-wrap
msgid "u_int dmb_speed"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:470
msgid ""
"This is an estimate of the number of kilobytes/second that the back-end can "
"process."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:470
#, no-wrap
msgid "void *dmb_cookie"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:472
msgid "This is a pointer to back-end private data."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:472
#, no-wrap
msgid "const struct dmover_algdesc *dmb_algdescs"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:476
msgid ""
"This points to an array of E<.Fa dmover_algdesc> structures which describe "
"the functions the data mover can perform."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:476
#, no-wrap
msgid "int dmb_nalgdescs"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:480
msgid "This is the number of elements in the E<.Em dmb_algdescs> array."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:480
#, no-wrap
msgid "void (*dmb_process)(struct dmover_backend *)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:482
msgid "This is the entry point to the back-end used to process requests."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:491
msgid ""
"When invoked by the E<.Nm dmover> facility, the back-end's E<.Fn "
"(*dmb_process)> function should examine the pending request queue in its "
"E<.Fa dmover_backend> structure:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:492
#, no-wrap
msgid "TAILQ_HEAD(, dmover_request) dmb_pendreqs"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:494
msgid "This is the queue of pending requests."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:494
#, no-wrap
msgid "int dmb_npendreqs"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:498
msgid "This is the number of requests in the E<.Em dmb_pendreqs> queue."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:509
msgid ""
"If an error occurs when processing the request, the E<.Em DMOVER_REQ_ERROR> "
"bit must be set in the E<.Em dreq_flags> member of the request, and the "
"E<.Em dreq_error> member set to an E<.Xr errno 2> value to indicate the "
"error."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:515
msgid ""
"When the back-end has finished processing the request, it must call the "
"E<.Fn dmover_done> function.  This function eventually invokes the client's "
"call-back routine."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:518
msgid ""
"If a hardware-assisted data mover uses interrupts, the interrupt handlers "
"should be registered at IPL_VM."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:520
msgid "The following functions are provided to the back-ends:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:521
#, no-wrap
msgid "Fn dmover_backend_register backend"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:530
msgid ""
"The E<.Fn dmover_backend_register> function registers the back-end E<.Fa "
"backend> with the E<.Nm dmover> facility."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:530
#, no-wrap
msgid "Fn dmover_backend_unregister backend"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:540
msgid ""
"The E<.Fn dmover_backend_unregister> function removes the back-end E<.Fa "
"backend> from the E<.Nm dmover> facility.  The back-end must already be "
"registered."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/dmover.9:540
#, no-wrap
msgid "Fn dmover_done req"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:546
msgid ""
"The E<.Fn dmover_done> function is called by the back-end when it has "
"finished processing a request, whether the request completed successfully or "
"not."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:553
msgid ""
"The E<.Fn dmover_backend_register> and E<.Fn dmover_backend_unregister> "
"functions must not be called from interrupt context."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:561
msgid ""
"The E<.Fn dmover_done> function may be called at E<.Em IPL_VM>, E<.Em "
"IPL_SOFTCLOCK>, E<.Em IPL_SOFTNET>, or in non-interrupt context."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:568
msgid ""
"The following is an example of a client using E<.Nm dmover> to zero-fill a "
"region of memory.  In this example, the CPU will be able to context switch "
"to another thread and perform work while the hardware-assisted data mover "
"clears the specified block of memory."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:575
#, no-wrap
msgid ""
"int\n"
"hw_bzero(void *buf, size_t len)\n"
"{\n"
"\tstruct dmover_session *dses;\n"
"\tstruct dmover_request *dreq;\n"
"\tint error;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:579
#, no-wrap
msgid ""
"\terror = dmover_session_create(DMOVER_FUNC_ZERO, \\*[Am]dses);\n"
"\tif (error)\n"
"\t\treturn (error);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:585
#, no-wrap
msgid ""
"\tdreq = dmover_request_alloc(dses, NULL);\n"
"\tif (dreq == NULL) {\n"
"\t\tdmover_session_destroy(dses);\n"
"\t\treturn (ENOMEM);\n"
"\t}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:591
#, no-wrap
msgid ""
"\tdreq-\\*[Gt]dreq_flags = DMOVER_REQ_WAIT;\n"
"\tdreq-\\*[Gt]dreq_callback = NULL;\n"
"\tdreq-\\*[Gt]dreq_outbuf.dreq_outbuf_type = DMOVER_BUF_LINEAR;\n"
"\tdreq-\\*[Gt]dreq_outbuf.dmbuf_linear.l_addr = buf;\n"
"\tdreq-\\*[Gt]dreq_outbuf.dmbuf_linear.l_len = len;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:593
#, no-wrap
msgid "\tdmover_process(dreq);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:596
#, no-wrap
msgid ""
"\terror = (dreq-\\*[Gt]dreq_flags \\*[Am] DMOVER_REQ_ERROR) ?\n"
"\t    dreq-\\*[Gt]dreq_error : 0;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:599
#, no-wrap
msgid ""
"\tdmover_request_free(dreq);\n"
"\tdmover_session_destroy(dses);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:602
#, no-wrap
msgid ""
"\treturn (error);\n"
"}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:606
msgid "E<.Xr queue 3>, E<.Xr dmoverio 4>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:611
msgid "The E<.Nm dmover> facility first appeared in E<.Nx 2.0>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:618
msgid ""
"The E<.Nm dmover> facility was designed and implemented by E<.An Jason "
"R. Thorpe> E<.Aq thorpej@wasabisystems.com> and contributed by Wasabi "
"Systems, Inc."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dmover.9:622
msgid ""
"The mechanism by which a back-end should advertise its performance to the "
"request scheduler is not well-defined.  Therefore, the load-balancing "
"mechanism within the request scheduler is also not well-defined."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/do_setresuid.9:31
#, no-wrap
msgid "September 28, 2003"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/do_setresuid.9:32
#, no-wrap
msgid "DO_SETRESUID 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/do_setresuid.9:37
msgid "E<.Nm do_setresuid>, E<.Nm do_setresgid>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/do_setresuid.9:37
#, no-wrap
msgid "set process uid and gid"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/do_setresuid.9:39
#, no-wrap
msgid "sys/ucred.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/do_setresuid.9:44
msgid ""
"E<.Ft int> E<.Fn do_setresuid \"struct lwp *lwp\" \"uid_t ruid\" \"uid_t "
"euid\" \"uid_t svuid\" \"u_int flags\"> E<.Ft int> E<.Fn do_setresgid "
"\"struct lwp *lwp\" \"uid_t ruid\" \"uid_t euid\" \"uid_t svuid\" \"u_int "
"flags\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/do_setresuid.9:51
msgid ""
"The E<.Nm do_setresuid> and E<.Nm do_setresgid> functions are used to "
"implement the various system calls that allow a process to change its real, "
"effective, and saved uid and gid values."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/do_setresuid.9:61
msgid ""
"The E<.Nm do_setresuid> function sets the specified processes real user ID "
"to E<.Ar ruid>, its effective user ID to E<.Ar euid>, and its saved user ID "
"to E<.Ar svuid>.  If any of the uid arguments are \\-1 then that assignment "
"is skipped."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/do_setresuid.9:68
msgid ""
"If E<.Fn suser> is true, then any values may be assigned, otherwise the new "
"uid values must match one of the existing values and the caller must have "
"set the relevant bit in E<.Ar flags>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/do_setresuid.9:75
msgid ""
"The E<.Ar flags> argument specifies which of the existing uid values the new "
"value must match.  It should be set to a logical OR of "
"ID_{R,E,S}_EQ_{R,E,S}, where ID_E_EQ_R means that it is valid to set the "
"effective ID to the current value of the real ID."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/do_setresuid.9:81
msgid ""
"The E<.Nm do_setresgid> function sets the group IDs but otherwise behaves in "
"the same manner as E<.Nm>.  The processes group list is neither examined nor "
"effected."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/do_setresuid.9:86
msgid "E<.Xr setregid 2>, E<.Xr setreuid 2>, E<.Xr setuid 2>, E<.Xr suser 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/do_setresuid.9:89
msgid "These functions are implemented in: E<.Pa sys/kern/kern_prot.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/do_setresuid.9:93
msgid ""
"Implemented for E<.Nx 2.0> to replace ad-hoc code in each system call "
"routine and in the various compat modules."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/dofileread.9:30 org_netbsd/src/share/man/man9/fsetown.9:30 org_netbsd/src/share/man/man9/radio.9:27 org_netbsd/src/share/man/man9/scsipi.9:27 org_netbsd/src/share/man/man9/ucom.9:30 org_netbsd/src/share/man/man9/userret.9:30 org_netbsd/src/share/man/man9/wskbd.9:30
#, no-wrap
msgid "December 20, 2005"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/dofileread.9:31
#, no-wrap
msgid "DOFILEREAD 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dofileread.9:38
msgid ""
"E<.Nm dofileread>, E<.Nm dofilereadv>, E<.Nm dofilewrite>, E<.Nm "
"dofilewritev>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/dofileread.9:38
#, no-wrap
msgid "high-level file operations"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/dofileread.9:40 org_netbsd/src/share/man/man9/file.9:43 org_netbsd/src/share/man/man9/filedesc.9:53 org_netbsd/src/share/man/man9/fsetown.9:39 org_netbsd/src/share/man/man9/vnfileops.9:45
#, no-wrap
msgid "sys/file.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dofileread.9:56
msgid ""
"E<.Ft int> E<.Fn dofileread \"struct lwp *l\" \"int fd\" \"struct file *fp\" "
"\"void *buf\" \"size_t nbyte\" \"off_t *offset\" \"int flags\" \"register_t "
"*retval\"> E<.Ft int> E<.Fn dofilewrite \"struct lwp *l\" \"int fd\" "
"\"struct file *fp\" \"const void *buf\" \"size_t nbyte\" \"off_t *offset\" "
"\"int flags\" \"register_t *retval\"> E<.Ft int> E<.Fn dofilereadv \"struct "
"lwp *l\" \"int fd\" \"struct file *fp\" \"const struct iovec *iovp\" \"int "
"iovcnt\" \"off_t *offset\" \"int flags\" \"register_t *retval\"> E<.Ft int> "
"E<.Fn dofilewritev \"struct lwp *l\" \"int fd\" \"struct file *fp\" \"const "
"struct iovec *iovp\" \"int iovcnt\" \"off_t *offset\" \"int flags\" "
"\"register_t *retval\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dofileread.9:66
msgid ""
"The functions implement the underlying functionality of the E<.Xr read 2>, "
"E<.Xr write 2>, E<.Xr readv 2>, and E<.Xr writev 2> system calls.  They are "
"also used throughout the kernel as high-level access routines for file I/O."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dofileread.9:83
msgid ""
"The E<.Fn dofileread> function attempts to read E<.Fa nbytes> of data from "
"the object referenced by file entry E<.Fa fp> into the buffer pointed to by "
"E<.Fa buf>.  The E<.Fn dofilewrite> function attempts to write E<.Fa nbytes> "
"of data to the object referenced by file entry E<.Fa fp> from the buffer "
"pointed to by E<.Fa buf>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dofileread.9:93
msgid ""
"The E<.Fn dofilereadv> and E<.Fn dofilewritev> functions perform the same "
"operations, but scatter the data with the E<.Fa iovcnt> buffers specified by "
"the members of the E<.Fa iov> array."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dofileread.9:104
msgid ""
"The offset of the file operations is explicitly specified by E<.Fa "
"*offset>.  The new file offset after the file operation is returned in E<.Fa "
"*offset>.  If the FOF_UPDATE_OFFSET flag is specified in the E<.Fa flags> "
"argument, the file offset in the file entry E<.Fa fp> is updated to reflect "
"the new file offset, otherwise it remains unchanged after the operation."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dofileread.9:109
msgid ""
"The file descriptor E<.Fa fd> is largely unused except for use by the ktrace "
"framework for reporting to userlevel the process's file descriptor."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dofileread.9:113
msgid ""
"Upon successful completion the number of bytes which were transferred is "
"returned in E<.Fa *retval>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dofileread.9:116
msgid ""
"Upon successful completion zero is returned, otherwise an appropriate error "
"is returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dofileread.9:119
msgid ""
"The framework for these file operations is implemented within the file E<.Pa "
"sys/kern/sys_generic.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dofileread.9:120 org_netbsd/src/share/man/man9/filedesc.9:304
msgid "E<.Xr file 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/dopowerhooks.9:31
#, no-wrap
msgid "DOPOWERHOOKS 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dopowerhooks.9:35
msgid "E<.Nm dopowerhooks>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/dopowerhooks.9:35
#, no-wrap
msgid "run all power hooks"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dopowerhooks.9:39
msgid "E<.Ft void> E<.Fn dopowerhooks \"int why\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dopowerhooks.9:46
msgid ""
"E<.Em The> E<.Nm> E<.Em routine is deprecated.> E<.Em Use> E<.Xr "
"pmf_system_suspend 9> E<.Em instead.>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dopowerhooks.9:55
msgid ""
"The E<.Fn dopowerhooks> function invokes all power hooks established using "
"the E<.Xr powerhook_establish 9> function.  When power is disappearing the "
"power hooks are called in reverse order, i.e., the power hook established "
"last will be called first.  When power is restored they are called normal "
"order."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dopowerhooks.9:59
msgid ""
"This function is called from the E<.Xr apm 4> driver when a power change is "
"detected."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/dopowerhooks.9:60
msgid "E<.Xr powerhook_establish 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/doshutdownhooks.9:36
#, no-wrap
msgid "DOSHUTDOWNHOOKS 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/doshutdownhooks.9:40
msgid "E<.Nm doshutdownhooks>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/doshutdownhooks.9:40
#, no-wrap
msgid "run all shutdown hooks"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/doshutdownhooks.9:44
msgid "E<.Ft void> E<.Fn doshutdownhooks \"void\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/doshutdownhooks.9:51
msgid ""
"E<.Em The> E<.Nm> E<.Em routine is deprecated.> E<.Em Use> E<.Xr "
"pmf_system_shutdown 9> E<.Em instead.>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/doshutdownhooks.9:59
msgid ""
"The E<.Fn doshutdownhooks> function invokes all shutdown hooks established "
"using the E<.Xr shutdownhook_establish 9> function.  Shutdown hooks are "
"called in reverse order, i.e., the shutdown hook established last will be "
"called first."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/doshutdownhooks.9:66
msgid ""
"This function is called from E<.Fn cpu_reboot> with interrupts turned off.  "
"It is called immediately before the system is halted or rebooted, after file "
"systems have been unmounted, after the clock has been updated, and after a "
"system dump has been done (if necessary)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/doshutdownhooks.9:68
msgid "E<.Xr cpu_reboot 9>, E<.Xr shutdownhook_establish 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/driver.9:30
#, no-wrap
msgid "July 23, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/driver.9:31
#, no-wrap
msgid "DRIVER 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:35
msgid "E<.Nm driver>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/driver.9:35
#, no-wrap
msgid "description of a device driver"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:48
msgid ""
"E<.Ft static int> E<.Fn foo_match \"device_t parent\" \"cfdata_t match\" "
"\"void *aux\"> E<.Ft static void> E<.Fn foo_attach \"device_t parent\" "
"\"device_t self\" \"void *aux\"> E<.Ft static int> E<.Fn foo_detach "
"\"device_t self\" \"int flags\"> E<.Ft static int> E<.Fn foo_activate "
"\"device_t self\" \"enum devact act\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:54
msgid ""
"This page briefly describes the basic E<.Nx> autoconfiguration interface "
"used by device drivers.  For a detailed overview of the autoconfiguration "
"framework see E<.Xr autoconf 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:65
msgid ""
"Each device driver must present to the system a standard autoconfiguration "
"interface.  This interface is provided by the E<.Em cfattach> structure.  "
"The interface to the driver is constant and is defined statically inside the "
"driver.  For example, the interface to driver E<.Dq foo> is defined with:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:73
#, no-wrap
msgid ""
"CFATTACH_DECL(foo, \t\t\t/* driver name */\n"
"\tsizeof(struct foo_softc),\t/* size of instance data */\n"
"\tfoo_match,\t\t\t/* match/probe function */\n"
"\tfoo_attach,\t\t\t/* attach function */\n"
"\tfoo_detach,\t\t\t/* detach function */\n"
"\tfoo_activate);\t\t\t/* activate function */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:98
msgid ""
"For each device instance controlled by the driver, the autoconfiguration "
"framework allocates a block of memory to record device-instance-specific "
"driver variables.  The size of this memory block is specified by the second "
"argument in the E<.Em CFATTACH_DECL> macro.  The memory block is referred to "
"as the driver's E<.Em softc> structure.  The E<.Em softc> structure is only "
"accessed within the driver, so its definition is local to the driver.  "
"Nevertheless, the E<.Em softc> structure should adopt the standard E<.Nx> "
"configuration and naming conventions.  For example, the E<.Em softc> "
"structure for driver E<.Dq foo> is defined with:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:104
#, no-wrap
msgid ""
"struct foo_softc {\n"
"\tdevice_t sc_dev;\t\t/* generic device info */\n"
"\t/* device-specific state */\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:113
msgid ""
"The autoconfiguration framework mandates that the first member of the E<.Em "
"softc> structure must be the driver-independent E<.Em device_t>.  Probably "
"its most useful aspect to the driver is that it contains the device-instance "
"name E<.Em dv_xname>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:124
msgid ""
"If a driver has character device interfaces accessed from userland, the "
"driver must define the E<.Em cdevsw> structure.  The structure is constant "
"and is defined inside the driver.  For example, the E<.Em cdevsw> structure "
"for driver E<.Dq foo> is defined with:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:139
#, no-wrap
msgid ""
"const struct cdevsw foo_cdevsw {\n"
"\tint (*d_open)(dev_t, int, int, struct lwp *);\n"
"\tint (*d_close)(dev_t, int, int, struct lwp *);\n"
"\tint (*d_read)(dev_t, struct uio *, int);\n"
"\tint (*d_write)(dev_t, struct uio *, int);\n"
"\tint (*d_ioctl)(dev_t, u_long, void *, int, struct lwp *);\n"
"\tvoid (*d_stop)(struct tty *, int);\n"
"\tstruct tty *(*d_tty)(dev_t);\n"
"\tint (*d_poll)(dev_t, int, struct lwp *);\n"
"\tpaddr_t (*d_mmap)(dev_t, off_t, int);\n"
"\tint (*d_kqfilter)(dev_t, struct knote *);\n"
"\tint d_flag;\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:145
msgid ""
"The structure variable must be named foo_cdevsw by appending the letters "
"E<.Dq _cdevsw> to the driver's base name.  This convention is mandated by "
"the autoconfiguration framework."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:157
msgid ""
"If the driver E<.Dq foo> has also block device interfaces, the driver must "
"define the E<.Em bdevsw> structure.  The structure is constant and is "
"defined inside the driver.  For example, the E<.Em bdevsw> structure for "
"driver E<.Dq foo> is defined with:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:168
#, no-wrap
msgid ""
"const struct bdevsw foo_bdevsw {\n"
"\tint (*d_open)(dev_t, int, int, struct lwp *);\n"
"\tint (*d_close)(dev_t, int, int, struct lwp *);\n"
"\tvoid (*d_strategy)(struct buf *);\n"
"\tint (*d_ioctl)(dev_t, u_long, void *, int, struct lwp *);\n"
"\tint (*d_dump)(dev_t, daddr_t, void *, size_t);\n"
"\tint (*d_psize)(dev_t);\n"
"\tint d_flag;\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:174
msgid ""
"The structure variable must be named foo_bdevsw by appending the letters "
"E<.Dq _bdevsw> to the driver's base name.  This convention is mandated by "
"the autoconfiguration framework."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:222
msgid ""
"During system bootstrap, the autoconfiguration framework searches the system "
"for devices.  For each device driver, its match function is called (via its "
"E<.Em cfattach> structure) to match the driver with a device instance.  The "
"match function is called with three arguments.  This first argument E<.Fa "
"parent> is a pointer to the driver's parent device structure.  The second "
"argument E<.Fa match> is a pointer to a data structure describing the "
"autoconfiguration framework's understanding of the driver.  Both the E<.Fa "
"parent> and E<.Fa match> arguments are ignored by most drivers.  The third "
"argument E<.Fa aux> contains a pointer to a structure describing a potential "
"device-instance.  It is passed to the driver from the parent.  The match "
"function would type-cast the E<.Fa aux> argument to its appropriate "
"attachment structure and use its contents to determine whether it supports "
"the device.  Depending on the device hardware, the contents of the "
"attachment structure may contain E<.Dq locators> to locate the device "
"instance so that the driver can probe it for its identity.  If the probe "
"process identifies additional device properties, it may modify the members "
"of the attachment structure.  For these devices, the E<.Nx> convention is to "
"call the match routine E<.Fn foo_probe> instead of E<.Fn foo_match> to make "
"this distinction clear.  Either way, the match function returns a nonzero "
"integer indicating the confidence of supporting this device and a value of 0 "
"if the driver doesn't support the device.  Generally, only a single driver "
"exists for a device, so the match function returns 1 for a positive match."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:248
msgid ""
"The autoconfiguration framework will call the attach function (via its E<.Em "
"cfattach> structure)  of the driver which returns the highest value from its "
"match function.  The attach function is called with three arguments.  The "
"attach function performs the necessary process to initialise the device for "
"operation.  The first argument E<.Fa parent> is a pointer to the driver's "
"parent device structure.  The second argument E<.Fa self> is a pointer to "
"the driver's device structure.  It is also a pointer to our E<.Em softc> "
"structure since the device structure is its first member.  The third "
"argument E<.Fa aux> is a pointer to the attachment structure.  The E<.Fa "
"parent> and E<.Fa aux> arguments are the same as passed to the match "
"function."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:256
msgid ""
"The driver's attach function is called before system interrupts are "
"enabled.  If interrupts are required during initialisation, then the attach "
"function should make use of E<.Fn config_interrupts> (see E<.Xr autoconf "
"9>)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:279
msgid ""
"Some devices can be removed from the system without requiring a system "
"reboot.  The autoconfiguration framework calls the driver's detach function "
"(via its E<.Em cfattach> structure) during device detachment.  If the device "
"does not support detachment, then the driver does not have to provide a "
"detach function.  The detach function is used to relinquish resources "
"allocated to the driver which are no longer needed.  The first argument "
"E<.Fa self> is a pointer to the driver's device structure.  It is the same "
"structure as passed to the attach function.  The second argument E<.Fa "
"flags> contains detachment flags.  Valid values are E<.Dv DETACH_FORCE> "
"(force detachment; hardware gone) and E<.Dv DETACH_QUIET> (do not print a "
"notice)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:305
msgid ""
"The autoconfiguration framework may call the driver's activate function to "
"notify the driver of a change in the resources that have been allocated to "
"it.  For example, an Ethernet driver has to be notified if the network stack "
"is being added or removed from the kernel.  The first argument to the "
"activate function E<.Fa self> is a pointer to the driver's device "
"structure.  It is the same argument as passed to the attach function.  The "
"second argument E<.Fa act> describes the action.  Valid actions are E<.Dv "
"DVACT_ACTIVATE> (activate the device) and E<.Dv DVACT_DEACTIVATE> "
"(deactivate the device).  If the action is not supported the activate "
"function should return E<.Er EOPNOTSUPP>.  The E<.Dv DVACT_DEACTIVATE> call "
"will only be made if the E<.Dv DVACT_ACTIVATE> call was successful.  The "
"activate function is called in interrupt context."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:324
msgid ""
"Most drivers will want to make use of interrupt facilities.  Interrupt "
"locators provided through the attachment structure should be used to "
"establish interrupts within the system.  Generally, an interrupt interface "
"is provided by the parent.  The interface will require a handler and a "
"driver-specific argument to be specified.  This argument is usually a "
"pointer to the device-instance-specific softc structure.  When a hardware "
"interrupt for the device occurs the handler is called with the argument.  "
"Interrupt handlers should return 0 for E<.Dq interrupt not for me>, 1 for "
"E<.Dq I took care of it>, or -1 for E<.Do> I guess it was mine, but I wasn't "
"expecting it E<.Dc>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:337
msgid ""
"For a driver to be compiled into the kernel, E<.Xr config 1> must be aware "
"of its existence.  This is done by including an entry in "
"files.\\*[Lt]bus\\*[Gt] in the directory containing the driver.  For "
"example, the driver E<.Dq foo> attaching to bus E<.Dq bar> with dependency "
"on kernel module E<.Dq baz> has the entry:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:341
#, no-wrap
msgid ""
"device\tfoo: baz\n"
"attach\tfoo at bar\n"
"file\tdev/bar/foo.c\t\tfoo\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:344
msgid "An entry can now be added to the machine description file:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:346
#, no-wrap
msgid "foo*\tat bar?\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:361
msgid ""
"For device interfaces of a driver to be compiled into the kernel, E<.Xr "
"config 1> must be aware of its existence.  This is done by including an "
"entry in majors.\\*[Lt]arch\\*[Gt].  For example, the driver E<.Dq foo> with "
"character device interfaces, a character major device number E<.Dq cmaj>, "
"block device interfaces, a block device major number E<.Dq bmaj> and "
"dependency on kernel module E<.Dq baz> has the entry:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:363
#, no-wrap
msgid "device-major\tfoo\tchar cmaj block bmaj\tbaz\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:369
msgid ""
"For a detailed description of the machine description file and the E<.Dq "
"device definition> language see E<.Xr config 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/driver.9:373
msgid "E<.Xr config 1>, E<.Xr autoconf 9>, E<.Xr config 9>, E<.Xr pmf 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/edid.9:33
#, no-wrap
msgid "EDID 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/edid.9:37
msgid "E<.Nm edid>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/edid.9:37
#, no-wrap
msgid "VESA Extended Display Identification Data"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/edid.9:39
#, no-wrap
msgid "dev/videomode/edidvar.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/edid.9:40
#, no-wrap
msgid "dev/videomode/edidreg.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/edid.9:54
msgid ""
"E<.Ft int> E<.Fo edid_is_valid> E<.Fa \"uint8_t *data\"> E<.Fc> E<.Ft int> "
"E<.Fo edid_parse> E<.Fa \"uint8_t *data\"> E<.Fa \"struct edid_info *info\"> "
"E<.Fc> E<.Ft void> E<.Fo edid_print> E<.Fa \"struct edid_info *info\"> "
"E<.Fc>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/edid.9:58
msgid ""
"These functions provide support parsing the Extended Display Identification "
"Data which describes a display device such as a monitor or flat panel "
"display."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/edid.9:66
msgid ""
"The E<.Fn edid_is_valid> function simply tests if the EDID block in E<.Fa "
"data> contains valid data.  This test includes a verification of the "
"checksum, and that valid vendor and product idenfication data is present.  "
"The data block contain at least 128 bytes."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/edid.9:74
msgid ""
"The E<.Fn edid_parse> function parses the supplied E<.Fa data> block (which "
"again, must be at least 128 bytes), writing the relevant data into the "
"structure pointed to by E<.Fa info>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/edid.9:80
msgid ""
"The E<.Fn edid_print> function prints the data in the given E<.Fa info> "
"structure to the console device."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/edid.9:97
msgid ""
"The E<.Fn edid_is_valid> function returns 0 if the data block is valid, and "
"E<.Er EINVAL> otherwise.  The E<.Fn edid_parse> function returns zero if the "
"data was successfully parsed, and non-zero otherwise."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/edid.9:100
msgid ""
"The EDID subsystem is implemented within the file E<.Pa "
"sys/dev/videomode/edid.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/edid.9:106
msgid ""
"The EDID subsystem also makes use of VESA Generalized Timing Formula located "
"located in E<.Pa sys/dev/videomode/vesagtf.c> and the generic videomode "
"database located in E<.Pa sys/dev/videomode/videomode.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/edid.9:109
msgid ""
"The following code uses these functions to retrieve and print information "
"about a monitor:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/edid.9:122
#, no-wrap
msgid ""
"\t...\n"
"\t/* initialize i2c tag... */\n"
"\t...\n"
"\tif ((ddc_read_edid(tag, buffer, 128) == 0) &&\n"
"\t    (edid_parse(buffer, &info) == 0))\n"
"\t\tedid_print(info);\n"
"\t...\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/edid.9:126
msgid "E<.Xr ddc 9>, E<.Xr iic 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/edid.9:129
msgid "These routines were added in E<.Nx 4.0>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/errno.9:33
#, no-wrap
msgid "December 3, 2004"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/errno.9:34
#, no-wrap
msgid "ERRNO 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/errno.9:38
msgid "E<.Nm errno>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/errno.9:38
#, no-wrap
msgid "kernel internal error numbers"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/errno.9:45
msgid ""
"This section provides an overview of the error numbers used internally by "
"the kernel and indicate neither success nor failure.  These error numbers "
"are not returned to userland code."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/errno.9:45 org_netbsd/src/share/man/man9/inittodr.9:79 org_netbsd/src/share/man/man9/malloc.9:302 org_netbsd/src/share/man/man9/pool.9:302
#, no-wrap
msgid "DIAGNOSTICS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/errno.9:61
msgid ""
"Kernel functions that indicate success or failure by means of either 0 or an "
"E<.Xr errno 2> value sometimes have a need to indicate that E<.Dq special> "
"handling is required at an upper layer or, in the case of E<.Xr ioctl 2> "
"processing, that E<.Dq nothing was wrong but the request was not handled>.  "
"To handle these cases, some negative E<.Xr errno 2> values are defined which "
"are handled by the kernel before returning a different E<.Xr errno 2> value "
"to userland or simply zero."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/errno.9:64
msgid "The following is a list of the defined names and their meanings as given in"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/errno.9:64
#, no-wrap
msgid "errno.h ."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/errno.9:69
msgid ""
"It is important to note that the value \\-1 is E<.Em not> used, since it is "
"commonly used to indicate generic failure and leaves it up to the caller to "
"determine the action to take."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/errno.9:70
#, no-wrap
msgid "Er \\-2 EJUSTRETURN Em \"Modify regs, just return\" ."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/errno.9:72
msgid "No more work is required and the function should just return."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/errno.9:72
#, no-wrap
msgid "Er \\-3 ERESTART Em \"Restart syscall\" ."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/errno.9:77
msgid ""
"The system call should be restarted.  This typically means that the machine "
"dependent system call trap code will reposition the process's instruction "
"pointer or program counter to re-execute the current system call with no "
"other work required."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/errno.9:77
#, no-wrap
msgid "Er \\-4 EPASSTHROUGH Em \"Operation not handled by this layer\" ."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/errno.9:84
msgid ""
"The operation was not handled and should be passed through to another "
"layer.  This often occurs when processing E<.Xr ioctl 2> requests since "
"lower layer processing may not handle something that subsequent code at a "
"higher level will."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/errno.9:84
#, no-wrap
msgid "Er \\-5 EDUPFD Em \"Duplicate file descriptor.\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/errno.9:101
msgid ""
"This error is returned from the device open routine indicating that the "
"E<.Ar l_dupfd> field contains the file descriptor information to be returned "
"to the caller, instead of the file descriptor that has been opened already.  "
"This error is used by cloning device multiplexors.  Cloning device "
"multiplexors open a new file descriptor and associate that file descriptor "
"with the appropriate cloned device.  They set E<.Ar l_dupfd> to that new "
"file descriptor and return E<.Er EDUPFD>.  E<.Xr vn_open 9> takes the file "
"descriptor pointed to by E<.Ar l_dupfd> and copies it to the file descriptor "
"that the open call will return."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/errno.9:101
#, no-wrap
msgid "Er \\-6 EMOVEFD Em \"Move file descriptor.\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/errno.9:107
msgid ""
"This error is similar to E<.Er EDUPFD> except that the file descriptor in "
"E<.Ar l_dupfd> is closed after it has been copied."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/errno.9:111
msgid "E<.Xr errno 2>, E<.Xr ioctl 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/errno.9:119
msgid ""
"An E<.Nm> manual page appeared in E<.At v6>.  This E<.Nm> manual page "
"appeared in E<.Nx 3.0>."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/ethersubr.9:31
#, no-wrap
msgid "ETHERSUBR 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:44
msgid ""
"E<.Nm ethersubr>, E<.Nm ether_ifattach>, E<.Nm ether_addmulti>, E<.Nm "
"ether_delmulti>, E<.Nm ETHER_FIRST_MULTI>, E<.Nm ETHER_NEXT_MULTI>, E<.Nm "
"ETHER_IS_MULTICAST>, E<.Nm fddi_ifattach>, E<.Nm fddi_addmulti>, E<.Nm "
"fddi_delmulti>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/ethersubr.9:44
#, no-wrap
msgid "Ethernet and FDDI driver support functions and macros"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/ethersubr.9:46 org_netbsd/src/share/man/man9/ethersubr.9:184
#, no-wrap
msgid "net/if_ether.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:59
msgid ""
"E<.Ft void> E<.Fn ether_ifattach \"struct ifnet *ifp\" \"uint8_t *lla\"> "
"E<.Ft int> E<.Fn ether_addmulti \"const struct sockaddr *sa\" \"struct "
"ethercom *ec\"> E<.Ft int> E<.Fn ether_delmulti \"const struct sockaddr "
"*sa\" \"struct ethercom *ec\"> E<.Ft void> E<.Fn ETHER_FIRST_MULTI \"struct "
"ether_multistep step\" \"struct ethercom *ec\" \"struct ether_multi *enm\"> "
"E<.Ft void> E<.Fn ETHER_NEXT_MULTI \"struct ether_multistep step\" \"struct "
"ether_multi *enm\"> E<.Ft int> E<.Fn ETHER_IS_MULTICAST \"uint8_t *addr\">"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/ethersubr.9:59 org_netbsd/src/share/man/man9/ethersubr.9:189
#, no-wrap
msgid "net/if_fddi.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:66
msgid ""
"E<.Ft void> E<.Fn fddi_ifattach \"struct ifnet *ifp\" \"uint8_t *lla\"> "
"E<.Ft int> E<.Fn fddi_addmulti \"const struct sockaddr *sa\" \"struct "
"ethercom *ec\"> E<.Ft int> E<.Fn fddi_delmulti \"const struct sockaddr *sa\" "
"\"struct ethercom *ec\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:77
msgid ""
"The E<.Nm> functions provide the interface between the E<.Nm> module and the "
"network drivers which need Ethernet support.  Such drivers must request the "
"E<.Ar ether> attribute in their E<.Ar files> declaration and call the "
"appropriate functions as specified below."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:82
msgid ""
"FDDI drivers must request the \"fddi\" attribute in their \"files\" "
"declaration and call the functions tagged with \"fddi_\" or \"FDDI_\" "
"instead, where different.  Some macros are shared."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:86
msgid ""
"Note that you also need the E<.Xr arp 9> stuff to support IPv4 on your "
"hardware."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ethersubr.9:87
#, no-wrap
msgid "Fn ether_ifattach ifp lla"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:91
msgid ""
"Perform the device-independent, but Ethernet-specific initialization of the "
"interface pointed to by E<.Fa ifp>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:97
msgid ""
"Among other duties, this function creates a record for the link level "
"address in the interface's address list and records the link level address "
"pointed to by E<.Fa lla> there."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:99
msgid "This function must be called from the driver's attach function."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ethersubr.9:99
#, no-wrap
msgid "Fn fddi_ifattach ifp lla"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:101
msgid "Corresponding function for FDDI devices."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ethersubr.9:101
#, no-wrap
msgid "Fn ether_addmulti sa ec"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ethersubr.9:102
#, no-wrap
msgid "Fn ether_delmulti sa ec"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:111
msgid ""
"Add E<.Pq Fn ether_addmulti> or delete E<.Pq Fn ether_delmulti> the address "
"described by the E<.Fa sa> pointer to the Ethernet multicast list belonging "
"to E<.Fa ec>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:121
msgid ""
"These functions must be called from the driver's ioctl function to handle "
"E<.Dv SIOCADDMULTI> and E<.Dv SIOCDELMULTI> requests.  If these return E<.Er "
"ENETRESET>, the hardware multicast filter must be reinitialized."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:131
msgid ""
"These functions accept E<.Dv AF_UNSPEC> addresses, which are interpreted as "
"Ethernet addresses, or E<.Dv AF_INET> addresses.  In the latter case, E<.Dv "
"INADDR_ANY> is mapped to a range describing all the Ethernet address space "
"reserved for IPv4 multicast addresses."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:143
msgid ""
"The E<.Fn ether_addmulti> returns E<.Er EAFNOSUPPORT> if an unsupported "
"address family is specified, E<.Er EINVAL> if a non-multicast address is "
"specified, or E<.Er ENETRESET> if the multicast list really changed and the "
"driver should synchronize its hardware filter with it."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:150
msgid ""
"The E<.Fn ether_delmulti> returns, in addition to the above errors, E<.Er "
"ENXIO> if the specified address can't be found in the list of multicast "
"addresses."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ethersubr.9:150
#, no-wrap
msgid "Fn fddi_addmulti sa ec"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ethersubr.9:151
#, no-wrap
msgid "Fn fddi_delmulti sa ec"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:153
msgid "Corresponding functions for FDDI devices."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ethersubr.9:153
#, no-wrap
msgid "Fn ETHER_NEXT_MULTI step enm"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:160
msgid ""
"A macro to step through all of the E<.Em ether_multi> records, one at a "
"time.  The current position is remembered in E<.Fa step>, which the caller "
"must provide."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ethersubr.9:160
#, no-wrap
msgid "Fn ETHER_FIRST_MULTI step ec enm"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:168
msgid ""
"A macro that must be called to initialize E<.Fa step> and get the first "
"record.  Both macros return a E<.Dv NULL> E<.Fa enm> when there are no "
"remaining records."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ethersubr.9:168
#, no-wrap
msgid "Fn ETHER_IS_MULTICAST addr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:172
msgid ""
"A macro that returns 1, if E<.Fa addr> points to an Ethernet/FDDI multicast "
"(or broadcast) address."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:175
msgid "E<.Xr arp 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:178
msgid "Rewritten to attach to the new ARP system in E<.Nx 1.3>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:180
msgid "UCB CSRG (original implementation)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:182
msgid "Ignatios Souvatzis (support for new ARP system)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:184
msgid "Ethernet support functions are declared in"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:187
msgid "and defined (if not implemented as macro) in E<.Pa sys/net/if_ethersubr.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:189
msgid "FDDI support functions are declared in"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ethersubr.9:191
msgid "and defined (if not implemented as macro) in E<.Pa sys/net/if_fddisubr.c>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/evcnt.9:35
#, no-wrap
msgid "January 14, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/evcnt.9:36
#, no-wrap
msgid "EVCNT 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:43
msgid ""
"E<.Nm evcnt>, E<.Nm evcnt_attach_dynamic>, E<.Nm evcnt_attach_static>, E<.Nm "
"evcnt_detach>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/evcnt.9:43
#, no-wrap
msgid "generic event counter framework"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/evcnt.9:45
#, no-wrap
msgid "sys/evcnt.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:53
msgid ""
"E<.Ft void> E<.Fn evcnt_attach_dynamic \"struct evcnt *ev\" \"int type\" "
"\"const struct evcnt *parent\" \"const char *group\" \"const char *name\"> "
"E<.Ft void> E<.Fn evcnt_attach_static \"struct evcnt *ev\"> E<.Ft void> "
"E<.Fn evcnt_detach \"struct evcnt *ev\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:59
msgid ""
"The E<.Nx> generic event counter framework is designed to provide a flexible "
"and hierarchical event counting facility, which is useful for tracking "
"system events (including device interrupts)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:64
msgid ""
"The fundamental component of this framework is the E<.Em evcnt> structure.  "
"Its user-accessible fields are:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:75
#, no-wrap
msgid ""
"struct evcnt {\n"
"\tuint64_t\tev_count;\t/* how many have occurred */\n"
"\tTAILQ_ENTRY(evcnt) ev_list;\t/* entry on list of all counters */\n"
"\tunsigned char\tev_type;\t/* counter type; see below */\n"
"\tunsigned char\tev_grouplen;\t/* 'group' len, excluding NUL */\n"
"\tunsigned char\tev_namelen;\t/* 'name' len, excluding NUL */\n"
"\tconst struct evcnt *ev_parent;\t/* parent, for hierarchical ctrs */\n"
"\tconst char\t*ev_group;\t/* name of group */\n"
"\tconst char\t*ev_name;\t/* name of specific event */\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:82
msgid ""
"The system maintains a global linked list of all active event counters.  "
"This list, called E<.Nm allevents>, may grow or shrink over time as event "
"counters are dynamically added to and removed from the system."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:87
msgid ""
"Each event counter is marked (in the E<.Fa ev_type> field) with the type of "
"event being counted.  The following types are currently defined:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/evcnt.9:88
#, no-wrap
msgid "Ev EVCNT_TYPE_MISC"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:90
msgid "Miscellaneous; doesn't fit into one of the other types."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/evcnt.9:90
#, no-wrap
msgid "Ev EVCNT_TYPE_INTR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:93
msgid "Interrupt counter, reported by E<.Ic vmstat -i>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/evcnt.9:93
#, no-wrap
msgid "Ev EVCNT_TYPE_TRAP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:95
msgid "Processor trap style events."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:118
msgid ""
"Each event counter also has a group name E<.Pq Fa ev_group> and an event "
"name E<.Pq Fa ev_name> which are used to identify the counter.  The group "
"name may be shared by a set of counters.  For example, device interrupt "
"counters would use the name of the device whose interrupts are being counted "
"as the group name.  The counter name is meant to distinguish the counter "
"from others in its group (and need not be unique across groups).  Both names "
"should be understandable by users, since they are printed by commands like "
"E<.Xr vmstat 1>.  The constant E<.Dv EVCNT_STRING_MAX> is defined to be the "
"maximum group or event name length in bytes (including the trailing E<.Dv "
"NUL>).  In the current implementation it is 256."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:133
msgid ""
"To support hierarchical tracking of events, each event counter can name a "
"E<.Dq parent> event counter.  For instance, interrupt dispatch code could "
"have an event counter per interrupt line, and devices could each have "
"counters for the number of interrupts that they were responsible for "
"causing.  In that case, the counter for a device on a given interrupt line "
"would have the line's counter as its parent.  The value E<.Dv NULL> is used "
"to indicate that a counter has no parent.  A counter's parent must be "
"attached before the counter is attached, and detached after the counter is "
"detached."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:147
msgid ""
"The E<.Fn EVCNT_INITIALIZER> macro can be used to provide a static "
"initializer for an event counter structure.  It is invoked as E<.Fn "
"EVCNT_INITIALIZER \"type\" \"parent\" \"group\" \"name\">, and its arguments "
"will be placed into the corresponding fields of the event counter structure "
"it is initializing.  The E<.Fa group> and E<.Fa name> arguments must be "
"constant strings."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/evcnt.9:150
#, no-wrap
msgid "Fn evcnt_attach_dynamic ev type parent group name"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:159
msgid ""
"Attach the event counter structure pointed to by E<.Fa ev> to the system "
"event list.  The event counter is cleared and its fields initialized using "
"the arguments to the function call.  The contents of the remaining elements "
"in the structure (e.g., the name lengths) are calculated, and the counter is "
"added to the system event list."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:164
msgid ""
"The strings specified as the group and counter names must persist (with the "
"same value)  throughout the life of the event counter; they are referenced "
"by, not copied into, the counter."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/evcnt.9:164
#, no-wrap
msgid "Fn evcnt_attach_static ev"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:174
msgid ""
"Attach the statically-initialized event counter structure pointed to by "
"E<.Fa ev> to the system event list.  The event counter is assumed to be "
"statically initialized using the E<.Fn EVCNT_INITIALIZER> macro.  This "
"function simply calculates structure elements' values as appropriate (e.g., "
"the string lengths), and adds the counter to the system event list."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/evcnt.9:174
#, no-wrap
msgid "Fn evcnt_detach ev"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:178
msgid ""
"Detach the event counter structure pointed to by E<.Fa ev> from the system "
"event list."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:196
msgid ""
"Note that no method is provided to increment the value of an event counter.  "
"Code incrementing an event counter should do so by directly accessing its "
"E<.Fa ev_count> field in a manner that is known to be safe.  For instance, "
"additions to a device's event counters in the interrupt handler for that "
"device will often be safe without additional protection (because interrupt "
"handler entries for a given device have to be serialized).  However, for "
"other uses of event counters, additional locking or use of machine-dependent "
"atomic operation may be appropriate.  (The overhead of using a mechanism "
"that is guaranteed to be safe to increment every counter, regardless of "
"actual need for such a mechanism where the counter is being incremented, "
"would be too great.  On some systems, it might involve a global lock and "
"several function calls.)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:199
msgid ""
"This section includes a description on basic use of the framework and "
"example usage of its functions."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:216
msgid ""
"Device drivers can use the E<.Fn evcnt_attach_dynamic> and E<.Fn "
"evcnt_detach> functions to manage device-specific event counters.  "
"Statically configured system modules can use E<.Fn evcnt_attach_static> to "
"configure global event counters.  Similarly, loadable modules can use E<.Fn "
"evcnt_attach_static> to configure their global event counters, E<.Fn "
"evcnt_attach_dynamic> to attach device-specific event counters, and E<.Fn "
"evcnt_detach> to detach all counters when being unloaded."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:227
msgid ""
"Device drivers that wish to use the generic event counter framework should "
"place event counter structures in their E<.Dq softc> structures.  For "
"example, to keep track of the number of interrupts for a given device "
"(broken down further into E<.Dq device readable> and E<.Dq device writable> "
"interrupts) a device driver might use:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:235
#, no-wrap
msgid ""
"struct foo_softc {\n"
"\t[ . . . ]\n"
"\tstruct evcnt sc_ev_intr;\t/* interrupt count */\n"
"\tstruct evcnt sc_ev_intr_rd;\t/* 'readable' interrupt count */\n"
"\tstruct evcnt sc_ev_intr_wr;\t/* 'writable' interrupt count */\n"
"\t[ . . . ]\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:241
msgid ""
"In the device attach function, those counters would be registered with the "
"system using the E<.Fn evcnt_attach_dynamic> function, using code like:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:246
#, no-wrap
msgid ""
"void\n"
"fooattach(device_t parent, device_t self, void *aux)\n"
"{\n"
"\tstruct foo_softc *sc = device_private(self);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:256
#, no-wrap
msgid ""
"\t/* Initialize and attach event counters. */\n"
"\tevcnt_attach_dynamic(\\*[Am]sc-\\*[Gt]sc_ev, EVCNT_TYPE_INTR,\n"
"\t    NULL, device_xname(self), \"intr\");\n"
"\tevcnt_attach_dynamic(\\*[Am]sc-\\*[Gt]sc_ev_rd, EVCNT_TYPE_INTR,\n"
"\t    \\*[Am]sc-\\*[Gt]sc_ev, device_xname(self), \"intr rd\");\n"
"\tevcnt_attach_dynamic(\\*[Am]sc-\\*[Gt]sc_ev_wr, EVCNT_TYPE_INTR,\n"
"\t    \\*[Am]sc-\\*[Gt]sc_ev, device_xname(self), \"intr wr\");\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:267
msgid ""
"If the device can be detached from the system, its detach function should "
"invoke E<.Fn evcnt_detach> on each attached counter (making sure to detach "
"any E<.Dq parent> counters only after detaching all children)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:270
msgid ""
"Code like the following might be used to initialize a static event counter "
"(in this example, one used to track CPU alignment traps):"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:273
#, no-wrap
msgid ""
"\tstruct evcnt aligntrap_ev = EVCNT_INITIALIZER(EVCNT_TYPE_MISC,\n"
"\t    NULL, \"cpu\", \"aligntrap\")\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:276
msgid "To attach this event counter, code like the following could be used:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:278
#, no-wrap
msgid "\tevcnt_attach_static(\\*[Am]aligntrap_ev);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:284
msgid ""
"The event counter framework itself is implemented within the file E<.Pa "
"sys/kern/subr_evcnt.c>.  Data structures and function prototypes for the "
"framework are located in E<.Pa sys/sys/device.h>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:286
msgid "Event counters are used throughout the system."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:292
msgid ""
"The E<.Xr vmstat 1> source file E<.Pa usr.bin/vmstat/vmstat.c> shows an "
"example of how to access event counters from user programs."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:294
msgid "E<.Xr vmstat 1>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:310
msgid ""
"A set of interrupt counter interfaces with similar names to the interfaces "
"in the E<.Nx> generic event counter framework appeared as part of the new "
"autoconfiguration system in E<.Bx 4.4>.  Those interfaces were never widely "
"adopted in E<.Nx> because of limitations in their applicability.  (Their use "
"was limited to non-hierarchical, dynamically attached device interrupt "
"counters.)  The E<.Nx> generic event counter framework first appeared in "
"E<.Nx 1.5>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/evcnt.9:315
msgid ""
"The E<.Nx> generic event counter framework was designed and implemented by "
"E<.An Chris Demetriou> E<.Aq cgd@NetBSD.org>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/extattr.9:29
#, no-wrap
msgid "January 2, 2005"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/extattr.9:30
#, no-wrap
msgid "EXTATTR 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extattr.9:34
msgid "E<.Nm extattr>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/extattr.9:34
#, no-wrap
msgid "file system extended attributes"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/extattr.9:37 org_netbsd/src/share/man/man9/namecache.9:46 org_netbsd/src/share/man/man9/namei.9:45 org_netbsd/src/share/man/man9/vattr.9:39 org_netbsd/src/share/man/man9/vfsops.9:51 org_netbsd/src/share/man/man9/vfssubr.9:59 org_netbsd/src/share/man/man9/vnfileops.9:46 org_netbsd/src/share/man/man9/vnode.9:61 org_netbsd/src/share/man/man9/vnodeops.9:85 org_netbsd/src/share/man/man9/vnsubr.9:50
#, no-wrap
msgid "sys/vnode.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/extattr.9:38 org_netbsd/src/share/man/man9/vnodeops.9:91
#, no-wrap
msgid "sys/extattr.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extattr.9:61
msgid ""
"Extended attributes allow additional meta-data to be associated with vnodes "
"representing files and directories.  The semantics of this additional data "
"is that of a E<.Dq name=value> pair, where a name may be defined or "
"undefined, and if defined, associated with zero or more bytes of arbitrary "
"binary data.  Extended attribute names exist within a set of namespaces; "
"each operation on an extended attribute is required to provide the namespace "
"to which the operation refers.  If the same name is present in multiple "
"namespaces, the extended attributes associated with the names are stored and "
"manipulated independently.  The following two namespaces are defined "
"universally, although individual file systems may implement additional "
"namespaces, or not implement these namespaces: E<.Dv "
"EXTATTR_NAMESPACE_USER>, E<.Dv EXTATTR_NAMESPACE_SYSTEM>.  The semantics of "
"these attributes are intended to be as follows: user attribute data is "
"protected according the normal discretionary and mandatory protections "
"associated with the data in the file or directory; system attribute data is "
"protected such that appropriate privilege is required to directly access or "
"manipulate these attributes."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extattr.9:75
msgid ""
"Reads of extended attribute data may return specific contiguous regions of "
"the meta-data, in the style of E<.Xr VOP_READ 9>, but writes will replace "
"the entire current E<.Dq value> associated with a given name.  As there are "
"a plethora of file systems with differing extended attributes, availability "
"and functionality of these functions may be limited, and they should be used "
"with awareness of the underlying semantics of the supporting file system.  "
"Authorization schemes for extended attribute data may also vary by file "
"system, as well as maximum attribute size, and whether or not any or "
"specific new attributes may be defined."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extattr.9:84
msgid ""
"Extended attributes are named using a nul-terminated character string.  "
"Depending on underlying file system semantics, this name may or may not be "
"case-sensitive.  Appropriate vnode extended attribute calls are: E<.Xr "
"VOP_GETEXTATTR 9>, E<.Xr VOP_LISTEXTATTR 9>, and E<.Xr VOP_SETEXTATTR 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extattr.9:86
msgid "E<.Xr vfsops 9>, E<.Xr vnodeops 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/extent.9:30
#, no-wrap
msgid "September 23, 1996"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/extent.9:31
#, no-wrap
msgid "EXTENT 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:42
msgid ""
"E<.Nm extent>, E<.Nm extent_create>, E<.Nm extent_destroy>, E<.Nm "
"extent_alloc>, E<.Nm extent_alloc_subregion>, E<.Nm extent_alloc_region>, "
"E<.Nm extent_free>, E<.Nm extent_print>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/extent.9:42
#, no-wrap
msgid "general purpose extent manager"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/extent.9:44 org_netbsd/src/share/man/man9/malloc.9:48
#, no-wrap
msgid "sys/malloc.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/extent.9:45
#, no-wrap
msgid "sys/extent.h"
msgstr ""

#.  too many arguments for a single .Fn
#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:75
msgid ""
"E<.Ft struct extent *> E<.Fn extent_create \"char *name\" \"u_long start\" "
"\"u_long end\" \"int mtype\" \"void *storage\" \"size_t storagesize\" \"int "
"flags\"> E<.Ft void> E<.Fn extent_destroy \"struct extent *ex\"> E<.Ft int> "
"E<.Fn extent_alloc \"struct extent *ex\" \"u_long size\" \"u_long "
"alignment\" \"u_long boundary\" \"int flags\" \"u_long *result\"> E<.Ft int> "
"E<.Fn extent_alloc_subregion \"struct extent *ex\" \"u_long substart\" "
"\"u_long subend\" \"u_long size\" \"u_long alignment\" \"u_long boundary\" "
"\"u_long flags\" \"u_long *result\"> E<.Ft int> E<.Fn extent_alloc1 \"struct "
"extent *ex\" \"u_long size\" \"u_long alignment\" \"u_long skew\" \"u_long "
"boundary\" \"int flags\" \"u_long *result\"> E<.Ft int> E<.Fo "
"extent_alloc_subregion1> E<.Fa \"struct extent *ex\"> E<.Fa \"u_long "
"substart\"> E<.Fa \"u_long subend\"> E<.Fa \"u_long size\"> E<.Fa \"u_long "
"alignment\"> E<.Fa \"u_long skew\"> E<.Fa \"u_long boundary\"> E<.Fa "
"\"u_long flags\"> E<.Fa \"u_long *result\"> E<.Fc> E<.Ft int> E<.Fn "
"extent_alloc_region \"struct extent *ex\" \"u_long start\" \"u_long size\" "
"\"int flags\"> E<.Ft int> E<.Fn extent_free \"struct extent *ex\" \"u_long "
"start\" \"u_long size\" \"int flags\"> E<.Ft void> E<.Fn extent_print "
"\"struct extent *ex\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:83
msgid ""
"The E<.Nx> extent manager provides management of areas of memory or other "
"number spaces (such as I/O ports).  An opaque structure called an E<.Nm "
"extent map> keeps track of allocated regions within the number space."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:112
msgid ""
"E<.Fn extent_create> creates an extent map managing the space from E<.Fa "
"start> to E<.Fa end> inclusive.  All memory allocation will use the memory "
"type E<.Fa mtype> E<.Po> see E<.Xr malloc 9> E<.Pc>.  The extent map will "
"have the name E<.Fa name>, used for identification in case of an error.  If "
"the flag E<.Dv EX_NOCOALESCE> is specified, only entire regions may be freed "
"within the extent map, but internal coalescing of regions is disabled so "
"that E<.Fn extent_free> will never have to allocate a region descriptor and "
"therefore will never fail.  The caller must specify one of the flags E<.Dv "
"EX_NOWAIT> or E<.Dv EX_WAITOK>, specifying whether it is okay to wait for "
"memory allocated for extent map overhead."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:139
msgid ""
"There are some applications which may want to use an extent map but can't "
"use E<.Fn malloc> and E<.Fn free>.  These applications may provide "
"pre-allocated storage for all descriptor overhead with the arguments E<.Fa "
"storage> and E<.Fa storagesize>.  An extent of this type is called a E<.Nm "
"fixed extent>.  If the application can safely use E<.Fn malloc> and E<.Fn "
"free>, E<.Fa storage> should be E<.Dv NULL>.  A fixed extent has a fixed "
"number of region descriptors, so care should be taken to provide enough "
"storage for them; alternatively, the flag E<.Dv EX_MALLOCOK> may be passed "
"to allocation requests to indicate that a fixed extent map may be extended "
"using a call to E<.Fn malloc>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:147
msgid ""
"E<.Fn extent_destroy> destroys the extent map E<.Fa ex>, freeing all "
"allocated regions.  If the extent is not a fixed extent, the region and "
"internal extent descriptors themselves are freed.  This function always "
"succeeds."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:157
msgid ""
"E<.Fn extent_alloc> allocates a region in extent E<.Fa ex> of size E<.Fa "
"size> that fits the provided parameters.  There are two distinct allocation "
"policies, which are selected by the E<.Fa flags> argument:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/extent.9:158
#, no-wrap
msgid "Dv EX_FAST"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:161
msgid ""
"Allocate the first region that fits the provided parameters, regardless of "
"resulting extent fragmentation."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/extent.9:161
#, no-wrap
msgid "default"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:164
msgid ""
"Allocate the smallest region that is capable of holding the request, thus "
"minimizing fragmentation of the extent."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:198
msgid ""
"The caller must specify if waiting for space in the extent is allowed using "
"the flag E<.Dv EX_WAITSPACE>.  If E<.Dv EX_WAITSPACE> is not specified, the "
"allocation will fail if the request can not be satisfied without sleeping.  "
"The caller must also specify, using the E<.Dv EX_NOWAIT> or E<.Dv EX_WAITOK> "
"flags, if waiting for overhead allocation is allowed.  The request will be "
"aligned to E<.Fa alignment> boundaries.  Alignment values must be a power of "
"2.  If no alignment is necessary, the value 1 should be specified.  If E<.Fa "
"boundary> is nonzero, the allocated region will not cross any of the numbers "
"which are a multiple of E<.Fa boundary>.  If the caller specifies the E<.Dv "
"EX_BOUNDZERO> flag, the boundary lines begin at zero.  Otherwise, the "
"boundary lines begin at the beginning of the extent.  The allocated region "
"may begin on a boundary address, but the end of the region will not touch "
"nor cross it.  A boundary argument smaller than the size of the request is "
"invalid.  Upon successful completion, E<.Fa *result> will contain the start "
"of the allocated region."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:212
msgid ""
"E<.Fn extent_alloc_subregion> is similar to E<.Fn extent_alloc>, but it "
"allows the caller to specify that the allocated region must fall within the "
"subregion from E<.Fa substart> to E<.Fa subend> inclusive.  The other "
"arguments and the return values of E<.Fn extent_alloc_subregion> are "
"otherwise the same as those of E<.Fn extent_alloc>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:232
msgid ""
"E<.Fn extent_alloc_region> allocates the specific region in the extent map "
"E<.Fa ex> beginning at E<.Fa start> with the size E<.Fa size>.  The caller "
"must specify whether it is okay to wait for the indicated region to be free "
"using the flag E<.Dv EX_WAITSPACE>.  If E<.Dv EX_WAITSPACE> is not "
"specified, the allocation will fail if the request can not be satisfied "
"without sleeping.  The caller must also specify, using the E<.Dv EX_NOWAIT> "
"or E<.Dv EX_WAITOK> flags, if waiting for overhead allocation is allowed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:250
msgid ""
"The E<.Fn extent_alloc1> and E<.Fn extent_alloc_subregion1> functions are "
"extensions that take one additional argument, E<.Fa skew>, that modifies the "
"requested alignment result in the following way: the value E<.Pq Fa result "
"No - Fa skew> is aligned to E<.Fa alignment> boundaries.  E<.Fa skew> must "
"be a smaller number than E<.Fa alignment>.  Also, a boundary argument "
"smaller than the sum of the requested skew and the size of the request is "
"invalid."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:275
msgid ""
"E<.Fn extent_free> frees a region of E<.Fa size> bytes in extent E<.Fa ex> "
"starting at E<.Fa start>.  If the extent has the E<.Dv EX_NOCOALESCE> "
"property, only entire regions may be freed.  If the extent has the E<.Dv "
"EX_NOCOALESCE> property and the caller attempts to free a partial region, "
"behavior is undefined.  The caller must specify one of the flags E<.Dv "
"EX_NOWAIT> or E<.Dv EX_WAITOK> to specify whether waiting for memory is "
"okay; these flags have meaning in the event that allocation of a region "
"descriptor is required during the freeing process.  This situation occurs "
"only when a partial region that begins and ends in the middle of another "
"region is freed.  Behavior is undefined if invalid arguments are provided."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:281
msgid ""
"E<.Fn extent_print> Print out information about extent E<.Fa ex>.  This "
"function always succeeds.  Behavior is undefined if invalid arguments are "
"provided."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/extent.9:281 org_netbsd/src/share/man/man9/sysctl.9:107
#, no-wrap
msgid "LOCKING"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:291
msgid ""
"The extent manager performs all necessary locking on the extent map itself, "
"and any other data structures internal to the extent manager.  The locks "
"used by the extent manager are simplelocks, and will never sleep E<.Po> see "
"E<.Xr lock 9> E<.Pc>.  This should be taken into account when designing the "
"locking protocol for users of the extent manager."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:306
msgid ""
"The behavior of all extent manager functions is undefined if given invalid "
"arguments.  E<.Fn extent_create> returns the extent map on success, or E<.Dv "
"NULL> if it fails to allocate storage for the extent map.  It always "
"succeeds when creating a fixed extent or when given the flag E<.Dv "
"EX_WAITOK>.  E<.Fn extent_alloc>, E<.Fn extent_alloc_region>, E<.Fn "
"extent_alloc_subregion>, and E<.Fn extent_free> return one of the following "
"values:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/extent.9:307
#, no-wrap
msgid "Dv 0"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:309
msgid "Operation was successful."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/extent.9:309
#, no-wrap
msgid "Dv ENOMEM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:315
msgid ""
"If E<.Dv EX_NOWAIT> is specified, the extent manager was not able to "
"allocate a region descriptor for the new region or to split a region when "
"freeing a partial region."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/extent.9:315
#, no-wrap
msgid "Dv EAGAIN"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:319
msgid "Requested region is not available and E<.Dv EX_WAITSPACE> was not specified."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/extent.9:319
#, no-wrap
msgid "Dv EINTR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:324
msgid ""
"Process received a signal while waiting for the requested region to become "
"available in the extent.  Does not apply to E<.Fn extent_free>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:328
msgid ""
"Here is an example of a (useless) function that uses several of the extent "
"manager routines."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:335
#, no-wrap
msgid ""
"void\n"
"func()\n"
"{\n"
"\tstruct extent *foo_ex;\n"
"\tu_long region_start;\n"
"\tint error;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:343
#, no-wrap
msgid ""
"\t/*\n"
"\t * Extent \"foo\" manages a 256k region starting at 0x0 and\n"
"\t * only allows complete regions to be freed so that\n"
"\t * extent_free() never needs to allocate memory.\n"
"\t */\n"
"\tfoo_ex = extent_create(\"foo\", 0x0, 0x3ffff, M_DEVBUF,\n"
"\t    NULL, 0, EX_WAITOK | EX_NOCOALESCE);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:353
#, no-wrap
msgid ""
"\t/*\n"
"\t * Allocate an 8k region, aligned to a 4k boundary, which\n"
"\t * does not cross any of the 3 64k boundaries (at 64k,\n"
"\t * 128k, and 192k) within the extent.\n"
"\t */\n"
"\terror = extent_alloc(foo_ex, 0x2000, 0x1000, 0x10000,\n"
"\t    EX_NOWAIT, \\*[Am]region_start);\n"
"\tif (error)\n"
"\t\tpanic(\"you lose\");\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:359
#, no-wrap
msgid ""
"\t/*\n"
"\t * Give up the extent.\n"
"\t */\n"
"\textent_destroy(foo_ex);\n"
"}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:365
msgid ""
"The extent manager itself is implemented within the file E<.Pa "
"sys/kern/subr_extent.c>.  Function prototypes for the framework are located "
"in E<.Pa sys/sys/extent.h>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:370
msgid ""
"The i386 bus management code uses the extent manager for managing I/O ports "
"and I/O memory.  This code is in the file E<.Pa "
"sys/arch/i386/i386/machdep.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:372
msgid "E<.Xr malloc 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:377
msgid "The E<.Nx> extent manager appeared in E<.Nx 1.3>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/extent.9:388
msgid ""
"The E<.Nx> extent manager was architected and implemented by E<.An Jason "
"R. Thorpe> E<.Aq thorpej@NetBSD.org>.  E<.An Matthias Drochner> E<.Aq "
"drochner@zelux6.zel.kfa-juelich.de> contributed to the initial testing and "
"optimization of the implementation.  E<.An Chris Demetriou> E<.Aq "
"cgd@NetBSD.org> contributed many architectural suggestions."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/fetch.9:35 org_netbsd/src/share/man/man9/store.9:35
#, no-wrap
msgid "January 7, 1996"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/fetch.9:36
#, no-wrap
msgid "FETCH 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fetch.9:46
msgid ""
"E<.Nm fetch>, E<.Nm fubyte>, E<.Nm fuibyte>, E<.Nm fusword>, E<.Nm "
"fuswintr>, E<.Nm fuword>, E<.Nm fuiword>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/fetch.9:46
#, no-wrap
msgid "fetch data from user-space"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fetch.9:58
msgid ""
"E<.Ft int> E<.Fn fubyte \"const void *base\"> E<.Ft int> E<.Fn fusword "
"\"const void *base\"> E<.Ft int> E<.Fn fuswintr \"const void *base\"> E<.Ft "
"long> E<.Fn fuword \"const void *base\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fetch.9:62
msgid ""
"The E<.Nm> functions are designed to copy small amounts of data from "
"user-space."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fetch.9:67
#, no-wrap
msgid "Fn fubyte"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fetch.9:70
msgid "Fetches a byte of data from the user-space address E<.Fa base>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fetch.9:70
#, no-wrap
msgid "Fn fusword"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fetch.9:73
msgid "Fetches a short word of data from the user-space address E<.Fa base>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fetch.9:73
#, no-wrap
msgid "Fn fuswintr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fetch.9:77
msgid ""
"Fetches a short word of data from the user-space address E<.Fa base>.  This "
"function is safe to call during an interrupt context."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fetch.9:77
#, no-wrap
msgid "Fn fuword"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fetch.9:80
msgid "Fetches a word of data from the user-space address E<.Fa base>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fetch.9:90
msgid ""
"The E<.Nm> functions return the data fetched or -1 on failure.  Note that "
"these functions all do \"unsigned\" access, and therefore will never sign "
"extend byte or short values.  This prevents ambiguity with the error return "
"value for all functions except E<.Fn fuword>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fetch.9:93
msgid "E<.Xr copy 9>, E<.Xr store 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fetch.9:100
msgid ""
"The function E<.Fn fuword> has no way to unambiguously signal an error, "
"because the data it reads might legitimately be the same as the -1 used to "
"indicate an error.  The other functions do not have this problem because the "
"unsigned values returned by those can never match the -1 error return value."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/file.9:30
#, no-wrap
msgid "May 17, 2009"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/file.9:31
#, no-wrap
msgid "FILE 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:41
msgid ""
"E<.Nm file>, E<.Nm closef>, E<.Nm ffree>, E<.Nm FILE_IS_USABLE>, E<.Nm "
"FILE_USE>, E<.Nm FILE_UNUSE>, E<.Nm FILE_SET_MATURE>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/file.9:41
#, no-wrap
msgid "operations on file entries"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:56
msgid ""
"E<.Ft int> E<.Fn closef \"struct file *fp\" \"struct lwp *l\"> E<.Ft void> "
"E<.Fn ffree \"struct file *fp\"> E<.Ft int> E<.Fn FILE_IS_USABLE \"struct "
"file *fp\"> E<.Ft void> E<.Fn FILE_USE \"struct file *fp\"> E<.Ft void> "
"E<.Fn FILE_UNUSE \"struct file *fp\" \"struct lwp *l\"> E<.Ft void> E<.Fn "
"FILE_SET_MATURE \"struct file *fp\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:63
msgid ""
"The file descriptor table of a process references a file entry for each file "
"used by the kernel.  See E<.Xr filedesc 9> for details of the file "
"descriptor table.  Each file entry is given by:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:92
#, no-wrap
msgid ""
"struct file {\n"
"        LIST_ENTRY(file) f_list;        /* list of active files */\n"
"        int             f_flag;\n"
"        int             f_iflags;       /* internal flags */\n"
"        int             f_type;         /* descriptor type */\n"
"        u_int           f_count;        /* reference count */\n"
"        u_int           f_msgcount;     /* message queue references */\n"
"        int             f_usecount;     /* number active users */\n"
"        kauth_cred_t    f_cred;         /* creds associated with descriptor "
"*/\n"
"        struct fileops {\n"
"                int (*fo_read)(struct file *fp, off_t *offset,\n"
"\t\t\tstruct uio *uio, kauth_cred_t cred, int flags);\n"
"                int (*fo_write)(struct file *fp, off_t *offset,\n"
"                        struct uio *uio, kauth_cred_t cred, int flags);\n"
"                int (*fo_ioctl)(struct file *fp, u_long com, void *data,\n"
"\t\t\tstruct lwp *l);\n"
"                int (*fo_fcntl)(struct file *fp, u_int com, void *data,\n"
"\t\t\tstruct lwp *l);\n"
"                int (*fo_poll)(struct file *fp, int events,\n"
"\t\t\tstruct lwp *l);\n"
"                int (*fo_stat)(struct file *fp, struct stat *sp,\n"
"\t\t\tstruct lwp *l);\n"
"                int (*fo_close)(struct file *fp, struct lwp *l);\n"
"        } *f_ops;\n"
"        off_t           f_offset;\n"
"        void         *f_data;         /* descriptor data */\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:122
msgid ""
"E<.Nx> treats file entries in an object-oriented fashion after they are "
"created.  Each entry specifies the object type, E<.Em f_type>, which can "
"have the values E<.Dv DTYPE_VNODE>, E<.Dv DTYPE_SOCKET>, E<.Dv DTYPE_PIPE> "
"and E<.Dv DTYPE_MISC>.  The file entry also has a pointer to a data "
"structure, E<.Em f_data>, that contains information specific to the instance "
"of the underlying object.  The data structure is opaque to the routines that "
"manipulate the file entry.  Each entry also contains an array of function "
"pointers, E<.Em f_ops>, that translate the generic operations on a file "
"descriptor into the specific action associated with its type.  A reference "
"to the data structure is passed as the first parameter to a function that "
"implements a file operation.  The operations that must be implemented for "
"each descriptor type are read, write, ioctl, fcntl, poll, stat, and close.  "
"See E<.Xr vnfileops 9> for an overview of the vnode file operations.  All "
"state associated with an instance of an object must be stored in that "
"instance's data structure; the underlying objects are not permitted to "
"manipulate the file entry themselves."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:133
msgid ""
"For data files, the file entry points to a E<.Xr vnode 9> structure.  Pipes "
"and sockets do not have data blocks allocated on the disk and are handled by "
"the special-device filesystem that calls appropriate drivers to handle I/O "
"for them.  For pipes, the file entry points to a system block that is used "
"during data transfer.  For sockets, the file entry points to a system block "
"that is used in doing interprocess communications."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:142
msgid ""
"The descriptor table of a process (and thus access to the objects to which "
"the descriptors refer) is inherited from its parent, so several different "
"processes may reference the same file entry.  Thus, each file entry has a "
"reference count, E<.Em f_count>.  Each time a new reference is created, the "
"reference count is incremented.  When a descriptor is closed, the reference "
"count is decremented.  When the reference count drops to zero, the file "
"entry is freed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:156
msgid ""
"Some file descriptor semantics can be altered through the E<.Ar flags> "
"argument to the E<.Xr open 2> system call.  These flags are recorded in "
"E<.Em f_flags> member of the file entry.  For example, the flags record "
"whether the descriptor is open for reading, writing, or both reading and "
"writing.  The following flags and their corresponding E<.Xr open 2> flags "
"are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/file.9:158
#, no-wrap
msgid "FAPPEND"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:160
msgid "E<.Dv O_APPEND>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/file.9:160
#, no-wrap
msgid "FASYNC"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:162
msgid "E<.Dv O_ASYNC>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/file.9:162
#, no-wrap
msgid "O_FSYNC"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:164 org_netbsd/src/share/man/man9/file.9:172
msgid "E<.Dv O_SYNC>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/file.9:164
#, no-wrap
msgid "FNDELAY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:166 org_netbsd/src/share/man/man9/file.9:168 org_netbsd/src/share/man/man9/file.9:170
msgid "E<.Dv O_NONBLOCK>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/file.9:166
#, no-wrap
msgid "O_NDELAY"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/file.9:168
#, no-wrap
msgid "FNONBLOCK"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/file.9:170
#, no-wrap
msgid "FFSYNC"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/file.9:172
#, no-wrap
msgid "FDSYNC"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:174
msgid "E<.Dv O_DSYNC>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/file.9:174
#, no-wrap
msgid "FRSYNC"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:176
msgid "E<.Dv O_RSYNC>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/file.9:176
#, no-wrap
msgid "FALTIO"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:178
msgid "E<.Dv O_ALT_IO>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:184
msgid ""
"Some additional state-specific flags are recorded in the E<.Em f_iflags> "
"member.  Valid values include:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/file.9:186
#, no-wrap
msgid "FIF_WANTCLOSE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:192
msgid ""
"If set, then the reference count on the file is zero, but there were "
"multiple users of the file.  This can happen if a file descriptor table is "
"shared by multiple processes.  This flag notifies potential users that the "
"file is closing and will prevent them from adding additional uses to the "
"file."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/file.9:192
#, no-wrap
msgid "FIF_LARVAL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:194
msgid "The file entry is not fully constructed (mature) and should not be used."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:207
msgid ""
"The E<.Xr read 2> and E<.Xr write 2> system calls do not take an offset in "
"the file as an argument.  Instead, each read or write updates the current "
"file offset, E<.Em f_offset> in the file according to the number of bytes "
"transferred.  Since more than one process may open the same file and each "
"needs its own offset in the file, the offset cannot be stored in the "
"per-object data structure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/file.9:209
#, no-wrap
msgid "Fn closef fp l"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:221
msgid ""
"The internal form of E<.Xr close 2> which decrements the reference count on "
"file entry E<.Fa fp>.  The E<.Fn closef> function release all locks on the "
"file owned by lwp E<.Fa l>, decrements the reference count on the file "
"entry, and invokes E<.Fn ffree> to free the file entry."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/file.9:221
#, no-wrap
msgid "Fn ffree \"struct file *fp\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:226
msgid "Free file entry E<.Fa fp>.  The file entry was created in E<.Xr falloc 9>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/file.9:226
#, no-wrap
msgid "Fn FILE_IS_USABLE fp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:230
msgid ""
"Ensure that the file entry is useable by ensuring that neither the "
"FIF_WANTCLOSE and FIF_LARVAL flags are not set in E<.Em f_iflags>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/file.9:230
#, no-wrap
msgid "Fn FILE_USE fp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:233
msgid "Increment the reference count on file entry E<.Fa fp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/file.9:233
#, no-wrap
msgid "Fn FILE_UNUSE fp l"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:240
msgid ""
"Decrement the reference count on file entry E<.Fa fp>.  If the FIF_WANTCLOSE "
"flag is set in E<.Em f_iflags>, the file entry is freed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/file.9:240
#, no-wrap
msgid "Fn FILE_SET_MATURE fp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:244
msgid ""
"Mark the file entry as being fully constructed (mature) by clearing the "
"FIF_LARVAL flag in E<.Em f_iflags>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:248
msgid ""
"The framework for file entry handling is implemented within the file E<.Pa "
"sys/kern/kern_descrip.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/file.9:252
msgid "E<.Xr dofileread 9>, E<.Xr filedesc 9>, E<.Xr vnfileops 9>, E<.Xr vnode 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/fileassoc.9:28 org_netbsd/src/share/man/man9/sysmon_pswitch.9:30
#, no-wrap
msgid "January 26, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/fileassoc.9:29
#, no-wrap
msgid "FILEASSOC 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:33
msgid "E<.Nm fileassoc>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/fileassoc.9:33
#, no-wrap
msgid "in-kernel, file-system independent, file-meta data association"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/fileassoc.9:35
#, no-wrap
msgid "sys/fileassoc.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:56
msgid ""
"E<.Ft int> E<.Fn fileassoc_register \"const char *name\" "
"\"fileassoc_cleanup_cb_t cleanup_cb\" \"fileassoc_t *result\"> E<.Ft int> "
"E<.Fn fileassoc_deregister \"fileassoc_t id\"> E<.Ft void *> E<.Fn "
"fileassoc_lookup \"struct vnode *vp\" \"fileassoc_t id\"> E<.Ft int> E<.Fn "
"fileassoc_table_delete \"struct mount *mp\"> E<.Ft int> E<.Fn "
"fileassoc_table_clear \"struct mount *mp\" \"fileassoc_t id\"> E<.Ft int> "
"E<.Fn fileassoc_table_run \"struct mount *mp\" \"fileassoc_t id\" "
"\"fileassoc_cb_t cb\" \"void *cookie\"> E<.Ft int> E<.Fn "
"fileassoc_file_delete \"struct vnode *vp\"> E<.Ft int> E<.Fn fileassoc_add "
"\"struct vnode *vp\" \"fileassoc_t id\" \"void *data\"> E<.Ft int> E<.Fn "
"fileassoc_clear \"struct vnode *vp\" \"fileassoc_t id\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:61
msgid ""
"The E<.Nm> KPI allows association of meta-data with files independent of "
"file-system support for such elaborate meta-data."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:65
msgid ""
"When plugging a new fileassoc to the system, a developer can specify private "
"data to be associated with every file, as well as (potentially different)  "
"private data to be associated with every file-system mount."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:68
msgid ""
"For example, a developer might choose to associate a custom ACL with every "
"file, and a count of total files with ACLs with the mount."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/fileassoc.9:68
#, no-wrap
msgid "KERNEL PROGRAMMING INTERFACE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:73
msgid ""
"Designed with simplicity in mind, the E<.Nm> KPI usually accepts four "
"different types of parameters to the most commonly used routines:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fileassoc.9:74
#, no-wrap
msgid "Ft struct mount * Ar mp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:76
msgid "Describing a mount on which to take action."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fileassoc.9:76
#, no-wrap
msgid "Ft struct vnode * Ar vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:78
msgid "Describing a file on which to take action."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fileassoc.9:78
#, no-wrap
msgid "Ft fileassoc_t Ar id"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:81
msgid ""
"Describing an id, as returned from a successful call to E<.Fn "
"fileassoc_register>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fileassoc.9:81
#, no-wrap
msgid "Ft void * Ar data"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:83
msgid ""
"Describing a custom private data block, attached to either a file or a "
"mount."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:93
msgid ""
"Before using the E<.Nm> KPI it is important to keep in mind that the "
"interface provides memory management only for E<.Nm> internal memory.  Any "
"additional memory stored in the tables (such as private data-structures used "
"by custom fileassocs) should be allocated and freed by the developer."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:101
msgid ""
"E<.Nm> provides the ability to specify a E<.Dq cleanup> routine to E<.Fn "
"fileassoc_register> (see below)  to be called whenever an entry for a file "
"or a mount is deleted."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/fileassoc.9:101
#, no-wrap
msgid "REGISTRATION AND DEREGISTRATION ROUTINES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:105
msgid ""
"These routines allow a developer to allocate a E<.Nm> slot to be used for "
"private data."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fileassoc.9:106
#, no-wrap
msgid "Fn fileassoc_register name cleanup_cb result"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:116
msgid ""
"Registers a new fileassoc as E<.Ar name>, and returns a E<.Ft fileassoc_t> "
"via E<.Fa result> to be used as identifier in subsequent calls to the E<.Nm> "
"subsystem."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:120
msgid ""
"E<.Fn fileassoc_register> returns zero on success.  Otherwise, an error "
"number will be returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:127
msgid ""
"If E<.Ar cleanup_cb> is not E<.Dv NULL>, it will be called during "
"delete/clear operations (see routines below) with indication whether the "
"passed data is file- or mount-specific."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:136
msgid ""
"E<.Ar cleanup_cb> should be a function receiving a E<.Ft void *> and "
"returning E<.Ft void>.  See the E<.Sx EXAMPLES> section for illustration."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fileassoc.9:137
#, no-wrap
msgid "Fn fileassoc_deregister id"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:142
msgid "Deregisters a E<.Nm fileassoc> whose id is E<.Ar id>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:149
msgid ""
"Note that calling E<.Fn fileassoc_deregister> only frees the associated slot "
"in the E<.Nm> subsystem.  It is up to the developer to take care of garbage "
"collection."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/fileassoc.9:150
#, no-wrap
msgid "LOOKUP ROUTINES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:154
msgid ""
"These routines allow lookup of E<.Nm> mounts, files, and private data "
"attached to them."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fileassoc.9:155
#, no-wrap
msgid "Fn fileassoc_lookup vp id"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:160
msgid ""
"Returns the private data for the file/id combination or E<.Dv NULL> if not "
"found."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/fileassoc.9:161
#, no-wrap
msgid "MOUNT-WIDE ROUTINES"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fileassoc.9:163
#, no-wrap
msgid "Fn fileassoc_table_delete mp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:166
msgid "Deletes a fileassoc table for E<.Ar mp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fileassoc.9:167
#, no-wrap
msgid "Fn fileassoc_table_clear mp id"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:172
msgid "Clear all table entries for E<.Ar fileassoc> from E<.Ar mp>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:176
msgid ""
"If specified, the fileassoc's E<.Dq cleanup routine> will be called with a "
"pointer to the private data-structure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fileassoc.9:177
#, no-wrap
msgid "Fn fileassoc_table_run mp id cb cookie"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:185
msgid ""
"For each entry for E<.Ar id>, call E<.Ar cb> with the entry being the first "
"argument, and E<.Ar cookie> being the second argument."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:192
msgid ""
"E<.Ar cb> is a function returning E<.Ft void> and receiving one E<.Ft \"void "
"*\"> parameter."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/fileassoc.9:193
#, no-wrap
msgid "FILE-SPECIFIC ROUTINES"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fileassoc.9:195
#, no-wrap
msgid "Fn fileassoc_file_delete vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:198
msgid "Delete the fileassoc entries for E<.Ar vp>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:204
msgid ""
"If specified, the E<.Dq cleanup routines> of all fileassoc types added will "
"be called with a pointer to the corresponding private data structure and "
"indication of E<.Dv FILEASSOC_CLEANUP_FILE>."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/fileassoc.9:205
#, no-wrap
msgid "FILEASSOC-SPECIFIC ROUTINES"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fileassoc.9:207
#, no-wrap
msgid "Fn fileassoc_add vp id data"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:214
msgid ""
"Add private data in E<.Ar data> for E<.Ar vp>, for the fileassoc specified "
"by E<.Ar id>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:220
msgid ""
"If a table for the mount-point E<.Ar vp> is on doesn't exist, one will be "
"created automatically.  E<.Nm> manages internally the optimal table sizes as "
"tables are modified."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fileassoc.9:220
#, no-wrap
msgid "Fn fileassoc_clear vp id"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:225
msgid ""
"Clear the private data for E<.Ar vp>, for the fileassoc specified by E<.Ar "
"id>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:230
msgid ""
"If specified, the fileassoc's E<.Dq cleanup routine> will be called with a "
"pointer to the private data-structure and indication of E<.Dv "
"FILEASSOC_CLEANUP_FILE>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:235
msgid ""
"The following code examples should give you a clue on using E<.Nm> for your "
"purposes."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:239
msgid ""
"First, we'll begin with registering a new id.  We need to do that to save a "
"slot for private data storage with each mount and/or file:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:242
#, no-wrap
msgid ""
"fileassoc_t myhook_id;\n"
"int error;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:246
#, no-wrap
msgid ""
"error = fileassoc_register(\"my_hook\", myhook_cleanup, \\*[Am]myhook_id);\n"
"if (error != 0)\n"
"\t...handle error...\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:252
msgid ""
"In the above example we pass a E<.Fn myhook_cleanup> routine.  It could look "
"something like this:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:256
#, no-wrap
msgid ""
"void\n"
"myhook_cleanup(void *data)\n"
"{\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:261
#, no-wrap
msgid ""
"\tprintf(\"Myhook: Removing entry for file.\\en\");\n"
"\t...handle file entry removal...\n"
"\tfree(data, M_TEMP);\n"
"}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:265
msgid ""
"Another useful thing would be to add our private data to a file.  For "
"example, let's assume we keep a custom ACL with each file:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:270
#, no-wrap
msgid ""
"int\n"
"myhook_acl_add(struct vnode *vp, struct myhook_acl *acl)\n"
"{\n"
"\tint error;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:276
#, no-wrap
msgid ""
"\terror = fileassoc_add(vp, myhook_id, acl);\n"
"\tif (error) {\n"
"\t\tprintf(\"Myhook: Could not add ACL.\\en\");\n"
"\t\t...handle error...\n"
"\t}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:278
#, no-wrap
msgid "\tprintf(\"Myhook: Added ACL.\\en\");\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:281 org_netbsd/src/share/man/man9/fileassoc.9:306
#, no-wrap
msgid ""
"\treturn (0);\n"
"}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:284
msgid "Adding an entry will override any entry that previously exists."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:288
msgid ""
"Whatever your plug is, eventually you'll want to access the private data you "
"store with each file.  To do that you can use the following:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:293
#, no-wrap
msgid ""
"int\n"
"myhook_acl_access(struct vnode *vp, int access_flags)\n"
"{\n"
"\tstruct myhook_acl *acl;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:297
#, no-wrap
msgid ""
"\tacl = fileassoc_lookup(vp, myhook_id);\n"
"\tif (acl == NULL)\n"
"\t\treturn (0);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:303
#, no-wrap
msgid ""
"\terror = myhook_acl_eval(acl, access_flags);\n"
"\tif (error) {\n"
"\t\tprintf(\"Myhook: Denying access based on ACL decision.\\en\");\n"
"\t\treturn (error);\n"
"\t}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:310
msgid ""
"And, in some cases, it may be desired to remove private data associated with "
"an file:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:312
#, no-wrap
msgid "int error;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:318
#, no-wrap
msgid ""
"error = fileassoc_clear(vp, myhook_id);\n"
"if (error) {\n"
"\tprintf(\"Myhook: Error occurred during fileassoc removal.\\en\");\n"
"\t...handle error...\n"
"}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:326
msgid ""
"As mentioned previously, the call to E<.Fn fileassoc_clear> will result in a "
"call to the E<.Dq cleanup routine> specified in the initial call to E<.Fn "
"fileassoc_register>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:328
msgid "The above should be enough to get you started."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:332
msgid "For example usage of E<.Nm>, see the Veriexec code."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:337
msgid "The E<.Nm> is implemented within E<.Pa src/sys/kern/kern_fileassoc.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:342
msgid "The E<.Nm> KPI first appeared in E<.Nx 4.0>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fileassoc.9:344
msgid "E<.An Elad Efrat Aq elad@NetBSD.org> E<.An Brett Lymn Aq blymn@NetBSD.org>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/filedesc.9:30
#, no-wrap
msgid "July 24, 2006"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/filedesc.9:31
#, no-wrap
msgid "FILEDESC 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:51
msgid ""
"E<.Nm filedesc>, E<.Nm dupfdopen>, E<.Nm falloc>, E<.Nm fd_getfile>, E<.Nm "
"fdalloc>, E<.Nm fdcheckstd>, E<.Nm fdclear>, E<.Nm fdclone>, E<.Nm "
"fdcloseexec>, E<.Nm fdcopy>, E<.Nm fdexpand>, E<.Nm fdfree>, E<.Nm fdinit>, "
"E<.Nm fdrelease>, E<.Nm fdremove>, E<.Nm fdshare>, E<.Nm fdunshare>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/filedesc.9:51
#, no-wrap
msgid "file descriptor tables and operations"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/filedesc.9:54
#, no-wrap
msgid "sys/filedesc.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:87
msgid ""
"E<.Ft int> E<.Fn falloc \"struct lwp *l\" \"struct file **resultfp\" \"int "
"*resultfd\"> E<.Ft struct file *> E<.Fn fd_getfile \"struct filedesc *fdp\" "
"\"int fd\"> E<.Ft int> E<.Fn dupfdopen \"struct lwp *l\" \"int indx\" \"int "
"dfd\" \"int mode\" \"int error\"> E<.Ft int> E<.Fn fdalloc \"struct proc "
"*p\" \"int want\" \"int *result\"> E<.Ft int> E<.Fn fdcheckstd \"struct lwp "
"*l\"> E<.Ft void> E<.Fn fdclear \"struct lwp *l\"> E<.Ft int> E<.Fn fdclone "
"\"struct lwp *l\" \"struct file *fp\" \"int fd\" \"int flag\" \"const struct "
"fileops *fops\" \"void *data\"> E<.Ft void> E<.Fn fdcloseexec \"struct lwp "
"*l\"> E<.Ft struct filedesc *> E<.Fn fdcopy \"struct proc *p\"> E<.Ft void> "
"E<.Fn fdexpand \"struct proc *p\"> E<.Ft void> E<.Fn fdfree \"struct lwp "
"*l\"> E<.Ft struct filedesc *> E<.Fn fdinit \"struct proc *p\"> E<.Ft int> "
"E<.Fn fdrelease \"struct lwp *l\" \"int fd\"> E<.Ft void> E<.Fn fdremove "
"\"struct filedesc *fdp\" \"int fd\"> E<.Ft void> E<.Fn fdshare \"struct proc "
"*p1\" \"struct proc *p2\"> E<.Ft void> E<.Fn fdunshare \"struct lwp *l\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:95
msgid ""
"For user processes, all I/O is done through file descriptors.  These file "
"descriptors represent underlying objects supported by the kernel and are "
"created by system calls specific to the type of object.  In E<.Nx>, six "
"types of objects can be represented by file descriptors: data files, pipes, "
"sockets, event queues, crypto, and miscellaneous."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:101
msgid ""
"The kernel maintains a descriptor table for each process which is used to "
"translate the external representation of a file descriptor into an internal "
"representation.  The file descriptor is merely an index into this table.  "
"The file descriptor table maintains the following information:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:105
msgid "the number of descriptors allocated in the file descriptor table;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:107
msgid "approximate next free descriptor;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:109
msgid "a reference count on the file descriptor table; and"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:111
msgid "an array of open file entries."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:122
msgid ""
"On creation of the file descriptor table, a fixed number of file entries are "
"created.  It is the responsibility of the file descriptor operations to "
"expand the available number of entries if more are required.  Each file "
"entry in the descriptor table contains the information necessary to access "
"the underlying object and to maintain common information.  See E<.Xr file 9> "
"for details of operations on the file entries."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:131
msgid ""
"New file descriptors are generally allocated by E<.Fn falloc> and freed by "
"E<.Fn fdrelease>.  File entries are extracted from the file descriptor table "
"by E<.Fn fd_getfile>.  Most of the remaining functions in the interface are "
"purpose specific and perform lower-level file descriptor operations."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:134
msgid ""
"The following functions are high-level interface routines to access the file "
"descriptor table for a process and its file entries."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/filedesc.9:136
#, no-wrap
msgid "Fn falloc p *resultfp *resultfd"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:149
msgid ""
"Create a new open file entry and allocate a file descriptor for process "
"E<.Fa p>.  This operation is performed by invoking E<.Fn fdalloc> to "
"allocate the new file descriptor.  The credential on the file entry are "
"inherited from process E<.Fa p>.  The E<.Fn falloc> function is responsible "
"for expanding the file descriptor table when necessary."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:158
msgid ""
"A pointer to the file entry is returned in E<.Fa *resultfp> and the file "
"descriptor is returned in E<.Fa *resultfd>.  The E<.Fn falloc> function "
"returns zero on success, otherwise an appropriate error is returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/filedesc.9:158
#, no-wrap
msgid "Fn fd_getfile fdp fd"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:166
msgid ""
"Get the file entry for file descriptor E<.Fa fd> in the file descriptor "
"table E<.Fa fdp>.  The file entry is returned if it is valid and useable, "
"otherwise E<.Dv NULL> is returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/filedesc.9:166
#, no-wrap
msgid "Fn dupfdopen l indx dfd mode error"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:171
msgid "Duplicate file descriptor E<.Fa dfd> for lwp E<.Fa l>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:175
msgid "The following functions operate on the file descriptor table for a process."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/filedesc.9:177
#, no-wrap
msgid "Fn fdalloc p want *result"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:188
msgid ""
"Allocate a file descriptor E<.Fa want> for process E<.Fa p>.  The resultant "
"file descriptor is returned in E<.Fa *result>.  The E<.Fn fdalloc> function "
"returns zero on success, otherwise an appropriate error is returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/filedesc.9:188
#, no-wrap
msgid "Fn fdcheckstd l"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:199
msgid ""
"Check the standard file descriptors 0, 1, and 2 and ensure they are "
"referencing valid file descriptors.  If they are not, create references to "
"E<.Pa /dev/null>.  This operation is necessary as these file descriptors are "
"given implicit significance in the Standard C Library and it is unsafe for "
"E<.Xr setuid 2> and E<.Xr setgid 2> processes to be started with these file "
"descriptors closed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/filedesc.9:199
#, no-wrap
msgid "Fn fdclear l"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:208
msgid ""
"Clear the descriptor table for lwp E<.Fa l>.  This operation is performed by "
"invoking E<.Fn fdinit> to initialise a new file descriptor table to replace "
"the old file descriptor table and invoking E<.Fn fdfree> to release the old "
"one."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/filedesc.9:208
#, no-wrap
msgid "Fn fdclone l fp fd flag fops data"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:220
msgid ""
"This function is meant to be used by devices which allocate a file entry "
"upon open.  E<.Fn fdclone> fills E<.Fa fp> with the given parameters.  It "
"always returns the in-kernel errno value E<.Er EMOVEFD>, which is meant to "
"be returned from the device open routine.  This special return value is "
"interpreted by the caller of the device open routine."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/filedesc.9:220
#, no-wrap
msgid "Fn fdcloseexec l"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:230
msgid ""
"Close any files for process E<.Fa p> that are marked E<.Dq close on exec>.  "
"This operation is performed by invoking E<.Fn fdunshare> for the process and "
"invoking E<.Fn fdrelease> on the appropriate file descriptor."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/filedesc.9:230
#, no-wrap
msgid "Fn fdcopy p"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:238
msgid ""
"Copy the file descriptor table from process E<.Fa p> and return a pointer to "
"the copy.  The returned file descriptor is guaranteed to have a reference "
"count of one.  All file descriptor state is maintained.  The reference "
"counts on each file entry referenced by the file descriptor table is "
"incremented accordingly."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/filedesc.9:238
#, no-wrap
msgid "Fn fdexpand p"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:242
msgid ""
"Expand the file descriptor table for process E<.Fa p> by allocating memory "
"for additional file descriptors."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/filedesc.9:242
#, no-wrap
msgid "Fn fdfree l"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:247
msgid ""
"Decrement the reference count on the file descriptor table for lwp E<.Fa l> "
"and release the file descriptor table if the reference count drops to zero."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/filedesc.9:247
#, no-wrap
msgid "Fn fdinit p"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:253
msgid ""
"Create a file descriptor table using the same current and root directories "
"of process E<.Fa p>.  The returned file descriptor table is guaranteed to "
"have a reference count of one."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/filedesc.9:253
#, no-wrap
msgid "Fn fdrelease l fd"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:260
msgid ""
"Remove file descriptor E<.Fa fd> from the file descriptor table of lwp E<.Fa "
"l>.  The operation is performed by invoking E<.Fn closef>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/filedesc.9:260
#, no-wrap
msgid "Fn fdremove fdp fd"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:265
msgid ""
"Unconditionally remove the file descriptor E<.Fa fd> from file descriptor "
"table E<.Fa fdp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/filedesc.9:265
#, no-wrap
msgid "Fn fdshare p1 p2"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:276
msgid ""
"Share the file descriptor table belonging to process E<.Fa p1> with process "
"E<.Fa p2>.  Process E<.Fa p2> is assumed not to have a file descriptor table "
"already allocated.  The reference count on the file descriptor table is "
"incremented.  This function is used by E<.Xr fork1 9>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/filedesc.9:276
#, no-wrap
msgid "Fn fdunshare l"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:285
msgid ""
"Ensure that lwp E<.Fa l> does not share its file descriptor table.  If its "
"file descriptor table has more than one reference, the file descriptor table "
"is copied by invoking E<.Fn fdcopy>.  The reference count on the original "
"file descriptor table is decremented."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:290
msgid ""
"Successful operations return zero.  A failed operation will return a "
"non-zero return value.  Possible values include:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/filedesc.9:292
#, no-wrap
msgid "Bq Er EBADF"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:294
msgid "Bad file descriptor specified."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/filedesc.9:294
#, no-wrap
msgid "Bq Er EMFILE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:296
msgid "Cannot exceed file descriptor limit."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/filedesc.9:296 org_netbsd/src/share/man/man9/vnodeops.9:1429
#, no-wrap
msgid "Bq Er ENOSPC"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:298
msgid "No space left in file descriptor table."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/filedesc.9:303
msgid ""
"The framework for file descriptor handling is implemented within the file "
"E<.Pa sys/kern/kern_descrip.c>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/firmload.9:30
#, no-wrap
msgid "January 17, 2006"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/firmload.9:31
#, no-wrap
msgid "FIRMLOAD 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/firmload.9:35
msgid "E<.Nm firmload>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/firmload.9:35
#, no-wrap
msgid "Firmware loader API for device drivers"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/firmload.9:37
#, no-wrap
msgid "dev/firmload.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/firmload.9:58
msgid ""
"E<.Ft int> E<.Fn \"firmware_open\" \"const char *drvname\" \"const char "
"*imgname\" \"firmware_handle_t *fhp\"> E<.Ft int> E<.Fn \"firmware_close\" "
"\"firmware_handle_t fh\"> E<.Ft off_t> E<.Fn \"firmware_get_size\" "
"\"firmware_handle_t fh\"> E<.Ft int> E<.Fn \"firmware_read\" "
"\"firmware_handle_t fh\" \"off_t offset\" \"void *buf\" \"size_t size\"> "
"E<.Ft void *> E<.Fn \"firmware_malloc\" \"size_t size\"> E<.Ft void> E<.Fn "
"\"firmware_free\" \"void *buf\" \"size_t size\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/firmload.9:66
msgid ""
"E<.Nm> provides a simple and convenient API for device drivers to load "
"firmware images from files residing in the file system that are necessary "
"for the devices that they control.  Firmware images reside in "
"sub-directories, one for each driver, of a series of colon-separated path "
"prefixes specified by the sysctl variable E<.Dv hw.firmware.path>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/firmload.9:70
msgid "The following functions are provided by the E<.Nm> API:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/firmload.9:71
#, no-wrap
msgid "Fn firmware_open drvname imgname fhp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/firmload.9:85
msgid ""
"Open then firmware image E<.Fa imgname> for the driver E<.Fa drvname>.  The "
"path to the firmware image file is constructed by appending the string E<.Dq "
"\"/drvname/imgname\"> to each configured path prefix until opening the "
"firmware image file succeeds.  Upon success, E<.Fn firmware_open> returns 0 "
"and stores a firmware image handle in the location pointed to by E<.Fa "
"fhp>.  Otherwise, an error code is returned to indicate the reason for "
"failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/firmload.9:85
#, no-wrap
msgid "Fn firmware_close fh"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/firmload.9:90
msgid ""
"Close the firmware image file associated with the firmware handle E<.Fa "
"fh>.  Returns 0 upon success or an error code to indicate the reason for "
"failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/firmload.9:90
#, no-wrap
msgid "Fn firmware_get_size fh"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/firmload.9:94
msgid ""
"Returns the size of the image file associated with the firmware handle E<.Fa "
"fh>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/firmload.9:94
#, no-wrap
msgid "Fn firmware_read fh offset buf size"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/firmload.9:105
msgid ""
"Reads from the image file associated with the firmware handle E<.Fa fh> "
"beginning at offset E<.Fa offset> for length E<.Fa size>.  The firmware "
"image data is placed into the buffer specified by E<.Fa buf>.  Returns 0 "
"upon success or an error code to indicate the reason for failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/firmload.9:105
#, no-wrap
msgid "Fn firmware_malloc size"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/firmload.9:112
msgid ""
"Allocates a region of wired kernel memory of size E<.Fa size>.  Note: E<.Fn "
"firmware_malloc> may block."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/firmload.9:112
#, no-wrap
msgid "Fn firmware_free buf size"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/firmload.9:116
msgid "Frees a region of memory previously allocated by E<.Fn firmware_malloc>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/firmload.9:121
msgid "E<.Xr autoconf 9>, E<.Xr malloc 9>, E<.Xr vnsubr 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/firmload.9:126
msgid "The E<.Nm> framework first appeared in E<.Nx 4.0>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/firmload.9:127
msgid "E<.An Jason Thorpe Aq thorpej@NetBSD.org>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/flash.9:32
#, no-wrap
msgid "March 31, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/flash.9:33
#, no-wrap
msgid "FLASH 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/flash.9:37
msgid "E<.Nm flash>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/flash.9:37
#, no-wrap
msgid "subsystem for flash-like memory devices"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/flash.9:39
#, no-wrap
msgid "dev/flash/flash.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/flash.9:42
msgid ""
"E<.Ft device_t> E<.Fn flash_attach_mi \"const struct flash_interface *fl\" "
"\"device_t dev\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/flash.9:49
msgid ""
"Flash-like devices can register themselves to the E<.Nm> layer with the "
"E<.Fa flash_hw_if> structure.  This structure has function pointers and "
"other fields."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/flash.9:59
msgid ""
"The attachment can be done by calling E<.Fn flash_attach_mi> with this "
"structure and the device's E<.Vt device_t> as an argument.  Return value is "
"the flash layer device.  The E<.Fa flash_interface> structure is shown "
"below."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/flash.9:67
#, no-wrap
msgid ""
"struct flash_interface {\n"
"\tint (*erase) (device_t, struct flash_erase_instruction *);\n"
"\tint (*read) (device_t, off_t, size_t, size_t *, uint8_t *);\n"
"\tint (*write) (device_t, off_t, size_t, size_t *, const uint8_t *);\n"
"\tint (*block_markbad)(device_t, uint64_t);\n"
"\tint (*block_isbad)(device_t, uint64_t);\n"
"\tint (*sync) (device_t);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/flash.9:69
#, no-wrap
msgid "\tint (*submit)(device_t, struct buf *);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/flash.9:72
#, no-wrap
msgid ""
"\t/* storage for partition info */\n"
"\tstruct flash_partition partition;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/flash.9:81
#, no-wrap
msgid ""
"\t/* total size of mtd */\n"
"\tflash_addr_t size;\n"
"\tuint32_t page_size;\n"
"\tuint32_t erasesize;\n"
"\tuint32_t writesize;\n"
"\tuint32_t minor;\n"
"\tuint8_t\ttype;\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/flash.9:85
msgid "E<.Xr flash 4>, E<.Xr nand 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/flash.9:86
msgid "E<.An Adam Hoka Aq ahoka@NetBSD.org>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/fork1.9:31
#, no-wrap
msgid "January 4, 2008"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/fork1.9:32
#, no-wrap
msgid "FORK1 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fork1.9:36
msgid "E<.Nm fork1>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/fork1.9:36
#, no-wrap
msgid "create a new process"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fork1.9:42
msgid ""
"E<.Ft int> E<.Fn \"fork1\" \"struct lwp *l1\" \"int flags\" \"int exitsig\" "
"\"void *stack\" \"size_t stacksize\" \"void (*func)(void *)\" \"void *arg\" "
"\"register_t *retval\" \"struct proc **rnewprocp\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fork1.9:55
msgid ""
"E<.Fn fork1> creates a new process out of the process behind E<.Ar l1>, "
"which is assumed to be the current lwp.  This function is used primarily to "
"implement the E<.Xr fork 2> and E<.Xr vfork 2> system calls, but is "
"versatile enough to be used as a backend for e.g. the E<.Xr __clone 2> call."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fork1.9:60
msgid ""
"The E<.Ar flags> argument controls the semantics of the fork operation, and "
"is made up of the bitwise-OR of the following values:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fork1.9:61
#, no-wrap
msgid "FORK_PPWAIT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fork1.9:67
msgid ""
"The parent process will sleep until the child process successfully calls "
"E<.Xr execve 2> or exits (either by a call to E<.Xr _exit 2> or abnormally)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fork1.9:67
#, no-wrap
msgid "FORK_SHAREVM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fork1.9:71
msgid ""
"The child process will share the parent's virtual address space.  If this "
"flag is not specified, the child will get a copy-on-write snapshot of the "
"parent's address space."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fork1.9:71
#, no-wrap
msgid "FORK_SHARECWD"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fork1.9:74
msgid ""
"The child process will share the parent's current directory, root directory, "
"and file creation mask."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fork1.9:74
#, no-wrap
msgid "FORK_SHAREFILES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fork1.9:76
msgid "The child process will share the parent's file descriptors."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fork1.9:76
#, no-wrap
msgid "FORK_SHARESIGS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fork1.9:78
msgid "The child process will share the parent's signal actions."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fork1.9:78
#, no-wrap
msgid "FORK_NOWAIT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fork1.9:80
msgid "The child process will at creation time be inherited by the init process."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fork1.9:80
#, no-wrap
msgid "FORK_CLEANFILES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fork1.9:83
msgid ""
"The child process will not copy or share the parent's descriptors, but "
"rather will start out with a clean set."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fork1.9:88
msgid "A E<.Ar flags> value of 0 indicates a standard fork operation."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fork1.9:93
msgid ""
"The E<.Ar exitsig> argument controls the signal sent to the parent on child "
"death.  If normal operation desired, SIGCHLD should be supplied."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fork1.9:104
msgid ""
"It is possible to specify the child userspace stack location and size by "
"using the E<.Ar stack> and E<.Ar stacksize> arguments, respectively.  Values "
"E<.Dv NULL> and 0, respectively, will give the child the default values for "
"the machine architecture in question."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fork1.9:114
msgid ""
"The arguments E<.Ar func> and E<.Ar arg> can be used to specify a kernel "
"function to be called when the child process returns instead of E<.Fn "
"child_return>.  These are used for example in starting the init process and "
"creating kernel threads."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fork1.9:122
msgid ""
"The E<.Ar retval> argument is provided for the use of system call stubs.  If "
"E<.Ar retval> is not NULL, it will hold the following values after "
"successful completion of the fork operation:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fork1.9:123
#, no-wrap
msgid "Ar retval[0]"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fork1.9:125
msgid "This will contain the pid of the child process."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fork1.9:125
#, no-wrap
msgid "Ar retval[1]"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fork1.9:128
msgid ""
"In the parent process, this will contain the value 0.  In the child process, "
"this will contain 1."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fork1.9:135
msgid ""
"User level system call stubs typically subtract 1 from E<.Ar retval[1]> and "
"bitwise-AND it with E<.Ar retval[0]>, thus returning the pid to the parent "
"process and 0 to the child."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fork1.9:142
msgid ""
"If E<.Ar rnewprocp> is not NULL, E<.Ar *rnewprocp> will point to the newly "
"created process upon successful completion of the fork operation."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fork1.9:147
msgid ""
"Upon successful completion of the fork operation, E<.Fn fork1> returns 0.  "
"Otherwise, the following error values are returned:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fork1.9:148 org_netbsd/src/share/man/man9/fork1.9:150 org_netbsd/src/share/man/man9/kthread.9:173 org_netbsd/src/share/man/man9/kthread.9:175
#, no-wrap
msgid "Bq Er EAGAIN"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fork1.9:150 org_netbsd/src/share/man/man9/kthread.9:175
msgid "The limit on the total number of system processes would be exceeded."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fork1.9:155 org_netbsd/src/share/man/man9/kthread.9:180
msgid ""
"The limit E<.Dv RLIMIT_NPROC> on the total number of processes under "
"execution by this user id would be exceeded."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fork1.9:159
msgid "E<.Xr execve 2>, E<.Xr fork 2>, E<.Xr vfork 2>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/fsetown.9:31
#, no-wrap
msgid "FSETOWN 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fsetown.9:37
msgid "E<.Nm fsetown>, E<.Nm fgetown>, E<.Nm fownsignal>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/fsetown.9:37
#, no-wrap
msgid "file descriptor owner handling functions"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fsetown.9:46
msgid ""
"E<.Ft int> E<.Fn fsetown \"struct lwp *l\" \"pid_t *pgid\" \"int cmd\" "
"\"const void *data\"> E<.Ft int> E<.Fn fgetown \"struct lwp *l\" \"pid_t "
"pgid\" \"int cmd\" \"void *data\"> E<.Ft void> E<.Fn fownsignal \"pid_t "
"pgid\" \"int signo\" \"int code\" \"int band\" \"void *fdescdata\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fsetown.9:51
msgid ""
"These functions handle file descriptor owner related ioctls and related "
"signal delivery.  Device drivers and other parts of the kernel call these "
"functions from ioctl entry functions or I/O notification functions."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fsetown.9:79
msgid ""
"E<.Fn fsetown> sets the owner of file.  E<.Fa cmd> is an ioctl command, one "
"of E<.Dv SIOCSPGRP>, E<.Dv FIOSETOWN>, and E<.Dv TIOCSPGRP>.  E<.Fa data> is "
"interpreted as a pointer to a signed integer, the integer being the ID of "
"the owner.  The E<.Fa cmd> determines how exactly E<.Fa data> should be "
"interpreted.  If E<.Fa cmd> is E<.Dv TIOCSPGRP>, the ID needs to be positive "
"and is interpreted as process group ID.  For E<.Dv SIOCSPGRP> and E<.Dv "
"FIOSETOWN>, the passed ID is the process ID if positive, or the process "
"group ID if negative."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fsetown.9:101
msgid ""
"E<.Fn fgetown> returns the current owner of the file.  E<.Fa cmd> is an "
"ioctl command, one of E<.Dv SIOCGPGRP>, E<.Dv FIOGETOWN>, and E<.Dv "
"TIOCGPGRP>.  E<.Fa data> is interpreted as a pointer to a signed integer, "
"and the value is set according to the passed E<.Fa cmd>.  For E<.Dv "
"TIOCGPGRP>, the returned E<.Fa data> value is positive process group ID if "
"the owner is the process group, or negative process ID if the owner is a "
"process.  For other ioctls, the returned value is the positive process ID if "
"the owner is a process, or the negative process group ID if the owner is a "
"process group."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fsetown.9:132
msgid ""
"E<.Fn fownsignal> schedules the E<.Fa signo> signal to be sent to the "
"current file descriptor owner.  The signals typically used with this "
"function are E<.Dv SIGIO> and E<.Dv SIGURG>.  The E<.Fa code> and E<.Fa "
"band> arguments are sent along with the signal as additional signal specific "
"information if E<.Dv SA_SIGINFO> is activated.  If the information is not "
"available from the context of the E<.Fn fownsignal> call, these should be "
"passed as zero.  E<.Fa fdescdata> is used to lookup the file descriptor for "
"E<.Dv SA_SIGINFO> signals.  If it is specified, the file descriptor number "
"is sent along with the signal as additional signal specific information.  If "
"file descriptor data pointer is not available in the context of the E<.Fn "
"fownsignal> call, E<.Dv NULL> should be used instead."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fsetown.9:144
msgid ""
"Note that a E<.Xr fcntl 2> E<.Dv F_SETOWN request> is translated by the "
"kernel to a E<.Dv FIOSETOWN> ioctl, and E<.Dv F_GETOWN> is translated to "
"E<.Dv FIOGETOWN>.  This is done transparently by generic code, before the "
"device- or subsystem-specific ioctl entry function is called."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fsetown.9:150
msgid ""
"E<.Xr fcntl 2>, E<.Xr siginfo 2>, E<.Xr signal 7>, E<.Xr ioctl 9>, E<.Xr "
"signal 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fsetown.9:152
msgid "These kernel functions appeared in E<.Nx 2.0>."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/fstrans.9:31
#, no-wrap
msgid "FSTRANS 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:44
msgid ""
"E<.Nm fstrans>, E<.Nm fstrans_setstate>, E<.Nm fstrans_getstate>, E<.Nm "
"fstrans_start>, E<.Nm fstrans_start_nowait>, E<.Nm fstrans_done>, E<.Nm "
"fstrans_is_owner>, E<.Nm fscow_establish>, E<.Nm fscow_disestablish>, E<.Nm "
"fscow_run>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/fstrans.9:44
#, no-wrap
msgid "file system suspension helper subsystem"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/fstrans.9:46 org_netbsd/src/share/man/man9/vfs_hooks.9:39 org_netbsd/src/share/man/man9/vfsops.9:50 org_netbsd/src/share/man/man9/vfssubr.9:58 org_netbsd/src/share/man/man9/vnodeops.9:86
#, no-wrap
msgid "sys/mount.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/fstrans.9:47
#, no-wrap
msgid "sys/fstrans.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:68
msgid ""
"E<.Ft int> E<.Fn fstrans_setstate \"struct mount *mp\" \"enum fstrans_state "
"new_state\"> E<.Ft \"enum fstrans_state\"> E<.Fn fstrans_getstate \"struct "
"mount *mp\"> E<.Ft void> E<.Fn fstrans_start \"struct mount *mp\" \"enum "
"fstrans_lock_type lock_type\"> E<.Ft int> E<.Fn fstrans_start_nowait "
"\"struct mount *mp\" \"enum fstrans_lock_type lock_type\"> E<.Ft void> E<.Fn "
"fstrans_done \"struct mount *mp\"> E<.Ft int> E<.Fn fstrans_is_owner "
"\"struct mount *mp\"> E<.Ft int> E<.Fn fscow_establish \"struct mount *mp\" "
"\"int (*func)(void *, struct buf *, bool)\" \"void *cookie\"> E<.Ft int> "
"E<.Fn fscow_disestablish \"struct mount *mp\" \"int (*func)(void *, struct "
"buf *, bool)\" \"void *cookie\"> E<.Ft int> E<.Fn fscow_run \"struct buf "
"*bp\" \"bool data_valid\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:73
msgid ""
"The E<.Nm> subsystem is a set of operations to assist file system "
"suspension.  These operations must not be used outside of file systems."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:78
msgid ""
"File systems supporting this subsystem must set the flag E<.Dv "
"IMNT_HAS_TRANS> in E<.Dv \"mnt_iflag\">."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:80
msgid "File systems are always in one of these states:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fstrans.9:82
#, no-wrap
msgid "Dv FSTRANS_NORMAL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:84
msgid "Normal operations."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fstrans.9:84
#, no-wrap
msgid "Dv FSTRANS_SUSPENDING"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:86
msgid "Preparing a suspension."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fstrans.9:86
#, no-wrap
msgid "Dv FSTRANS_SUSPENDED"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:88
msgid "Suspended."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:92
msgid "This state is represented by E<.Vt \"enum fstrans_state\">."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:98
msgid ""
"All file system operations use a E<.Em \"fstrans lock\">.  This lock is "
"recursive.  A thread already owning a lock will always get another lock.  "
"The lock has two variants:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fstrans.9:99
#, no-wrap
msgid "Dv FSTRANS_SHARED"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:102
msgid ""
"A lock that will be granted if the file system is in state E<.Dv "
"FSTRANS_NORMAL>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fstrans.9:102
#, no-wrap
msgid "Dv FSTRANS_LAZY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:109
msgid ""
"A lock that will be granted if the file system is in state E<.Dv "
"FSTRANS_NORMAL> or E<.Dv FSTRANS_SUSPENDING>.  It needs special care because "
"operations using this variant will not block while the file system prepares "
"suspension."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:113
msgid "The lock variant is represented by E<.Vt \"enum fstrans_lock_type\">."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:118
msgid "The following functions comprise the E<.Tn API> provided by E<.Nm>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fstrans.9:119
#, no-wrap
msgid "Fn fstrans_getstate mp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:122
msgid "Returns the current state of the file system E<.Fa mp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fstrans.9:122
#, no-wrap
msgid "Fn fstrans_setstate mp new_state"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:127
msgid "Changes the state of the file system E<.Fa mp> to E<.Fa new_state>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fstrans.9:127
#, no-wrap
msgid "Fn fstrans_start mp lock_type"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:132
msgid "Sets a lock of type E<.Fa lock_type> on the file system E<.Fa mp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fstrans.9:132
#, no-wrap
msgid "Fn fstrans_start_nowait mp lock_type"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:138
msgid ""
"Like E<.Fn fstrans_start>, but will not wait for a state change of the file "
"system when attempting to acquire the lock.  The thread may still sleep "
"while attempting to acquire the lock."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fstrans.9:138
#, no-wrap
msgid "Fn fstrans_done mp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:141
msgid "Releases a lock on the file system E<.Fa mp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fstrans.9:141
#, no-wrap
msgid "Fn fstrans_is_owner mp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:146
msgid ""
"Returns E<.Dv true> if this thread is currently suspending the file system "
"E<.Fa mp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fstrans.9:146
#, no-wrap
msgid "Fn fscow_establish mp func cookie"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:152
msgid ""
"Establish a copy-on-write callback for the file system E<.Fa mp>.  The "
"function E<.Fa func> will be called for every buffer written through this "
"file system."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fstrans.9:152
#, no-wrap
msgid "Fn fscow_disestablish mp func cookie"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:155
msgid ""
"Disestablish a copy-on-write callback registered with E<.Fn "
"fscow_establish>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/fstrans.9:155
#, no-wrap
msgid "Fn fscow_run bp data_valid"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:163
msgid ""
"Run all copy-on-write callbacks established for the file system this buffer "
"belongs to.  If E<.Fa data_valid> is E<.Dv true> the buffer data has not yet "
"been modified."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:170
msgid ""
"The functions E<.Fn fstrans_setstate> and E<.Fn fstrans_start_nowait> return "
"zero on success and an error value on failure."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:172
msgid "The following is an example of a file system suspend operation."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:177
#, no-wrap
msgid ""
"int\n"
"xxx_suspendctl(struct mount *mp, int cmd)\n"
"{\n"
"\tint error;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:183
#, no-wrap
msgid ""
"\tswitch (cmd) {\n"
"\tcase SUSPEND_SUSPEND:\n"
"\t\terror = fstrans_setstate(mp, FSTRANS_SUSPENDING);\n"
"\t\tif (error != 0)\n"
"\t\t\treturn error;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:185
#, no-wrap
msgid "\t\t/* Sync file system state to disk. */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:187
#, no-wrap
msgid "\t\treturn fstrans_setstate(mp, FSTRANS_SUSPENDED);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:190
#, no-wrap
msgid ""
"\tcase SUSPEND_RESUME:\n"
"\t\treturn fstrans_setstate(mp, FSTRANS_NORMAL);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:195
#, no-wrap
msgid ""
"\tdefault:\n"
"\t\treturn EINVAL;\n"
"\t}\n"
"}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:198
msgid "This is an example of a file system operation."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:205
#, no-wrap
msgid ""
"int\n"
"xxx_create(void *v)\n"
"{\n"
"\tstruct vop_create_args *ap = v;\n"
"\tstruct mount *mp = ap-\\*[Gt]a_dvp-\\*[Gt]v_mount;\n"
"\tint error;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:208
#, no-wrap
msgid ""
"\tif ((error = fstrans_start(mp, FSTRANS_SHARED)) != 0)\n"
"\t\treturn error;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:210
#, no-wrap
msgid "\t/* Actually create the node. */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:212
#, no-wrap
msgid "\tfstrans_done(mp);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:215
#, no-wrap
msgid ""
"\treturn 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:219
msgid "E<.Xr vfs_resume 9>, E<.Xr vfs_suspend 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:222
msgid ""
"The actual code implementing this subsystem can be found in the file E<.Pa "
"sys/kern/vfs_trans.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/fstrans.9:227
msgid "The E<.Nm> subsystem appeared in E<.Nx 5.0>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/getiobuf.9:27
#, no-wrap
msgid "May 6, 2008"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/getiobuf.9:28
#, no-wrap
msgid "GETIOBUF 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/getiobuf.9:33
msgid "E<.Nm getiobuf>, E<.Nm putiobuf>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/getiobuf.9:33
#, no-wrap
msgid "I/O descriptor allocation interface"
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/getiobuf.9:42
msgid ""
"E<.Ft struct buf *> E<.Fn getiobuf \"struct vnode *vp\" \"bool waitok\"> "
"E<.Ft void> E<.Fn putiobuf \"struct buf *bp\">"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/getiobuf.9:48
msgid "E<.Fn getiobuf> allocates a E<.Em buf> structure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/getiobuf.9:50
#, no-wrap
msgid "Fa vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/getiobuf.9:54
msgid ""
"The vnode to which the allocated buffer will be associated.  This can be "
"E<.Dv NULL>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/getiobuf.9:54
#, no-wrap
msgid "Fa waitok"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/getiobuf.9:61
msgid ""
"If true, E<.Fa getiobuf> can sleep until enough memory is available.  "
"Otherwise, it returns E<.Dv NULL> immediately if not enough memory is "
"available."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/getiobuf.9:69
msgid ""
"Note that the allocated buffer doesn't belong to the buffer cache.  To free "
"it, E<.Fn putiobuf> should be used.  E<.Fn brelse> should not be used on it."
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/getiobuf.9:77
msgid ""
"E<.Fn putiobuf> frees E<.Fa bp>, which should be a buffer allocated with "
"E<.Fn getiobuf>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/getiobuf.9:79
msgid "E<.Xr buffercache 9>, E<.Xr intro 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/hardclock.9:30 org_netbsd/src/share/man/man9/hz.9:30
#, no-wrap
msgid "March 25, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/hardclock.9:31
#, no-wrap
msgid "HARDCLOCK 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hardclock.9:35
msgid "E<.Nm hardclock>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/hardclock.9:35
#, no-wrap
msgid "real-time timer"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hardclock.9:39
msgid "E<.Ft void> E<.Fn hardclock \"struct clockframe *frame\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hardclock.9:50
msgid ""
"The E<.Fn hardclock> function is called E<.Xr hz 9> times per second.  It "
"implements the real-time system clock.  The argument E<.Va frame> is an "
"opaque, machine-dependent structure that encapsulates the previous machine "
"state."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hardclock.9:54
msgid "The E<.Fn hardclock> performs different tasks such as:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hardclock.9:62
msgid ""
"Run the current process's virtual and profile time (decrease the "
"corresponding timers, if they are activated, and generate E<.Li SIGVTALRM> "
"or E<.Li SIGPROF>, respectively)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hardclock.9:71
msgid ""
"Increment the time-of-day, taking care of any E<.Xr ntpd 8> or E<.Xr adjtime "
"2> induced changes and leap seconds, as well as any necessary compensations "
"to keep in sync with PPS signals or external clocks, if support for this is "
"in the kernel (see E<.Xr options 4>)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hardclock.9:74
msgid ""
"Schedule softclock interrupts if any callouts should be triggered (see E<.Xr "
"callout 9>)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hardclock.9:81
msgid ""
"E<.Xr adjtime 2>, E<.Xr ntp_adjtime 2>, E<.Xr signal 7>, E<.Xr ntpd 8>, "
"E<.Xr callout 9>, E<.Xr hz 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/hash.9:30
#, no-wrap
msgid "December 5, 2001"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/hash.9:31
#, no-wrap
msgid "HASH 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hash.9:38
msgid "E<.Nm hash>, E<.Nm hash32_buf>, E<.Nm hash32_str>, E<.Nm hash32_strn>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/hash.9:38
#, no-wrap
msgid "kernel hash functions"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/hash.9:41
#, no-wrap
msgid "sys/hash.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hash.9:48
msgid ""
"E<.Ft uint32_t> E<.Fn hash32_buf \"const void *buf\" \"size_t len\" "
"\"uint32_t ihash\"> E<.Ft uint32_t> E<.Fn hash32_str \"const void *buf\" "
"\"uint32_t ihash\"> E<.Ft uint32_t> E<.Fn hash32_strn \"const void *buf\" "
"\"size_t len\" \"uint32_t ihash\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hash.9:52
msgid "The E<.Nm> functions returns a hash of the given buffer."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hash.9:68
msgid ""
"The E<.Fn hash32_buf> function returns a 32 bit hash of E<.Fa buf>, which is "
"E<.Fa len> bytes long, seeded with an initial hash of E<.Fa ihash> (which is "
"usually E<.Dv HASH32_BUF_INIT>).  This function may use a different "
"algorithm to E<.Fn hash32_str> and E<.Fn hash32_strn>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hash.9:86
msgid ""
"The E<.Fn hash32_str> function returns a 32 bit hash of E<.Fa buf>, which is "
"a E<.Dv NUL> terminated E<.Tn ASCII> string, seeded with an initial hash of "
"E<.Fa ihash> (which is usually E<.Dv HASH32_STR_INIT>).  This function must "
"use the same algorithm as E<.Fn hash32_strn>, so that the same data returns "
"the same hash."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hash.9:107
msgid ""
"The E<.Fn hash32_strn> function returns a 32 bit hash of E<.Fa buf>, which "
"is a E<.Dv NUL> terminated E<.Tn ASCII> string, up to a maximum of E<.Fa "
"len> bytes, seeded with an initial hash of E<.Fa ihash> (which is usually "
"E<.Dv HASH32_STR_INIT>).  This function must use the same algorithm as E<.Fn "
"hash32_str>, so that the same data returns the same hash."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hash.9:112
msgid ""
"The E<.Fa ihash> parameter is provided to allow for incremental hashing by "
"allowing successive calls to use a previous hash value."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hash.9:116
msgid "The E<.Fa hash32_*> functions return a 32 bit hash of the provided buffer."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hash.9:118
msgid "The kernel hashing API first appeared in E<.Nx 1.6>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/hashinit.9:30
#, no-wrap
msgid "July 1, 2008"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/hashinit.9:31
#, no-wrap
msgid "HASHINIT 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hashinit.9:36
msgid "E<.Nm hashinit>, E<.Nm hashdone>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/hashinit.9:36
#, no-wrap
msgid "kernel hash table construction and destruction"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hashinit.9:48
msgid ""
"E<.Ft \"void *\"> E<.Fo hashinit> E<.Fa \"u_int chains\"> E<.Fa \"enum "
"hashtype htype\"> E<.Fa \"bool waitok\"> E<.Fa \"u_long *hashmask\"> E<.Fc> "
"E<.Ft void> E<.Fn hashdone \"void *hashtbl\" \"enum hashtype htype\" "
"\"u_long hashmask\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hashinit.9:78
msgid ""
"The E<.Fn hashinit> function allocates and initializes space for a simple "
"chaining hash table.  The number of slots will be the least power of two not "
"smaller than E<.Fa chains>.  The customary choice for E<.Fa chains> is the "
"maximum number of elements you intend to store divided by your intended load "
"factor.  The E<.Dv LIST...> or E<.Dv TAILQ...> macros of E<.Xr queue 3> can "
"be used to manipulate the chains; pass E<.Dv HASH_LIST> or E<.Dv HASH_TAILQ> "
"as E<.Fa htype> to indicate which.  Each slot will be initialized as the "
"head of an empty chain of the proper type.  Because different data "
"structures from E<.Xr queue 3> can define head structures of different "
"sizes, the total size of the allocated table can vary with the choice of "
"E<.Fa htype>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hashinit.9:85
msgid ""
"If E<.Fa waitok> is true, E<.Fa hashinit> can wait until enough memory is "
"available.  Otherwise, it immediately fails if there is not enough memory is "
"available."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hashinit.9:90
msgid ""
"A value will be stored into E<.Fa *hashmask> suitable for masking any "
"computed hash, to obtain the index of a chain head in the allocated table."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hashinit.9:106
msgid ""
"The E<.Fn hashdone> function deallocates the storage allocated by E<.Fn "
"hashinit> and pointed to by E<.Fa hashtbl>, given the same E<.Fa htype> and "
"E<.Fa hashmask> that were passed to and returned from E<.Fn hashinit>.  If "
"the table contains any nonempty chain when E<.Fn hashdone> is called, the "
"result is undefined."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hashinit.9:118
msgid ""
"The value returned by E<.Fn hashinit> should be cast as pointer to an array "
"of E<.Dv LIST_HEAD> or E<.Dv TAILQ_HEAD> as appropriate.  E<.Fn hashinit> "
"returns E<.Dv NULL> on failure."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hashinit.9:122
msgid "E<.Xr queue 3>, E<.Xr hash 9>, E<.Xr malloc 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hashinit.9:125
msgid "These functions are implemented in E<.Pa sys/kern/subr_hash.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hashinit.9:143
msgid ""
"A E<.Fn hashinit> function was present, without the E<.Fa htype> or E<.Fa "
"mflags> arguments, in E<.Bx 4.4 alpha>.  It was independent of E<.Xr queue "
"3> and simply allocated and nulled a table of pointer-sized slots.  It sized "
"the table to the E<.Em largest> power of two E<.Em not greater than> E<.Fa "
"chains>; that is, it built in a load factor between 1 and 2."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hashinit.9:167
msgid ""
"E<.Nx 1.0> was the first E<.Nx> release to have a E<.Fn hashinit> function.  "
"It resembled that from E<.Bx 4.4> but made each slot a E<.Dv LIST_HEAD> from "
"E<.Xr queue 3>.  For E<.Nx 1.3.3> it had been changed to size the table to "
"the least power of two not less than E<.Em or equal to> E<.Fa chains>.  By "
"E<.Nx 1.4> it had the E<.Fa mflags> argument and the current sizing rule."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hashinit.9:181
msgid ""
"E<.Nx 1.5> had the E<.Fn hashdone> function.  By E<.Nx 1.6> E<.Fn hashinit> "
"supported E<.Dv LIST> or E<.Dv TAILQ> chains selected with E<.Fa htype>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hashinit.9:203
msgid ""
"E<.Fx> has a E<.Fn hashinit> with behavior equivalent (as of E<.Fx 6.1>)  to "
"that in E<.Nx 1.0>, and a E<.Fn hashdestroy> that behaves as E<.Fn hashdone> "
"but checks that all chains are empty first.  E<.Ox> has a E<.Fn hashinit> "
"comparable (as of E<.Ox 3.9>)  to that of E<.Nx 1.4>.  This manual page was "
"added for E<.Nx 4.0>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hashinit.9:205
msgid ""
"The only part of the work of implementing a hash table that these functions "
"relieve is the part that isn't much work."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/humanize_number.9:30
#, no-wrap
msgid "August 7, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/humanize_number.9:31
#, no-wrap
msgid "HUMANIZE_NUMBER 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/humanize_number.9:36
msgid "E<.Nm humanize_number>, E<.Nm format_bytes>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/humanize_number.9:36
#, no-wrap
msgid "human readable numbers"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/humanize_number.9:43
msgid ""
"E<.Ft int> E<.Fn humanize_number \"char *buf\" \"size_t len\" \"uint64_t "
"number\" \"const char *suffix\" \"int divisor\"> E<.Ft int> E<.Fn "
"format_bytes \"char *buf\" \"size_t len\" \"uint64_t number\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/humanize_number.9:58
msgid ""
"The E<.Fn humanize_number> function formats the unsigned 64-bit quantity "
"given in E<.Fa number> into E<.Fa buf>.  A space and then E<.Fa suffix> is "
"appended to the end.  The supplied E<.Fa buf> must be at least E<.Fa len> "
"bytes long."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/humanize_number.9:76
msgid ""
"If the formatted number (including E<.Fa suffix>)  is too long to fit into "
"E<.Fa buf>, E<.Fn humanize_number> divides E<.Fa number> by E<.Fa divisor> "
"until it will fit.  In this case, E<.Fa suffix> is prefixed with the "
"appropriate SI designator.  Suitable values of E<.Fa divisor> are 1024 or "
"1000 to remain consistent with the common meanings of the SI designator "
"prefixes."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/humanize_number.9:78
msgid "The prefixes are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/humanize_number.9:79
#, no-wrap
msgid "Sy Prefix Ta Sy Description Ta Sy Multiplier"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/humanize_number.9:80
#, no-wrap
msgid "k\tkilo\t1024"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/humanize_number.9:81
#, no-wrap
msgid "M\tmega\t1048576"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/humanize_number.9:82
#, no-wrap
msgid "G\tgiga\t1073741824"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/humanize_number.9:83
#, no-wrap
msgid "T\ttera\t1099511627776"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/humanize_number.9:84
#, no-wrap
msgid "P\tpeta\t1125899906842624"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/humanize_number.9:85
#, no-wrap
msgid "E\texa\t1152921504606846976"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/humanize_number.9:94
msgid ""
"The E<.Fa len> argument must be at least 4 plus the length of E<.Fa suffix>, "
"in order to ensure a useful result in E<.Fa buf>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/humanize_number.9:111
msgid ""
"The E<.Fn format_bytes> function is a front-end to E<.Fn humanize_number>.  "
"It calls the latter with a E<.Fa suffix> of E<.Dq B>.  Also, if the suffix "
"in the returned E<.Fa buf> would not have a prefix, the suffix is removed.  "
"This means that a result of E<.Dq 100000> occurs, instead of E<.Dq 100000 "
"B>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/humanize_number.9:115
msgid ""
"Both functions return the number of characters stored in E<.Fa buf> "
"(excluding the terminating NUL) upon success, or \\-1 upon failure."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/humanize_number.9:117
msgid "E<.Xr humanize_number 3>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/humanize_number.9:119
msgid "These functions first appeared in E<.Nx 1.5>."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/hz.9:31
#, no-wrap
msgid "HZ 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hz.9:39
msgid "E<.Nm hz>, E<.Nm tick>, E<.Nm tickadj>, E<.Nm stathz>, E<.Nm profhz>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/hz.9:39
#, no-wrap
msgid "system time model"
msgstr ""

#.  XXX: .Vt extern int schedhz; ?
#. type: Plain text
#: org_netbsd/src/share/man/man9/hz.9:49
msgid ""
"E<.Vt extern int hz;> E<.Vt extern int tick;> E<.Vt extern int tickadj;> "
"E<.Vt extern int stathz;> E<.Vt extern int profhz;>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hz.9:56
msgid ""
"The essential clock handling routines in E<.Nx> are written to operate with "
"two timers that run independently of each other.  The main clock, running "
"E<.Va hz> times per second, is used to keep track of real time."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hz.9:71
msgid ""
"In another words, E<.Va hz> specifies the number of times the E<.Xr "
"hardclock 9> timer ticks per second.  Normally E<.Xr hardclock 9> increments "
"time by E<.Va tick> each time it is called.  If the system clock has "
"drifted, E<.Xr adjtime 2> may be used to skew this increment based on the "
"rate of E<.Va tickadj>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hz.9:82
msgid ""
"The second timer is used to gather timing statistics.  It also handles "
"kernel and user profiling.  If the second timer is programmable, it is "
"randomized to avoid aliasing between the two clocks.  The mean frequency of "
"the second timer is E<.Va stathz>.  If a separate clock is not available, "
"E<.Va stathz> is set to E<.Va hz>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hz.9:90
msgid ""
"If profiling is enabled, the clock normally used to drive E<.Va stathz> may "
"be run at a higher rate E<.Va profhz>, which is required to be a multiple of "
"E<.Va stathz>.  This will give higher resolution profiling information."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hz.9:107
msgid ""
"These system variables are also available as E<.Em struct clockinfo> from "
"E<.Xr sysctl 3> and E<.Sy kern.clockrate> from E<.Xr sysctl 8>.  The E<.Va "
"hz> is hardware-dependent; it can be overridden (if the machine dependent "
"code supports this) by defining E<.Dv HZ> in the kernel configuration file "
"(see E<.Xr options 4>).  Only override the default value if you really know "
"what you are doing."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/hz.9:112
msgid ""
"E<.Xr adjtime 2>, E<.Xr callout 9>, E<.Xr hardclock 9>, E<.Xr microtime 9>, "
"E<.Xr time_second 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/ieee80211.9:31 org_netbsd/src/share/man/man9/ieee80211_crypto.9:30 org_netbsd/src/share/man/man9/ieee80211_input.9:30 org_netbsd/src/share/man/man9/ieee80211_ioctl.9:30 org_netbsd/src/share/man/man9/ieee80211_node.9:30 org_netbsd/src/share/man/man9/ieee80211_output.9:30 org_netbsd/src/share/man/man9/ieee80211_proto.9:30
#, no-wrap
msgid "September 12, 2006"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/ieee80211.9:32
#, no-wrap
msgid "IEEE80211 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211.9:41
msgid ""
"E<.Nm ieee80211_ifattach , ieee80211_ifdetach>, E<.Nm ieee80211_mhz2ieee , "
"ieee80211_chan2ieee , ieee80211_ieee2mhz>, E<.Nm ieee80211_media_init , "
"ieee80211_media_change , ieee80211_media_status>, E<.Nm ieee80211_watchdog>, "
"E<.Nm ieee80211_setmode , ieee80211_chan2mode>, E<.Nm ieee80211_rate2media , "
"ieee80211_media2rate>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/ieee80211.9:41
#, no-wrap
msgid "core 802.11 network stack functions"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/ieee80211.9:43 org_netbsd/src/share/man/man9/ieee80211_input.9:37 org_netbsd/src/share/man/man9/ieee80211_ioctl.9:37 org_netbsd/src/share/man/man9/ieee80211_node.9:49 org_netbsd/src/share/man/man9/ieee80211_output.9:38 org_netbsd/src/share/man/man9/ieee80211_proto.9:42 org_netbsd/src/share/man/man9/ieee80211_radiotap.9:38 org_netbsd/src/share/man/man9/rssadapt.9:42
#, no-wrap
msgid "net80211/ieee80211_var.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/ieee80211.9:44 org_netbsd/src/share/man/man9/ieee80211_input.9:38 org_netbsd/src/share/man/man9/ieee80211_ioctl.9:38 org_netbsd/src/share/man/man9/ieee80211_node.9:50 org_netbsd/src/share/man/man9/ieee80211_output.9:39 org_netbsd/src/share/man/man9/ieee80211_proto.9:43
#, no-wrap
msgid "net80211/ieee80211_proto.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211.9:78
msgid ""
"E<.Ft void> E<.Fn ieee80211_ifattach \"struct ieee80211com *ic\"> E<.Ft "
"void> E<.Fn ieee80211_ifdetach \"struct ieee80211com *ic\"> E<.Ft u_int> "
"E<.Fn ieee80211_mhz2ieee \"u_int freq\" \"u_int flags\"> E<.Ft u_int> E<.Fn "
"ieee80211_chan2ieee \"struct ieee80211com *ic\" \"struct ieee80211_channel "
"*c\"> E<.Ft u_int> E<.Fn ieee80211_ieee2mhz \"u_int chan\" \"u_int flags\"> "
"E<.Ft void> E<.Fo ieee80211_media_init> E<.Fa \"struct ieee80211com *ic\" "
"\"ifm_change_cb_t media_change\"> E<.Fa \"ifm_stat_cb_t media_stat\"> E<.Fc> "
"E<.Ft int> E<.Fn ieee80211_media_change \"struct ifnet *ifp\"> E<.Ft void> "
"E<.Fn ieee80211_media_status \"struct ifnet *ifp\" \"struct ifmediareq "
"*imr\"> E<.Ft void> E<.Fn ieee80211_watchdog \"struct ieee80211com *ic\"> "
"E<.Ft int> E<.Fn ieee80211_setmode \"struct ieee80211com *ic\" \"enum "
"ieee80211_phymode mode\"> E<.Ft enum ieee80211_phymode> E<.Fo "
"ieee80211_chan2mode> E<.Fa \"struct ieee80211com *ic\" \"struct "
"ieee80211_channel *chan\"> E<.Fc> E<.Ft int> E<.Fo ieee80211_rate2media> "
"E<.Fa \"struct ieee80211com *ic\" \"int rate\" \"enum ieee80211_phymode "
"mode\"> E<.Fc> E<.Ft int> E<.Fn ieee80211_media2rate \"int mword\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211.9:87
msgid ""
"The E<.Nm ieee80211> collection of functions are used to manage wireless "
"network interfaces in the system which use the system's software 802.11 "
"network stack.  Most of these functions require that attachment to the stack "
"is performed before calling.  Several utility functions are also provided; "
"these are safe to call from any driver without prior initialization."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211.9:102
msgid ""
"The E<.Fn ieee80211_ifattach> function attaches the wireless network "
"interface E<.Fa ic> to the 802.11 network stack layer.  This function must "
"be called before using any of the E<.Nm ieee80211> functions which need to "
"store driver state across invocations.  This function also performs Ethernet "
"and BPF attachment (by calling E<.Fn ether_ifattach> and E<.Fn bpfattach2>)  "
"on behalf of the caller."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211.9:110
msgid ""
"The E<.Fn ieee80211_ifdetach> function frees any E<.Nm ieee80211> structures "
"associated with the driver, and performs Ethernet and BPF detachment on "
"behalf of the caller."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211.9:125
msgid ""
"The E<.Fn ieee80211_mhz2ieee> utility function converts the frequency E<.Fa "
"freq> (specified in MHz) to an IEEE 802.11 channel number.  The E<.Fa flags> "
"argument is a hint which specifies whether the frequency is in the 2GHz ISM "
"band E<.Pq Vt IEEE80211_CHAN_2GHZ> or the 5GHz band E<.Pq Vt "
"IEEE80211_CHAN_5GHZ>; appropriate clipping of the result is then performed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211.9:138
msgid ""
"The E<.Fn ieee80211_chan2ieee> function converts the channel specified in "
"E<.Fa *c> to an IEEE channel number for the driver E<.Fa ic>.  If the "
"conversion would be invalid, an error message is printed to the system "
"console.  This function REQUIRES that the driver is hooked up to the E<.Nm "
"ieee80211> subsystem."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211.9:153
msgid ""
"The E<.Fn ieee80211_ieee2mhz> utility function converts the IEEE channel "
"number E<.Ft chan> to a frequency (in MHz).  The E<.Fa flags> argument is a "
"hint which specifies whether the frequency is in the 2GHz ISM band E<.Pq Vt "
"IEEE80211_CHAN_2GHZ> or the 5GHz band E<.Pq Vt IEEE80211_CHAN_5GHZ>; "
"appropriate clipping of the result is then performed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211.9:175
msgid ""
"The E<.Fn ieee80211_media_init> function initializes media data structures "
"used by the E<.Vt ifmedia> interface for the driver E<.Fa ic>.  It must be "
"called by the driver after calling E<.Fn ieee80211_ifattach> and before "
"calling most E<.Nm ieee80211> functions.  The E<.Fa media_change> and E<.Fa "
"media_stat> arguments specify helper functions which will be invoked by the "
"E<.Vt ifmedia> framework when the user changes or queries media options, "
"using a command such as E<.Xr ifconfig 8>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211.9:184
msgid ""
"The E<.Fn ieee80211_media_status> and E<.Fn ieee80211_media_change> "
"functions are device-independent handlers for E<.Vt ifmedia> commands and "
"are not intended to be called directly."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211.9:193
msgid ""
"The E<.Fn ieee80211_watchdog> function is intended to be called from a "
"driver's E<.Va if_watchdog> routine.  It is used to perform periodic cleanup "
"of state within the software 802.11 stack, as well as timing out scans."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211.9:199
msgid ""
"The E<.Fn ieee80211_setmode> function is called from within the 802.11 stack "
"to change the mode of the driver's PHY; it is not intended to be called "
"directly."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211.9:209
msgid ""
"The E<.Fn ieee80211_chan2mode> function returns the PHY mode required for "
"use with the channel E<.Fa chan> on the device E<.Fa ic>.  This is typically "
"used when selecting a rate set, to be advertised in beacons, for example."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211.9:228
msgid ""
"The E<.Fn ieee80211_rate2media> function converts the bit rate E<.Fa rate> "
"(measured in units of 0.5Mbps) to an E<.Vt ifmedia> sub-type, for the device "
"E<.Fa ic> running in PHY mode E<.Fa mode>.  The E<.Fn ieee80211_media2rate> "
"performs the reverse of this conversion, returning the bit rate (in 0.5Mbps "
"units) corresponding to an E<.Vt ifmedia> sub-type."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211.9:236
msgid ""
"E<.Xr ieee80211_crypto 9>, E<.Xr ieee80211_input 9>, E<.Xr ieee80211_ioctl "
"9>, E<.Xr ieee80211_node 9>, E<.Xr ieee80211_output 9>, E<.Xr "
"ieee80211_proto 9>, E<.Xr ieee80211_radiotap 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211.9:243 org_netbsd/src/share/man/man9/ieee80211_crypto.9:93 org_netbsd/src/share/man/man9/ieee80211_input.9:105 org_netbsd/src/share/man/man9/ieee80211_ioctl.9:87 org_netbsd/src/share/man/man9/ieee80211_node.9:240 org_netbsd/src/share/man/man9/ieee80211_output.9:133 org_netbsd/src/share/man/man9/ieee80211_proto.9:69
msgid ""
"The E<.Nm ieee80211> series of functions first appeared in E<.Nx 1.5>, and "
"were later ported to E<.Fx 4.6>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211.9:248 org_netbsd/src/share/man/man9/ieee80211_crypto.9:98 org_netbsd/src/share/man/man9/ieee80211_input.9:111 org_netbsd/src/share/man/man9/ieee80211_ioctl.9:92 org_netbsd/src/share/man/man9/ieee80211_node.9:245 org_netbsd/src/share/man/man9/ieee80211_output.9:138 org_netbsd/src/share/man/man9/ieee80211_proto.9:74
msgid ""
"E<.An -nosplit> This man page was written by E<.An Bruce M. Simpson Aq "
"bms@FreeBSD.org> and E<.An Darron Broad Aq darron@kewl.org>."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/ieee80211_crypto.9:31
#, no-wrap
msgid "IEEE80211_CRYPTO 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_crypto.9:35
msgid ""
"E<.Nm ieee80211_crypto_attach , ieee80211_crypto_detach , "
"ieee80211_crypto_encap>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/ieee80211_crypto.9:35
#, no-wrap
msgid "802.11 WEP encryption functions"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_crypto.9:45
msgid ""
"E<.Ft void> E<.Fn ieee80211_crypto_attach \"struct ieee80211com *ic\"> E<.Ft "
"void> E<.Fn ieee80211_crypto_detach \"struct ieee80211com *ic\"> E<.Ft "
"struct ieee80211_key *> E<.Fo ieee80211_crypto_encap> E<.Fa \"struct "
"ieee80211com *ic\" \"struct ieee80211_node *ni\" \"struct mbuf *m0\"> E<.Fc>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_crypto.9:47
msgid "These functions provide encryption support for 802.11 device drivers."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_crypto.9:54
msgid ""
"The E<.Fn ieee80211_crypto_attach> function initializes crypto support for "
"the interface E<.Fa ic>.  The default is null crypto."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_crypto.9:61
msgid ""
"The E<.Fn ieee80211_crypto_detach> function frees data structures associated "
"with crypto support for the interface E<.Fa ic>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_crypto.9:65
msgid ""
"The two above functions are automatically called by the interface attach and "
"detach routines, respectively."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_crypto.9:84
msgid ""
"The E<.Fn ieee80211_crypto_encap> function encapsulates the packet supplied "
"in mbuf E<.Fa m0>, with the crypto headers given the for node E<.Fa ni>.  "
"Software encryption is possibly performed.  In case of no specified key for "
"E<.Fa ni> or multicast traffic, the default key for the interface E<.Fa ic> "
"is used for encapsulation.  The key is returned in the case of successful "
"encapsulation, otherwise E<.Dv NULL> is returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_crypto.9:86 org_netbsd/src/share/man/man9/ieee80211_input.9:98 org_netbsd/src/share/man/man9/ieee80211_node.9:233 org_netbsd/src/share/man/man9/ieee80211_output.9:126 org_netbsd/src/share/man/man9/ieee80211_proto.9:62
msgid "E<.Xr ieee80211 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/ieee80211_input.9:31
#, no-wrap
msgid "IEEE80211_INPUT 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_input.9:35
msgid "E<.Nm ieee80211_input , ieee80211_decap , ieee80211_recv_mgmt>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/ieee80211_input.9:35
#, no-wrap
msgid "software 802.11 stack input functions"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_input.9:51
msgid ""
"E<.Ft void> E<.Fo ieee80211_input> E<.Fa \"struct ieee80211com *ic\" "
"\"struct mbuf *m\" \"struct ieee80211_node *ni\"> E<.Fa \"int rssi\" "
"\"u_int32_t rstamp\"> E<.Fc> E<.Ft struct mbuf *> E<.Fn ieee80211_decap "
"\"struct ieee80211com *ic\" \"struct mbuf *m\"> E<.Ft void> E<.Fo "
"ieee80211_recv_mgmt> E<.Fa \"struct ieee80211com *ic\" \"struct mbuf *m0\" "
"\"struct ieee80211_node *ni\"> E<.Fa \"int subtype\" \"int rssi\" "
"\"u_int32_t rstamp\"> E<.Fc>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_input.9:54
msgid "These functions process received 802.11 frames."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_input.9:75
msgid ""
"The E<.Fn ieee80211_input> function takes an mbuf chain E<.Fa m> containing "
"a complete 802.11 frame from the driver E<.Fa ic> and passes it to the "
"software 802.11 stack for input processing.  The E<.Fa ni> argument "
"specifies an instance of E<.Vt struct ieee80211_node> (which may be "
"driver-specific) representing the node from which the frame was received.  "
"The arguments E<.Fa rssi> and E<.Fa stamp> are typically derived from "
"on-card data structures; they are used for recording the signal strength and "
"time received of the frame respectively."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_input.9:88
msgid ""
"The E<.Fn ieee80211_decap> function performs decapsulation of the 802.11 "
"frame in the mbuf chain E<.Fa m> received by the device E<.Fa ic>, taking "
"the form of the 802.11 address fields into account; the structure of 802.11 "
"addresses vary according to the intended source and destination of the "
"frame.  It is typically called from within E<.Fn ieee80211_input>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_input.9:96
msgid ""
"The E<.Fn ieee80211_recv_mgmt> performs input processing for 802.11 "
"management frames.  It is typically called from within E<.Fn "
"ieee80211_input>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_input.9:112
msgid "There is no netisr queue specifically for the software 802.11 stack yet."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/ieee80211_ioctl.9:31
#, no-wrap
msgid "IEEE80211_IOCTL 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_ioctl.9:35
msgid "E<.Nm ieee80211_cfgget , ieee80211_cfgset , ieee80211_ioctl>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/ieee80211_ioctl.9:35
#, no-wrap
msgid "802.11 interface ioctl commands"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/ieee80211_ioctl.9:39 org_netbsd/src/share/man/man9/ieee80211_radiotap.9:39
#, no-wrap
msgid "net80211/ieee80211_ioctl.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_ioctl.9:46
msgid ""
"E<.Ft int> E<.Fn ieee80211_cfgget \"struct ieee80211com *ic\" \"u_long cmd\" "
"\"void *data\"> E<.Ft int> E<.Fn ieee80211_cfgset \"struct ieee80211com "
"*ic\" \"u_long cmd\" \"void *data\"> E<.Ft int> E<.Fn ieee80211_ioctl "
"\"struct ieee80211com *ic\" \"u_long cmd\" \"void *data\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_ioctl.9:50
msgid ""
"These functions are typically invoked by drivers in response to requests for "
"information or to change settings from the userland."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_ioctl.9:63
msgid ""
"The E<.Fn ieee80211_cfgget> and E<.Fn ieee80211_cfgset> functions implement "
"a legacy interface for getting and setting 802.11 interface attributes "
"respectively.  The interface is compatible with the RIDs implemented by the "
"E<.Xr wi 4> driver and used by the E<.Xr wiconfig 8> utility."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_ioctl.9:75
msgid ""
"The E<.Fn ieee80211_ioctl> function implements ioctls such as key management "
"for wireless devices.  Ioctls related to the Ethernet layer also pass "
"through here, but are handed off to E<.Fn ether_ioctl> when no match for "
"E<.Fa cmd> is found."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_ioctl.9:80
msgid "E<.Xr wi 4>, E<.Xr ifconfig 8>, E<.Xr wiconfig 8>, E<.Xr ieee80211 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/ieee80211_node.9:31
#, no-wrap
msgid "IEEE80211_NODE 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_node.9:47
msgid ""
"E<.Nm ieee80211_node_attach>, E<.Nm ieee80211_node_lateattach>, E<.Nm "
"ieee80211_node_detach>, E<.Nm ieee80211_begin_scan>, E<.Nm "
"ieee80211_next_scan>, E<.Nm ieee80211_end_scan>, E<.Nm "
"ieee80211_create_ibss>, E<.Nm ieee80211_alloc_node>, E<.Nm "
"ieee80211_dup_bss>, E<.Nm ieee80211_find_node>, E<.Nm ieee80211_free_node>, "
"E<.Nm ieee80211_free_allnodes>, E<.Nm ieee80211_iterate_nodes>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/ieee80211_node.9:47
#, no-wrap
msgid "software 802.11 stack node management functions"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/ieee80211_node.9:51
#, no-wrap
msgid "net80211/ieee80211_node.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_node.9:86
msgid ""
"E<.Ft void> E<.Fn ieee80211_node_attach \"struct ieee80211com *ic\"> E<.Ft "
"void> E<.Fn ieee80211_node_lateattach \"struct ieee80211com *ic\"> E<.Ft "
"void> E<.Fn ieee80211_node_detach \"struct ieee80211com *ic\"> E<.Ft void> "
"E<.Fn ieee80211_begin_scan \"struct ieee80211com *ic\" \"int reset\"> E<.Ft "
"void> E<.Fn ieee80211_next_scan \"struct ieee80211com *ic\"> E<.Ft void> "
"E<.Fn ieee80211_end_scan \"struct ieee80211com *ic\"> E<.Ft void> E<.Fo "
"ieee80211_create_ibss> E<.Fa \"struct ieee80211com *ic\" \"struct "
"ieee80211_channel *chan\"> E<.Fc> E<.Ft struct ieee80211_node *> E<.Fn "
"ieee80211_alloc_node \"struct ieee80211com *ic\" \"u_int8_t *macaddr\"> "
"E<.Ft struct ieee80211_node *> E<.Fo ieee80211_dup_bss> E<.Fa \"struct "
"ieee80211_node_table *nt\" \"const u_int8_t *macaddr\"> E<.Fc> E<.Ft struct "
"ieee80211_node *> E<.Fo ieee80211_find_node> E<.Fa \"struct "
"ieee80211_node_table *nt\" \"const u_int8_t *macaddr\"> E<.Fc> E<.Ft void> "
"E<.Fn ieee80211_free_node \"struct ieee80211_node *ni\"> E<.Ft void> E<.Fn "
"ieee80211_free_allnodes \"struct ieee80211_node_table *nt\"> E<.Ft void> "
"E<.Fo ieee80211_iterate_nodes> E<.Fa \"struct ieee80211_node_table *nt\" "
"\"ieee80211_iter_func *f\" \"void *arg\"> E<.Fc>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_node.9:91
msgid ""
"These functions are used to manage node lists within the software 802.11 "
"stack.  These lists are typically used for implementing host-mode AP "
"functionality, or providing signal quality information about neighbouring "
"nodes."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_node.9:105
msgid ""
"The E<.Fn ieee80211_node_attach> function is called from E<.Xr "
"ieee80211_ifattach 9> to initialize node database management callbacks for "
"the interface E<.Fa ic> (specifically for memory allocation, node copying "
"and node signal inspection).  These functions may be overridden in special "
"circumstances, as long as this is done after calling E<.Xr "
"ieee80211_ifattach 9> and prior to any other call which may allocate a node."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_node.9:117
msgid ""
"The E<.Fn ieee80211_node_lateattach> function initialises the E<.Va ic_bss> "
"node element of the interface E<.Fa ic> during E<.Xr ieee80211_media_init "
"9>.  This late attachment is to account for certain special cases described "
"under E<.Fn ieee80211_node_attach>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_node.9:124
msgid ""
"The E<.Fn ieee80211_node_detach> function destroys all node database state "
"associated with the interface E<.Fa ic>, and is usually called during device "
"detach."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_node.9:138
msgid ""
"The E<.Fn ieee80211_begin_scan> function initialises the node database in "
"preparation of a scan for an access point on the interface E<.Fa ic> and "
"begins the scan.  The parameter E<.Fa reset> controls if a previously built "
"node list should be cleared.  The actual scanning for an access point is not "
"fully automated: the device driver itself controls stepping through the "
"channels, usually by a periodical callback."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_node.9:147
msgid ""
"The E<.Fn ieee80211_next_scan> function is used to inform the E<.Xr "
"ieee80211 9> layer that the next channel for interface E<.Fa ic> should be "
"scanned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_node.9:154
msgid ""
"The E<.Fn ieee80211_create_ibss> function sets up the net80211-specific "
"portion of an interface's softc, E<.Fa ic>, for use in IBSS mode."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_node.9:169
msgid ""
"The E<.Fn ieee80211_end_scan> function is called by E<.Fn "
"ieee80211_next_scan> when the state machine has peformed a full cycle of "
"scanning on all available radio channels.  Internally, E<.Fn "
"ieee80211_end_scan> will inspect the node cache associated with the "
"interface E<.Fa ic> for suitable access points found during scanning, and "
"associate with one, should the parameters of the node match those of the "
"configuration requested."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_node.9:184
msgid ""
"The E<.Fn ieee80211_alloc_node> function allocates an instance of E<.Vt "
"\"struct ieee80211_node\"> for a node having the MAC address E<.Fa macaddr>, "
"and associates it with the node table E<.Fa nt>.  If the allocation is "
"successful, the node structure is initialised by E<.Fn "
"ieee80211_setup_node>; otherwise, E<.Dv NULL> is returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_node.9:199
msgid ""
"The E<.Fn ieee80211_dup_bss> function is similar to E<.Fn "
"ieee80211_alloc_node>, but is instead used to create a node database entry "
"for the BSSID E<.Fa macaddr> associated with the note table E<.Fa nt>.  If "
"the allocation is successful, the node structure is initialised by E<.Fn "
"ieee80211_setup_node>; otherwise, E<.Dv NULL> is returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_node.9:211
msgid ""
"The E<.Fn ieee80211_find_node> function will iterate through the node table "
"E<.Fa nt>, searching for a node entry which matches E<.Fa macaddr>.  If the "
"entry is found, its reference count is incremented, and a pointer to the "
"node is returned; otherwise, E<.Dv NULL> is returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_node.9:219
msgid ""
"The E<.Fn ieee80211_free_allnodes> function will iterate through the node "
"list calling E<.Fn ieee80211_free_node> for all the nodes in table E<.Fa "
"nt>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_node.9:231
msgid ""
"The E<.Fn ieee80211_iterate_nodes> function will call the user-defined "
"callback function E<.Fa f> for all nodes in the table E<.Fa nt>.  The "
"callback is invoked with the with the user-supplied value E<.Fa arg> and a "
"pointer to the current node."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/ieee80211_output.9:31
#, no-wrap
msgid "IEEE80211_OUTPUT 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_output.9:36
msgid ""
"E<.Nm ieee80211_encap , ieee80211_add_rates>, E<.Nm ieee80211_add_xrates , "
"ieee80211_send_mgmt>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/ieee80211_output.9:36
#, no-wrap
msgid "software 802.11 stack output functions"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_output.9:52
msgid ""
"E<.Ft struct mbuf *> E<.Fo ieee80211_encap> E<.Fa \"struct ieee80211com "
"*ic\" \"struct mbuf *m\" \"struct ieee80211_node *ni\"> E<.Fc> E<.Ft "
"u_int8_t *> E<.Fn ieee80211_add_rates \"u_int8_t *frm\" \"const struct "
"ieee80211_rateset *rs\"> E<.Ft u_int8_t *> E<.Fn ieee80211_add_xrates "
"\"u_int8_t *frm\" \"const struct ieee80211_rateset *rs\"> E<.Ft int> E<.Fo "
"ieee80211_send_mgmt> E<.Fa \"struct ieee80211com *ic\" \"struct "
"ieee80211_node *ni\" \"int type\" \"int arg\"> E<.Fc>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_output.9:55
msgid ""
"These functions handle the encapsulation and transmission of 802.11 frames "
"within the software 802.11 stack."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_output.9:66
msgid ""
"The E<.Fn ieee80211_encap> function encapsulates an outbound data frame "
"contained within the mbuf chain E<.Fa m> from the interface E<.Fa ic>.  The "
"argument E<.Fa ni> is a reference to the destination node."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_output.9:73
msgid ""
"If the function is successful, the mbuf chain is updated with the 802.11 "
"frame header prepended, and a pointer to the head of the chain is returned.  "
"If an error occurs, E<.Dv NULL> is returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_output.9:85
msgid ""
"The E<.Fn ieee80211_add_rates> utility function is used to add the rate set "
"element E<.Fa *rs> to the frame E<.Fa frm>.  A pointer to the location in "
"the buffer after the addition of the rate set is returned.  It is typically "
"used when constructing management frames from within the software 802.11 "
"stack."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_output.9:97
msgid ""
"The E<.Fn ieee80211_add_xrates> utility function is used to add the extended "
"rate set element E<.Fa *rs> to the frame E<.Fa frm>.  A pointer to the "
"location in the buffer after the addition of the rate set is returned.  It "
"is typically used when constructing management frames from within the "
"software 802.11 stack in 802.11g mode."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_output.9:107
msgid ""
"The E<.Fn ieee80211_send_mgmt> function transmits a management frame on the "
"interface E<.Fa ic> to the destination node E<.Fa ni> of type E<.Fa type>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_output.9:113
msgid ""
"The argument E<.Fa arg> specifies either a sequence number for "
"authentication operations, a status code for [re]association operations, or "
"a reason for deauthentication and deassociation operations."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_output.9:119
msgid ""
"Nodes other than E<.Va ic_bss> have their reference count incremented to "
"reflect their use for an indeterminate amount of time.  This reference is "
"freed when the function returns."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_output.9:124
msgid ""
"The function returns 0 if successful; if temporary buffer space is not "
"available, the function returns E<.Er ENOMEM>."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/ieee80211_proto.9:31
#, no-wrap
msgid "IEEE80211_PROTO 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_proto.9:40
msgid ""
"E<.Nm ieee80211_proto_attach>, E<.Nm ieee80211_proto_detach>, E<.Nm "
"ieee80211_print_essid>, E<.Nm ieee80211_dump_pkt>, E<.Nm "
"ieee80211_fix_rate>, E<.Nm ieee80211_proto>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/ieee80211_proto.9:40
#, no-wrap
msgid "software 802.11 stack protocol helper functions"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_proto.9:56
msgid ""
"E<.Ft void> E<.Fn ieee80211_proto_attach \"struct ieee80211com *ic\"> E<.Ft "
"void> E<.Fn ieee80211_proto_detach \"struct ieee80211com *ic\"> E<.Ft void> "
"E<.Fn ieee80211_print_essid \"u_int8_t *essid\" \"int len\"> E<.Ft void> "
"E<.Fn ieee80211_dump_pkt \"u_int8_t *buf\" \"int len\" \"int rate\" \"int "
"rssi\"> E<.Ft int> E<.Fo ieee80211_fix_rate> E<.Fa \"struct ieee80211_node "
"*ni\" \"int flags\"> E<.Fc>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_proto.9:60
msgid ""
"These functions are helper functions used throughout the software 802.11 "
"protocol stack."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:31
#, no-wrap
msgid "March 12, 2006"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:32
#, no-wrap
msgid "IEEE80211_RADIOTAP 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:36
msgid "E<.Nm ieee80211_radiotap>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:36
#, no-wrap
msgid "software 802.11 stack packet capture definitions"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:40
#, no-wrap
msgid "net80211/ieee80211_radiotap.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:51
msgid ""
"The E<.Nm> definitions provide a device-independent E<.Xr bpf 4> attachment "
"for the capture of information about 802.11 traffic which is not part of the "
"802.11 frame structure."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:57
msgid ""
"Radiotap was designed to balance the desire for a capture format that "
"conserved CPU and memory bandwidth on embedded systems, with the desire for "
"a hardware-independent, extensible format that would support the diverse "
"capabilities of virtually all 802.11 radios."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:61
msgid ""
"These considerations led radiotap to settle on a format consisting of a "
"standard preamble followed by an extensible bitmap indicating the presence "
"of optional capture fields."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:66
msgid ""
"The capture fields were packed into the header as compactly as possible, "
"modulo the requirements that they had to be packed swiftly, with their "
"natural alignment, in the same order as the bits indicating their presence."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:75
msgid ""
"This typically includes information such as signal quality and timestamps.  "
"This information may be used by a variety of user agents, including E<.Xr "
"tcpdump 8>.  It is requested by using the E<.Xr bpf 4> data-link type E<.Dv "
"DLT_IEEE_80211_RADIO>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:78
msgid "Each frame using this attachment has the following header prepended to it:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:85
#, no-wrap
msgid ""
"struct ieee80211_radiotap_header {\n"
"\tu_int8_t\tit_version;\t/* set to 0 */\n"
"\tu_int8_t\tit_pad;\n"
"\tu_int16_t\tit_len;\t\t/* entire length */\n"
"\tu_int32_t\tit_present;\t/* fields present */\n"
"} __attribute__((__packed__));\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:99
msgid ""
"A device driver implementing E<.Vt radiotap> typically defines a structure "
"embedding an instance of E<.Vt \"struct ieee80211_radiotap_header\"> at the "
"beginning, with subsequent fields naturally aligned, and in the appropriate "
"order.  Also, a driver defines a macro to set the bits of the E<.Va "
"it_present> bitmap to indicate which fields exist and are filled in by the "
"driver."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:101
msgid "Radiotap capture fields are in little-endian byte order."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:113
msgid ""
"Radiotap capture fields E<.Em must be naturally aligned>.  That is, 16-, "
"32-, and 64-bit fields must begin on 16-, 32-, and 64-bit boundaries, "
"respectively.  In this way, drivers can avoid unaligned accesses to radiotap "
"capture fields.  radiotap-compliant drivers must insert padding before a "
"capture field to ensure its natural alignment.  radiotap-compliant packet "
"dissectors, such as E<.Xr tcpdump 8>, expect the padding."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:118
msgid ""
"Developers beware: all compilers may not pack structs alike.  If a driver "
"developer constructs their radiotap header with a packed structure, in order "
"to ensure natural alignment, then it is important that they insert padding "
"bytes by themselves."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:126
msgid ""
"Radiotap headers are copied to the userland via a separate bpf attachment.  "
"It is necessary for the driver to create this attachment after calling E<.Xr "
"ieee80211_ifattach 9> by calling E<.Fn bpfattach2> with the data-link type "
"set to E<.Dv DLT_IEEE802_11_RADIO>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:133
msgid ""
"When the information is available, usually immediately before a link-layer "
"transmission or after a receive, the driver copies it to the bpf layer using "
"the E<.Fn bpf_mtap2> function."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:138
msgid ""
"The following extension fields are defined for E<.Vt radiotap>, in the order "
"in which they should appear in the buffer copied to userland:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:139
#, no-wrap
msgid "Dv IEEE80211_RADIOTAP_TSFT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:144
msgid ""
"This field contains the unsigned 64-bit value, in microseconds, of the MAC's "
"802.11 Time Synchronization Function timer, when the first bit of the MPDU "
"arrived at the MAC.  This field should be present for received frames only."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:144
#, no-wrap
msgid "Dv IEEE80211_RADIOTAP_FLAGS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:147
msgid ""
"This field contains a single unsigned 8-bit value, containing a bitmap of "
"flags specifying properties of the frame being transmitted or received."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:147
#, no-wrap
msgid "Dv IEEE80211_RADIOTAP_RATE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:150
msgid ""
"This field contains a single unsigned 8-bit value, which is the data rate in "
"use in units of 500Kbps."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:150
#, no-wrap
msgid "Dv IEEE80211_RADIOTAP_CHANNEL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:157
msgid ""
"This field contains two unsigned 16-bit values.  The first value is the "
"frequency upon which this PDU was transmitted or received.  The second value "
"is a bitmap containing flags which specify properties of the channel in "
"use.  These are documented within the header file,"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:157
#, no-wrap
msgid "net80211/ieee80211_radiotap.h ."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:158
#, no-wrap
msgid "Dv IEEE80211_RADIOTAP_FHSS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:163
msgid ""
"This field contains two 8-bit values.  This field should be present for "
"frequency-hopping radios only.  The first byte is the hop set.  The second "
"byte is the pattern in use."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:163
#, no-wrap
msgid "Dv IEEE80211_RADIOTAP_DBM_ANTSIGNAL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:166
msgid ""
"This field contains a single signed 8-bit value, which indicates the RF "
"signal power at the antenna, in decibels difference from 1mW."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:166
#, no-wrap
msgid "Dv IEEE80211_RADIOTAP_DBM_ANTNOISE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:169
msgid ""
"This field contains a single signed 8-bit value, which indicates the RF "
"noise power at the antenna, in decibels difference from 1mW."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:169
#, no-wrap
msgid "Dv IEEE80211_RADIOTAP_LOCK_QUALITY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:177
msgid ""
"This field contains a single unsigned 16-bit value, indicating the quality "
"of the Barker Code lock.  No unit is specified for this field.  There does "
"not appear to be a standard way of measuring this at this time; this "
"quantity is often referred to as E<.Dq \"Signal Quality\"> in some "
"datasheets."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:177
#, no-wrap
msgid "Dv IEEE80211_RADIOTAP_TX_ATTENUATION"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:182
msgid ""
"This field contains a single unsigned 16-bit value, expressing transmit "
"power as unitless distance from maximum power set at factory calibration.  0 "
"indicates maximum transmit power.  Monotonically nondecreasing with lower "
"power levels."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:182
#, no-wrap
msgid "Dv IEEE80211_RADIOTAP_DB_TX_ATTENUATION"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:187
msgid ""
"This field contains a single unsigned 16-bit value, expressing transmit "
"power as decibel distance from maximum power set at factory calibration.  0 "
"indicates maximum transmit power.  Monotonically nondecreasing with lower "
"power levels."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:187
#, no-wrap
msgid "Dv IEEE80211_RADIOTAP_DBM_TX_POWER"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:191
msgid ""
"Transmit power expressed as decibels from a 1mW reference.  This field is a "
"single signed 8-bit value.  This is the absolute power level measured at the "
"antenna port."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:191
#, no-wrap
msgid "Dv IEEE80211_RADIOTAP_ANTENNA"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:196
msgid ""
"For radios which support antenna diversity, this field contains a single "
"unsigned 8-bit value specifying which antenna is being used to transmit or "
"receive this frame.  The first antenna is antenna 0."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:196
#, no-wrap
msgid "Dv IEEE80211_RADIOTAP_DB_ANTSIGNAL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:200
msgid ""
"This field contains a single unsigned 8-bit value, which indicates the RF "
"signal power at the antenna, in decibels difference from an arbitrary, fixed "
"reference."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:200
#, no-wrap
msgid "Dv IEEE80211_RADIOTAP_DB_ANTNOISE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:204
msgid ""
"This field contains a single unsigned 8-bit value, which indicates the RF "
"noise power at the antenna, in decibels difference from an arbitrary, fixed "
"reference."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:204
#, no-wrap
msgid "Dv IEEE80211_RADIOTAP_RX_FLAGS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:206
msgid "An unsigned 16-bit bitmap indicating properties of received frames."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:206
#, no-wrap
msgid "Dv IEEE80211_RADIOTAP_TX_FLAGS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:208
msgid "An unsigned 16-bit bitmap indicating properties of transmitted frames."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:208
#, no-wrap
msgid "Dv IEEE80211_RADIOTAP_RTS_RETRIES u_int8_t data"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:212
msgid ""
"Unsigned 8-bit value indicating how many times the NIC retransmitted the "
"Request to Send (RTS) in an RTS/CTS handshake before receiving an 802.11 "
"Clear to Send (CTS)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:212
#, no-wrap
msgid "Dv IEEE80211_RADIOTAP_DATA_RETRIES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:215
msgid ""
"Unsigned 8-bit value indicating how many times the NIC retransmitted a "
"unicast data packet before receiving an 802.11 Acknowledgement."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:215
#, no-wrap
msgid "Dv IEEE80211_RADIOTAP_EXT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:229
msgid ""
"This bit is reserved for any future extensions to the E<.Vt radiotap> "
"structure.  A driver sets E<.Dv IEEE80211_RADIOTAP_EXT> to extend the "
"it_present bitmap by another 64 bits.  The bitmap can be extended by "
"multiples of 32 bits to 96, 128, 160 bits or longer, by setting E<.Dv "
"IEEE80211_RADIOTAP_EXT> in the extensions.  The bitmap ends at the first "
"extension field where E<.Dv IEEE80211_RADIOTAP_EXT> is not set."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:232
msgid "Radiotap header for the Cisco Aironet driver:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:242
#, no-wrap
msgid ""
"struct an_rx_radiotap_header {\n"
"\tstruct ieee80211_radiotap_header\tar_ihdr;\n"
"\tu_int8_t\tar_flags;\n"
"\tu_int8_t\tar_rate;\n"
"\tu_int16_t\tar_chan_freq;\n"
"\tu_int16_t\tar_chan_flags;\n"
"\tu_int8_t\tar_antsignal;\n"
"\tu_int8_t\tar_antnoise;\n"
"} __attribute__((__packed__));\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:245
msgid "Bitmap indicating which fields are present in the above structure:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:252
#, no-wrap
msgid ""
"#define AN_RX_RADIOTAP_PRESENT \\e\n"
"\t((1 \\*[Gt]\\*[Gt] IEEE80211_RADIOTAP_FLAGS) | \\e\n"
"\t (1 \\*[Gt]\\*[Gt] IEEE80211_RADIOTAP_RATE) | \\e\n"
"\t (1 \\*[Gt]\\*[Gt] IEEE80211_RADIOTAP_CHANNEL) | \\e\n"
"\t (1 \\*[Gt]\\*[Gt] IEEE80211_RADIOTAP_DBM_ANTSIGNAL) | \\e\n"
"\t (1 \\*[Gt]\\*[Gt] IEEE80211_RADIOTAP_DBM_ANTNOISE))\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:256
msgid "E<.Xr bpf 4>, E<.Xr ieee80211 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:264
msgid ""
"The E<.Nm> definitions first appeared in E<.Nx 1.5>, and were later ported "
"to E<.Fx 4.6>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:273
msgid ""
"E<.An -nosplit> The E<.Nm> interface was designed and implemented by E<.An "
"David Young Aq dyoung@pobox.com>.  E<.An David Young> is the maintainer of "
"the radiotap capture format.  Contact him to add new capture fields."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ieee80211_radiotap.9:277
msgid ""
"This manual page was written by E<.An Bruce M. Simpson Aq bms@FreeBSD.org> "
"and E<.An Darron Broad Aq darron@kewl.org>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/iic.9:37
#, no-wrap
msgid "October 15, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/iic.9:38
#, no-wrap
msgid "IIC 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:47
msgid ""
"E<.Nm iic_acquire_bus>, E<.Nm iic_release_bus>, E<.Nm iic_exec>, E<.Nm "
"iic_smbus_write_byte>, E<.Nm iic_smbus_read_byte>, E<.Nm "
"iic_smbus_receive_byte>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/iic.9:47
#, no-wrap
msgid "Inter IC (I2C) bus"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/iic.9:49
#, no-wrap
msgid "dev/i2c/i2cvar.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:94
msgid ""
"E<.Ft int> E<.Fo iic_acquire_bus> E<.Fa \"i2c_tag_t ic\"> E<.Fa \"int "
"flags\"> E<.Fc> E<.Ft int> E<.Fo iic_release_bus> E<.Fa \"i2c_tag_t ic\"> "
"E<.Fa \"int flags\"> E<.Fc> E<.Ft int> E<.Fo iic_exec> E<.Fa \"i2c_tag_t "
"ic\"> E<.Fa \"i2c_op_t op\"> E<.Fa \"i2c_addr_t addr\"> E<.Fa \"const void "
"*cmdbuf\"> E<.Fa \"size_t cmdlen\"> E<.Fa \"void *buf\"> E<.Fa \"size_t "
"buflen\"> E<.Fa \"int flags\"> E<.Fc> E<.Ft int> E<.Fo iic_smbus_write_byte> "
"E<.Fa \"i2c_tag_t ic\"> E<.Fa \"i2c_addr_t addr\"> E<.Fa \"uint8_t cmd\"> "
"E<.Fa \"uint8_t data\"> E<.Fa \"int flags\"> E<.Fc> E<.Ft int> E<.Fo "
"iic_smbus_read_byte> E<.Fa \"i2c_tag_t ic\"> E<.Fa \"i2c_addr_t addr\"> "
"E<.Fa \"uint8_t cmd\"> E<.Fa \"uint8_t *datap\"> E<.Fa \"int flags\"> E<.Fc> "
"E<.Ft int> E<.Fo iic_smbus_receive_byte> E<.Fa \"i2c_tag_t ic\"> E<.Fa "
"\"i2c_addr_t addr\"> E<.Fa \"uint8_t *datap\"> E<.Fa \"int flags\"> E<.Fc>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:105
msgid ""
"I2C is a two-wire bus developed by Philips used for connecting integrated "
"circuits.  It is commonly used for connecting devices such as EEPROMs, "
"temperature sensors, fan controllers, real-time clocks, tuners, and other "
"types of integrated circuits.  The E<.Nm iic> interface provides a means of "
"communicating with I2C-connected devices.  The System Management Bus, or "
"SMBus, is a variant of the I2C bus with a simplified command protocol and "
"some electrical differences."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:108
msgid ""
"Drivers for devices attached to the I2C bus will make use of the following "
"data types:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/iic.9:109
#, no-wrap
msgid "Fa i2c_tag_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:115
msgid ""
"Controller tag for the I2C bus.  This is a pointer to a E<.Fa struct "
"i2c_controller>, consisting of function pointers filled in by the I2C "
"controller driver."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/iic.9:115
#, no-wrap
msgid "Fa i2c_op_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:118
msgid "I2C bus operation.  The following I2C bus operations are defined:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/iic.9:119
#, no-wrap
msgid "I2C_OP_READ"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:121
msgid "Perform a read operation."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/iic.9:121
#, no-wrap
msgid "I2C_OP_READ_WITH_STOP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:124
msgid ""
"Perform a read operation and send a STOP condition on the I2C bus at the "
"conclusion of the read."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/iic.9:124
#, no-wrap
msgid "I2C_OP_WRITE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:126
msgid "Perform a write operation."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/iic.9:126
#, no-wrap
msgid "I2C_OP_WRITE_WITH_STOP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:129
msgid ""
"Perform a write operation and send a STOP condition on the I2C bus at the "
"conclusion of the write."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/iic.9:130
#, no-wrap
msgid "Fa i2c_addr_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:132
msgid "I2C device address."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/iic.9:132
#, no-wrap
msgid "Fa struct i2c_attach_args"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:135
msgid ""
"Devices are attached to an I2C bus using this structure.  The structure is "
"defined as follows:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:141
#, no-wrap
msgid ""
"struct i2c_attach_args {\n"
"\ti2c_tag_t ia_tag;\t/* controller */\n"
"\ti2c_addr_t ia_addr;\t/* address of device */\n"
"\tint ia_size;\t\t/* size (for EEPROMs) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:146
msgid ""
"The following functions comprise the API provided to drivers of "
"I2C-connected devices:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/iic.9:147
#, no-wrap
msgid "Fn iic_acquire_bus ic flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:158
msgid ""
"Acquire an exclusive lock on the I2C bus.  This is required since only one "
"device may communicate on the I2C bus at a time.  Drivers should acquire the "
"bus lock, perform the I2C bus operations necessary, and then release the bus "
"lock.  Passing the E<.Dv I2C_F_POLL> flag indicates to E<.Fn "
"iic_acquire_bus> that sleeping is not permitted."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/iic.9:158
#, no-wrap
msgid "Fn iic_release_bus ic flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:166
msgid ""
"Release an exclusive lock on the I2C bus.  If the E<.Dv I2C_F_POLL> flag was "
"passed to E<.Fn iic_acquire_bus>, it must also be passed to E<.Fn "
"iic_release_bus>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/iic.9:166
#, no-wrap
msgid "Fn iic_exec ic op addr cmdbuf cmdlen buf buflen flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:197
msgid ""
"Perform a series of I2C transactions on the bus.  E<.Fn iic_exec> initiates "
"the operation by sending a START condition on the I2C bus and then "
"transmitting the address of the target device along with the transaction "
"type.  If E<.Fa cmdlen> is non-zero, the command pointed to by E<.Fa cmdbuf> "
"is then sent to the device.  If E<.Fa buflen> is non-zero, E<.Fn iic_exec> "
"will then transmit or receive the data, as indicated by E<.Fa op>.  If E<.Fa "
"op> indicates a read operation, E<.Fn iic_exec> will send a REPEATED START "
"before transferring the data.  If E<.Fa op> so indicates, a STOP condition "
"will be sent on the I2C bus at the conclusion of the operation.  Passing the "
"E<.Dv I2C_F_POLL> flag indicates to E<.Fn iic_exec> that sleeping is not "
"permitted."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/iic.9:197
#, no-wrap
msgid "Fn iic_smbus_write_byte ic addr cmd data flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:205
msgid ""
"Perform an SMBus WRITE BYTE operation.  This is equivalent to "
"I2C_OP_WRITE_WITH_STOP with E<.Fa cmdlen> of 1 and E<.Fa buflen> of 1."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/iic.9:205
#, no-wrap
msgid "Fn iic_smbus_read_byte ic addr cmd datap flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:213
msgid ""
"Perform an SMBus READ BYTE operation.  This is equivalent to "
"I2C_OP_READ_WITH_STOP with E<.Fa cmdlen> of 1 and E<.Fa buflen> of 1."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/iic.9:213
#, no-wrap
msgid "Fn iic_smbus_receive_byte ic addr datap flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:221
msgid ""
"Perform an SMBus RECEIVE BYTE operation.  This is equivalent to "
"I2C_OP_READ_WITH_STOP with E<.Fa cmdlen> of 0 and E<.Fa buflen> of 1."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/iic.9:222
#, no-wrap
msgid "CONTROLLER INTERFACE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:227
msgid ""
"The I2C controller driver must fill in the function pointers of an E<.Fa "
"i2c_controller> structure, which is defined as follows:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:230
#, no-wrap
msgid ""
"struct i2c_controller {\n"
"\tvoid\t*ic_cookie;\t/* controller private */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:233
#, no-wrap
msgid ""
"\tint\t(*ic_acquire_bus)(void *, int);\n"
"\tvoid\t(*ic_release_bus)(void *, int);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:236
#, no-wrap
msgid ""
"\tint\t(*ic_exec)(void *, i2c_op_t, i2c_addr_t,\n"
"\t\t   const void *, size_t, void *, size_t, int);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:243
#, no-wrap
msgid ""
"\tint\t(*ic_send_start)(void *, int);\n"
"\tint\t(*ic_send_stop)(void *, int);\n"
"\tint\t(*ic_initiate_xfer)(void *, i2c_addr_t, int);\n"
"\tint\t(*ic_read_byte)(void *, uint8_t *, int);\n"
"\tint\t(*ic_write_byte)(void *, uint8_t, int);\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:250
msgid ""
"The E<.Fn (*ic_acquire_bus)> and E<.Fn (*ic_release_bus)> functions must "
"always be provided."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:257
msgid ""
"The controller driver may elect to provide an E<.Fn (*ic_exec)> function.  "
"This function is intended for use by automated controllers that do not "
"provide manual control over I2C bus conditions such as START and STOP."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:264
msgid ""
"If the E<.Fn (*ic_exec)> function is not provided, the following 5 functions "
"will be used by E<.Fn iic_exec> in order to execute the I2C bus operation:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/iic.9:265
#, no-wrap
msgid "Fn (*ic_send_start) cookie flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:270
msgid ""
"Send a START condition on the I2C bus.  The E<.Dv I2C_F_POLL> flag indicates "
"that sleeping is not permitted."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/iic.9:270
#, no-wrap
msgid "Fn (*ic_send_stop) cookie flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:275
msgid ""
"Send a STOP condition on the I2C bus.  The E<.Dv I2C_F_POLL> flag indicates "
"that sleeping is not permitted."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/iic.9:275
#, no-wrap
msgid "Fn (*ic_initiate_xfer) cookie addr flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:289
msgid ""
"Initiate a transfer on the I2C bus by sending a START condition and then "
"transmitting the I2C device address and transfer type.  The E<.Dv "
"I2C_F_READ> flag indicates a read transfer; the lack of this flag indicates "
"a write transfer.  The E<.Dv I2C_F_POLL> flag indicates that sleeping is not "
"permitted.  The error code E<.Dv ETIMEDOUT> should be returned if a timeout "
"that would indicate that the device is not present occurs."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/iic.9:289
#, no-wrap
msgid "Fn (*ic_read_byte) cookie datap flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:304
msgid ""
"Read a byte from the I2C bus into the memory location referenced by E<.Fa "
"datap>.  The E<.Dv I2C_F_LAST> flag indicates that this is the final byte of "
"the transfer, and that a NACK condition should be sent on the I2C bus "
"following the transfer of the byte.  The E<.Dv I2C_F_STOP> flag indicates "
"that a STOP condition should be sent on the I2C bus following the transfer "
"of the byte.  The E<.Dv I2C_F_POLL> flag indicates that sleeping is not "
"permitted."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/iic.9:304
#, no-wrap
msgid "Fn (*ic_write_byte) cookie data flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:315
msgid ""
"Write the byte contained in E<.Fa data> to the I2C bus.  The E<.Dv "
"I2C_F_STOP> flag indicates that a STOP condition should be sent on the I2C "
"bus following the transfer of the byte.  The E<.Dv I2C_F_POLL> flag "
"indicates that sleeping is not permitted."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:333
msgid ""
"E<.Xr iic 4>, E<.Xr i2cscan 8> E<.Rs> E<.%A NXP Semiconductors> E<.%T "
"I2C-bus Specification and User Manual> E<.%N Revision 03> E<.%D June 19, "
"2007> E<.%U "
"http://www.ics.nxp.com/support/documents/i2c/pdf/i2c.bus.specification.pdf> "
"E<.Re> E<.Rs> E<.%A Duracell Inc. et. al.> E<.%T System Management Bus "
"(SMBus) Specification> E<.%N Version 2.0> E<.%D August 3, 2000> E<.%U "
"http://smbus.org/specs/smbus20.pdf> E<.Re>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:341
msgid ""
"The E<.Nm iic> API first appeared in E<.Nx 2.0>.  E<.Ox> support was added "
"in E<.Ox 3.6>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/iic.9:350
msgid ""
"The E<.Nm iic> API was written by Steve C. Woodford and Jason R. Thorpe for "
"E<.Nx> and then ported to E<.Ox> by E<.An Alexander Yurchenko Aq "
"grange@openbsd.org>."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/imax.9:28
#, no-wrap
msgid "IMAX 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/imax.9:39
msgid ""
"E<.Nm imax>, E<.Nm imin>, E<.Nm lmax>, E<.Nm lmin>, E<.Nm max>, E<.Nm min>, "
"E<.Nm ulmax>, E<.Nm ulmin>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/imax.9:39
#, no-wrap
msgid "compare integers"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/imax.9:57
msgid ""
"E<.Ft int> E<.Fn imax \"int a\" \"int b\"> E<.Ft int> E<.Fn imin \"int a\" "
"\"int b\"> E<.Ft long> E<.Fn lmax \"long a\" \"long b\"> E<.Ft long> E<.Fn "
"lmin \"long a\" \"long b\"> E<.Ft u_int> E<.Fn max \"u_int a\" \"u_int b\"> "
"E<.Ft u_int> E<.Fn min \"u_int a\" \"u_int b\"> E<.Ft u_long> E<.Fn ulmax "
"\"u_long a\" \"u_long b\"> E<.Ft u_long> E<.Fn ulmin \"u_long a\" \"u_long "
"b\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/imax.9:67
msgid ""
"The E<.Fn imin>, E<.Fn lmin>, E<.Fn min>, and E<.Fn ulmin> functions return "
"whichever argument is algebraically smaller, differing only in their "
"argument and return types: these functions operate on, respectively, natural "
"size, long, unsigned and unsigned long integers."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/imax.9:79
msgid ""
"The E<.Fn imax>, E<.Fn lmax>, E<.Fn max>, and E<.Fn ulmax> functions are "
"identical except that they return the algebraically larger argument between "
"E<.Ar a> and E<.Ar b>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/imax.9:80
msgid "E<.Xr ilog2 3>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/in4_cksum.9:30
#, no-wrap
msgid "May 22, 2001"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/in4_cksum.9:31
#, no-wrap
msgid "IN_CKSUM 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in4_cksum.9:37
msgid "E<.Nm in_cksum>, E<.Nm in4_cksum>, E<.Nm in6_cksum>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/in4_cksum.9:37
#, no-wrap
msgid "compute Internet checksum"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in4_cksum.9:45
msgid ""
"E<.Ft uint16_t> E<.Fn in_cksum \"struct mbuf *m\" \"int len\"> E<.Ft "
"uint16_t> E<.Fn in4_cksum \"struct mbuf *m\" \"uint8_t nxt\" \"int off\" "
"\"int len\"> E<.Ft uint16_t> E<.Fn in6_cksum \"struct mbuf *m\" \"uint8_t "
"nxt\" \"int off\" \"int len\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in4_cksum.9:60
msgid ""
"These functions are used to compute the ones-complement checksum required by "
"IP and IPv6.  The E<.Fn in4_cksum> function is used to compute the "
"transport-layer checksum required by E<.Xr tcp 4> and E<.Xr udp 4> over a "
"range of bytes starting at E<.Fa off> and continuing on for E<.Fa len> bytes "
"within the mbuf E<.Fa m>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in4_cksum.9:71
msgid ""
"If the E<.Fa nxt> parameter is non-zero, it is assumed to be an IP protocol "
"number.  It is also assumed that the data within E<.Fa m> starts with an IP "
"header, and the transport-layer header starts at E<.Fa off>; a pseudo-header "
"is constructed as specified in RFC768 and RFC793, and the pseudo-header is "
"prepended to the data covered by the checksum."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in4_cksum.9:82
msgid ""
"The E<.Fn in6_cksum> function is similar; if E<.Fa nxt> is non-zero, it is "
"assumed that E<.Fa m> starts with an IPv6 header, and that the "
"transport-layer header starts after E<.Fa off> bytes."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in4_cksum.9:87
msgid ""
"The E<.Fn in_cksum> function is equivalent to E<.Fn in4_cksum \"m\" \"0\" "
"\"0\" \"len\">."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in4_cksum.9:94
msgid ""
"These functions are always performance critical and should be reimplemented "
"in assembler or optimized C for each platform; when available, use of "
"repeated full-width add-with-carry followed by reduction of the sum to a 16 "
"bit width usually leads to best results.  See RFC's 1071, 1141, 1624, and "
"1936 for more information about efficient computation of the internet "
"checksum."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in4_cksum.9:96
msgid "All three functions return the computed checksum value."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in4_cksum.9:103
msgid ""
"E<.Xr inet 4>, E<.Xr inet6 4>, E<.Xr tcp 4>, E<.Xr udp 4>, E<.Xr protocols "
"5>, E<.Xr mbuf 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in4_cksum.9:106
msgid ""
"These functions implement the Internet transport-layer checksum as specified "
"in RFC768, RFC793, and RFC2460."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in4_cksum.9:111
msgid ""
"The E<.Fn in6_cksum> function currently requires special handling of "
"link-local addresses in the pseudo-header due to the use of embedded "
"scope-id's within link-local addresses."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/in_getifa.9:30
#, no-wrap
msgid "February 22, 2007"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/in_getifa.9:31
#, no-wrap
msgid "IN_GETIFA 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:35
msgid "E<.Nm in_getifa>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/in_getifa.9:35
#, no-wrap
msgid "Look up the IPv4 source address best matching an IPv4 destination"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:38
msgid "E<.Cd options IPSELSRC>"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/in_getifa.9:38
#, no-wrap
msgid "netinet/in_selsrc.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:41
msgid ""
"E<.Ft struct ifaddr *> E<.Fn in_getifa \"struct ifaddr *ifa\" \"const struct "
"sockaddr *dst0\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:60
msgid ""
"E<.Nm> enforces the IPv4 source-address selection policy.  Add the "
"source-address selection policy mechanism to your kernel with E<.Cd options "
"IPSELSRC>.  E<.Cd options IPSELSRC> lets the operator set the policy for "
"choosing the source address of any socket bound to the E<.Dq wildcard> "
"address, E<.Dv INADDR_ANY>.  Note that the policy is applied E<.Em after> "
"the kernel makes its forwarding decision, thereby choosing the output "
"interface; in other words, this mechanism does not affect whether or not "
"E<.Nx> is a E<.Dq strong ES>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:72
msgid ""
"An operator affects the source-address selection using E<.Xr sysctl 8> and "
"E<.Xr ifconfig 8>.  Operators set policies with E<.Xr sysctl 8>.  Some "
"policies consider the E<.Dq preference number> of an address.  An operator "
"may set preference numbers for each address with E<.Xr ifconfig 8>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:96
msgid ""
"A source-address policy is a priority-ordered list of source-address ranking "
"functions.  A ranking function maps its arguments, E<.Po> E<.Em source "
"address>, E<.Em source index>, E<.Em source preference>, E<.Em destination "
"address> E<.Pc>, to integers.  The E<.Em source index> is the position of "
"E<.Em source address> in the interface address list; the index of the first "
"address is 0.  The E<.Em source preference> is the preference number the "
"operator assigned to E<.Em source address>.  The E<.Em destination address> "
"is the socket peer / packet destination."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:98
msgid "Presently, there are four ranking functions to choose from:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/in_getifa.9:99
#, no-wrap
msgid "index"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:103
msgid "ranks by E<.Em source index>; lower indices are ranked more highly."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/in_getifa.9:103
#, no-wrap
msgid "preference"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:107
msgid ""
"ranks by E<.Em source preference>; higher preference numbers are ranked more "
"highly."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/in_getifa.9:107
#, no-wrap
msgid "common-prefix-len"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:113
msgid ""
"ranks each E<.Em source address> by the length of the longest prefix it has "
"in common with E<.Em destination address>; longer common prefixes rank more "
"highly."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/in_getifa.9:113
#, no-wrap
msgid "same-category"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:139
msgid ""
"determines the \"categories\" of E<.Em source> and E<.Em destination "
"address>.  A category is one of E<.Em private>, E<.Em link-local>, or E<.Em "
"other>.  If the categories exactly match, same-category assigns a rank of "
"2.  Some sources are ranked 1 by category: a E<.Em link-local> source with a "
"E<.Em private> destination, a E<.Em private> source with a E<.Em link-local> "
"destination, and a E<.Em private> source with an E<.Em other> destination "
"rank 1.  All other sources rank 0."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:141
msgid "Categories are defined as follows."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/in_getifa.9:142
#, no-wrap
msgid "private"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:144
msgid "RFC1918 networks, 192.168/16, 172.16/12, and 10/8"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/in_getifa.9:144
#, no-wrap
msgid "link-local"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:146
msgid "169.254/16, 224/24"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/in_getifa.9:146
#, no-wrap
msgid "other"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:148
msgid "all other networks---i.e., not private, not link-local"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:157
msgid ""
"To apply a policy, the kernel applies all ranking functions in the policy to "
"every source address, producing a vector of ranks for each source.  The "
"kernel sorts the sources in descending, lexicographical order by their "
"rank-vector, and chooses the highest-ranking (first) source.  The kernel "
"breaks ties by choosing the source with the least E<.Em source index>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:161
msgid ""
"The operator may set a policy on individual interfaces.  The operator may "
"also set a global policy that applies to all interfaces whose policy he does "
"not set individually."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:163
msgid "Here is the sysctl tree for the policy at system startup:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:171
#, no-wrap
msgid ""
"net.inet.ip.selectsrc.default = index\n"
"net.inet.ip.interfaces.ath0.selectsrc =\n"
"net.inet.ip.interfaces.sip0.selectsrc =\n"
"net.inet.ip.interfaces.sip1.selectsrc =\n"
"net.inet.ip.interfaces.lo0.selectsrc =\n"
"net.inet.ip.interfaces.pflog0.selectsrc =\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:182
msgid ""
"The policy on every interface is the E<.Dq empty> policy, so the default "
"policy applies.  The default policy, E<.Em index>, is the E<.Dq historical> "
"policy in E<.Nx>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:184
msgid "The operator may override the default policy on ath0,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:186
#, no-wrap
msgid ""
"\t# sysctl -w "
"net.inet.ip.interfaces.ath0.selectsrc=same-category,common-prefix-len,preference\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:189 org_netbsd/src/share/man/man9/in_getifa.9:202
msgid "yielding this policy:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:192
#, no-wrap
msgid ""
"net.inet.ip.selectsrc.default = index\n"
"net.inet.ip.interfaces.ath0.selectsrc = "
"same-category,common-prefix-len,preference\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:195
msgid "The operator may set a new default,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:199
#, no-wrap
msgid ""
"# sysctl -w net.inet.ip.selectsrc.debug=\\*[Gt] "
"same-category,common-prefix-len,preference\n"
"# sysctl -w net.inet.ip.interfaces.ath0.selectsrc=\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:205
#, no-wrap
msgid ""
"net.inet.ip.selectsrc.default = same-category,common-prefix-len,preference\n"
"net.inet.ip.interfaces.ath0.selectsrc =\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:209
msgid ""
"In a number of applications, the policy above will usually pick suitable "
"source addresses if ath0 is configured in this way:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:215
#, no-wrap
msgid ""
"# ifconfig ath0 inet 64.198.255.1/24\n"
"# ifconfig ath0 inet 10.0.0.1/24\n"
"# ifconfig ath0 inet 169.254.1.1/24\n"
"# ifconfig ath0 inet 192.168.49.1/24 preference 5\n"
"# ifconfig ath0 inet 192.168.37.1/24 preference 9\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:219
msgid ""
"A sysctl, net.inet.ip.selectsrc.debug, turns on and off debug messages "
"concerned with source selection.  You may set it to 0 (no messages) or 1."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:222
msgid "E<.Xr ifconfig 8>, E<.Xr sysctl 8>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:228
msgid ""
"The family of IPv6 source-address selection policies defined by E<.Li "
"RFC3484> resembles the family of IPv4 policies that E<.Nm> enforces."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:242
msgid ""
"With E<.Cd options IPSELSRC>, a new interface E<.Xr ioctl 2>, E<.Dv "
"SIOCSIFADDRPREF>, was introduced.  It ought to be documented in E<.Xr inet "
"4>.  Also, E<.Xr options 4> ought to cross-reference this manual page."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/in_getifa.9:245
msgid ""
"This work should be used to set IPv6 source-address selection policies, "
"especially the family of policies defined by E<.Li RFC3484>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/inittodr.9:35 org_netbsd/src/share/man/man9/todr.9:30
#, no-wrap
msgid "September 6, 2006"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/inittodr.9:36
#, no-wrap
msgid "INITTODR 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/inittodr.9:40
msgid "E<.Nm inittodr>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/inittodr.9:40
#, no-wrap
msgid "initialize system time"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/inittodr.9:44
msgid "E<.Ft void> E<.Fn inittodr \"time_t base\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/inittodr.9:53
msgid ""
"The E<.Fn inittodr> function determines the time and sets the system clock.  "
"It tries to pick the correct time using a set of heuristics that examine the "
"system's battery-backed clock and the time reported by the file system, as "
"given in E<.Fa base>.  Those heuristics include:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/inittodr.9:59
msgid ""
"If the battery-backed clock has a valid time, and is not significantly "
"behind the time provided by E<.Fa base>, it is used."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/inittodr.9:68
msgid ""
"If the battery-backed clock does not have a valid time, or is significantly "
"behind the time provided in E<.Fa base>, and the time provided in E<.Fa "
"base> is within reason, E<.Fa base> is used as the current time."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/inittodr.9:74
msgid ""
"If the battery-backed clock appears invalid, and E<.Fa base> appears "
"non-sensical or was not provided (was given as zero), an arbitrary base "
"(typically some time within the same year that the kernel was last updated) "
"will be used."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/inittodr.9:79
msgid ""
"Once a system time has been determined, it is stored in the E<.Va time> "
"variable."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/inittodr.9:85
msgid ""
"The E<.Fn inittodr> function prints diagnostic messages if it has trouble "
"figuring out the system time.  Conditions that can cause diagnostic messages "
"to be printed include:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/inittodr.9:88
msgid "There is no battery-backed clock present on the system."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/inittodr.9:90
msgid "The battery-backed clock's time appears nonsensical."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/inittodr.9:94
msgid "The E<.Fa base> time appears nonsensical."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/inittodr.9:98
msgid ""
"The E<.Fa base> time and the battery-backed clock's time differ by a large "
"amount."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/inittodr.9:103
msgid "E<.Xr clock_ymdhms_to_secs 9>, E<.Xr resettodr 9>, E<.Xr time_second 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/inittodr.9:105
msgid ""
"Some systems use heuristics for picking the correct time that are slightly "
"different."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/intro.9:30
#, no-wrap
msgid "December 2, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/intro.9:31
#, no-wrap
msgid "INTRO 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:35
msgid "E<.Nm intro>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/intro.9:35
#, no-wrap
msgid "introduction to kernel internals"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:41
msgid ""
"This section contains information related to the internal operation of the "
"system kernel.  It describes function interfaces and variables of use to the "
"systems and device driver programmer."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:44
msgid ""
"In addition to the normal man page format, the kernel pages include an "
"additional section:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:50
msgid ""
"Contains the pathname(s) of the source file(s) which contain the definition "
"and/or source code of the variables or functions being documented.  Any "
"paths are relative to the top level of the source tree (traditionally E<.Pa "
"/usr/src>)."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/intro.9:51
#, no-wrap
msgid "MEMORY MANAGEMENT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:55
msgid "Machine-dependent swap interface.  See E<.Xr cpu_swapout 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:59
msgid "Introduction to kernel memory allocators.  See E<.Xr memoryallocators 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:63
msgid "Machine-dependent portion of the virtual memory system.  See E<.Xr pmap 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:67
msgid "Virtual memory system external interface.  See E<.Xr uvm 9>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/intro.9:67
#, no-wrap
msgid "I/O SUBSYSTEM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:71
msgid "Buffer cache interfaces.  See E<.Xr buffercache 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:75
msgid "Device buffer queues.  See E<.Xr bufq 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:79
msgid "Initiate I/O on raw devices.  See E<.Xr physio 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:83
msgid "I/O descriptor allocation interface.  See E<.Xr getiobuf 9>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/intro.9:83
#, no-wrap
msgid "PROCESS CONTROL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:87
msgid "Machine-dependent process exit.  See E<.Xr cpu_exit 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:91
msgid "Idle CPU while waiting for work.  See E<.Xr cpu_idle 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:95
msgid "Finish a fork operation.  See E<.Xr cpu_lwp_fork 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:99
msgid "Switch to another light weight process.  See E<.Xr mi_switch 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:103
msgid "Current process and processor.  See E<.Xr curproc 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:107
msgid "Set process uid and gid.  See E<.Xr do_setresuid 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:112
msgid "New processes and kernel threads.  See E<.Xr fork1 9>, E<.Xr kthread 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:116
msgid "Context switch notification.  See E<.Xr cpu_need_resched 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:120
msgid "Common scheduler framework.  See E<.Xr csf 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:124
msgid "Software signal facilities.  See E<.Xr signal 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:128
msgid "Suspend the scheduler.  See E<.Xr suspendsched 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:132
msgid "Return path to user-mode execution.  See E<.Xr userret 9>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/intro.9:132
#, no-wrap
msgid "FILE SYSTEM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:136
msgid "High-level file operations.  See E<.Xr dofileread 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:141
msgid ""
"Convert an extended attribute namespace identifier to a string and vice "
"versa.  See E<.Xr extattr 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:145
msgid "Operations on file entries.  See E<.Xr file 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:149
msgid ""
"In-kernel, file-system independent, file-meta data association.  See E<.Xr "
"fileassoc 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:153
msgid "File descriptor tables and operations.  See E<.Xr filedesc 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:157
msgid "File descriptor owner handling functions.  See E<.Xr fsetown 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:161
msgid "File system suspension helper subsystem.  See E<.Xr fstrans 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:167
msgid ""
"Pathname lookup, cache and management.  See E<.Xr namei 9>, E<.Xr namecache "
"9>, E<.Xr pathname 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:171
msgid "Kernel interface to file systems.  See E<.Xr vfs 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:176
msgid ""
"Kernel representation of a file or directory and vnode attributes.  See "
"E<.Xr vnode 9>, E<.Xr vattr 9>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/intro.9:176
#, no-wrap
msgid "NETWORKING"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:180
msgid ""
"Kernel interfaces for manipulating output queues on network interfaces.  See "
"E<.Xr altq 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:184
msgid "Externally visible ARP functions.  See E<.Xr arp 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:188
msgid ""
"Ethernet and FDDI driver support functions and macros.  See E<.Xr ethersubr "
"9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:194
msgid ""
"Core 802.11 network stack functions and rate adaptation based on received "
"signal strength.  See E<.Xr ieee80211 9>, E<.Xr rssadapt 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:198
msgid "Compute Internet checksum.  See E<.Xr in_cksum 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:202
msgid ""
"Look up the IPv4 source address best matching an IPv4 destination.  See "
"E<.Xr in_getifa 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:206
msgid ""
"Functions and macros for managing memory used by networking code.  See E<.Xr "
"mbuf 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:210
msgid "Packet filter interface.  See E<.Xr pfil 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:214
msgid "Route callout functions.  See E<.Xr rt_timer 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:218
msgid "TCP congestion control API.  See E<.Xr tcp_congctl 9>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/intro.9:218
#, no-wrap
msgid "LOCKING AND INTERRUPT CONTROL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:222
msgid "Condition variables.  See E<.Xr condvar 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:226
msgid "Kernel lock functions.  See E<.Xr lock 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:230
msgid "Memory barriers.  See E<.Xr mb 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:234
msgid "Mutual exclusion primitives.  See E<.Xr mutex 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:238
msgid "Restartable atomic sequences.  See E<.Xr ras 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:242
msgid "Reader / writer lock primitives.  See E<.Xr rwlock 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:246
msgid "Machine-independent software interrupt framework.  See E<.Xr softintr 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:250
msgid "Functions to modify system interrupt priority level.  See E<.Xr spl 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:254
msgid "Functions ro raise the system priority level.  See E<.Xr splraiseipl 9>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/intro.9:254
#, no-wrap
msgid "SECURITY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:258
msgid "Kernel authorization framework.  See E<.Xr kauth 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:262
msgid "API for cryptographic services in the kernel.  See E<.Xr opencrypto 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:266
msgid "Security model development guidelines.  See E<.Xr secmodel 9>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/intro.9:266
#, no-wrap
msgid "SYSTEM TIME CONTROL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:270
msgid "Execute a function after a specified length of time.  See E<.Xr callout 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:274
msgid "Microsecond delay.  See E<.Xr delay 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:278
msgid "Real-time timer.  See E<.Xr hardclock 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:282
msgid "System clock frequency.  See E<.Xr hz 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:287
msgid ""
"Initialization of system time and time-of-day clock support.  See E<.Xr "
"inittodr 9>, E<.Xr todr 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:291
msgid "Check that a timeval value is valid, and correct.  See E<.Xr itimerfix 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:295
msgid "System time variables.  See E<.Xr timecounter 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:299
msgid "Realtime system clock.  See E<.Xr microtime 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:303
msgid "Get the time elapsed since boot.  See E<.Xr microuptime 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:307
msgid "Convert milliseconds to system clock ticks.  See E<.Xr mstohz 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:311
msgid "Function to help implement rate-limited actions.  See E<.Xr ppsratecheck 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:315
msgid "Function to help implement rate-limited actions.  See E<.Xr ratecheck 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:319
msgid "Set battery-backed clock from system time.  See E<.Xr resettodr 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:323
msgid "System time variables.  See E<.Xr time_second 9>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/intro.9:323
#, no-wrap
msgid "KERNEL AND USER SPACE DATA COPY FUNCTIONS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:327
msgid "Kernel space to/from user space copy functions.  See E<.Xr copy 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:331
msgid "Store data to user-space.  See E<.Xr store 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:335
msgid "Fetch data from user-space.  See E<.Xr fetch 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:339
msgid "Move data described by a struct uio.  See E<.Xr uiomove 9>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/intro.9:339
#, no-wrap
msgid "MACHINE DEPENDENT KERNEL FUNCTIONS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:343
msgid "Machine-dependent clock setup interface.  See E<.Xr cpu_initclocks 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:347
msgid "Machine-dependent process core dump interface.  See E<.Xr cpu_coredump 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:351
msgid "Machine-dependent kernel core dumps.  See E<.Xr cpu_dumpconf 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:355
msgid "Unique CPU identification number See E<.Xr cpu_number 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:359
msgid "Halt or reboot the system See E<.Xr cpu_reboot 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:363
msgid "Machine-dependent root file system setup See E<.Xr cpu_rootconf 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:367
msgid "Machine-dependent CPU startup See E<.Xr cpu_startup 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:371
msgid "Disk label management routines.  See E<.Xr disklabel 9>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/intro.9:371
#, no-wrap
msgid "DEVICE CONFIGURATION"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:375
msgid "Autoconfiguration frame-work.  See E<.Xr autoconf 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:379
msgid "Description of a device driver.  See E<.Xr driver 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:383
msgid ""
"The autoconfiguration framework ``device definition'' language.  See E<.Xr "
"config 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:387
msgid "Machine-dependent device autoconfiguration.  See E<.Xr cpu_configure 9>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/intro.9:387
#, no-wrap
msgid "MI DEVICE DRIVER API"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:391
msgid "Bus and Machine Independent DMA Mapping Interface.  See E<.Xr bus_dma 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:395
msgid "Bus space manipulation functions.  See E<.Xr bus_space 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:399
msgid "Generic disk framework.  See E<.Xr disk 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:406
msgid ""
"Hardware-assisted data mover interface.  See E<.Xr dmover 9>.  Generic event "
"counter framework.  See E<.Xr evcnt 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:410
msgid "Firmware loader API for device drivers.  See E<.Xr firmload 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:414
msgid ""
"How to implement a new ioctl call to access device drivers.  See E<.Xr ioctl "
"9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:418
msgid "Extensible line discipline framework.  See E<.Xr linedisc 9>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/intro.9:418
#, no-wrap
msgid "CONSOLE DEVICES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:422
msgid "Console magic key sequence management.  See E<.Xr cnmagic 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:426
msgid "Console access interface.  See E<.Xr cons 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:430
msgid "Raster display operations.  See E<.Xr rasops 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:434
msgid "Generic virtual console framework.  See E<.Xr vcons 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:438
msgid "Machine-independent console support.  See E<.Xr wscons 9>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/intro.9:438
#, no-wrap
msgid "DEVICE SPECIFIC IMPLEMENTATION"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:442
msgid "Interface between low and high level audio drivers.  See E<.Xr audio 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:446
msgid "Bluetooth Device/Protocol API.  See E<.Xr bluetooth 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:450
msgid "Support for CardBus PC-Card devices.  See E<.Xr cardbus 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:454
msgid "VESA Display Data Channel V2.  See E<.Xr ddc 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:458
msgid "VESA Extended Display Identification Data.  See E<.Xr edid 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:462
msgid "Inter IC (I2C) bus.  See E<.Xr iic 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:466
msgid ""
"Baseboard I/O control ASIC for DEC TURBOchannel systems.  See E<.Xr ioasic "
"9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:470
msgid "Industry-standard Architecture.  See E<.Xr isa 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:474
msgid "Introduction to ISA Plug-and-Play support.  See E<.Xr isapnp 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:478
msgid "MicroChannel Architecture bus.  See E<.Xr mca 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:482
msgid "PPBUS microseqencer developer's guide.  See E<.Xr microseq 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:486
msgid "Peripheral Component Interconnect.  See E<.Xr pci 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:490
msgid "Perform PCI bus configuration.  See E<.Xr pci_configure_bus 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:494
msgid "PCI bus interrupt manipulation functions.  See E<.Xr pci_intr 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:498
msgid "PC keyboard port interface.  See E<.Xr pckbport 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:502
msgid "Support for PCMCIA PC-Card devices.  See E<.Xr pcmcia 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:506
msgid "User-space interface to ppbus parallel port.  See E<.Xr ppi 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:510
msgid "Interface between low and high level radio drivers.  See E<.Xr radio 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:514
msgid ""
"Functions to make a device available for entropy collection.  See E<.Xr rnd "
"9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:518
msgid "SCSI/ATAPI middle-layer interface.  See E<.Xr scsipi 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:522
msgid "TURBOchannel bus.  See E<.Xr tc 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:526
msgid "USB tty support.  See E<.Xr ucom 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:530
msgid "USB device drivers interface.  See E<.Xr usbdi 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:534
msgid "Versa Module Euroboard bus.  See E<.Xr vme 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:538
msgid "Machine-independent IDE/ATAPI driver.  See E<.Xr wdc 9>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/intro.9:538
#, no-wrap
msgid "KERNEL EVENT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:542
msgid ""
"Functions to add or remove kernel event filters.  See E<.Xr kfilter_register "
"9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:546
msgid "Functions to raise kernel event.  See E<.Xr knote 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:550
msgid "Record and wakeup select requests.  See E<.Xr selrecord 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:554
msgid "Simple do-it-in-thread-context framework.  See E<.Xr workqueue 9>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/intro.9:554
#, no-wrap
msgid "KERNEL HELPER FUNCTIONS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:558
msgid "Kernel expression verification macros.  See E<.Xr KASSERT 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:562
msgid ""
"Convert a single byte between (unsigned) packed bcd and binary.  See E<.Xr "
"bcdtobin 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:566
msgid "Bitmask output conversion.  See E<.Xr snprintb 3>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:570
msgid "General purpose extent manager.  See E<.Xr extent 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:574
msgid "Compare integers.  See E<.Xr imax 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:578
msgid "Kernel formatted output conversion.  See E<.Xr kprintf 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:589
msgid ""
"Data comparing, moving, copying, setting and cleaning.  See E<.Xr memcmp 9>, "
"E<.Xr memmove 9>, E<.Xr memcpy 9>, E<.Xr memset 9>, E<.Xr bcmp 9>, E<.Xr "
"bcopy 9>, E<.Xr bzero 9>, E<.Xr kcopy 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:593
msgid ""
"Log a message from the kernel through the /dev/klog device.  See E<.Xr log "
"9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:597
msgid "Bring down system on fatal error.  See E<.Xr panic 9>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/intro.9:597
#, no-wrap
msgid "MISC"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:601
msgid "Power management and inter-driver messaging.  See E<.Xr pmf 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:605
msgid "Run all shutdown hooks.  See E<.Xr pmf_system_shutdown 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:609
msgid "Kernel internal error numbers.  See E<.Xr errno 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:614
msgid ""
"Kernel hash functions, hash table construction and destruction.  See E<.Xr "
"hash 9>, E<.Xr hashinit 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:618
msgid "Format a number into a human readable form.  See E<.Xr humanize_number 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:622
msgid "Machine-dependent interface to ipkdb.  See E<.Xr ipkdb 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:626
msgid "Options string management.  See E<.Xr optstr 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:630
msgid "Performs pattern matching on strings.  See E<.Xr pmatch 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:634
msgid "Hardware Performance Monitoring Interface.  See E<.Xr pmc 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:638
msgid "Add or remove a shutdown hook.  See E<.Xr pmf 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:642
msgid "Non-local jumps.  See E<.Xr setjmp 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:646
msgid "System variable control interfaces.  See E<.Xr sysctl 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/intro.9:650
msgid "The E<.Nx> kernel internals section first appeared in E<.Nx 1.2>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/ioasic.9:30
#, no-wrap
msgid "August 6, 2000"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/ioasic.9:31
#, no-wrap
msgid "IOASIC 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:40
msgid ""
"E<.Nm IOASIC>, E<.Nm ioasic_intr_establish>, E<.Nm "
"ioasic_intr_disestablish>, E<.Nm ioasic_intr_evcnt>, E<.Nm "
"ioasic_attach_devs>, E<.Nm ioasic_submatch>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/ioasic.9:40
#, no-wrap
msgid "baseboard I/O control ASIC for DEC TURBOchannel systems"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/ioasic.9:43 org_netbsd/src/share/man/man9/tc.9:47
#, no-wrap
msgid "dev/tc/tcvar.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/ioasic.9:44
#, no-wrap
msgid "dev/tc/ioasicreg.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/ioasic.9:45
#, no-wrap
msgid "dev/tc/ioasicvar.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:58
msgid ""
"E<.Ft void> E<.Fn ioasic_intr_establish \"struct device *dev\" \"void "
"*cookie\" \"int level\" \"int (*handler)(void *)\" \"void *arg\"> E<.Ft "
"void> E<.Fn ioasic_intr_disestablish \"struct device *dev\" \"void "
"*cookie\"> E<.Ft const struct evcnt *> E<.Fn ioasic_intr_evcnt \"struct "
"device *dev\" \"void *cookie\"> E<.Ft void> E<.Fn ioasic_attach_devs "
"\"struct ioasic_softc *sc\" \"struct ioasic_dev *ioasic_devs\" \"int "
"ioasic_ndevs\"> E<.Ft int> E<.Fn ioasic_submatch \"struct cfdata *match\" "
"\"struct ioasicdev_attach_args *ia\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:70
msgid ""
"The E<.Nm> device provides support for the DEC proprietary IOCTL ASIC found "
"on all DEC TURBOchannel machines with MIPS (DECstation 5000 series, "
"excluding the 5000/200) and Alpha (3000-series) systems.  The E<.Nm> is "
"memory-mapped into the TURBOchannel system slot to interface up to sixteen "
"I/O devices.  It connects the TURBOchannel to a 16-bit wide I/O bus and "
"supplies various control signals to the devices that share this bus."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:82
msgid ""
"The E<.Nm> provides hardware DMA channels and interrupt support.  DMA "
"transfers are between one and four 32-bit words (16 bytes) in length, "
"depending on the device.  The E<.Nm> stores the data in internal data "
"registers.  The data is transferred to and from the registers in 16-bit "
"words to the device.  Various interrupts are signalled on DMA "
"pointer-related conditions."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:86 org_netbsd/src/share/man/man9/pci.9:196
msgid ""
"Drivers for devices attached to the E<.Nm> will make use of the following "
"data types:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioasic.9:87
#, no-wrap
msgid "Fa struct ioasicdev_attach_args"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:92
msgid ""
"A structure used to inform the driver of the E<.Nm> device properties.  It "
"contains the following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:97
#, no-wrap
msgid ""
"\tchar\t\t\tiada_modname\n"
"\ttc_offset_t\t\tiada_offset\n"
"\ttc_addr_t\t\tiada_addr\n"
"\tvoid\t\t\t*iada_cookie;\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioasic.9:98
#, no-wrap
msgid "Fa struct ioasic_softc"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:101
msgid ""
"The parent structure which contains at the following members which are "
"useful for drivers:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:105
#, no-wrap
msgid ""
"\tbus_space_tag_t\t\tsc_bst;\n"
"\tbus_space_handle_t\tsc_bsh;\n"
"\tbus_dma_tag_t\t\tsc_dmat;\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioasic.9:106
#, no-wrap
msgid "Fa struct ioasic_dev"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:110
msgid ""
"A structure describing the machine-dependent devices attached to the E<.Nm> "
"containing the following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:115
#, no-wrap
msgid ""
"\tchar\t\t\t*iad_modname;\n"
"\ttc_offset_t\t\tiad_offset;\n"
"\tvoid\t\t\t*iad_cookie;\n"
"\tuint32_t\t\tiad_intrbits;\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioasic.9:119
#, no-wrap
msgid "Fn ioasic_intr_establish dev cookie level handler arg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:130
msgid ""
"Establish an interrupt handler with device E<.Fa dev> for the interrupt "
"described completely by E<.Fa cookie>.  The priority of the interrupt is "
"specified by E<.Fa level>.  When the interrupt occurs the function E<.Fa "
"handler> is called with argument E<.Fa arg>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioasic.9:130
#, no-wrap
msgid "Fn ioasic_intr_disestablish dev cookie"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:135
msgid ""
"Dis-establish the interrupt handler with device E<.Fa dev> for the interrupt "
"described complete ly E<.Fa cookie>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioasic.9:135
#, no-wrap
msgid "Fn ioasic_intr_evcnt dev cookie"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:140 org_netbsd/src/share/man/man9/tc.9:132
msgid ""
"Do interrupt event counting with device E<.Fa dev> for the event described "
"completely by E<.Fa cookie>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioasic.9:140
#, no-wrap
msgid "Fn ioasic_attach_devs sc ioasic_devs ioasic_ndevs"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:145
msgid "Configure each of the E<.Fa ioasic_ndevs> devices in E<.Fa ioasic_devs>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioasic.9:145
#, no-wrap
msgid "Fn ioasic_submatch match ia"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:147
msgid "Check that the device offset is not OASIC_OFFSET_UNKNOWN."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:162
msgid ""
"The E<.Fn ioasic_intr_establish>, E<.Fn ioasic_intr_disestablish>, and E<.Fn "
"ioasic_intr_evcnt> functions are likely to used by all E<.Nm> device "
"drivers.  The E<.Fn ioasic_attach_devs> function is used by ioasic driver "
"internally and is of interest to driver writers because it must be aware of "
"your device for it to be found during autoconfiguration."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:172
msgid ""
"The IOASIC is a direct-connection bus.  During autoconfiguration, "
"machine-dependent code will provide an array of E<.Fa struct ioasic_devs> "
"describing devices attached to the E<.Nm> to be used by the ioasic driver.  "
"The ioasic driver will pass this array to E<.Fn ioasic_attach_devs> to "
"attach the drivers with the devices."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:175
msgid "Drivers match the device using E<.Fa iada_modname>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:181
msgid ""
"During attach, all drivers should use the parent's bus_space and bus_dma "
"resources, and map the appropriate bus_space region using E<.Fn "
"bus_space_subregion> with E<.Fa iada_offset>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:187
msgid ""
"No additional support is provided for E<.Nm> DMA beyond the facilities "
"provided by the E<.Xr bus_dma 9> interface."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:199
msgid ""
"The E<.Nm> provides two pairs of DMA address pointers (transmitting and "
"receiving) for each DMA-capable device.  The pair of address pointers point "
"to consecutive (but not necessarily contiguous) DMA blocks of size "
"IOASIC_DMA_BLOCKSIZE.  Upon successful transfer of the first block, DMA "
"continues to the next block and an interrupt is posted to signal an address "
"pointer update.  DMA transfers are enabled and disabled by bits inside the "
"E<.Nm> status (CSR) register."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:204
msgid ""
"The interrupt handler must update the address pointers to point to the next "
"block in the DMA transfer.  The address pointer update must be completed "
"before the completion of the second DMA block, otherwise a DMA overrun error "
"condition will occur."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:209
msgid ""
"The IOASIC subsystem itself is implemented within the file E<.Pa "
"sys/dev/tc/ioasic_subr.c>.  Machine-dependent portions can be found in E<.Pa "
"sys/arch/\\*[Lt]arch\\*[Gt]/tc/ioasic.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioasic.9:214
msgid ""
"E<.Xr ioasic 4>, E<.Xr autoconf 9>, E<.Xr bus_dma 9>, E<.Xr bus_space 9>, "
"E<.Xr driver 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/ioctl.9:30
#, no-wrap
msgid "December 11, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/ioctl.9:31
#, no-wrap
msgid "IOCTL 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:35
msgid "E<.Nm ioctl>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/ioctl.9:35
#, no-wrap
msgid "how to implement a new ioctl call to access device drivers"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/ioctl.9:37 org_netbsd/src/share/man/man9/ppi.9:37
#, no-wrap
msgid "sys/ioctl.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/ioctl.9:38
#, no-wrap
msgid "sys/ioccom.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:41
msgid "E<.Ft int> E<.Fn ioctl \"int\" \"unsigned long\" \"...\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:44
msgid "E<.Nm> are internally defined as"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:45
#, no-wrap
msgid "#define FOOIOCTL fun(t,n,pt)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:49
msgid "where the different variables and functions are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:50
#, no-wrap
msgid "Cm FOOIOCTL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:54
msgid ""
"the name which will later be given in the E<.Xr ioctl 2> system call as "
"second argument, e.g.,"
msgstr ""

#. type: Dl
#: org_netbsd/src/share/man/man9/ioctl.9:54
#, no-wrap
msgid "ioctl(s, FOOIOCTL, ...) ."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:55
#, no-wrap
msgid "Fn fun"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:57
msgid "a macro which can be one of"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:58
#, no-wrap
msgid "_IO"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:61
msgid ""
"the call is a simple message to the kernel by itself.  It does not copy "
"anything into the kernel, nor does it want anything back."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:61
#, no-wrap
msgid "_IOR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:64
msgid "the call only reads parameters from the kernel and does not pass any to it"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:64
#, no-wrap
msgid "_IOW"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:67
msgid ""
"the call only writes parameters to the kernel, but does not want anything "
"back"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:67
#, no-wrap
msgid "_IOWR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:69
msgid "the call writes data to the kernel and wants information back."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:70
#, no-wrap
msgid "Ar t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:74
msgid ""
"This integer describes to which subsystem the ioctl applies.  E<.Ar t> can "
"be one of"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:75
#, no-wrap
msgid "'1'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:77
msgid "pulse-per-second interface"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:77
#, no-wrap
msgid "'4'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:79
msgid "E<.Xr isdn 4>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:79
#, no-wrap
msgid "'a'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:81
msgid "ISO networking"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:81 org_netbsd/src/share/man/man9/ioctl.9:83 org_netbsd/src/share/man/man9/ioctl.9:86 org_netbsd/src/share/man/man9/ioctl.9:88 org_netbsd/src/share/man/man9/ioctl.9:90
#, no-wrap
msgid "'A'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:83
msgid "ac devices (hp300)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:86
msgid "Advanced Power Management (hpcmips, i386, sparc), see E<.Xr apm 4>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:88
msgid "ADB devices (mac68k, macppc)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:92
msgid "E<.Xr isdntel 4>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:92 org_netbsd/src/share/man/man9/ioctl.9:94 org_netbsd/src/share/man/man9/ioctl.9:97 org_netbsd/src/share/man/man9/ioctl.9:100
#, no-wrap
msgid "'b'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:94
msgid "E<.Xr \\&tb 4>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:97
msgid "Bluetooth HCI sockets, see E<.Xr bluetooth 4>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:100
msgid "Bluetooth Hub Control, see E<.Xr bthub 4>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:103
msgid "Bluetooth SCO audio driver, see E<.Xr btsco 4>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:103 org_netbsd/src/share/man/man9/ioctl.9:105
#, no-wrap
msgid "'B'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:105
msgid "bell device (x68k)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:107 org_netbsd/src/share/man/man9/pfil.9:148
msgid "E<.Xr bpf 4>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:107 org_netbsd/src/share/man/man9/ioctl.9:109 org_netbsd/src/share/man/man9/ioctl.9:111
#, no-wrap
msgid "'c'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:109
msgid "coda"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:111
msgid "E<.Xr \\&cd 4>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:113
msgid "E<.Xr \\&ch 4>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:113 org_netbsd/src/share/man/man9/ioctl.9:115
#, no-wrap
msgid "'C'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:115
msgid "clock devices (amiga, atari, hp300, x68k)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:117
msgid "E<.Xr isdnctl 4>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:117
#, no-wrap
msgid "'d'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:119
msgid "the disk subsystem"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:119
#, no-wrap
msgid "'E'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:121
msgid "E<.Xr envsys 4>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:121
#, no-wrap
msgid "'f'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:123
msgid "files"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:123 org_netbsd/src/share/man/man9/ioctl.9:125
#, no-wrap
msgid "'F'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:125
msgid "Sun-compatible framebuffers"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:129
msgid "E<.Xr ccd 4> and E<.Xr vnd 4>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:129
#, no-wrap
msgid "'g'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:131
msgid "qdss framebuffers"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:131
#, no-wrap
msgid "'G'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:133
msgid "grf devices (amiga, atari, hp300, mac68k, x68k)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:133
#, no-wrap
msgid "'h'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:135 org_netbsd/src/share/man/man9/ioctl.9:137
msgid "HIL devices (hp300)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:135 org_netbsd/src/share/man/man9/ioctl.9:137
#, no-wrap
msgid "'H'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:139
msgid "HPc framebuffers"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:139
#, no-wrap
msgid "'i'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:141
msgid "a (pseudo) interface"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:141
#, no-wrap
msgid "'I'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:144
msgid "E<.Xr ite 4> (mac68k)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:144
#, no-wrap
msgid "'J'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:146
msgid "ISA joystick interface"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:146
#, no-wrap
msgid "'k'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:148
msgid "Sun-compatible (and other) keyboards"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:148
#, no-wrap
msgid "'l'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:150
msgid "leo devices (atari)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:150
#, no-wrap
msgid "'m'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:152
msgid "E<.Xr mtio 4>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:152 org_netbsd/src/share/man/man9/ioctl.9:154
#, no-wrap
msgid "'M'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:154
msgid "mouse devices (atari)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:156
msgid "E<.Xr mlx 4>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:156 org_netbsd/src/share/man/man9/ioctl.9:158
#, no-wrap
msgid "'n'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:158
msgid "virtual console device (arm32)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:160
msgid "SMB networking"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:160
#, no-wrap
msgid "'O'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:162
msgid "OpenPROM and OpenFirmware"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:162
#, no-wrap
msgid "'p'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:164
msgid "power control (x68k)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:164 org_netbsd/src/share/man/man9/ioctl.9:166 org_netbsd/src/share/man/man9/ioctl.9:168 org_netbsd/src/share/man/man9/ioctl.9:170 org_netbsd/src/share/man/man9/ioctl.9:172 org_netbsd/src/share/man/man9/ioctl.9:174
#, no-wrap
msgid "'P'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:166
msgid "parallel port (amiga, x68k)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:168
msgid "profiling (arm32)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:170
msgid "printer/plotter interface (hp300)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:172
msgid "pci(4)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:174
msgid "compat/ossaudio and soundcard.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:177
msgid "E<.Xr magma 4> bpp (sparc)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:177 org_netbsd/src/share/man/man9/ioctl.9:179
#, no-wrap
msgid "'q'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:179 org_netbsd/src/share/man/man9/ioctl.9:183
msgid "E<.Xr altq 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:181
msgid "pmax graphics devices"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:181 org_netbsd/src/share/man/man9/ioctl.9:183
#, no-wrap
msgid "'Q'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:185
msgid "raw SCSI commands"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:185 org_netbsd/src/share/man/man9/ioctl.9:187
#, no-wrap
msgid "'r'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:187
msgid "the routing subsystem"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:189
msgid "E<.Xr \\&md 4>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:189 org_netbsd/src/share/man/man9/ioctl.9:191
#, no-wrap
msgid "'R'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:191
msgid "E<.Xr isdnbchan 4>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:193
msgid "E<.Xr rnd 4>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:193 org_netbsd/src/share/man/man9/ioctl.9:195
#, no-wrap
msgid "'s'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:195
msgid "the socket layer"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:197
msgid "satlink devices"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:197 org_netbsd/src/share/man/man9/ioctl.9:199 org_netbsd/src/share/man/man9/ioctl.9:201 org_netbsd/src/share/man/man9/ioctl.9:203 org_netbsd/src/share/man/man9/ioctl.9:205
#, no-wrap
msgid "'S'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:199
msgid "SCSI disks (arc, hp300, pmax)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:201
msgid "watchdog devices (sh3)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:203
msgid "ISA speaker devices"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:205
msgid "stic devices"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:207
msgid "scanners"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:207
#, no-wrap
msgid "'t'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:209
msgid "the tty layer"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:209
#, no-wrap
msgid "'u'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:211
msgid "user defined ???"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:211
#, no-wrap
msgid "'U'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:214
msgid "scsibus (see E<.Xr scsi 4>)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:214
#, no-wrap
msgid "'v'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:217
msgid "Sun-compatible E<.Dq firm events>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:217 org_netbsd/src/share/man/man9/ioctl.9:219
#, no-wrap
msgid "'V'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:219
msgid "view device (amiga, atari)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:221
msgid "sram device (x68k)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:221
#, no-wrap
msgid "'w'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:223
msgid "watchdog devices"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:223 org_netbsd/src/share/man/man9/ioctl.9:225
#, no-wrap
msgid "'W'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:225
msgid "wt devices"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:227
msgid "wscons devices"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:227
#, no-wrap
msgid "'x'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:229
msgid "bt8xx devices"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:229 org_netbsd/src/share/man/man9/ioctl.9:231
#, no-wrap
msgid "'Z'"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:231
msgid "ite devices (amiga, atari, x68k)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:233
msgid "passthrough ioctls"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:234
#, no-wrap
msgid "Ar n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:241
msgid ""
"This numbers the ioctl within the group.  There may be only one E<.Ar n> for "
"a given E<.Ar t>.  This is an unsigned 8 bit number."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ioctl.9:241
#, no-wrap
msgid "Ar pt"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:246
msgid ""
"This specifies the type of the passed parameter.  This one gets internally "
"transformed to the size of the parameter, so for example, if you want to "
"pass a structure, then you have to specify that structure and not a pointer "
"to it or sizeof(struct foo)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:251
msgid ""
"In order for the new ioctl to be known to the system it is installed in "
"either \\*[Lt]sys/ioctl.h\\*[Gt] or one of the files that are reached from "
"\\*[Lt]sys/ioctl.h\\*[Gt]."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:260
msgid ""
"All ioctl() routines should return either 0 or a defined error code.  The "
"use of magic numbers such as -1, to indicate that a given ioctl code was not "
"handled is strongly discouraged.  The value -1 coincides with the historic "
"value for E<.Cm ERESTART> which was shown to produce user space code that "
"never returned from a call to E<.Xr ioctl 2>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:281
msgid ""
"For ioctl codes that are not handled by a given routine, the pseudo error "
"value E<.Cm EPASSTHROUGH> is provided.  E<.Cm EPASSTHROUGH> indicates that "
"no error occurred during processing (it did not fail), but neither was "
"anything processed (it did not succeed).  This supersedes the use of either "
"E<.Cm ENOTTY> (which is an explicit failure) or -1 (which has no contextual "
"meaning)  as a return value.  E<.Cm ENOTTY> will get passed directly back to "
"user space and bypass any further processing by other ioctl layers.  Only "
"code that wishes to suppress possible further processing of an ioctl code "
"(e.g., the tty line discipline code) should return E<.Cm ENOTTY>.  All other "
"code should return E<.Cm EPASSTHROUGH>, even if it knows that no other "
"layers will be called upon."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:290
msgid ""
"If the value E<.Cm EPASSTHROUGH> is returned to E<.Fn sys_ioctl>, then it "
"will there be changed to E<.Cm ENOTTY> to be returned to user space, thereby "
"providing the proper error notification to the application."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:293
#, no-wrap
msgid "#define\tFOOIOCTL\t_IOWR('i', 23, int)\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:296
#, no-wrap
msgid ""
"int a = 3;\n"
"error = ioctl(s, FOOICTL, \\*[Am]a);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:299
msgid "Within the ioctl()-routine of the driver, it can be then accessed like"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:304
#, no-wrap
msgid ""
"driver_ioctl(..., u_long cmd, void *data)\n"
"{\n"
"\t...\n"
"\tswitch (cmd) {\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:311
#, no-wrap
msgid ""
"\tcase FOOIOCTL:\n"
"\t\tint *a = (int *)data;\n"
"\t\tprintf(\" Value passed: %d\\en\", *a);\n"
"\t\tbreak;\n"
"\t}\n"
"}\n"
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/ioctl.9:312 org_netbsd/src/share/man/man9/kauth.9:1592 org_netbsd/src/share/man/man9/kmem.9:139 org_netbsd/src/share/man/man9/sysctl.9:619 org_netbsd/src/share/man/man9/uvm.9:587 org_netbsd/src/share/man/man9/xcall.9:93
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:318
msgid ""
"Note that if you for example try to read information from an ethernet driver "
"where the name of the card is included in the third argument (e.g., ioctl(s, "
"READFROMETH, struct ifreq *)), then you have to use the _IOWR() form not the "
"_IOR(), as passing the name of the card to the kernel already consists of "
"writing data."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ioctl.9:319
msgid "E<.Xr ioctl 2>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/ipkdb.9:30 org_netbsd/src/share/man/man9/sockopt.9:26
#, no-wrap
msgid "September 4, 2009"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/ipkdb.9:31
#, no-wrap
msgid "IPKDB 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:35
msgid "E<.Nm ipkdb>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/ipkdb.9:35
#, no-wrap
msgid "machine-dependent interface to ipkdb"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/ipkdb.9:37
#, no-wrap
msgid "ipkdb/ipkdb.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:56
msgid ""
"E<.Ft void> E<.Fn ipkdb_init \"void\"> E<.Ft void> E<.Fn ipkdb_connect \"int "
"when\"> E<.Ft int> E<.Fn ipkdbcmds \"void\"> E<.Ft void> E<.Fn ipkdbinit "
"\"void\"> E<.Ft void> E<.Fn ipkdb_trap \"void\"> E<.Ft int> E<.Fn ipkdb_poll "
"\"void\"> E<.Ft int> E<.Fn ipkdbif_init \"struct ipkdb_if *kip\"> E<.Ft int> "
"E<.Fn ipkdbfbyte \"u_char *c\"> E<.Ft int> E<.Fn ipkdbsbyte \"u_char *c\" "
"\"int i\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:59
msgid ""
"The machine-dependent code must support this interface for operation with "
"E<.Xr ipkdb 4>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:74
msgid ""
"During system bootstrap, machine-dependent code must invoke E<.Fn "
"ipkdb_init>.  If the kernel is booted with E<.Dv RB_KDB> set in E<.Va "
"boothowto> (see E<.Xr boothowto 9>), E<.Xr ipkdb 4> is enabled by invoking "
"E<.Fn ipkdb_connect>, setting the E<.Fa when> argument to 0."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:84
msgid ""
"E<.Fn ipkdbcmds> is invoked by machine-dependent code when the trap "
"mechanism determines that the debugger should be entered, i.e., on a single "
"step or breakpoint interrupt from kernel code.  The trapping mechanism "
"should already have stored the registers into the global area ipkdbregs.  "
"The layout of this area must be the same as that expected by E<.Xr gdb 1>.  "
"Valid return values are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ipkdb.9:86
#, no-wrap
msgid "Dv IPKDB_CMD_RUN"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:88
msgid "user wants to continue"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ipkdb.9:88
#, no-wrap
msgid "Dv IPKDB_CMD_STEP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:90
msgid "user wants to do single stepping"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ipkdb.9:90
#, no-wrap
msgid "Dv IPKDB_CMD_EXIT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:92
msgid "user has detached from debugging"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:96
msgid ""
"The machine-dependent code must provide the following functions for the "
"machine-independent code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ipkdb.9:97
#, no-wrap
msgid "Fn ipkdbinit \"\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:100
msgid ""
"This routine gets called when the debugger should be entered for the first "
"time."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ipkdb.9:100
#, no-wrap
msgid "Fn ipkdb_trap \"\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:108
msgid ""
"This routine is part of the trap handler.  Whenever a trap happens (e.g., "
"when hitting a breakpoint during debugging), E<.Fn ipkdb_trap> decides if "
"the Debugger needs to be called.  If there are other ways to decide that, "
"it's not necessary to provide an E<.Fn ipkdb_trap> implementation."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ipkdb.9:108
#, no-wrap
msgid "Fn ipkdb_poll \"\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:115
msgid ""
"This routine gets called after a panic to check for a key press by the "
"user.  If implemented it allows the user to press any key on the console to "
"do the automatic reboot after a panic.  Otherwise the debugging interface "
"will wait forever for some remote debugger to attach in case of a panic."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ipkdb.9:115
#, no-wrap
msgid "Fn ipkdbif_init kip"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:130
msgid ""
"In order to be able to find the debugging interface, the network driver must "
"invoke E<.Fn ipkdbif_init> with E<.Fa kip> specifying a E<.Fa struct "
"ipkdb_if> plus some additional parameters that allow it to access the "
"devices registers, hopefully using E<.Xr bus_space 9> methods.  In the E<.Fa "
"ipkdb_if> structure, the attach routine must initialize the following "
"fields:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ipkdb.9:132
#, no-wrap
msgid "myenetaddr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:134
msgid "fill this with the own ethernet address of the device/machine"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ipkdb.9:134
#, no-wrap
msgid "flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:138
msgid "mark at least E<.Dv IPKDB_MYHW> here"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ipkdb.9:138
#, no-wrap
msgid "name"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:140
msgid "name of the device, only used for a message"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ipkdb.9:140
#, no-wrap
msgid "start"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:144
msgid "routine called every time E<.Nm> is entered"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ipkdb.9:144
#, no-wrap
msgid "leave"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:148
msgid "routine called every time E<.Nm> is left"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ipkdb.9:148
#, no-wrap
msgid "receive"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:150
msgid "routine called to receive a packet"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ipkdb.9:150
#, no-wrap
msgid "send"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:152
msgid "routine called to send a packet"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:155
msgid "Additional fields that may be set are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ipkdb.9:157
#, no-wrap
msgid "myinetaddr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:161
msgid "fill this with the own internet address, and mark E<.Dv IPKDB_MYIP> in flags"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ipkdb.9:161
#, no-wrap
msgid "port"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:163
msgid "may be used as a pointer to some device"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ipkdb.9:164
#, no-wrap
msgid "Fn ipkdbfbyte c"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:169
msgid ""
"This routine should fetch a byte from address E<.Fa c>.  It must not enter "
"any trap handling code, but instead return \\-1 on inability to access the "
"data."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ipkdb.9:169
#, no-wrap
msgid "Fn ipkdbsbyte c i"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:177
msgid ""
"This routine should set the byte pointed to by E<.Fa c> to the value given "
"as E<.Fa i>.  The routine must not enter any trap handling code.  "
"Furthermore it should reset the modification bit in the relevant page table "
"entry to the value before the store."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ipkdb.9:180
msgid "E<.Xr ipkdb 4>, E<.Xr boothowto 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/isa.9:30
#, no-wrap
msgid "January 29, 2006"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/isa.9:31
#, no-wrap
msgid "ISA 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:57
msgid ""
"E<.Nm ISA>, E<.Nm isa_intr_alloc>, E<.Nm isa_intr_establish>, E<.Nm "
"isa_intr_disestablish>, E<.Nm isa_intr_evcnt>, E<.Nm isa_dmamap_create>, "
"E<.Nm isa_dmamap_destroy>, E<.Nm isa_dmamem_alloc>, E<.Nm isa_dmamem_free>, "
"E<.Nm isa_dmamem_map>, E<.Nm isa_dmamem_unmap>, E<.Nm isa_malloc>, E<.Nm "
"isa_free>, E<.Nm isa_dmastart>, E<.Nm isa_dmaabort>, E<.Nm isa_dmacount>, "
"E<.Nm isa_dmadone>, E<.Nm isa_dmamaxsize>, E<.Nm isa_drq_alloc>, E<.Nm "
"isa_drq_free>, E<.Nm isa_drq_isfree>, E<.Nm isa_dmacascade>, E<.Nm "
"isa_mappage>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/isa.9:57
#, no-wrap
msgid "Industry-standard Architecture"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/isa.9:60 org_netbsd/src/share/man/man9/isapnp.9:41
#, no-wrap
msgid "dev/isa/isareg.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/isa.9:61 org_netbsd/src/share/man/man9/isapnp.9:42
#, no-wrap
msgid "dev/isa/isavar.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:72
msgid ""
"E<.Ft int> E<.Fn isa_intr_alloc \"isa_chipset_tag_t ic\" \"int mask\" \"int "
"type\" \"int *irq\"> E<.Ft const struct evcnt *> E<.Fn isa_intr_evcnt "
"\"isa_chipset_tag_t ic\" \"int irq\"> E<.Ft void *> E<.Fn isa_intr_establish "
"\"isa_chipset_tag_t ic\" \"int irq\" \"int type\" \"int level\" \"int "
"(*handler)(void *)\" \"void *arg\"> E<.Ft void> E<.Fn isa_intr_disestablish "
"\"isa_chipset_tag_t ic\" \"void *ih\">"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/isa.9:72
#, no-wrap
msgid "dev/isa/isadmareg.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/isa.9:73
#, no-wrap
msgid "dev/isa/isadmavar.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:117
msgid ""
"E<.Ft int> E<.Fn isa_dmamap_create \"isa_chipset_tag_t ic\" \"int chan\" "
"\"bus_size_t size\" \"int flags\"> E<.Ft void> E<.Fn isa_dmamap_destroy "
"\"isa_chipset_tag_t ic\" \"int chan\"> E<.Ft int> E<.Fn isa_dmamem_alloc "
"\"isa_chipset_tag_t ic\" \"int chan\" \"bus_size_t size\" \"bus_addr_t "
"*addrp\" \"int flags\"> E<.Ft void> E<.Fn isa_dmamem_free "
"\"isa_chipset_tag_t ic\" \"int chan\" \"bus_addr_t addr\" \"bus_size_t "
"size\"> E<.Ft int> E<.Fn isa_dmamem_map \"isa_chipset_tag_t ic\" \"int "
"chan\" \"bus_addr_t addr\" \"bus_size_t size\" \"void **kvap\" \"int "
"flags\"> E<.Ft void> E<.Fn isa_dmamem_unmap \"isa_chipset_tag_t ic\" \"int "
"chan\" \"void *kva\" \"size_t size\"> E<.Ft void *> E<.Fn isa_malloc "
"\"isa_chipset_tag_t ic\" \"int chan\" \"size_t size\" \"int pool\" \"int "
"flags\"> E<.Ft void> E<.Fn isa_free \"void *addrp\" \"int pool\"> E<.Ft int> "
"E<.Fn isa_dmastart \"isa_chipset_tag_t ic\" \"int chan\" \"bus_addr_t addr\" "
"\"bus_size_t size\" \"struct lwp *lwp\" \"int flags\" \"int bf\"> E<.Ft "
"void> E<.Fn isa_dmaabort \"isa_chipset_tag_t ic\" \"int chan\"> E<.Ft "
"bus_size_t> E<.Fn isa_dmacount \"isa_chipset_tag_t ic\" \"int chan\"> E<.Ft "
"void> E<.Fn isa_dmadone \"isa_chipset_tag_t ic\" \"int chan\"> E<.Ft "
"bus_size_t> E<.Fn isa_dmamaxsize \"isa_chipset_tag_t ic\" \"int chan\"> "
"E<.Ft int> E<.Fn isa_drq_alloc \"isa_chipset_tag_t ic\" \"int chan\"> E<.Ft "
"int> E<.Fn isa_drq_free \"isa_chipset_tag_t ic\" \"int chan\"> E<.Ft int> "
"E<.Fn isa_drq_isfree \"isa_chipset_tag_t ic\" \"int chan\"> E<.Ft int> E<.Fn "
"isa_dmacascade \"isa_chipset_tag_t ic\" \"int chan\"> E<.Ft paddr_t> E<.Fn "
"isa_mappage \"void *mem\" \"off_t offset\" \"int prot\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:121
msgid "The machine-independent E<.Nm> subsystem provides support for the ISA bus."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:127
msgid ""
"The ISA bus was introduced on the IBM PC/AT.  It is an extension to the "
"original bus found on the original IBM PC.  The ISA bus is essentially the "
"host bus of the Intel 80286 processor, however the widespread acceptance of "
"the bus as a de facto standard has seen it appear on systems without Intel "
"processors."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:134
msgid ""
"The ISA bus has a 16-bit data bus, a 24-bit memory address bus, a 16-bit I/O "
"address bus, and operates at 8MHz.  It provides 15 interrupt lines and 8 DMA "
"channels supporting DMA transfers of 64KB or 128KB transfers depending on "
"the width of the channel being used.  Historically, some devices only "
"decoded the 10 lowest bits of the I/O address bus, preventing use of the "
"full 16-bit address space."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:138
msgid ""
"On newer machines, the ISA bus is no longer connected directly to the host "
"bus, and is usually connected via a PCI-ISA bridge.  Either way, the bus "
"looks the same to the device driver."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:142
msgid ""
"Drivers for devices attached to the E<.Nm> bus will make use of the "
"following data types:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:143
#, no-wrap
msgid "Fa isa_chipset_tag_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:145
msgid "Chipset tag for the ISA bus."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:145
#, no-wrap
msgid "Fa struct isa_attach_args"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:148
msgid ""
"Location hints for devices are recorded in this structure.  It contains the "
"following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:161
#, no-wrap
msgid ""
"\tbus_space_tag_t ia_iot;\t\t/* isa i/o space tag */\n"
"\tbus_space_tag_t ia_memt;\t/* isa mem space tag */\n"
"\tbus_dma_tag_t ia_dmat;\t\t/* DMA tag */\n"
"\tisa_chipset_tag_t ia_ic;\n"
"\tint ia_iobase;\t\t\t/* base i/o address */\n"
"\tint ia_iosize;\t\t\t/* span of ports used */\n"
"\tint ia_maddr;\t\t\t/* physical mem addr */\n"
"\tu_int ia_msize;\t\t\t/* size of memory */\n"
"\tint ia_irq;\t\t\t/* interrupt request */\n"
"\tint ia_drq;\t\t\t/* DMA request */\n"
"\tint ia_drq2;\t\t\t/* second DMA request */\n"
"\tvoid *ia_aux;\t\t\t/* driver specific */\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:165
#, no-wrap
msgid "Fn isa_intr_alloc ic mask type irq"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:168
msgid ""
"This function is generally not required by device drivers.  It is used by "
"bridges attaching other busses to the ISA bus."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:168
#, no-wrap
msgid "Fn isa_intr_evcnt ic irq"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:171
msgid "Returns the event counter associated with interrupt line E<.Fa irq>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:171
#, no-wrap
msgid "Fn isa_intr_establish ic irq type level handler arg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:187
msgid ""
"To establish an ISA interrupt handler, a driver calls E<.Fn "
"isa_intr_establish> with the interrupt number E<.Fa irq>, type E<.Fa type>, "
"and level E<.Fa level>.  When the interrupt occurs the function E<.Fa "
"handler> is called with argument E<.Fa arg>.  Valid values for E<.Fa type> "
"are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:188
#, no-wrap
msgid "IST_NONE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:190
msgid "Reserve interrupt, but don't actually establish."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:190
#, no-wrap
msgid "IST_EDGE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:192
msgid "Edge-triggered interrupt."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:192
#, no-wrap
msgid "IST_LEVEL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:194
msgid "Level-triggered interrupt."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:194
#, no-wrap
msgid "IST_PULSE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:196
msgid "Pulse-triggered interrupt."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:201
msgid ""
"E<.Fn isa_intr_establish> returns an opaque handle to an event descriptor if "
"it succeeds, and returns NULL on failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:202
#, no-wrap
msgid "Fn isa_intr_disestablish ic ih"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:207
msgid ""
"Dis-establish the interrupt handler with handle E<.Fa ih>.  The handle was "
"returned from E<.Fn isa_intr_establish>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:207
#, no-wrap
msgid "Fn isa_drq_alloc ic chan"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:216
msgid ""
"Reserves the DMA channel E<.Fa chan> for future use.  Normally, this call "
"precedes an E<.Fn isa_dmamap_create> call.  It is an error to start DMA on a "
"channel that has not been reserved with E<.Fn isa_drq_alloc>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:216
#, no-wrap
msgid "Fn isa_drq_free ic chan"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:220
msgid "Marks the DMA channel E<.Fa chan> as available again."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:220
#, no-wrap
msgid "Fn isa_dmamap_create ic chan size flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:232
msgid ""
"Creates a DMA map for channel E<.Fa chan>.  It is initialised to accept "
"maximum DMA transfers of size E<.Fa size>.  Valid values for the E<.Fa "
"flags> argument are the same as for E<.Fn bus_dmamap_create> (see E<.Xr "
"bus_dma 9>).  This function returns zero on success or an error value on "
"failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:232
#, no-wrap
msgid "Fn isa_dmamap_destroy ic chan"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:235
msgid "Destroy the DMA map for DMA channel E<.Fa chan>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:235
#, no-wrap
msgid "Fn isa_dmamem_alloc ic chan size addrp flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:249
msgid ""
"Allocate DMA-safe memory of size E<.Fa size> for channel E<.Fa chan>.  Valid "
"values for the E<.Fa flags> argument are the same as for E<.Fn "
"bus_dmamem_alloc> (see E<.Xr bus_dma 9>).  The bus-address of the memory is "
"returned in E<.Fa addrp>.  This function returns zero on success or an error "
"value on failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:249
#, no-wrap
msgid "Fn isa_dmamem_free ic chan addr size"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:259
msgid ""
"Frees memory previously allocated by E<.Fn isa_dmamem_alloc> for channel "
"E<.Fa chan>.  The bus-address and size of the memory are specified by E<.Fa "
"addr> and E<.Fa size> respectively."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:259
#, no-wrap
msgid "Fn isa_dmamem_map ic chan addr size kvap flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:277
msgid ""
"Maps DMA-safe memory (allocated with E<.Fn isa_dmamem_alloc>)  specified by "
"bus-address E<.Fa addr> and of size E<.Fa size> into kernel virtual address "
"space for DMA channel E<.Fa chan>.  Valid values for the E<.Fa flags> "
"argument are the same as for E<.Fn bus_dmamem_map> (see E<.Xr bus_dma 9>).  "
"The kernel virtual address is returned in E<.Fa kvap>.  This function "
"returns zero on success or an error value on failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:277
#, no-wrap
msgid "Fn isa_dmamem_unmap ic chan kva size"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:285
msgid ""
"Unmaps memory (previously mapped with E<.Fn isa_dmamem_map>)  of size E<.Fa "
"size> for channel E<.Fa chan>.  The kernel virtual address space used by the "
"mapping is freed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:285
#, no-wrap
msgid "Fn isa_malloc ic chan size pool flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:296
msgid ""
"This function is a shortcut for allocating and mapping DMA-safe memory in a "
"single step.  The arguments correspond with the arguments to E<.Fn "
"isa_dmamem_alloc> and E<.Fn isa_dmamem_map>.  The argument E<.Fa pool> is a "
"pool to record the memory allocation.  This function returns a pointer to "
"the DMA-safe memory."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:296
#, no-wrap
msgid "Fn isa_free addrp pool"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:311
msgid ""
"This function is a shortcut for unmapping and deallocating DMA-safe memory "
"in a single step.  It replaces E<.Fn isa_dmamem_unmap> and E<.Fn "
"isa_dmamem_free>.  The argument E<.Fa addrp> is the pointer to the DMA-safe "
"memory returned by E<.Fn isa_malloc>.  The argument E<.Fa pool> is the same "
"as the value passed to E<.Fn isa_malloc>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:311
#, no-wrap
msgid "Fn isa_dmastart ic chan addr size lwp flags bf"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:330
msgid ""
"Load DMA memory specified by address E<.Fa addr> of size E<.Fa size> into "
"the DMA controller at channel E<.Fa chan> and set it in motion.  The "
"argument E<.Fa lwp> is used to indicate the address space in which the "
"buffer is located.  If NULL, the buffer is assumed to be in kernel space.  "
"Otherwise, the buffer is assumed to be in lwp E<.Fa lwp 's> address space.  "
"The argument E<.Fa flags> describes the type of ISA DMA.  Valid values are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:331
#, no-wrap
msgid "DMAMODE_WRITE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:333
msgid "DMA transfer from host to device."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:333
#, no-wrap
msgid "DMAMODE_READ"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:335
msgid "DMA transfer to host from device."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:335
#, no-wrap
msgid "DMAMODE_SINGLE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:337
msgid "Transfer buffer once and stop."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:337
#, no-wrap
msgid "DMAMODE_DEMAND"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:339
msgid "Demand mode."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:339
#, no-wrap
msgid "DMAMODE_LOOP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:341
msgid "Transfer buffer continuously in loop until notified to stop."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:341
#, no-wrap
msgid "DMAMODE_LOOPDEMAND"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:343
msgid "Transfer buffer continuously in loop and demand mode."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:352
msgid ""
"The argument E<.Fa bf> is the bus-space flags.  Valid values are the same as "
"for E<.Fn bus_dmamap_load> (see E<.Xr bus_dma 9>)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:352
#, no-wrap
msgid "Fn isa_dmaabort ic chan"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:355
msgid "Abort a DMA transfer on channel E<.Fa chan>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:355
#, no-wrap
msgid "Fn isa_dmacount ic chan"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:359
msgid ""
"Returns the offset in the DMA memory of the current DMA transfer on channel "
"E<.Fa chan>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:359
#, no-wrap
msgid "Fn isa_dmadone ic chan"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:364
msgid ""
"Unloads the DMA memory on channel E<.Fa chan> after a DMA transfer has "
"completed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:364
#, no-wrap
msgid "Fn isa_dmamaxsize ic chan"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:367
msgid "Returns the maximum allowable DMA transfer size for channel E<.Fa chan>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:367
#, no-wrap
msgid "Fn isa_drq_isfree ic chan"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:380
msgid ""
"If the E<.Fa ia_drq> or E<.Fa ia_drq2> members of E<.Fa struct "
"isa_attach_args> are wildcarded, then the driver is expected to probe the "
"hardware for valid DMA channels.  In this case, the driver can check to see "
"if the hardware-supported DMA channel E<.Fa chan> is available for use."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:380
#, no-wrap
msgid "Fn isa_dmacascade ic chan"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:384
msgid ""
"Programs the 8237 DMA controller channel E<.Fa chan> to accept external DMA "
"control by the device hardware."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isa.9:384
#, no-wrap
msgid "Fn isa_mappage mem offset prot"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:388
msgid "Provides support for user E<.Xr mmap 2 Ns 'ing> of DMA-safe memory."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:414
msgid ""
"The ISA bus is an indirect-connection bus.  During autoconfiguration each "
"driver is required to probe the bus for the presence of a device.  An ISA "
"driver will receive a pointer to E<.Fa struct isa_attach_args> hinting at "
"\"locations\" on the ISA bus where the device may be located.  They should "
"use the E<.Em ia_iobase>, E<.Em ia_iosize>, E<.Em ia_maddr>, and E<.Em "
"ia_msize> members.  Not all of these hints will be necessary; locators may "
"be wildcarded with IOBASEUNK and MADDRUNK for E<.Em ia_iobase> and E<.Em "
"ia_maddr> respectively.  If a driver can probe the device for configuration "
"information at default locations, it may update the members of E<.Fa struct "
"isa_attach_args>.  The IRQ and DMA locators can also be wildcarded with "
"IRQUNK and DRQUNK respectively."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:418
msgid ""
"During the driver attach step, the I/O and memory address spaces should be "
"mapped (see E<.Xr bus_space 9>)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:428
msgid ""
"Extensive DMA facilities are provided for the ISA bus.  A driver can use up "
"to two DMA channels simultaneously.  The DMA channels allocated during "
"autoconfiguration are passed to the driver during the driver attach using "
"the E<.Fa ia_drq> and E<.Fa ia_drq2> members of E<.Fa struct "
"isa_attach_args>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:433
msgid ""
"Before allocating resources for DMA transfers on the ISA bus, a driver "
"should check the maximum allowable DMA transfer size for the DMA channel "
"using E<.Fn isa_dmamaxsize>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:445
msgid ""
"A DMA map should be created first using E<.Fn isa_dmamap_create>.  A DMA map "
"describes how DMA memory is loaded into the DMA controllers.  Only DMA-safe "
"memory can be used for DMA transfers.  DMA-safe memory is allocated using "
"E<.Fn isa_dmamem_alloc>.  The memory allocated by E<.Fn isa_dmamem_alloc> "
"must now be mapped into kernel virtual address space by E<.Fn "
"isa_dmamem_map> so that it can be accessed by the driver."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:457
msgid ""
"For a DMA transfer from the host to the device, the driver will fill the DMA "
"memory with the data to be transferred.  The DMA-transfer of the memory is "
"started using E<.Fn isa_dmastart> with E<.Fa flags> containing "
"DMAMODE_WRITE.  When the DMA transfer is completed, a call to E<.Fn "
"isa_dmadone> cleans up the DMA transfer by unloading the memory from the "
"controller."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:469
msgid ""
"For a DMA transfer from the device to the host, the DMA-transfer is started "
"using E<.Fn isa_dmastart> with E<.Fa flags> containing DMAMODE_READ.  When "
"the DMA transfer is completed, a call to E<.Fn isa_dmadone> cleans up the "
"DMA transfer by unloading the memory from the controller.  The memory can "
"now be access by the driver."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:476
msgid ""
"When the DMA resources are no longer required they should be released using "
"E<.Fn isa_dmamem_unmap>, E<.Fn isa_dmamem_free> and E<.Fn "
"isa_dmamap_destroy>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:481
msgid ""
"The ISA subsystem itself is implemented within the files E<.Pa "
"sys/dev/isa/isa.c> and E<.Pa sys/dev/isa/isadma.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:488
msgid ""
"E<.Xr isa 4>, E<.Xr autoconf 9>, E<.Xr bus_dma 9>, E<.Xr bus_space 9>, E<.Xr "
"driver 9>, E<.Xr isapnp 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:493
msgid "The machine-independent E<.Nm> subsystem appeared in E<.Nx 1.2>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isa.9:501
msgid ""
"The previous behaviour of E<.Fn isa_intr_establish> was to invoke E<.Fn "
"panic> on failure.  E<.Fn isa_intr_establish> now returns NULL on failure.  "
"Some old drivers written for the former behaviour discard the return value."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/isapnp.9:30
#, no-wrap
msgid "June 19, 2001"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/isapnp.9:31
#, no-wrap
msgid "ISAPNP 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:38
msgid ""
"E<.Nm ISAPNP>, E<.Nm isapnp_devmatch>, E<.Nm isapnp_config>, E<.Nm "
"isapnp_unconfig>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/isapnp.9:38
#, no-wrap
msgid "Plug 'n' Play ISA bus"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/isapnp.9:43
#, no-wrap
msgid "dev/isapnp/isapnpreg.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/isapnp.9:44
#, no-wrap
msgid "dev/isapnp/isapnpvar.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/isapnp.9:45
#, no-wrap
msgid "dev/isapnp/isapnpdevs.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:55
msgid ""
"E<.Ft int> E<.Fn isapnp_devmatch \"const struct isapnp_attach_args *ipa\" "
"\"const struct isapnp_devinfo *dinfo\" \"int *variant\"> E<.Ft int> E<.Fn "
"isapnp_config \"bus_space_tag_t iot\" \"bus_space_tag_t memt\" \"struct "
"isapnp_attach_args *ipa\"> E<.Ft void> E<.Fn isapnp_unconfig "
"\"bus_space_tag_t iot\" \"bus_space_tag_t memt\" \"struct isapnp_attach_args "
"*ipa\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:63
msgid ""
"The machine-independent E<.Nm> subsystem provides support for ISAPNP "
"devices.  ISAPNP devices were developed to support \"plug and play\" "
"connection on the ISA bus.  In all other aspects, the ISAPNP bus is same as "
"the ISA bus (see E<.Xr isa 9>)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:71
msgid ""
"Devices on the ISAPNP bus are uniquely identified by a 7-character string.  "
"Resources, such as I/O address space and interrupts, should be allocated to "
"the devices by the machine firmware.  On some machine the firmware seems "
"doesn't work correctly and E<.Nx> will attempt to allocate resources as "
"necessary."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:74
msgid ""
"Drivers attached to the ISAPNP bus will make use of the following data "
"types:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isapnp.9:75
#, no-wrap
msgid "Fa struct isapnp_matchinfo"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:81
msgid ""
"E<.Nx> kernel contains a database of known ISAPNP devices.  Each entry in "
"the database has a E<.Em struct isapnp_matchinfo>.  It contains the "
"following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:84
#, no-wrap
msgid ""
"\tconst char *name;\t\t/* device id string */\n"
"\tint variant;\t\t\t/* variant flag */\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isapnp.9:85
#, no-wrap
msgid "Fa struct isapnp_devinfo"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:91
msgid ""
"Defines the devices supported by a driver.  It contains pointer to an array "
"of supported E<.Em struct isapnp_matchinfo> structures and a pointer to "
"another array of compatibility devices.  It contains the following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:96
#, no-wrap
msgid ""
"\tstruct isapnp_matchinfo *devlogic;\n"
"\tint nlogic;\n"
"\tstruct isapnp_matchinfo *devcompat;\n"
"\tint ncompat;\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isapnp.9:97
#, no-wrap
msgid "Fa struct isapnp_region"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:100
msgid "Describes ISAPNP bus-space regions.  It contains the following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:104
#, no-wrap
msgid ""
"\tbus_space_handle_t h;\n"
"\tuint32_t base;\n"
"\tuint32_t length;\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isapnp.9:105
#, no-wrap
msgid "Fa struct isapnp_pin"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:109
msgid ""
"Describes the wiring of interrupts and DMA pins from the ISAPNP bus onto the "
"host processor.  It contains the following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:114
#, no-wrap
msgid ""
"\tuint8_t  num;\n"
"\tuint8_t  flags:4;\n"
"\tuint8_t  type:4;\n"
"\tuint16_t bits;\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isapnp.9:115
#, no-wrap
msgid "Fa struct isapnp_attach_args"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:118 org_netbsd/src/share/man/man9/pcmcia.9:196 org_netbsd/src/share/man/man9/vme.9:152
msgid ""
"A structure used to inform the driver of the device properties.  It contains "
"the following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:128
#, no-wrap
msgid ""
"\tbus_space_tag_t\tipa_iot;\t/* isa i/o space tag */\n"
"\tbus_space_tag_t\tipa_memt;\t/* isa mem space tag */\n"
"\tbus_dma_tag_t\tipa_dmat;\t/* isa dma tag */\n"
"\tisa_chipset_tag_t\tipa_ic;\n"
"\tstruct isapnp_region    ipa_io[ISAPNP_NUM_IO];\n"
"\tstruct isapnp_region    ipa_mem[ISAPNP_NUM_MEM];\n"
"\tstruct isapnp_region    ipa_mem32[ISAPNP_NUM_MEM32];\n"
"\tstruct isapnp_pin       ipa_irq[ISAPNP_NUM_IRQ];\n"
"\tstruct isapnp_pin       ipa_drq[ISAPNP_NUM_DRQ];\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isapnp.9:132
#, no-wrap
msgid "Fn isapnp_devmatch ipa dinfo variant"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:143
msgid ""
"Matches the device described by the attachment E<.Fa ipa> with the "
"device-match information in E<.Fa dinfo>.  If the device is matched, E<.Fn "
"isapnp_devmatch> returns a non-zero value and variant is the flag describing "
"the device variant.  E<.Fn isapnp_devmatch> returns zero if the device is "
"not found."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isapnp.9:143
#, no-wrap
msgid "Fn isapnp_config iot memt ipa"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:164
msgid ""
"Allocate device resources specified by E<.Fa ipa>.  The device is mapped "
"into the I/O and memory bus spaces specified by bus-space tags E<.Fa iot> "
"and E<.Fa memt> respectively.  The E<.Fa ipa_io>, E<.Fa ipa_mem>, E<.Fa "
"ipa_mem32>, E<.Fa ipa_irq>, and E<.Fa ipa_drq> members of E<.Fa ipa> are "
"updated to reflect the allocated and mapped resources.  E<.Fn isapnp_config> "
"returns zero on success and non-zero on error."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/isapnp.9:164
#, no-wrap
msgid "Fn isapnp_unconfig iot memt ipa"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:167
msgid "Free the resources allocated by E<.Fn isapnp_config>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:174
msgid ""
"During autoconfiguration, an ISAPNP driver will receive a pointer to E<.Fa "
"struct isapnp_attach_args> describing the device attached to the ISAPNP "
"bus.  Drivers match the device using E<.Fn ispnp_devmatch>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:191
msgid ""
"During the driver attach step, driver should initially allocate and map "
"resources using E<.Fn isapnp_config>.  The I/O (memory) bus-space resources "
"can be accessed using the bus-space tag E<.Fa ipa_iot> E<.Po> E<.Fa "
"ipa_memt> E<.Pc> and the bus-space handle E<.Fa ipa_io[0].h> E<.Po> E<.Fa "
"ipa_mem[0].h> E<.Pc> members of E<.Fa ipa>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:208
msgid ""
"Interrupts should be established using E<.Fn isa_intr_establish> E<.Po> see "
"E<.Xr isa 9> E<.Pc> with the IRQ specified by the E<.Fa ipa_irq[0].num> "
"member of E<.Fa ipa>.  Similarly, the standard E<.Xr isa 9> DMA interface "
"should be used with the E<.Fa ipa_drq[0].num> member of E<.Fa ipa>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:212
msgid ""
"Extensive DMA facilities are provided through the E<.Xr isa 9> DMA "
"facilities."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:224
msgid ""
"The E<.Nm> subsystem itself is implemented within the file E<.Pa "
"sys/dev/isapnp/isapnp.c>.  The database of the known devices exists within "
"the file E<.Pa sys/dev/isapnp/isapnpdevs.c> and is generated automatically "
"from the file E<.Pa sys/dev/isapnp/isapnpdevs>.  New devices should be added "
"to this file.  The database can be regenerated using the Makefile E<.Pa "
"sys/dev/isapnp/Makefile.isapnpdevs>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:237
msgid ""
"E<.Xr isa 4>, E<.Xr isapnp 4>, E<.Xr pnpbios 4>, E<.Xr autoconf 9>, E<.Xr "
"bus_dma 9>, E<.Xr bus_space 9>, E<.Xr driver 9>, E<.Xr isa 9> E<.Rs> E<.%T "
"\"Plug and Play ISA Specification V1.0a\"> E<.%D May 5 1994> E<.Re>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/isapnp.9:239
msgid "The machine-independent ISAPNP subsystem appear in E<.Nx 1.3>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/itimerfix.9:30
#, no-wrap
msgid "November 23, 2001"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/itimerfix.9:31
#, no-wrap
msgid "ITIMERFIX 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/itimerfix.9:35
msgid "E<.Nm itimerfix>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/itimerfix.9:35
#, no-wrap
msgid "check that a timeval value is valid, and correct"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/itimerfix.9:40
msgid "E<.Ft int> E<.Fn itimerfix \"struct timeval *tv\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/itimerfix.9:49
msgid ""
"The E<.Nm> function checks that the value in E<.Fa tv> is valid (0 \\*[Le] "
"tv-\\*[Gt]tv_sec \\*[Am]\\*[Am] 0 \\*[Le] tv-\\*[Gt]tv_usec \\*[Lt] "
"1000000), and that the total time represented is at least one E<.Em tick>, "
"or zero."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/itimerfix.9:52
msgid ""
"If the total represented time is nonzero and smaller than tick, it is "
"adjusted to exactly one tick."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/itimerfix.9:59
msgid "E<.Nm> returns 0 on success or E<.Er EINVAL> if E<.Fa tv> is invalid."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/itimerfix.9:63
msgid "E<.Xr nanosleep 2>, E<.Xr poll 2>, E<.Xr select 2>, E<.Xr setitimer 2>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/kauth.9:28 org_netbsd/src/share/man/man9/secmodel_securelevel.9:29
#, no-wrap
msgid "January 16, 2012"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/kauth.9:29
#, no-wrap
msgid "KAUTH 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:33
msgid "E<.Nm kauth>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/kauth.9:33
#, no-wrap
msgid "kernel authorization framework"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/kauth.9:35
#, no-wrap
msgid "sys/kauth.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:43
msgid ""
"E<.Nm>, or kernel authorization, is the subsystem managing all authorization "
"requests inside the kernel.  It manages user credentials and rights, and can "
"be used to implement a system-wide security policy.  It allows external "
"modules to plug-in the authorization process."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:51
msgid ""
"E<.Nm> introduces some new concepts, namely E<.Dq scopes> and E<.Dq "
"listeners>, which will be detailed together with other useful information "
"for kernel developers in this document."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/kauth.9:51
#, no-wrap
msgid "Types"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:55
msgid "Some E<.Nm> types include the following:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:56
#, no-wrap
msgid "kauth_cred_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:60
msgid ""
"Representing credentials that can be associated with an object.  Includes "
"user- and group-ids (real, effective, and save) as well as group membership "
"information."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:60
#, no-wrap
msgid "kauth_scope_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:62
msgid "Describes a scope."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:62
#, no-wrap
msgid "kauth_listener_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:64
msgid "Describes a listener."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/kauth.9:65
#, no-wrap
msgid "Terminology"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:71
msgid ""
"E<.Nm> operates in various E<.Dq scopes>, each scope holding a group of "
"E<.Dq listeners>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:77
msgid ""
"Each listener works as a callback for when an authorization request within "
"the scope is made.  When such a request is made, all listeners on the scope "
"are passed common information such as the credentials of the request "
"context, an identifier for the requested operation, and possibly other "
"information as well."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:81
msgid ""
"Every listener examines the passed information and returns its decision "
"regarding the requested operation.  It can either return:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:83
#, no-wrap
msgid "Dv KAUTH_RESULT_ALLOW"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:85
msgid "The listener allows the operation."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:85
#, no-wrap
msgid "Dv KAUTH_RESULT_DENY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:87
msgid "The listener denies the operation."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:87
#, no-wrap
msgid "Dv KAUTH_RESULT_DEFER"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:89
msgid "The listener defers the decision to other listeners."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:95
msgid ""
"For an operation to be allowed, at least one listener has to return E<.Dv "
"KAUTH_RESULT_ALLOW> while no other listener returned E<.Dv "
"KAUTH_RESULT_DENY>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:97
msgid "Scopes manage listeners that operate in the same aspect of the system."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/kauth.9:97
#, no-wrap
msgid "Kernel Programming Interface"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:104
msgid ""
"E<.Nm> exports a KPI that allows developers both of E<.Nx> and third-party "
"products to authorize requests, access and modify credentials, create and "
"remove scopes and listeners, and perform other miscellaneous operations on "
"credentials."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/kauth.9:104
#, no-wrap
msgid "Authorization Requests"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:111
msgid ""
"E<.Nm> provides a single authorization request routine, which all "
"authorization requests go through.  This routine dispatches the request to "
"the listeners of the appropriate scope, together with four optional "
"user-data variables, and returns the augmented result."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:113
msgid "It is declared as"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:116
msgid ""
"E<.Ft int Fn kauth_authorize_action \"kauth_scope_t scope\" \"kauth_cred_t "
"cred\" \"kauth_action_t op\" \"void *arg0\" \"void *arg1\" \"void *arg2\" "
"\"void *arg3\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:118
msgid "An authorization request can return one of two possible values:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:119
#, no-wrap
msgid "Dv 0 Po zero Pc"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:121
msgid "indicates success; operation is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:121
#, no-wrap
msgid "Dv EPERM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:125
msgid "indicates failure; operation is denied.  See E<.Xr errno 2>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:130
msgid ""
"Each scope has its own authorization wrapper, to make it easy to call from "
"various places by eliminating the need to specify the scope and/or cast "
"values.  The authorization wrappers are detailed in each scope's section."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:140
msgid ""
"E<.Fn kauth_authorize_action> has several special cases, when it will always "
"allow the request.  These are for when the request is issued by the kernel "
"itself (indicated by the credentials being either E<.Dv NOCRED> or E<.Dv "
"FSCRED>), or when there was no definitive decision from any of the listeners "
"(i.e., it was not explicitly allowed or denied) and no security model was "
"loaded."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/kauth.9:140
#, no-wrap
msgid "Generic Scope"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:144
msgid ""
"The generic scope, E<.Dq org.netbsd.kauth.generic>, manages generic "
"authorization requests in the kernel."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:146 org_netbsd/src/share/man/man9/kauth.9:165 org_netbsd/src/share/man/man9/kauth.9:396 org_netbsd/src/share/man/man9/kauth.9:552 org_netbsd/src/share/man/man9/kauth.9:764
msgid "The authorization wrapper for this scope is declared as"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:149
msgid ""
"E<.Ft int Fn kauth_authorize_generic \"kauth_cred_t cred\" \"kauth_action_t "
"op\" \"void *arg0\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:151 org_netbsd/src/share/man/man9/kauth.9:402 org_netbsd/src/share/man/man9/kauth.9:557
msgid "The following operations are available for this scope:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:152
#, no-wrap
msgid "Dv KAUTH_GENERIC_ISSUSER"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:154
msgid "Checks whether the credentials belong to the super-user."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:158
msgid ""
"Using this request is strongly discouraged and should only be done as a "
"temporary place-holder, as it is breaking the separation between the "
"interface for authorization requests from the back-end implementation."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/kauth.9:159
#, no-wrap
msgid "System Scope"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:163
msgid ""
"The system scope, E<.Dq org.netbsd.kauth.system>, manages authorization "
"requests affecting the entire system."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:169
msgid ""
"E<.Ft int Fn kauth_authorize_system \"kauth_cred_t cred\" \"kauth_action_t "
"op\" \"enum kauth_system_req req\" \"void *arg1\" \"void *arg2\" \"void "
"*arg3\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:171
msgid "The following requests are available for this scope:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:172
#, no-wrap
msgid "Dv KAUTH_SYSTEM_ACCOUNTING"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:174
msgid "Check if enabling/disabling accounting allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:174
#, no-wrap
msgid "Dv KAUTH_SYSTEM_CHROOT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:177 org_netbsd/src/share/man/man9/kauth.9:192 org_netbsd/src/share/man/man9/kauth.9:251 org_netbsd/src/share/man/man9/kauth.9:305 org_netbsd/src/share/man/man9/kauth.9:697
msgid "E<.Ar req> can be any of the following:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:178
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_CHROOT_CHROOT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:182
msgid "Check if calling E<.Xr chroot 2> is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:182
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_CHROOT_FCHROOT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:186
msgid "Check if calling E<.Xr fchroot 2> is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:187
#, no-wrap
msgid "Dv KAUTH_SYSTEM_CPU"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:189
msgid "Check CPU-manipulation access."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:193
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_CPU_SETSTATE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:195
msgid "Set CPU state, including setting it online or offline."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:196
#, no-wrap
msgid "Dv KAUTH_SYSTEM_DEBUG"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:200
msgid ""
"This request concentrates several debugging-related operations.  E<.Ar req> "
"can be any of the following:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:201
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_DEBUG_IPKDB"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:205
msgid "Check if using E<.Xr ipkdb 4> is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:206
#, no-wrap
msgid "Dv KAUTH_SYSTEM_FILEHANDLE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:208
msgid "Check if filehandle operations allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:208
#, no-wrap
msgid "Dv KAUTH_SYSTEM_FS_QUOTA"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:210
msgid "Check if file-system quota operations are allowed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:217
msgid ""
"E<.Ar arg1> is a E<.Ft struct mount *> describing the file-system mount in "
"question.  E<.Ar req> can be one of the following:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:218
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_FS_QUOTA_GET"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:220
msgid "Check if retrieving quota information is allowed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:225
msgid ""
"E<.Ar arg2> is a E<.Ft uid_t> with the user-id of the user whose quota "
"information is to be retrieved."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:225
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_FS_QUOTA_ONOFF"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:227
msgid "Check if turning quota on/off is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:227
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_FS_QUOTA_MANAGE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:229
msgid "Check if managing the quota by setting the quota/quota use is allowed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:234
msgid ""
"E<.Ar arg2> is a E<.Ft uid_t> with the user-id of the user whose quota/quota "
"use is to be set."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:234
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_FS_QUOTA_NOLIMIT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:236
msgid "Check if bypassing the quota (not enforcing it) is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:237
#, no-wrap
msgid "Dv KAUTH_SYSTEM_FS_RESERVEDSPACE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:239
msgid "Check if using the file-system reserved space is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:239
#, no-wrap
msgid "Dv KAUTH_SYSTEM_MODULE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:241
msgid "Check if a module request is allowed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:244
msgid "E<.Ar arg1> is the command."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:244
#, no-wrap
msgid "Dv KAUTH_SYSTEM_MKNOD"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:246
msgid "Check if creating devices is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:246
#, no-wrap
msgid "Dv KAUTH_SYSTEM_MOUNT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:248
msgid "Check if mount-related operations are allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:252
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_MOUNT_GET"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:262
msgid ""
"Check if retrieving information about a mount is allowed.  E<.Ar arg1> is a "
"E<.Ft struct mount *> with the mount structure in question, E<.Ar arg2> is a "
"E<.Ft void *> with file-system specific data, if any."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:262
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_MOUNT_NEW"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:264
msgid "Check if mounting a new file-system is allowed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:277
msgid ""
"E<.Ar arg1> is the E<.Ft struct vnode *> on which the file-system is to be "
"mounted, E<.Ar arg2> is an E<.Ft int> with the mount flags, and E<.Ar arg3> "
"is a E<.Ft void *> with file-system specific data, if any."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:277
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_MOUNT_UNMOUNT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:279
msgid "Checks if unmounting a file-system is allowed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:284
msgid "E<.Ar arg1> is a E<.Ft struct mount *> with the mount in question."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:284
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_MOUNT_UPDATE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:286
msgid "Checks if updating an existing mount is allowed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:299
msgid ""
"E<.Ar arg1> is the E<.Ft struct mount *> of the existing mount, E<.Ar arg2> "
"is an E<.Ft int> with the new mount flags, and E<.Ar arg3> is a E<.Ft void "
"*> with file-system specific data, if any."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:300
#, no-wrap
msgid "Dv KAUTH_SYSTEM_PSET"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:302
msgid "Check processor-set manipulation."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:306
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_PSET_ASSIGN"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:308
msgid "Change processor-set processor assignment."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:308
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_PSET_BIND"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:310
msgid "Bind an LWP to a processor-set."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:310
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_PSET_CREATE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:312
msgid "Create a processor-set."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:312
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_PSET_DESTROY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:314
msgid "Destroy a processor-set."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:315
#, no-wrap
msgid "Dv KAUTH_SYSTEM_REBOOT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:317
msgid "Check if rebooting is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:317
#, no-wrap
msgid "Dv KAUTH_SYSTEM_SETIDCORE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:319
msgid "Check if changing coredump settings for set-id processes is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:319
#, no-wrap
msgid "Dv KAUTH_SYSTEM_SWAPCTL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:323
msgid "Check if privileged E<.Xr swapctl 2> requests are allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:323
#, no-wrap
msgid "Dv KAUTH_SYSTEM_SYSCTL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:328
msgid ""
"This requests operations related to E<.Xr sysctl 9>.  E<.Ar req> indicates "
"the specific request and can be one of the following:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:329
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_SYSCTL_ADD"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:333
msgid "Check if adding a E<.Xr sysctl 9> node is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:333
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_SYSCTL_DELETE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:337
msgid "Check if deleting a E<.Xr sysctl 9> node is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:337
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_SYSCTL_DESC"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:341
msgid "Check if adding description to a E<.Xr sysctl 9> node is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:341
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_SYSCTL_MODIFY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:345
msgid ""
"Check if modifying a E<.Xr sysctl 9> node variable that doesn't have a "
"custom sysctl helper function is allowed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:347
msgid "This request might be deprecated in the future."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:347
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_SYSCTL_PRVT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:351
msgid "Check if accessing private E<.Xr sysctl 9> nodes is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:352
#, no-wrap
msgid "Dv KAUTH_SYSTEM_TIME"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:356
msgid ""
"This request groups time-related operations.  E<.Ar req> can be any of the "
"following:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:357
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_TIME_ADJTIME"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:361
msgid "Check if changing the time using E<.Xr adjtime 2> is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:361
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_TIME_NTPADJTIME"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:365
msgid "Check if setting the time using E<.Xr ntp_adjtime 2> is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:365
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_TIME_SYSTEM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:369
msgid "Check if changing the time (usually via E<.Xr settimeofday 2>)  is allowed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:384
msgid ""
"E<.Ar arg1> is a E<.Ft struct timespec *> with the new time, E<.Ar arg2> is "
"a E<.Ft struct timeval *> with the delta from the current time, E<.Ar arg3> "
"is a E<.Ft bool> indicating whether the caller is a device context (e.g.  "
"E<.Pa /dev/clockctl>)  or not."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:384
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_TIME_RTCOFFSET"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:386
msgid "Check if changing the RTC offset is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:386
#, no-wrap
msgid "Dv KAUTH_REQ_SYSTEM_TIME_TIMECOUNTERS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:388
msgid "Check if manipulating timecounters is allowed."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/kauth.9:390
#, no-wrap
msgid "Process Scope"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:394
msgid ""
"The process scope, E<.Dq org.netbsd.kauth.process>, manages authorization "
"requests related to processes in the system."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:400
msgid ""
"E<.Ft int Fn kauth_authorize_process \"kauth_cred_t cred\" \"kauth_action_t "
"op\" \"struct proc *p\" \"void *arg1\" \"void *arg2\" \"void *arg3\">"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:403
#, no-wrap
msgid "Dv KAUTH_PROCESS_KTRACE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:409
msgid ""
"Checks whether an object with one set of credentials can E<.Xr ktrace 1> "
"another process E<.Ar p>, possibly with a different set of credentials."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:418
msgid ""
"If E<.Ar arg1> is E<.Dv KAUTH_REQ_PROCESS_KTRACE_PERSISTENT>, this checks if "
"persistent tracing can be done.  Persistent tracing maintains the trace "
"across a set-user-id/set-group-id E<.Xr exec 3>, and normally requires "
"privileged credentials."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:418
#, no-wrap
msgid "Dv KAUTH_PROCESS_PROCFS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:423
msgid ""
"Checks whether object with passed credentials can use E<.Em procfs> to "
"access process E<.Ar p>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:442
msgid ""
"E<.Ar arg1> is the E<.Ft struct pfsnode *> for the target element in the "
"target process, and E<.Ar arg2> is the access type, which can be either "
"E<.Dv KAUTH_REQ_PROCESS_PROCFS_CTL>, E<.Dv KAUTH_REQ_PROCESS_PROCFS_READ>, "
"E<.Dv KAUTH_REQ_PROCESS_PROCFS_RW>, or E<.Dv "
"KAUTH_REQ_PROCESS_PROCFS_WRITE>, indicating E<.Em control>, E<.Em read>, "
"E<.Em read-write>, or E<.Em write> access respectively."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:442
#, no-wrap
msgid "Dv KAUTH_PROCESS_PTRACE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:447
msgid ""
"Checks whether object with passed credentials can use E<.Xr ptrace 2> to "
"access process E<.Ar p>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:452
msgid "E<.Ar arg1> is the E<.Xr ptrace 2> command."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:452
#, no-wrap
msgid "Dv KAUTH_PROCESS_CANSEE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:456
msgid ""
"Checks whether an object with one set of credentials can access information "
"about another process, possibly with a different set of credentials."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:464
msgid ""
"E<.Ar arg1> indicates the class of information being viewed, and can be "
"either of E<.Dv KAUTH_REQ_PROCESS_CANSEE_ARGS>, E<.Dv "
"KAUTH_REQ_PROCESS_CANSEE_ENTRY>, E<.Dv KAUTH_REQ_PROCESS_CANSEE_ENV>, or "
"E<.Dv KAUTH_REQ_PROCESS_CANSEE_OPENFILES>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:464
#, no-wrap
msgid "Dv KAUTH_PROCESS_SCHEDULER_GETAFFINITY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:466
msgid "Checks whether viewing the scheduler affinity is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:466
#, no-wrap
msgid "Dv KAUTH_PROCESS_SCHEDULER_SETAFFINITY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:468
msgid "Checks whether setting the scheduler affinity is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:468
#, no-wrap
msgid "Dv KAUTH_PROCESS_SCHEDULER_GETPARAM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:470
msgid "Checks whether viewing the scheduler policy and parameters is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:470
#, no-wrap
msgid "Dv KAUTH_PROCESS_SCHEDULER_SETPARAM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:472
msgid "Checks whether modifying the scheduler policy and parameters is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:472
#, no-wrap
msgid "Dv KAUTH_PROCESS_SIGNAL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:475
msgid ""
"Checks whether an object with one set of credentials can post signals to "
"another process."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:480
msgid ""
"E<.Ar p> is the process the signal is being posted to, and E<.Ar arg1> is "
"the signal number."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:480
#, no-wrap
msgid "Dv KAUTH_PROCESS_CORENAME"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:482
msgid "Controls access to process corename."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:489
msgid ""
"E<.Ar arg1> can be E<.Dv KAUTH_REQ_PROCESS_CORENAME_GET> or E<.Dv "
"KAUTH_REQ_PROCESS_CORENAME_SET>, indicating access to read or write the "
"process' corename, respectively."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:493
msgid "When modifying the corename, E<.Ar arg2> holds the new corename to be used."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:493
#, no-wrap
msgid "Dv KAUTH_PROCESS_FORK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:499
msgid ""
"Checks if the process can fork.  E<.Ar arg1> is an E<.Ft int> indicating how "
"many processes exist on the system at the time of the check."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:499
#, no-wrap
msgid "Dv KAUTH_PROCESS_KEVENT_FILTER"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:503
msgid "Checks whether setting a process E<.Xr kevent 2> filter is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:504
#, no-wrap
msgid "Dv KAUTH_PROCESS_NICE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:511
msgid ""
"Checks whether the E<.Em nice> value of E<.Ar p> can be changed to E<.Ar "
"arg1>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:511
#, no-wrap
msgid "Dv KAUTH_PROCESS_RLIMIT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:513
msgid "Controls access to process resource limits."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:520
msgid ""
"E<.Ar arg1> can be E<.Dv KAUTH_REQ_PROCESS_RLIMIT_GET> or E<.Dv "
"KAUTH_REQ_PROCESS_RLIMIT_SET>, indicating access to read or write the "
"process' resource limits, respectively."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:526
msgid ""
"When modifying resource limits, E<.Ar arg2> is the new value to be used and "
"E<.Ar arg3> indicates which resource limit is to be modified."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:526
#, no-wrap
msgid "Dv KAUTH_PROCESS_SETID"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:530
msgid ""
"Check if changing the user- or group-ids, groups, or login-name for E<.Ar p> "
"is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:530
#, no-wrap
msgid "Dv KAUTH_PROCESS_STOPFLAG"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:537
msgid ""
"Check if setting the stop flags for E<.Xr exec 3>, E<.Xr exit 3>, and E<.Xr "
"fork 2> is allowed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:545
msgid ""
"E<.Ar arg1> indicates the flag, and can be either E<.Dv P_STOPEXEC>, E<.Dv "
"P_STOPEXIT>, or E<.Dv P_STOPFORK> respectively."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/kauth.9:546
#, no-wrap
msgid "Network Scope"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:550
msgid ""
"The network scope, E<.Dq org.netbsd.kauth.network>, manages "
"networking-related authorization requests in the kernel."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:555
msgid ""
"E<.Ft int Fn kauth_authorize_network \"kauth_cred_t cred\" \"kauth_action_t "
"op\" \"enum kauth_network_req req\" \"void *arg1\" \"void *arg2\" \"void "
"*arg3\">"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:558
#, no-wrap
msgid "Dv KAUTH_NETWORK_ALTQ"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:560
msgid "Checks if an ALTQ operation is allowed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:563
msgid ""
"E<.Ar req> indicates the ALTQ subsystem in question, and can be one of the "
"following:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:565
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_ALTQ_AFMAP"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:566
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_ALTQ_BLUE"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:567
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_ALTQ_CBQ"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:568
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_ALTQ_CDNR"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:569
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_ALTQ_CONF"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:570
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_ALTQ_FIFOQ"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:571
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_ALTQ_HFSC"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:572
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_ALTQ_JOBS"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:573
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_ALTQ_PRIQ"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:574
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_ALTQ_RED"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:575
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_ALTQ_RIO"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:576
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_ALTQ_WFQ"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:578
#, no-wrap
msgid "Dv KAUTH_NETWORK_BIND"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:582
msgid "Checks if a E<.Xr bind 2> request is allowed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:587 org_netbsd/src/share/man/man9/kauth.9:719
msgid ""
"E<.Ar req> allows to indicate the type of the request to structure listeners "
"and callers easier.  Supported request types:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:588
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_BIND_PORT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:590
msgid "Checks if binding to a non-privileged/reserved port is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:590
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_BIND_PRIVPORT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:592
msgid "Checks if binding to a privileged/reserved port is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:593
#, no-wrap
msgid "Dv KAUTH_NETWORK_FIREWALL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:595
msgid "Checks if firewall-related operations are allowed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:598
msgid "E<.Ar req> indicates the sub-action, and can be one of the following:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:599
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_FIREWALL_FW"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:601
msgid "Modification of packet filtering rules."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:601
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_FIREWALL_NAT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:603
msgid "Modification of NAT rules."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:604
#, no-wrap
msgid "Dv KAUTH_NETWORK_INTERFACE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:606
msgid "Checks if network interface-related operations are allowed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:619
msgid ""
"E<.Ar arg1> is (optionally) the E<.Ft struct ifnet *> associated with the "
"interface.  E<.Ar arg2> is (optionally) an E<.Ft int> describing the "
"interface-specific operation.  E<.Ar arg3> is (optionally) a pointer to the "
"interface-specific request structure.  E<.Ar req> indicates the sub-action, "
"and can be one of the following:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:620
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_INTERFACE_GET"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:622
msgid "Check if retrieving information from the device is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:622
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_INTERFACE_GETPRIV"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:624
msgid "Check if retrieving privileged information from the device is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:624
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_INTERFACE_SET"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:626
msgid "Check if setting parameters on the device is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:626
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_INTERFACE_SETPRIV"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:628
msgid "Check if setting privileged parameters on the device is allowed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:637
msgid ""
"Note that unless the E<.Ft struct ifnet *> for the interface was passed in "
"E<.Ar arg1>, there's no way to tell what structure E<.Ar arg3> is."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:637
#, no-wrap
msgid "Dv KAUTH_NETWORK_INTERFACE_PPP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:641
msgid ""
"Checks if operations performed on the E<.Xr ppp 4> network interface are "
"allowed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:644 org_netbsd/src/share/man/man9/kauth.9:657 org_netbsd/src/share/man/man9/kauth.9:670 org_netbsd/src/share/man/man9/kauth.9:683
msgid "E<.Ar req> can be one of the following:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:645
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_INTERFACE_PPP_ADD"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:649
msgid ""
"Checks if adding and enabling a E<.Xr ppp 4> interface to the system is "
"allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:650
#, no-wrap
msgid "Dv KAUTH_NETWORK_INTERFACE_SLIP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:654
msgid ""
"Checks if operations performed on the E<.Xr sl 4> network interface are "
"allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:658
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_INTERFACE_SLIP_ADD"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:662
msgid ""
"Checks if adding and enabling a E<.Xr sl 4> interface to the system is "
"allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:663
#, no-wrap
msgid "Dv KAUTH_NETWORK_INTERFACE_STRIP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:667
msgid ""
"Checks if operations performed on the E<.Xr strip 4> network interface are "
"allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:671
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_INTERFACE_STRIP_ADD"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:675
msgid ""
"Check if adding and enabling a E<.Xr strip 4> interface to the system is "
"allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:676
#, no-wrap
msgid "Dv KAUTH_NETWORK_INTERFACE_TUN"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:680
msgid ""
"Checks if operations performed on the E<.Xr tun 4> network interface are "
"allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:684
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_INTERFACE_TUN_ADD"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:688
msgid ""
"Checks if adding and enabling a E<.Xr tun 4> interface to the system is "
"allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:689
#, no-wrap
msgid "Dv KAUTH_NETWORK_FORWSRCRT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:692
msgid ""
"Checks whether status of forwarding of source-routed packets can be modified "
"or not."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:692
#, no-wrap
msgid "Dv KAUTH_NETWORK_NFS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:694
msgid "Check if an NFS related operation is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:698
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_NFS_EXPORT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:700
msgid "Check if modifying the NFS export table is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:700
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_NFS_SVC"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:704
msgid "Check if access to the NFS E<.Xr nfssvc 2> syscall is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:705
#, no-wrap
msgid "Dv KAUTH_NETWORK_ROUTE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:707
msgid "Checks if a routing-related request is allowed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:712
msgid "E<.Ar arg1> is the E<.Ft struct rt_msghdr *> for the request."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:712
#, no-wrap
msgid "Dv KAUTH_NETWORK_SOCKET"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:714
msgid "Checks if a socket related operation is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:720
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_SOCKET_RAWSOCK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:722
msgid "Checks if opening a raw socket is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:722
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_SOCKET_OPEN"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:731
msgid ""
"Checks if opening a socket is allowed.  E<.Ar arg1 , arg2>, and E<.Ar arg3> "
"are all E<.Ft int> parameters describing the domain, socket type, and "
"protocol, respectively."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:731
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_SOCKET_CANSEE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:733
msgid "Checks if looking at the socket passed is allowed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:738 org_netbsd/src/share/man/man9/kauth.9:745
msgid "E<.Ar arg1> is a E<.Ft struct socket *> describing the socket."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:738
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_SOCKET_DROP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:740
msgid "Checks if a connection can be dropped."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:745
#, no-wrap
msgid "Dv KAUTH_REQ_NETWORK_SOCKET_SETPRIV"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:747
msgid "Checks if setting privileged socket options is allowed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:756
msgid ""
"E<.Ar arg1> is a E<.Ft struct socket *> describing the socket, E<.Ar arg2> "
"is a E<.Ft u_long> describing the socket option."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/kauth.9:758
#, no-wrap
msgid "Machine-dependent Scope"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:762
msgid ""
"The machine-dependent (machdep) scope, E<.Dq org.netbsd.kauth.machdep>, "
"manages machine-dependent authorization requests in the kernel."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:767
msgid ""
"E<.Ft int Fn kauth_authorize_machdep \"kauth_cred_t cred\" \"kauth_action_t "
"op\" \"void *arg0\" \"void *arg1\" \"void *arg2\" \"void *arg3\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:772
msgid ""
"The actions on this scope provide a set that may or may not affect all "
"platforms.  Below is a list of available actions, along with which platforms "
"are affected by each."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:773
#, no-wrap
msgid "Dv KAUTH_MACHDEP_CPU_UCODE_APPLY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:779
msgid ""
"Request to apply a CPU microcode to a CPU.  This is related to the E<.Em "
"CPU_UCODE> kernel config E<.Xr options 4>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:779
#, no-wrap
msgid "Dv KAUTH_MACHDEP_CACHEFLUSH"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:784
msgid "Request to flush the whole CPU cache.  Affects E<.Em m68k> Linux emulation."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:784
#, no-wrap
msgid "Dv KAUTH_MACHDEP_IOPERM_GET"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:790
msgid ""
"Request to get the I/O permission level.  Affects E<.Em amd64>, E<.Em i386>, "
"E<.Em xen>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:790
#, no-wrap
msgid "Dv KAUTH_MACHDEP_IOPERM_SET"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:796
msgid ""
"Request to set the I/O permission level.  Affects E<.Em amd64>, E<.Em i386>, "
"E<.Em xen>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:796
#, no-wrap
msgid "Dv KAUTH_MACHDEP_IOPL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:802
msgid ""
"Request to set the I/O privilege level.  Affects E<.Em amd64>, E<.Em i386>, "
"E<.Em xen>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:802
#, no-wrap
msgid "Dv KAUTH_MACHDEP_LDT_GET"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:808
msgid ""
"Request to get the LDT (local descriptor table).  Affects E<.Em amd64>, "
"E<.Em i386>, E<.Em xen>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:808
#, no-wrap
msgid "Dv KAUTH_MACHDEP_LDT_SET"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:814
msgid ""
"Request to set the LDT (local descriptor table).  Affects E<.Em amd64>, "
"E<.Em i386>, E<.Em xen>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:814
#, no-wrap
msgid "Dv KAUTH_MACHDEP_MTRR_GET"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:820
msgid ""
"Request to get the MTRR (memory type range registers).  Affects E<.Em "
"amd64>, E<.Em i386>, E<.Em xen>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:820
#, no-wrap
msgid "Dv KAUTH_MACHDEP_MTRR_SET"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:826
msgid ""
"Request to set the MTRR (memory type range registers).  Affects E<.Em "
"amd64>, E<.Em i386>, E<.Em xen>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:826
#, no-wrap
msgid "Dv KAUTH_MACHDEP_NVRAM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:830
msgid "Request to access (read/write) the NVRAM.  Affects E<.Em i386>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:830
#, no-wrap
msgid "Dv KAUTH_MACHDEP_UNMANAGEDMEM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:841
msgid ""
"Request to access unmanaged memory.  Affects E<.Em alpha>, E<.Em amd64>, "
"E<.Em arm>, E<.Em i386>, E<.Em powerpc>, E<.Em sh3>, E<.Em vax>, E<.Em xen>."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/kauth.9:842
#, no-wrap
msgid "Device Scope"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:851
msgid ""
"The device scope, E<.Dq org.netbsd.kauth.device>, manages authorization "
"requests related to devices on the system.  Devices can be, for example, "
"terminals, tape drives, Bluetooth accessories, and any other hardware.  "
"Network devices specifically are handled by the E<.Em network> scope."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:853
msgid "In addition to the standard authorization wrapper:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:856
msgid ""
"E<.Ft int Fn kauth_authorize_device \"kauth_cred_t cred\" \"kauth_action_t "
"op\" \"void *arg0\" \"void *arg1\" \"void *arg2\" \"void *arg3\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:858
msgid "this scope provides authorization wrappers for various device types."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:861
msgid ""
"E<.Ft int Fn kauth_authorize_device_tty \"kauth_cred_t cred\" "
"\"kauth_action_t op\" \"struct tty *tty\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:873
msgid ""
"Authorizes requests for E<.Em terminal devices> on the system.  The third "
"argument, E<.Ar tty>, is the terminal device in question.  It is passed to "
"the listener as E<.Ar arg0>.  The second argument, E<.Ar op>, is the action "
"and can be one of the following:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:874
#, no-wrap
msgid "Dv KAUTH_DEVICE_TTY_OPEN"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:877
msgid "Open the terminal device pointed to by E<.Ar tty>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:877
#, no-wrap
msgid "Dv KAUTH_DEVICE_TTY_PRIVSET"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:880
msgid "Set privileged settings on the terminal device pointed to by E<.Ar tty>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:880
#, no-wrap
msgid "Dv KAUTH_DEVICE_TTY_STI"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:887
msgid ""
"Use the E<.Dq TIOCSTI> device E<.Xr ioctl 2>, allowing to inject characters "
"into the terminal buffer, simulating terminal input."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:891
msgid ""
"E<.Ft int Fn kauth_authorize_device_spec \"kauth_cred_t cred\" \"enum "
"kauth_device_req req\" \"struct vnode *vp\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:895
msgid ""
"Authorizes requests for E<.Em special files>, usually disk devices, but also "
"direct memory access, on the system."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:911
msgid ""
"It passes E<.Dv KAUTH_DEVICE_RAWIO_SPEC> as the action to the listener, and "
"accepts two arguments.  E<.Ar req>, passed to the listener as E<.Ar arg0>, "
"is access requested, and can be one of E<.Dv "
"KAUTH_REQ_DEVICE_RAWIO_SPEC_READ>, E<.Dv KAUTH_REQ_DEVICE_RAWIO_SPEC_WRITE>, "
"or E<.Dv KAUTH_REQ_DEVICE_RAWIO_SPEC_RW>, representing read, write, or both "
"read/write access respectively.  E<.Ar vp> is the vnode of the special file "
"in question, and is passed to the listener as E<.Ar arg1>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:915
msgid ""
"Keep in mind that it is the responsibility of the security model developer "
"to check whether the underlying device is a disk or the system memory, using "
"E<.Fn iskmemdev>:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:919
#, no-wrap
msgid ""
"if ((vp-\\*[Gt]v_type == VCHR) \\*[Am]\\*[Am]\n"
"    iskmemdev(vp-\\*[Gt]v_un.vu_specinfo-\\*[Gt]si_rdev))\n"
"\t/* system memory access */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:923
msgid ""
"E<.Ft int Fn kauth_authorize_device_passthru \"kauth_cred_t cred\" \"dev_t "
"dev\" \"u_long mode\" \"void *data\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:928
msgid ""
"Authorizes hardware E<.Em passthru> requests, or user commands passed "
"directly to the hardware.  These have the potential of resulting in direct "
"disk and/or memory access."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:941
msgid ""
"It passes E<.Dv KAUTH_DEVICE_RAWIO_PASSTHRU> as the action to the listener, "
"and accepts three arguments.  E<.Ar dev>, passed as E<.Ar arg1> to the "
"listener, is the device for which the request is made.  E<.Ar mode>, passed "
"as E<.Ar arg0> to the listener, is a generic representation of the access "
"mode requested.  It can be one or more (binary-OR'd) of the following:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:943
#, no-wrap
msgid "KAUTH_REQ_DEVICE_RAWIO_PASSTHRU_READ"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:944
#, no-wrap
msgid "KAUTH_REQ_DEVICE_RAWIO_PASSTHRU_READCONF"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:945
#, no-wrap
msgid "KAUTH_REQ_DEVICE_RAWIO_PASSTHRU_WRITE"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:946
#, no-wrap
msgid "KAUTH_REQ_DEVICE_RAWIO_PASSTHRU_WRITECONF"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:954
msgid ""
"E<.Ar data>, passed as E<.Ar arg2> to the listener, is device-specific data "
"that may be associated with the request."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/kauth.9:954
#, no-wrap
msgid "Bluetooth Devices"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:957
msgid ""
"Authorizing actions relevant to Bluetooth devices is done using the standard "
"authorization wrapper, with the following actions:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:959
#, no-wrap
msgid "KAUTH_DEVICE_BLUETOOTH_BCSP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:963
msgid "Check if operations on a E<.Xr bcsp 4> device are allowed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:968 org_netbsd/src/share/man/man9/kauth.9:983
msgid ""
"E<.Ar arg0> is an E<.Ft enum kauth_device_req> with one of the following "
"values:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:969
#, no-wrap
msgid "Dv KAUTH_REQ_DEVICE_BLUETOOTH_BCSP_ADD"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:973
msgid "Check if adding and enabling a E<.Xr bcsp 4> device is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:974
#, no-wrap
msgid "KAUTH_DEVICE_BLUETOOTH_BTUART"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:978
msgid "Check if operations on a E<.Xr btuart 4> device are allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:984
#, no-wrap
msgid "Dv KAUTH_REQ_DEVICE_BLUETOOTH_BTUART_ADD"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:988
msgid "Check if adding and enabling a E<.Xr btuart 4> device is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:989
#, no-wrap
msgid "KAUTH_DEVICE_BLUETOOTH_RECV"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:991
msgid "Check if a packet can be received from the device."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1009
msgid ""
"E<.Ar arg0> is the packet type.  For E<.Dv HCI_CMD_PKT> packets, E<.Ar arg1> "
"is the opcode, for E<.Dv HCI_EVENT_PKT> packets, E<.Ar arg1> is the event "
"ID, and for E<.Dv HCI_ACLDATA_PKT> or E<.Dv HCI_SCODATA_PKT> packets, E<.Ar "
"arg1> is the connection handle."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1009
#, no-wrap
msgid "KAUTH_DEVICE_BLUETOOTH_SEND"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1011
msgid "Check if a packet can be sent to the device."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1020
msgid ""
"E<.Ar arg0> is a E<.Ft struct hci_unit *> describing the HCI unit, E<.Ar "
"arg1> is a E<.Ft hci_cmd_hdr_t *> describing the packet header."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1020
#, no-wrap
msgid "KAUTH_DEVICE_BLUETOOTH_SETPRIV"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1022 org_netbsd/src/share/man/man9/kauth.9:1048
msgid "Check if privileged settings can be changed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1035
msgid ""
"E<.Ar arg0> is a E<.Ft struct hci_unit *> describing the HCI unit, E<.Ar "
"arg1> is a E<.Ft struct btreq *> describing the request, and E<.Ar arg2> is "
"a E<.Ft u_long> describing the command."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/kauth.9:1036
#, no-wrap
msgid "Kernel random device"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1040
msgid ""
"Authorization actions relevant to the kernel random device, E<.Xr rnd 4>, is "
"done using the standard authorization wrapper, with the following actions:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1042
#, no-wrap
msgid "KAUTH_DEVICE_RND_ADDDATA"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1044
msgid "Check if adding data to the entropy pool is allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1044
#, no-wrap
msgid "KAUTH_DEVICE_RND_GETPRIV"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1046
msgid "Check if privileged settings and information can be retrieved."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1046
#, no-wrap
msgid "KAUTH_DEVICE_RND_SETPRIV"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/kauth.9:1049
#, no-wrap
msgid "Credentials Scope"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1055
msgid ""
"The credentials scope, E<.Dq org.netbsd.kauth.cred>, is a special scope used "
"internally by the E<.Nm> framework to provide hooking to credential-related "
"operations."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1063
msgid ""
"It is a E<.Dq notify-only> scope, allowing hooking operations such as "
"initialization of new credentials, credential inheritance during a fork, and "
"copying and freeing of credentials.  The main purpose for this scope is to "
"give a security model a way to control the aforementioned operations, "
"especially in cases where the credentials hold security model-private data."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1066
msgid ""
"Notifications are made using the following function, which is internal to "
"E<.Nm>:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1069
msgid ""
"E<.Ft int Fn kauth_cred_hook \"kauth_cred_t cred\" \"kauth_action_t action\" "
"\"void *arg0\" \"void *arg1\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1071
msgid "With the following actions:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1072
#, no-wrap
msgid "Dv KAUTH_CRED_COPY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1086
msgid ""
"The credentials are being copied.  E<.Ar cred> are the credentials of the "
"lwp context doing the copy, and E<.Ar arg0> and E<.Ar arg1> are both E<.Ft "
"kauth_cred_t> representing the E<.Dq from> and E<.Dq to> credentials, "
"respectively."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1086
#, no-wrap
msgid "Dv KAUTH_CRED_FORK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1089
msgid ""
"The credentials are being inherited from a parent to a child process during "
"a fork."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1098
msgid ""
"E<.Ar cred> are the credentials of the lwp context doing the fork, and E<.Ar "
"arg0> and E<.Ar arg1> are both E<.Ft struct proc *> of the parent and child "
"processes, respectively."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1098
#, no-wrap
msgid "Dv KAUTH_CRED_FREE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1102
msgid "The credentials in E<.Ar cred> are being freed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1102
#, no-wrap
msgid "Dv KAUTH_CRED_INIT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1106
msgid "The credentials in E<.Ar cred> are being initialized."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1110
msgid ""
"Since this is a notify-only scope, all listeners are required to return "
"E<.Dv KAUTH_RESULT_ALLOW>."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/kauth.9:1110
#, no-wrap
msgid "Credentials Accessors and Mutators"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1115
msgid ""
"E<.Nm> has a variety of accessor and mutator routines to handle E<.Ft "
"kauth_cred_t> objects."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1119
msgid ""
"The following routines can be used to access and modify the user- and "
"group-ids in a E<.Ft kauth_cred_t>:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1120
#, no-wrap
msgid "Ft uid_t Fn kauth_cred_getuid \"kauth_cred_t cred\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1123
msgid "Returns the real user-id from E<.Ar cred>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1123
#, no-wrap
msgid "Ft uid_t Fn kauth_cred_geteuid \"kauth_cred_t cred\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1126
msgid "Returns the effective user-id from E<.Ar cred>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1126
#, no-wrap
msgid "Ft uid_t Fn kauth_cred_getsvuid \"kauth_cred_t cred\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1129
msgid "Returns the saved user-id from E<.Ar cred>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1129
#, no-wrap
msgid "Ft void Fn kauth_cred_setuid \"kauth_cred_t cred\" \"uid_t uid\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1134
msgid "Sets the real user-id in E<.Ar cred> to E<.Ar uid>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1134
#, no-wrap
msgid "Ft void Fn kauth_cred_seteuid \"kauth_cred_t cred\" \"uid_t uid\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1139
msgid "Sets the effective user-id in E<.Ar cred> to E<.Ar uid>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1139
#, no-wrap
msgid "Ft void Fn kauth_cred_setsvuid \"kauth_cred_t cred\" \"uid_t uid\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1144
msgid "Sets the saved user-id in E<.Ar cred> to E<.Ar uid>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1144
#, no-wrap
msgid "Ft gid_t Fn kauth_cred_getgid \"kauth_cred_t cred\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1147
msgid "Returns the real group-id from E<.Ar cred>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1147
#, no-wrap
msgid "Ft gid_t Fn kauth_cred_getegid \"kauth_cred_t cred\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1150
msgid "Returns the effective group-id from E<.Ar cred>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1150
#, no-wrap
msgid "Ft gid_t Fn kauth_cred_getsvgid \"kauth_cred_t cred\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1153
msgid "Returns the saved group-id from E<.Ar cred>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1153
#, no-wrap
msgid "Ft void Fn kauth_cred_setgid \"kauth_cred_t cred\" \"gid_t gid\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1158
msgid "Sets the real group-id in E<.Ar cred> to E<.Ar gid>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1158
#, no-wrap
msgid "Ft void Fn kauth_cred_setegid \"kauth_cred_t cred\" \"gid_t gid\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1163
msgid "Sets the effective group-id in E<.Ar cred> to E<.Ar gid>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1163
#, no-wrap
msgid "Ft void Fn kauth_cred_setsvgid \"kauth_cred_t cred\" \"gid_t gid\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1168
msgid "Sets the saved group-id in E<.Ar cred> to E<.Ar gid>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1168
#, no-wrap
msgid "Ft u_int Fn kauth_cred_getrefcnt \"kauth_cred_t cred\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1171
msgid "Return the reference count for E<.Ar cred>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1176
msgid ""
"The following routines can be used to access and modify the group list in a "
"E<.Ft kauth_cred_t>:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1177
#, no-wrap
msgid ""
"Ft int Fn kauth_cred_ismember_gid \"kauth_cred_t cred\" \"gid_t gid\" \"int "
"*resultp\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1183
msgid ""
"Checks if the group-id E<.Ar gid> is a member in the group list of E<.Ar "
"cred>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1187
msgid "If it is, E<.Ar resultp> will be set to one, otherwise, to zero."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1189 org_netbsd/src/share/man/man9/kauth.9:1224 org_netbsd/src/share/man/man9/kauth.9:1242
msgid "The return value is an error code, or zero for success."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1189
#, no-wrap
msgid "Ft u_int Fn kauth_cred_ngroups \"kauth_cred_t cred\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1192
msgid "Return the number of groups in the group list of E<.Ar cred>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1192
#, no-wrap
msgid "Ft gid_t Fn kauth_cred_group \"kauth_cred_t cred\" \"u_int idx\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1197
msgid ""
"Return the group-id of the group at index E<.Ar idx> in the group list of "
"E<.Ar cred>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1197
#, no-wrap
msgid ""
"Ft int Fn kauth_cred_setgroups \"kauth_cred_t cred\" \"const gid_t *groups\" "
"\"size_t ngroups\" \"uid_t gmuid\" \"enum uio_seg seg\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1216
msgid ""
"Copy E<.Ar ngroups> groups from array pointed to by E<.Ar groups> to the "
"group list in E<.Ar cred>, adjusting the number of groups in E<.Ar cred> "
"appropriately.  E<.Ar seg> should be either E<.Dv UIO_USERSPACE> or E<.Dv "
"UIO_SYSSPACE> indicating whether E<.Ar groups> is a user or kernel space "
"address."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1218
msgid "Any groups remaining will be set to an invalid value."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1222
msgid ""
"E<.Ar gmuid> is unused for now, and to maintain interface compatibility with "
"the Darwin KPI."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1224
#, no-wrap
msgid ""
"Ft int Fn kauth_cred_getgroups \"kauth_cred_t cred\" \"gid_t *groups\" "
"\"size_t ngroups\" \"enum uio_seg seg\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1240
msgid ""
"Copy E<.Ar ngroups> groups from the group list in E<.Ar cred> to the buffer "
"pointed to by E<.Ar groups>.  E<.Ar seg> should be either E<.Dv "
"UIO_USERSPACE> or E<.Dv UIO_SYSSPACE> indicating whether E<.Ar groups> is a "
"user or kernel space address."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/kauth.9:1243
#, no-wrap
msgid "Credential Private Data"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1247
msgid ""
"E<.Nm> provides an interface to allow attaching security-model private data "
"to credentials."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1253
msgid ""
"The use of this interface has two parts that can be divided to direct and "
"indirect control of the private-data.  Directly controlling the private data "
"is done by using the below routines, while the indirect control is often "
"dictated by events such as process fork, and is handled by listening on the "
"credentials scope (see above)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1258
msgid ""
"Attaching private data to credentials works by registering a key to serve as "
"a unique identifier, distinguishing various sets of private data that may be "
"associated with the credentials.  Registering, and deregistering, a key is "
"done by using these routines:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1260
#, no-wrap
msgid "Ft int Fn kauth_register_key \"const char *name\" \"kauth_key_t *keyp\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1266
msgid ""
"Register new key for private data for E<.Ar name> (usually, the security "
"model name).  E<.Ar keyp> will be used to return the key to be used in "
"further calls."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1270
msgid ""
"The function returns 0 on success and an error code (see E<.Xr errno 2>)  on "
"failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1270
#, no-wrap
msgid "Ft int Fn kauth_deregister_key \"kauth_key_t key\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1273
msgid "Deregister private data key E<.Ar key>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1276
msgid "Once registered, private data may be manipulated by the following routines:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1277
#, no-wrap
msgid ""
"Ft void Fn kauth_cred_setdata \"kauth_cred_t cred\" \"kauth_key_t key\" "
"\"void *data\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1285
msgid "Set private data for E<.Ar key> in E<.Ar cred> to be E<.Ar data>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1285
#, no-wrap
msgid "Ft void * Fn kauth_cred_getdata \"kauth_cred_t cred\" \"kauth_key_t key\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1290
msgid "Retrieve private data for E<.Ar key> in E<.Ar cred>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1300
msgid ""
"Note that it is required to use the above routines every time the private "
"data is changed, i.e., using E<.Fn kauth_cred_getdata> and later modifying "
"the private data should be accompanied by a call to E<.Fn "
"kauth_cred_setdata> with the E<.Dq new> private data."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/kauth.9:1300
#, no-wrap
msgid "Credential Inheritance and Reference Counting"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1303
msgid "E<.Nm> provides an interface for handling shared credentials."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1309
msgid ""
"When a E<.Ft kauth_cred_t> is first allocated, its reference count is set to "
"1.  However, with time, its reference count can grow as more objects "
"(processes, LWPs, files, etc.) reference it."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1312
msgid ""
"The following routines are available for managing credentials reference "
"counting:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1313
#, no-wrap
msgid "Ft void Fn kauth_cred_hold \"kauth_cred_t cred\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1317
msgid "Increases reference count to E<.Ar cred> by one."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1317
#, no-wrap
msgid "Ft void Fn kauth_cred_free \"kauth_cred_t cred\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1321
msgid "Decreases the reference count to E<.Ar cred> by one."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1325
msgid ""
"If the reference count dropped to zero, the memory used by E<.Ar cred> will "
"be freed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1330
msgid ""
"Credential inheritance happens during a E<.Xr fork 2>, and is handled by the "
"following function:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1332
msgid ""
"E<.Ft void Fn kauth_proc_fork \"struct proc *parent\" \"struct proc "
"*child\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1338
msgid ""
"When called, it references the parent's credentials from the child, and "
"calls the credentials scope's hook with the E<.Dv KAUTH_CRED_FORK> action to "
"allow security model-specific handling of the inheritance to take place."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/kauth.9:1338
#, no-wrap
msgid "Credentials Memory Management"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1343
msgid ""
"Data-structures for credentials, listeners, and scopes are allocated from "
"memory pools managed by the E<.Xr pool 9> subsystem."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1347
msgid "The E<.Ft kauth_cred_t> objects have their own memory management routines:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1348
#, no-wrap
msgid "Ft kauth_cred_t Fn kauth_cred_alloc void"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1352
msgid ""
"Allocates a new E<.Ft kauth_cred_t>, initializes its lock, and sets its "
"reference count to one."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/kauth.9:1353
#, no-wrap
msgid "Conversion Routines"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1359
msgid ""
"Sometimes it might be necessary to convert a E<.Ft kauth_cred_t> to "
"userland's view of credentials, a E<.Ft struct uucred>, or vice versa."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1361
msgid "The following routines are available for these cases:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1362
#, no-wrap
msgid ""
"Ft void Fn kauth_uucred_to_cred \"kauth_cred_t cred\" \"const struct uucred "
"*uucred\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1365
msgid "Convert userland's view of credentials to a E<.Ft kauth_cred_t>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1369
msgid ""
"This includes effective user- and group-ids, a number of groups, and a group "
"list.  The reference count is set to one."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1374
msgid ""
"Note that E<.Nm> will try to copy as many groups as can be held inside a "
"E<.Ft kauth_cred_t>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1374
#, no-wrap
msgid ""
"Ft void Fn kauth_cred_to_uucred \"struct uucred *uucred\" \"const "
"kauth_cred_t cred\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1378
msgid "Convert E<.Ft kauth_cred_t> to userland's view of credentials."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1381
msgid ""
"This includes effective user- and group-ids, a number of groups, and a group "
"list."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1386
msgid ""
"Note that E<.Nm> will try to copy as many groups as can be held inside a "
"E<.Ft struct uucred>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1386
#, no-wrap
msgid "Ft int Fn kauth_cred_uucmp \"kauth_cred_t cred\" \"struct uucred *uucred\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1391
msgid "Compares E<.Ar cred> with the userland credentials in E<.Ar uucred>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1394
msgid ""
"Common values that will be compared are effective user- and group-ids, and "
"the group list."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/kauth.9:1395 org_netbsd/src/share/man/man9/veriexec.9:244
#, no-wrap
msgid "Miscellaneous Routines"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1399
msgid "Other routines provided by E<.Nm> are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1400
#, no-wrap
msgid "Ft void Fn kauth_cred_clone \"kauth_cred_t cred1\" \"kauth_cred_t cred2\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1406
msgid ""
"Clone credentials from E<.Ar cred1> to E<.Ar cred2>, except for the lock and "
"reference count."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1407
#, no-wrap
msgid "Ft kauth_cred_t Fn kauth_cred_dup \"kauth_cred_t cred\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1410
msgid "Duplicate E<.Ar cred>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1415
msgid ""
"What this routine does is call E<.Fn kauth_cred_alloc> followed by a call to "
"E<.Fn kauth_cred_clone>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1415
#, no-wrap
msgid "Ft kauth_cred_t Fn kauth_cred_copy \"kauth_cred_t cred\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1419
msgid "Works like E<.Fn kauth_cred_dup>, except for a few differences."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1433
msgid ""
"If E<.Ar cred> already has a reference count of one, it will be returned.  "
"Otherwise, a new E<.Ft kauth_cred_t> will be allocated and the credentials "
"from E<.Ar cred> will be cloned to it.  Last, a call to E<.Fn "
"kauth_cred_free> for E<.Ar cred> will be done."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1433
#, no-wrap
msgid "Ft kauth_cred_t Fn kauth_cred_get void"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1435
msgid "Return the credentials associated with the current LWP."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/kauth.9:1436
#, no-wrap
msgid "Scope Management"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1440
msgid ""
"E<.Nm> provides routines to manage the creation and deletion of scopes on "
"the system."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1446
msgid ""
"Note that the built-in scopes, the E<.Dq generic> scope and the E<.Dq "
"process> scope, can't be deleted."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1447
#, no-wrap
msgid ""
"Ft kauth_scope_t Fn kauth_register_scope \"const char *id\" "
"\"kauth_scope_callback_t cb\" \"void *cookie\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1460
msgid ""
"Register a new scope on the system.  E<.Ar id> is the name of the scope, "
"usually in reverse DNS-like notation.  For example, E<.Dq "
"org.netbsd.kauth.myscope>.  E<.Ar cb> is the default listener, to which "
"authorization requests for this scope will be dispatched to.  E<.Ar cookie> "
"is optional user-data that will be passed to all listeners during "
"authorization on the scope."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1460
#, no-wrap
msgid "Ft void Fn kauth_deregister_scope \"kauth_scope_t scope\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1467
msgid ""
"Deregister E<.Ar scope> from the scopes available on the system, and free "
"the E<.Ft kauth_scope_t> object E<.Ar scope>."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/kauth.9:1468
#, no-wrap
msgid "Listener Management"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1473
msgid ""
"Listeners in E<.Nm> are authorization callbacks that are called during an "
"authorization request in the scope which they belong to."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1476
msgid ""
"When an authorization request is made, all listeners associated with a scope "
"are called to allow, deny, or defer the request."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1483
msgid ""
"It is enough for one listener to deny the request in order for the request "
"to be denied; but all listeners are called during an authorization process "
"none-the-less.  All listeners are required to allow the request for it to be "
"granted, and in a case where all listeners defer the request -- leaving the "
"decision for other listeners -- the request is denied."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1485
msgid "The following KPI is provided for the management of listeners:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1486
#, no-wrap
msgid ""
"Ft kauth_listener_t Fn kauth_listen_scope \"const char *id\" "
"\"kauth_scope_callback_t cb\" \"void *cookie\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1495
msgid ""
"Create a new listener on the scope with the id E<.Ar id>, setting the "
"default listener to E<.Ar cb>.  E<.Ar cookie> is optional user-data that "
"will be passed to the listener when called during an authorization request."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kauth.9:1495
#, no-wrap
msgid "Ft void Fn kauth_unlisten_scope \"kauth_listener_t listener\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1503
msgid ""
"Removes E<.Ar listener> from the scope which it belongs to, ensuring it "
"won't be called again, and frees the E<.Ft kauth_listener_t> object E<.Ar "
"listener>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1512
msgid ""
"E<.Nm> provides no means for synchronization within listeners.  It is the "
"programmer's responsibility to make sure data used by the listener is "
"properly locked during its use, as it can be accessed simultaneously from "
"the same listener called multiple times.  It is also the programmer's "
"responsibility to do garbage collection after the listener, possibly freeing "
"any allocated data it used."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1517
msgid ""
"The common method to do the above is by having a reference count to each "
"listener.  On entry to the listener, this reference count should be raised, "
"and on exit -- lowered."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1525
msgid ""
"During the removal of a listener, first E<.Fn kauth_scope_unlisten> should "
"be called to make sure the listener code will not be entered in the future.  "
"Then, the code should wait (possibly sleeping) until the reference count "
"drops to zero.  When that happens, it is safe to do the final cleanup."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1528
msgid ""
"Listeners might sleep, so no locks can be held when calling an authorization "
"wrapper."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1531
msgid ""
"Older code had no abstraction of the security model, so most privilege "
"checks looked like this:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1534
#, no-wrap
msgid ""
"if (suser(cred, \\*[Am]acflag) == 0)\n"
"\t/* allow privileged operation */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1539
msgid ""
"Using the new interface, you must ask for a specific privilege explicitly.  "
"For example, checking whether it is possible to open a socket would look "
"something like this:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1544
#, no-wrap
msgid ""
"if (kauth_authorize_network(cred, KAUTH_NETWORK_SOCKET,\n"
"    KAUTH_REQ_NETWORK_SOCKET_OPEN, PF_INET, SOCK_STREAM,\n"
"    IPPROTO_TCP) == 0)\n"
"\t/* allow opening the socket */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1553
msgid ""
"Note that the E<.Em securelevel> implications were also integrated into the "
"E<.Nm> framework so you don't have to note anything special in the call to "
"the authorization wrapper, but rather just have to make sure the security "
"model handles the request as you expect it to."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1557
msgid ""
"To do that you can just E<.Xr grep 1> in the relevant security model "
"directory and have a look at the code."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/kauth.9:1557
#, no-wrap
msgid "EXTENDING KAUTH"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1563
msgid ""
"Although E<.Nm> provides a large set of both detailed and more or less "
"generic requests, it might be needed eventually to introduce more scopes, "
"actions, or requests."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1570
msgid ""
"Adding a new scope should happen only when an entire subsystem is introduced "
"and it is assumed other parts of the kernel may want to interfere with its "
"inner-workings.  When a subsystem that has the potential of impacting the "
"security of the system is introduced, existing security modules must be "
"updated to also handle actions on the newly added scope."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1573
msgid ""
"New actions should be added when sets of operations not covered at all "
"belong in an already existing scope."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1576
msgid ""
"Requests (or sub-actions) can be added as subsets of existing actions when "
"an operation that belongs in an already covered area is introduced."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1581
msgid ""
"Note that all additions should include updates to this manual, the security "
"models shipped with E<.Nx>, and the example skeleton security model."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1583
msgid "E<.Xr secmodel 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1585
msgid "The kernel authorization framework first appeared in Mac OS X 10.4."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1592
msgid ""
"The kernel authorization framework in E<.Nx> first appeared in E<.Nx 4.0>, "
"and is a clean-room implementation based on Apple TN2127, available at "
"http://developer.apple.com/technotes/tn2005/tn2127.html"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1604
msgid ""
"As E<.Nm> in E<.Nx> is still under active development, it is likely that the "
"ABI, and possibly the API, will differ between E<.Nx> versions.  Developers "
"are to take notice of this fact in order to avoid building code that expects "
"one version of the ABI and running it in a system with a different one."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1608
msgid ""
"E<.An Elad Efrat Aq elad@NetBSD.org> implemented the kernel authorization "
"framework in E<.Nx>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1611
msgid ""
"E<.An Jason R. Thorpe Aq thorpej@NetBSD.org> provided guidance and answered "
"questions about the Darwin implementation."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/kauth.9:1611
#, no-wrap
msgid "ONE MORE THING"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kauth.9:1616
msgid ""
"The E<.Nm> framework is dedicated to Brian Mitchell, one of the most "
"talented people I know.  Thanks for everything."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/kcopy.9:30
#, no-wrap
msgid "April 4, 2006"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/kcopy.9:31
#, no-wrap
msgid "KCOPY 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcopy.9:35
msgid "E<.Nm kcopy>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/kcopy.9:35
#, no-wrap
msgid "copy data with abort on page fault"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcopy.9:40
msgid "E<.Ft int> E<.Fn kcopy \"const void *src\" \"void *dst\" \"size_t len\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcopy.9:49
msgid ""
"E<.Fn kcopy> copies E<.Fa len> bytes from E<.Fa src> to E<.Fa dst>, aborting "
"if a fatal page fault is encountered."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcopy.9:56
msgid ""
"E<.Fn kcopy> must save and restore the old fault handler since it is called "
"by E<.Xr uiomove 9>, which may be in the path of servicing a non-fatal page "
"fault.  E<.Fn kcopy> returns 0 on success and an error number on failure."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcopy.9:59
msgid "E<.Xr errno 2>, E<.Xr memcpy 9>, E<.Xr uiomove 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/kcpuset.9:28
#, no-wrap
msgid "October 6, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/kcpuset.9:29
#, no-wrap
msgid "KCPUSET 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcpuset.9:50
msgid ""
"E<.Nm kcpuset>, E<.Nm kcpuset_create>, E<.Nm kcpuset_destroy>, E<.Nm "
"kcpuset_copy>, E<.Nm kcpuset_use>, E<.Nm kcpuset_unuse>, E<.Nm "
"kcpuset_copyin>, E<.Nm kcpuset_copyout>, E<.Nm kcpuset_zero>, E<.Nm "
"kcpuset_fill>, E<.Nm kcpuset_set>, E<.Nm kcpuset_clear>, E<.Nm "
"kcpuset_isset>, E<.Nm kcpuset_iszero>, E<.Nm kcpuset_match>, E<.Nm "
"kcpuset_merge>, E<.Nm kcpuset_atomic_set>, E<.Nm kcpuset_atomic_clear>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/kcpuset.9:50
#, no-wrap
msgid "dynamic kernel CPU sets"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/kcpuset.9:52
#, no-wrap
msgid "sys/kcpuset.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcpuset.9:87
msgid ""
"E<.Ft void> E<.Fn kcpuset_create \"kcpuset_t **retkcp\" \"bool zero\"> E<.Ft "
"void> E<.Fn kcpuset_destroy \"kcpuset_t *kcp\"> E<.Ft void> E<.Fn "
"kcpuset_copy \"kcpuset_t *dkcp\" \"kcpuset_t *skcp\"> E<.Ft void> E<.Fn "
"kcpuset_use \"kcpuset_t *kcp\"> E<.Ft void> E<.Fn kcpuset_unuse \"kcpuset_t "
"*kcp\" \"kcpuset_t **lst\"> E<.Ft int> E<.Fn kcpuset_copyin \"const cpuset_t "
"*ucp\" \"kcpuset_t *kcp\" \"size_t len\"> E<.Ft int> E<.Fn kcpuset_copyout "
"\"kcpuset_t *kcp\" \"cpuset_t *ucp\" \"size_t len\"> E<.Ft void> E<.Fn "
"kcpuset_zero \"kcpuset_t *kcp\"> E<.Ft void> E<.Fn kcpuset_fill \"kcpuset_t "
"*kcp\"> E<.Ft void> E<.Fn kcpuset_set \"kcpuset_t *kcp\" \"cpuid_t cpu\"> "
"E<.Ft void> E<.Fn kcpuset_clear \"kcpuset_t *kcp\" \"cpuid_t cpu\"> E<.Ft "
"int> E<.Fn kcpuset_isset \"kcpuset_t * kcp\" \"cpuid_t cpu\"> E<.Ft bool> "
"E<.Fn kcpuset_iszero \"kcpuset_t *kcp\"> E<.Ft bool> E<.Fn kcpuset_match "
"\"const kcpuset_t *kcp1\" \"const kcpuset_t *kcp2\"> E<.Ft void> E<.Fn "
"kcpuset_merge \"kcpuset_t *kcp1\" \"kcpuset_t *kcp2\"> E<.Ft void> E<.Fn "
"kcpuset_atomic_set \"kcpuset_t *kcp\" \"cpuid_t cpu\"> E<.Ft void> E<.Fn "
"kcpuset_atomic_clear \"kcpuset_t *kcp\" \"cpuid_t cpu\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcpuset.9:96
msgid ""
"The machine-independent E<.Nm> subsystem provides support for dynamic "
"processor sets.  Conceptually E<.Nm> can be understood to be the kernel "
"equivalent of the user space E<.Xr cpuset 3> interface."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kcpuset.9:98
#, no-wrap
msgid "Fn kcpuset_create retkcp zero"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcpuset.9:108
msgid ""
"The E<.Fn kcpuset_create> function creates a dynamic E<.Tn CPU> set and "
"stores the result to E<.Fa retkcp>.  If the boolean E<.Fa zero> is not "
"false, the allocated set is also initialized to zero."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kcpuset.9:108
#, no-wrap
msgid "Fn kcpuset_destroy kcp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcpuset.9:114
msgid ""
"Destroys the E<.Tn CPU> set E<.Fa kcp> and schedules any linked CPU sets for "
"deferred destruction."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kcpuset.9:114
#, no-wrap
msgid "Fn kcpuset_copy dkcp skcp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcpuset.9:121
msgid "Copies the E<.Tn CPU> set pointed by E<.Fa skcp> to E<.Fa dkcp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kcpuset.9:121
#, no-wrap
msgid "Fn kcpuset_use kcp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcpuset.9:128
msgid ""
"Marks E<.Fa kcp> as being in use by increasing the reference count of the "
"object.  Note that initially E<.Fn kcpuset_create> sets the reference count "
"to 1."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kcpuset.9:128
#, no-wrap
msgid "Fn kcpuset_unuse kcp lst"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcpuset.9:142
msgid ""
"Decreases the internal reference count of E<.Fa kcp>, and on the last "
"reference (when the count reaches zero), destroys E<.Fa kcp>.  If E<.Fa lst> "
"is not E<.Dv NULL>, then instead of destroying, E<.Fa kcp> will be added to "
"the E<.Fa lst> list for a deferred destruction."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kcpuset.9:142
#, no-wrap
msgid "Fn kcpuset_copyin ucp kcp len"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcpuset.9:153
msgid ""
"Copies the E<.Fa len> bytes long user-space E<.Tn CPU> set E<.Fa ucp> to the "
"kernel E<.Tn CPU> set E<.Fa kcp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kcpuset.9:153
#, no-wrap
msgid "Fn kcpuset_copyout kcp ucp len"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcpuset.9:162
msgid ""
"Copies the kernel E<.Tn CPU> set E<.Fa kcp> to the user-space E<.Tn CPU> set "
"E<.Fa ucp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kcpuset.9:162
#, no-wrap
msgid "Fn kcpuset_zero kcp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcpuset.9:165
msgid "Clears the set E<.Fa kcp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kcpuset.9:165
#, no-wrap
msgid "Fn kcpuset_fill kcp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcpuset.9:169
msgid "Fills the whole set E<.Fa kcp> with ones."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kcpuset.9:169
#, no-wrap
msgid "Fn kcpuset_set kcp cpu"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcpuset.9:174
msgid "Adds E<.Fa cpu> to the set E<.Fa kcp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kcpuset.9:174
#, no-wrap
msgid "Fn kcpuset_clear kcp cpu"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcpuset.9:179
msgid "Removes E<.Fa cpu> from the set E<.Fa kcp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kcpuset.9:179
#, no-wrap
msgid "Fn kcpuset_isset kcp cpu"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcpuset.9:186
msgid "Returns 1 if E<.Fa cpu> is part of the E<.Tn CPU> set E<.Fa kcp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kcpuset.9:186
#, no-wrap
msgid "Fn kcpuset_iszero kcp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcpuset.9:190
msgid "Returns true if the set E<.Fa kcp> is empty."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kcpuset.9:190
#, no-wrap
msgid "Fn kcpuset_match kcp1 kcp2"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcpuset.9:196
msgid ""
"Compares the sets E<.Fa kcp1> and E<.Fa kcp2>, returning true if these are "
"identical."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kcpuset.9:196
#, no-wrap
msgid "Fn kcpuset_merge kcp1 kcp2"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcpuset.9:201
msgid "Merges the set E<.Fa kcp2> to the set E<.Fa kcp1>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kcpuset.9:201
#, no-wrap
msgid "Fn kcpuset_atomic_set kcp cpu"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcpuset.9:209
msgid ""
"The E<.Fn kcpuset_atomic_set> function operates as E<.Fn kcpuset_set>, but "
"the operation is atomic; see E<.Xr atomic_ops 3> for more details."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kcpuset.9:209
#, no-wrap
msgid "Fn kcpuset_atomic_clear kcp cpu"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcpuset.9:217
msgid "Removes E<.Fa cpu> from the E<.Tn CPU> set E<.Fa kcp> atomically."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcpuset.9:223
msgid "The E<.Nm> subsystem is implemented within E<.Pa sys/kern/subr_kcpuset.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcpuset.9:225
msgid "E<.Xr cpuset 3>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kcpuset.9:229
msgid "The E<.Nm> subsystem first appeared in E<.Nx 6.0>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/kfilter_register.9:30
#, no-wrap
msgid "October 23, 2002"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/kfilter_register.9:31
#, no-wrap
msgid "KFILTER_REGISTER 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kfilter_register.9:36
msgid "E<.Nm kfilter_register>, E<.Nm kfilter_unregister>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/kfilter_register.9:36
#, no-wrap
msgid "add or remove kernel event filters"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/kfilter_register.9:38 org_netbsd/src/share/man/man9/knote.9:38
#, no-wrap
msgid "sys/event.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kfilter_register.9:43
msgid ""
"E<.Ft int> E<.Fn kfilter_register \"const char *name\" \"struct filterops "
"*filtops\" \"int *retfilter\"> E<.Ft int> E<.Fn kfilter_unregister \"const "
"char *name\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kfilter_register.9:69
msgid ""
"The E<.Fn kfilter_register> function adds a new kernel event filter "
"(kfilter) to the system, for use by callers of E<.Xr kqueue 2> and E<.Xr "
"kevent 2>.  E<.Fa name> is the name of the new filter (which must not "
"already exist), and E<.Fa filtops> is a pointer to a E<.Va filterops> "
"structure which describes the filter operations.  Both E<.Fa name> and E<.Fa "
"filtops> will be copied to an internal data structure, and a new filter "
"number will be allocated.  If E<.Fa retfilter> is not E<.Dv NULL>, then the "
"new filter number will be returned in the address pointed at by E<.Fa "
"retfilter>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kfilter_register.9:87
msgid ""
"The E<.Fn kfilter_unregister> function removes a kfilter named E<.Fa name> "
"that was previously registered with E<.Fn kfilter_register>.  If a filter "
"with the same E<.Fa name> is later reregistered with E<.Fn "
"kfilter_register>, it will get a different filter number (i.e., filter "
"numbers are not recycled).  It is not possible to unregister the system "
"filters (i.e., those that start with E<.Dq EVFILT_> and are documented in "
"E<.Xr kqueue 2>)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kfilter_register.9:91
msgid "The E<.Va filterops> structure is defined as follows:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kfilter_register.9:101
#, no-wrap
msgid ""
"struct filterops {\n"
"\tint\tf_isfd;\t\t/* true if ident == filedescriptor */\n"
"\tint\t(*f_attach)(struct knote *kn);\n"
"\t\t\t\t/* called when knote is ADDed */\n"
"\tvoid\t(*f_detach)(struct knote *kn);\n"
"\t\t\t\t/* called when knote is DELETEd */\n"
"\tint\t(*f_event)(struct knote *kn, long hint);\n"
"\t\t\t\t/* called when event is triggered */\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kfilter_register.9:109
msgid ""
"If the filter operation is for a file descriptor, E<.Va f_isfd> should be "
"non-zero, otherwise it should be zero.  This controls where the E<.Xr kqueue "
"2> system stores the knotes for an object."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kfilter_register.9:116
msgid ""
"E<.Fn kfilter_register> returns 0 on success, E<.Er EINVAL> if there's an "
"invalid argument, or E<.Er EEXIST> if the filter already exists,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kfilter_register.9:123
msgid ""
"E<.Fn kfilter_unregister> returns 0 on success, E<.Er EINVAL> if there's an "
"invalid argument, or E<.Er ENOENT> if the filter doesn't exist."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kfilter_register.9:128
msgid "E<.Xr kqueue 2>, E<.Xr free 9>, E<.Xr knote 9>, E<.Xr malloc 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kfilter_register.9:135
msgid ""
"The E<.Fn kfilter_register> and E<.Fn kfilter_unregister> functions first "
"appeared in E<.Nx 2.0>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kfilter_register.9:142
msgid ""
"The E<.Fn kfilter_register> and E<.Fn kfilter_unregister> functions were "
"implemented by E<.An Luke Mewburn> E<.Aq lukem@NetBSD.org>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/kmem.9:28 org_netbsd/src/share/man/man9/ubc.9:27
#, no-wrap
msgid "June 14, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/kmem.9:29
#, no-wrap
msgid "KMEM 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:34
msgid "E<.Nm kmem>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/kmem.9:34
#, no-wrap
msgid "kernel wired memory allocator"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/kmem.9:37
#, no-wrap
msgid "sys/kmem.h"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:52
msgid ""
"E<.Ft void *> E<.Fn kmem_alloc \"size_t size\" \"km_flag_t kmflags\"> E<.Ft "
"void *> E<.Fn kmem_zalloc \"size_t size\" \"km_flag_t kmflags\"> E<.Ft void> "
"E<.Fn kmem_free \"void *p\" \"size_t size\"> E<.Ft char *> E<.Fn "
"kmem_asprintf \"const char *fmt\" \"...\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:54
msgid "E<.Cd \"options DEBUG\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:58
msgid ""
"E<.Fn kmem_alloc> allocates kernel wired memory.  It takes the following "
"arguments."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:61
msgid "Specify the size of allocation in bytes."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kmem.9:61
#, no-wrap
msgid "Fa kmflags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:63
msgid "Either of the following:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kmem.9:64
#, no-wrap
msgid "KM_SLEEP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:67
msgid ""
"If the allocation cannot be satisfied immediately, sleep until enough memory "
"is available."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kmem.9:67
#, no-wrap
msgid "KM_NOSLEEP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:74
msgid ""
"Don't sleep.  Immediately return E<.Dv NULL> if there is not enough memory "
"available.  It should only be used when failure to allocate will not have "
"harmful, user-visible effects."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:81
msgid ""
"E<.Bf -symbolic> Use of E<.Dv KM_NOSLEEP> is strongly discouraged as it can "
"create transient, hard to debug failures that occur when the system is under "
"memory pressure.  E<.Ef>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:85
msgid ""
"In situations where it is not possible to sleep, for example because locks "
"are held by the caller, the code path should be restructured to allow the "
"allocation to be made in another place."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:89
msgid "The contents of allocated memory are uninitialized."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:91
msgid "Unlike Solaris, kmem_alloc(0, flags) is illegal."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:97
msgid ""
"E<.Fn kmem_zalloc> is the equivalent of E<.Fn kmem_alloc>, except that it "
"initializes the memory to zero."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:108
msgid ""
"E<.Fn kmem_asprintf> functions as the well known E<.Fn asprintf> function, "
"but allocates memory using E<.Fn kmem_alloc>.  This routine can sleep during "
"allocation.  The size of the allocated area is the length of the returned "
"character string, plus one (for the NUL terminator).  This must be taken "
"into consideration when freeing the returned area with E<.Fn kmem_free>."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:117
msgid ""
"E<.Fn kmem_free> frees kernel wired memory allocated by E<.Fn kmem_alloc> or "
"E<.Fn kmem_zalloc> so that it can be used for other purposes.  It takes the "
"following arguments."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:124
msgid ""
"The pointer to the memory being freed.  It must be the one returned by E<.Fn "
"kmem_alloc> or E<.Fn kmem_zalloc>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:133
msgid ""
"The size of the memory being freed, in bytes.  It must be the same as the "
"E<.Fa size> argument used for E<.Fn kmem_alloc> or E<.Fn kmem_zalloc> when "
"the memory was allocated."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:139
msgid "Freeing E<.Dv NULL> is illegal."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:150
msgid ""
"Making E<.Dv KM_SLEEP> allocations while holding mutexes or reader/writer "
"locks is discouraged, as the caller can sleep for an unbounded amount of "
"time in order to satisfy the allocation.  This can in turn block other "
"threads that wish to acquire locks held by the caller.  It should be noted "
"that E<.Fn kmem_free> may also block."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:158
msgid ""
"For some locks this is permissible or even unavoidable.  For others, "
"particularly locks that may be taken from soft interrupt context, it is a "
"serious problem.  As a general rule it is better not to allow this type of "
"situation to develop.  One way to circumvent the problem is to make "
"allocations speculative and part of a retryable sequence.  For example:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:181
#, no-wrap
msgid ""
"  retry:\n"
"        /* speculative unlocked check */\n"
"        if (need to allocate) {\n"
"                new_item = kmem_alloc(sizeof(*new_item), KM_SLEEP);\n"
"        } else {\n"
"                new_item = NULL;\n"
"        }\n"
"        mutex_enter(lock);\n"
"        /* check while holding lock for true status */\n"
"        if (need to allocate) {\n"
"                if (new_item == NULL) {\n"
"                        mutex_exit(lock);\n"
"                        goto retry;\n"
"                }\n"
"                consume(new_item);\n"
"                new_item = NULL;\n"
"        }\n"
"        mutex_exit(lock);\n"
"        if (new_item != NULL) {\n"
"                /* did not use it after all */\n"
"                kmem_free(new_item, sizeof(*new_item));\n"
"        }\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:190
msgid ""
"Kernels compiled with the E<.Dv DEBUG> option perform CPU intensive sanity "
"checks on kmem operations, and include the E<.Dv kmguard> facility which can "
"be enabled at runtime."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:198
msgid ""
"E<.Dv kmguard> adds additional, very high overhead runtime verification to "
"kmem operations.  To enable it, boot the system with the E<.Fl d> option, "
"which causes the debugger to be entered early during the kernel boot "
"process.  Issue commands such as the following:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:201
#, no-wrap
msgid ""
"db\\*[Gt] w kmem_guard_depth 0t30000\n"
"db\\*[Gt] c\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:214
msgid ""
"This instructs E<.Dv kmguard> to queue up to 60000 (30000*2) pages of "
"unmapped KVA to catch use-after-free type errors.  When E<.Fn kmem_free> is "
"called, memory backing a freed item is unmapped and the kernel VA space "
"pushed onto a FIFO.  The VA space will not be reused until another 30k items "
"have been freed.  Until reused the kernel will catch invalid accesses and "
"panic with a page fault.  Limitations:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:217
msgid "It has a severe impact on performance."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:219
msgid "It is best used on a 64-bit machine with lots of RAM."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:223
msgid "Allocations larger than PAGE_SIZE bypass the E<.Dv kmguard> facility."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:226
msgid "kmguard tries to catch the following types of bugs:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:229
msgid "Overflow at time of occurrence, by means of a guard page."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:233
msgid "Underflow at E<.Fn kmem_free>, by using a canary value."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:236
msgid "Invalid pointer or size passed, at E<.Fn kmem_free>."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:247
msgid ""
"On success, E<.Fn kmem_alloc> and E<.Fn kmem_zalloc> return a pointer to "
"allocated memory.  Otherwise, E<.Dv NULL> is returned."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:253
msgid ""
"The E<.Nm> subsystem is implemented within the file E<.Pa "
"sys/kern/subr_kmem.c>."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:260
msgid ""
"E<.Xr intro 9>, E<.Xr memoryallocators 9>, E<.Xr percpu 9>, E<.Xr pool_cache "
"9>, E<.Xr uvm_km 9>"
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:271
msgid ""
"Neither E<.Fn kmem_alloc> nor E<.Fn kmem_free> can be used from interrupt "
"context, from a soft interrupt, or from a callout.  Use E<.Xr pool_cache 9> "
"in these situations."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/kmem.9:271
#, no-wrap
msgid "SECURITY CONSIDERATIONS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kmem.9:276
msgid ""
"As the memory allocated by E<.Fn kmem_alloc> is uninitialized, it can "
"contain security-sensitive data left by its previous user.  It is the "
"caller's responsibility not to expose it to the world."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/knote.9:30
#, no-wrap
msgid "February 18, 2004"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/knote.9:31
#, no-wrap
msgid "KNOTE 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/knote.9:36
msgid "E<.Nm knote>, E<.Nm KNOTE>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/knote.9:36
#, no-wrap
msgid "raise kernel event"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/knote.9:42
msgid ""
"E<.Ft void> E<.Fn knote \"struct klist *list\" \"long hint\"> E<.Fn KNOTE "
"\"struct klist *list\" \"long hint\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/knote.9:52
msgid ""
"The E<.Fn knote> function provides a hook into the kqueue kernel event "
"notification mechanism to allow sections of the kernel to raise a kernel "
"event in the form of a E<.Sq knote>, which is a E<.Fa struct knote> as "
"defined in"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/knote.9:52
#, no-wrap
msgid "sys/event.h ."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/knote.9:71
msgid ""
"E<.Fn knote> takes a singly linked E<.Fa list> of knotes, along with a E<.Fa "
"hint> (which is passed to the appropriate filter routine).  E<.Fn knote> "
"then walks the E<.Fa list> making calls to the filter routine for each "
"knote.  As each knote contains a reference to the data structure that it is "
"attached to, the filter may choose to examine the data structure in deciding "
"whether an event should be reported.  The E<.Fa hint> is used to pass in "
"additional information, which may not be present in the data structure that "
"the filter examines."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/knote.9:80
msgid ""
"If the filter decides that the event should be returned, it returns a "
"non-zero value and E<.Fn knote> links the knote onto the tail end of the "
"active list in the corresponding kqueue for the application to retrieve.  If "
"the knote is already on the active list, no action is taken, but the call to "
"the filter occurs in order to provide an opportunity for the filter to "
"record the activity."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/knote.9:85
msgid ""
"E<.Fn knote> must not be called from interrupt contexts running at an "
"interrupt priority level higher than E<.Fn splsched>."
msgstr ""

#.  .Sh ERRORS
#. type: Plain text
#: org_netbsd/src/share/man/man9/knote.9:93
msgid ""
"E<.Fn KNOTE> is a macro that calls E<.Fn knote list hint> if E<.Fa list> is "
"not empty."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/knote.9:96
msgid "E<.Xr kqueue 2>, E<.Xr kfilter_register 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/knote.9:105
msgid ""
"The E<.Fn knote> and E<.Fn KNOTE> functions first appeared in E<.Fx 4.1>, "
"and then in E<.Nx 2.0>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/knote.9:109
msgid ""
"The E<.Fn kqueue> system was written by E<.An Jonathan Lemon Aq "
"jlemon@FreeBSD.org>."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/kpause.9:32
#, no-wrap
msgid "KPAUSE 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kpause.9:37
msgid "E<.Nm kpause>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/kpause.9:37
#, no-wrap
msgid "make the calling LWP sleep"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/kpause.9:46
msgid ""
"E<.Ft int> E<.Fn kpause \"const char *wmesg\" \"bool intr\" \"int timeo\" "
"\"kmutex_t *mtx\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kpause.9:53
msgid ""
"E<.Fn kpause> makes the calling LWP sleep.  It's similar to E<.Xr "
"cv_timedwait_sig 9> without the corresponding E<.Xr cv_signal 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kpause.9:57
msgid ""
"E<.Fn kpause> can wake up spontaneously.  Callers should prepare to handle "
"it."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kpause.9:59 org_netbsd/src/share/man/man9/ltsleep.9:111
#, no-wrap
msgid "Fa wmesg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kpause.9:67
msgid ""
"Specifies a string of no more than 8 characters that describes the resource "
"or condition associated with the call of E<.Fn kpause>.  The kernel does not "
"use this argument directly but makes it available for utilities such as "
"E<.Xr ps 1> to display."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kpause.9:67
#, no-wrap
msgid "Fa intr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kpause.9:72
msgid ""
"If true, sleep interruptably.  If the LWP receives a signal, or is "
"interrupted by another condition such as its containing process exiting, the "
"wait is ended early and an error code returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kpause.9:72
#, no-wrap
msgid "Fa timeo"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kpause.9:84
msgid ""
"Specify a timeout.  It is an architecture and system dependent value related "
"to the number of clock interrupts per second.  See E<.Xr hz 9> for details.  "
"The E<.Xr mstohz 9> macro can be used to convert a timeout expressed in "
"milliseconds to one suitable for E<.Fn kpause>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kpause.9:86
msgid "Zero means no timeout."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kpause.9:86
#, no-wrap
msgid "Fa mtx"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kpause.9:95
msgid ""
"Convenience and symmetry with other synchronization operations.  If not "
"E<.Dv NULL>, E<.Fa mtx> will be released once the LWP has prepared to sleep, "
"and will be reacquired before E<.Fn kpause> returns."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/kpause.9:103
msgid ""
"E<.Fn kpause> returns 0 when waking up spontaneously.  Otherwise, It returns "
"an error number."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/kpause.9:103 org_netbsd/src/share/man/man9/vnodeops.9:1411 org_netbsd/src/share/man/man9/vnsubr.9:253
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kpause.9:105
#, no-wrap
msgid "Bq Er EINTR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kpause.9:111
msgid ""
"E<.Fn kpause> returned due to other reasons.  Typically as a result of a "
"signal without E<.Dv SA_RESTART> property."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kpause.9:111
#, no-wrap
msgid "Bq Er ERESTART"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kpause.9:116
msgid ""
"E<.Fn kpause> returned as a result of a signal with E<.Dv SA_RESTART> "
"property."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kpause.9:116
#, no-wrap
msgid "Bq Er EWOULDBLOCK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kpause.9:118
msgid "The timeout expired."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kpause.9:126
msgid ""
"E<.Xr sigaction 2>, E<.Xr condvar 9>, E<.Xr delay 9>, E<.Xr errno 9>, E<.Xr "
"hz 9>, E<.Xr mstohz 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/kpreempt.9:28 org_netbsd/src/share/man/man9/spl.9:30
#, no-wrap
msgid "February 16, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/kpreempt.9:29
#, no-wrap
msgid "KPREEMPT 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kpreempt.9:34
msgid "E<.Nm kpreempt>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/kpreempt.9:34
#, no-wrap
msgid "control kernel preemption"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/kpreempt.9:49
msgid ""
"E<.Ft void> E<.Fn kpreempt_disable \"void\"> E<.Ft void> E<.Fn "
"kpreempt_enable \"void\"> E<.Ft bool> E<.Fn kpreempt_disabled \"void\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kpreempt.9:51
msgid "These functions are used to control kernel preemption of the calling LWP."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kpreempt.9:54
msgid ""
"On architectures where kernel preemption is not supported natively, these "
"functions may still be used."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kpreempt.9:61
msgid ""
"It should be noted that kernel preemption is also disabled when holding the "
"interrupt priority level above IPL_NONE, e.g. using E<.Xr spl 9> or spinning "
"E<.Xr mutex 9> calls or holding kernel_lock (indicating that the code is not "
"MT safe)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kpreempt.9:66
msgid ""
"E<.Fn kpreempt_disable> disables kernel preemption of the calling LWP.  Note "
"that disabling kernel preemption can prevent LWPs with higher priorities "
"from running."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kpreempt.9:70
msgid ""
"E<.Fn kpreempt_enable> enables kernel preemption of the calling LWP, which "
"was previously disabled by E<.Fn kpreempt_disable>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kpreempt.9:75
msgid "E<.Fn kpreempt_disable> and E<.Fn kpreempt_enable> can be nested."
msgstr ""

#.  ------------------------------------------------------------
#.  .Sh RETURN VALUES
#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/kpreempt.9:84
msgid ""
"E<.Fn kpreempt_disabled> returns E<.Dv true> if preemption of the calling "
"LWP is disabled.  It is only for diagnostic purpose."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kpreempt.9:87
msgid "E<.Xr intro 9>, E<.Xr mutex 9>, E<.Xr spl 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/kprintf.9:30
#, no-wrap
msgid "January 21, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/kprintf.9:31
#, no-wrap
msgid "KPRINTF 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:43
msgid ""
"E<.Nm device_printf>, E<.Nm printf>, E<.Nm snprintf>, E<.Nm vprintf>, E<.Nm "
"vsnprintf>, E<.Nm uprintf>, E<.Nm ttyprintf>, E<.Nm tprintf>, E<.Nm aprint>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/kprintf.9:43
#, no-wrap
msgid "kernel formatted output conversion"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:62
msgid ""
"E<.Ft void> E<.Fn \"device_printf\" \"device_t\" \"const char *format\" "
"\"...\"> E<.Ft void> E<.Fn \"printf\" \"const char *format\" \"...\"> E<.Ft "
"void> E<.Fn \"printf_nolog\" \"const char *format\" \"...\"> E<.Ft int> "
"E<.Fn \"snprintf\" \"char *buf\" \"size_t size\" \"const char *format\" "
"\"...\"> E<.Ft void> E<.Fn \"vprintf\" \"const char *format\" \"va_list "
"ap\"> E<.Ft int> E<.Fn \"vsnprintf\" \"char *buf\" \"size_t size\" \"const "
"char *format\" \"va_list ap\"> E<.Ft void> E<.Fn \"uprintf\" \"const char "
"*format\" \"...\"> E<.Ft void> E<.Fn \"ttyprintf\" \"struct tty *tty\" "
"\"const char *format\" \"...\">"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/kprintf.9:62
#, no-wrap
msgid "sys/tprintf.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:101
msgid ""
"E<.Ft tpr_t> E<.Fn \"tprintf_open\" \"struct proc *p\"> E<.Ft void> E<.Fn "
"\"tprintf\" \"tpr_t tpr\" \"const char *format\" \"...\"> E<.Ft void> E<.Fn "
"\"tprintf_close\" \"tpr_t tpr\"> E<.Ft void> E<.Fn \"aprint_normal\" \"const "
"char *format\" \"...\"> E<.Ft void> E<.Fn \"aprint_naive\" \"const char "
"*format\" \"...\"> E<.Ft void> E<.Fn \"aprint_verbose\" \"const char "
"*format\" \"...\"> E<.Ft void> E<.Fn \"aprint_debug\" \"const char *format\" "
"\"...\"> E<.Ft void> E<.Fn \"aprint_error\" \"const char *format\" \"...\"> "
"E<.Ft void> E<.Fn \"aprint_normal_dev\" \"device_t\" \"const char *format\" "
"\"...\"> E<.Ft void> E<.Fn \"aprint_naive_dev\" \"device_t\" \"const char "
"*format\" \"...\"> E<.Ft void> E<.Fn \"aprint_verbose_dev\" \"device_t\" "
"\"const char *format\" \"...\"> E<.Ft void> E<.Fn \"aprint_debug_dev\" "
"\"device_t\" \"const char *format\" \"...\"> E<.Ft void> E<.Fn "
"\"aprint_error_dev\" \"device_t\" \"const char *format\" \"...\"> E<.Ft "
"void> E<.Fn \"aprint_normal_ifnet\" \"struct ifnet *\" \"const char "
"*format\" \"...\"> E<.Ft void> E<.Fn \"aprint_naive_ifnet\" \"struct ifnet "
"*\" \"const char *format\" \"...\"> E<.Ft void> E<.Fn "
"\"aprint_verbose_ifnet\" \"struct ifnet *\" \"const char *format\" \"...\"> "
"E<.Ft void> E<.Fn \"aprint_debug_ifnet\" \"struct ifnet *\" \"const char "
"*format\" \"...\"> E<.Ft void> E<.Fn \"aprint_error_ifnet\" \"struct ifnet "
"*\" \"const char *format\" \"...\"> E<.Ft int> E<.Fn "
"\"aprint_get_error_count\" \"void\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:129
msgid ""
"The E<.Fn printf> family of functions allows the kernel to send formatted "
"messages to various output devices.  The functions E<.Fn printf> and E<.Fn "
"vprintf> send formatted strings to the system console.  The E<.Fn "
"device_printf> function is identical to E<.Fn printf>, except that it "
"prefixes the log message with the corresponding device name.  The E<.Fn "
"printf_nolog> function is identical to E<.Fn printf>, except it does not "
"send the data to the system log.  The functions E<.Fn snprintf> and E<.Fn "
"vsnprintf> write output to a string buffer.  These four functions work "
"similarly to their user space counterparts, and are not described in detail "
"here."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:136
msgid ""
"The functions E<.Fn uprintf> and E<.Fn ttyprintf> send formatted strings to "
"the current process's controlling tty and a specific tty, respectively."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:148
msgid ""
"The E<.Fn tprintf> function sends formatted strings to a process's "
"controlling tty, via a handle of type tpr_t.  This allows multiple write "
"operations to the tty with a guarantee that the tty will be valid across "
"calls.  A handle is acquired by calling E<.Fn tprintf_open> with the target "
"process as an argument.  This handle must be closed with a matching call to "
"E<.Fn tprintf_close>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:167
msgid ""
"The functions E<.Fn aprint_normal>, E<.Fn aprint_naive>, E<.Fn "
"aprint_verbose>, E<.Fn aprint_debug>, and E<.Fn aprint_error> are intended "
"to be used to print E<.Xr autoconf 9> messages.  Their verbosity depends on "
"flags set in the E<.Va boothowto> variable, through options passed during "
"bootstrap; see E<.Xr boothowto 9> and E<.Sx Interactive mode> in E<.Xr boot "
"8>:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kprintf.9:168
#, no-wrap
msgid "Dv AB_SILENT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:172
msgid "silent mode, enabled by E<.Ic boot> E<.Fl z>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kprintf.9:172
#, no-wrap
msgid "Dv AB_QUIET"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:176
msgid "quiet mode, enabled by E<.Ic boot> E<.Fl q>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kprintf.9:176
#, no-wrap
msgid "Dv AB_VERBOSE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:180
msgid "verbose mode, enabled by E<.Ic boot> E<.Fl v>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kprintf.9:180
#, no-wrap
msgid "Dv AB_DEBUG"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:184
msgid "debug mode, enabled by E<.Ic boot> E<.Fl x>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:190
msgid ""
"The E<.Fn aprint_*> functions have the following behaviour, based on the "
"above mentioned flags:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kprintf.9:191
#, no-wrap
msgid "Fn aprint_normal"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:196
msgid ""
"Sends to the console unless E<.Dv AB_QUIET> is set.  Always sends to the "
"log."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kprintf.9:196
#, no-wrap
msgid "Fn aprint_naive"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:201
msgid ""
"Sends to the console only if E<.Dv AB_QUIET> is set.  Never sends to the "
"log."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kprintf.9:201
#, no-wrap
msgid "Fn aprint_verbose"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:206
msgid ""
"Sends to the console only if E<.Dv AB_VERBOSE> is set.  Always sends to the "
"log."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kprintf.9:206
#, no-wrap
msgid "Fn aprint_debug"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:210
msgid "Sends to the console and the log only if E<.Dv AB_DEBUG> is set."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kprintf.9:210
#, no-wrap
msgid "Fn aprint_error"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:216
msgid ""
"Like E<.Fn aprint_normal>, but also keeps track of the number of times "
"called.  This allows a subsystem to report the number of errors that "
"occurred during a quiet or silent initialization phase."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:233
msgid ""
"For the E<.Fn aprint_*> functions there are two additional families of "
"functions with the suffixes E<.Dv _dev> and E<.Dv _ifnet> which work like "
"their counterparts without the suffixes, except that they take a E<.Ft "
"device_t> and E<.Ft struct ifnet *>, respectively, as first argument, and "
"prefix the log message with the corresponding device or interface name."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:237
msgid ""
"The E<.Fn aprint_get_error_count> function reports the number of errors and "
"resets the counter to 0."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:248
msgid ""
"If E<.Dv AB_SILENT> is set, none of the autoconfiguration message printing "
"routines send output to the console.  The E<.Dv AB_VERBOSE> and E<.Dv "
"AB_DEBUG> flags override E<.Dv AB_SILENT>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:256
msgid ""
"The E<.Fn snprintf> and E<.Fn vsnprintf> functions return the number of "
"characters placed in the buffer E<.Fa buf>.  This is different to the "
"user-space functions of the same name."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:262
msgid ""
"The E<.Fn tprintf_open> function returns E<.Dv NULL> if no terminal handle "
"could be acquired."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:269
msgid ""
"E<.Xr printf 1>, E<.Xr printf 3>, E<.Xr snprintb 3>, E<.Xr boot 8>, E<.Xr "
"autoconf 9>, E<.Xr boothowto 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:271
msgid "E<.Pa sys/kern/subr_prf.c>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:283
msgid ""
"The E<.Fn sprintf> and E<.Fn vsprintf> unsized string formatting functions "
"are supported for compatibility only, and are not documented here.  New code "
"should use the size-limited E<.Fn snprintf> and E<.Fn vsnprintf> functions "
"instead."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:295
msgid ""
"In E<.Nx 1.5> and earlier, E<.Fn printf> supported more format strings than "
"the user space E<.Fn printf>.  These nonstandard format strings are no "
"longer supported.  For the functionality provided by the former E<.Li %b> "
"format string, see E<.Xr snprintb 3>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:304
msgid ""
"The E<.Fn aprint_normal>, E<.Fn aprint_naive>, E<.Fn aprint_verbose>, and "
"E<.Fn aprint_debug> functions first appeared in E<.Bsx>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kprintf.9:313
msgid ""
"The E<.Fn uprintf> and E<.Fn ttyprintf> functions should be used sparingly, "
"if at all.  Where multiple lines of output are required to reach a process's "
"controlling terminal, E<.Fn tprintf> is preferred."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/kthread.9:30
#, no-wrap
msgid "August 7, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/kthread.9:31
#, no-wrap
msgid "KTHREAD 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:38
msgid ""
"E<.Nm kthread_create>, E<.Nm kthread_destroy>, E<.Nm kthread_exit>, E<.Nm "
"kthread_join>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/kthread.9:38
#, no-wrap
msgid "kernel threads"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/kthread.9:40
#, no-wrap
msgid "sys/kthread.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:50
msgid ""
"E<.Ft int> E<.Fn kthread_create \"pri_t pri\" \"int flags\" \"struct "
"cpu_info *ci\" \"void (*func)(void *)\" \"void *arg\" \"lwp_t **newlp\" "
"\"const char *fmt\" \"...\"> E<.Ft void> E<.Fn kthread_destroy \"lwp_t *l\"> "
"E<.Ft void> E<.Fn kthread_exit \"int ecode\"> E<.Ft int> E<.Fn kthread_join "
"\"lwp_t *l\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:53
msgid ""
"Kernel threads are light-weight processes which execute entirely within the "
"kernel."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:57
msgid ""
"Any process can request the creation of a new kernel thread.  Kernel threads "
"are not swapped out during memory congestion.  The VM space and limits are "
"shared with proc0 (usually swapper)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kthread.9:59
#, no-wrap
msgid "Fn kthread_create pri flags ci func arg newlp fmt ..."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:62
msgid "Create a kernel thread.  The arguments are as follows."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kthread.9:63
#, no-wrap
msgid "Fa pri"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:70
msgid ""
"Priority level for the thread.  If no priority level is desired specify "
"E<.Dv PRI_NONE>, causing E<.Fn kthread_create> to select the default "
"priority level."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:72
msgid "Flags that can be logically ORed together to alter the thread's behaviour."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kthread.9:72
#, no-wrap
msgid "Fa ci"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:79
msgid ""
"If E<.No non- Ns Dv NULL>, the thread will be created bound to the CPU "
"specified by E<.Fa ci>, meaning that it will only ever execute on that CPU.  "
"By default, the threads are free to execute on any CPU in the system."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kthread.9:79 org_netbsd/src/share/man/man9/workqueue.9:68
#, no-wrap
msgid "Fa func"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:85
msgid ""
"A function to be called when the thread begins executing.  This function "
"must not return.  If the thread runs to completion, it must call E<.Fn "
"kthread_exit> to properly terminate itself."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kthread.9:85 org_netbsd/src/share/man/man9/pool_cache.9:223 org_netbsd/src/share/man/man9/secmodel.9:153 org_netbsd/src/share/man/man9/vmem.9:150 org_netbsd/src/share/man/man9/workqueue.9:71
#, no-wrap
msgid "Fa arg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:91
msgid ""
"An argument to be passed to E<.Fn func>.  May be E<.Dv NULL> if not "
"required."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kthread.9:91
#, no-wrap
msgid "Fa newlp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:99
msgid ""
"A pointer to receive the new LWP structure for the kernel thread.  May be "
"E<.Dv NULL>, unless E<.Dv KTHREAD_MUSTJOIN> is specified in E<.Fa flags>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kthread.9:99
#, no-wrap
msgid "Fa fmt"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:104
msgid ""
"A string containing format information used to display the kernel thread "
"name.  Must not be E<.Dv NULL>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:109
msgid "The following E<.Va flags> are defined."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kthread.9:110
#, no-wrap
msgid "Dv KTHREAD_IDLE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:117
msgid ""
"Causes the thread to be created in the E<.Dv LSIDL> (idle) state.  By "
"default, the threads are created in the E<.Dv LSRUN> (runnable) state, "
"meaning they will begin execution shortly after creation."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kthread.9:117
#, no-wrap
msgid "Dv KTHREAD_MPSAFE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:121
msgid ""
"Specifies that the thread does its own locking and so is multiprocessor "
"safe.  If not specified, the global kernel lock will be held whenever the "
"thread is running (unless explicitly dropped by the thread)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kthread.9:121
#, no-wrap
msgid "Dv KTHREAD_INTR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:125
msgid ""
"Specifies that the thread services device interrupts.  This flag is intended "
"for kernel internal use and should not normally be specified."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kthread.9:125
#, no-wrap
msgid "Dv KTHREAD_TS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:141
msgid ""
"Causes the kthread to be created in the E<.Dv SCHED_OTHER> class "
"(timeshared).  The thread's priority will be dynamically adjusted by the "
"scheduler.  Increased activity by the kthread will cause its priority to "
"fall; decreased activity will cause its priority to rise.  By default, "
"kthreads are created in the E<.Dv SCHED_RR> class, with a fixed priority "
"specified by E<.Ar pri>.  Threads in the E<.Dv SCHED_RR> class do not have "
"their priority dynamically adjusted by the scheduler."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kthread.9:141
#, no-wrap
msgid "Dv KTHREAD_MUSTJOIN"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:148
msgid ""
"Indicates that created kthread must be joined.  In such case E<.Fn "
"kthread_exit> will wait until E<.Fn kthread_join> will be called."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kthread.9:149
#, no-wrap
msgid "Fn kthread_destroy l"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:154
msgid ""
"From another thread executing in the kernel, cause a kthread to exit.  The "
"kthread must be in the E<.Dv LSIDL> (idle) state."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kthread.9:154
#, no-wrap
msgid "Fn kthread_exit ecode"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:157
msgid "Exit from a kernel thread.  Must only be called by a kernel thread."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/kthread.9:157
#, no-wrap
msgid "Fn kthread_join l"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:166
msgid ""
"Suspend execution of calling thread until the target kthread terminates.  "
"Conceptually the function can be compared to the user space E<.Xr "
"pthread_join 3>, however it must be called only once for kernel thread which "
"was created using the E<.Dv KTHREAD_MUSTJOIN> flag and would wait on E<.Fa "
"kthread_exit>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:172
msgid ""
"Upon successful completion, E<.Fn kthread_create> returns 0.  Otherwise, the "
"following error values are returned:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:186
msgid ""
"The kthread framework itself is implemented within the file E<.Pa "
"sys/kern/kern_kthread.c>.  Data structures and function prototypes for the "
"framework are located in E<.Pa sys/sys/kthread.h>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:191
msgid "E<.Xr condvar 9>, E<.Xr driver 9>, E<.Xr softint 9>, E<.Xr workqueue 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/kthread.9:193
msgid "The kthread framework appeared in E<.Nx 1.4>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/linedisc.9:35
#, no-wrap
msgid "November 1, 2000"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/linedisc.9:36
#, no-wrap
msgid "LINEDISC 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/linedisc.9:43
msgid ""
"E<.Nm linedisc>, E<.Nm ttyldisc_add>, E<.Nm ttyldisc_lookup>, E<.Nm "
"ttyldisc_remove>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/linedisc.9:43
#, no-wrap
msgid "extensible line discipline framework"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/linedisc.9:45
#, no-wrap
msgid "sys/conf.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/linedisc.9:52
msgid ""
"E<.Ft int> E<.Fn ttyldisc_add \"struct linesw *disc\" \"int no\"> E<.Ft "
"struct linesw *> E<.Fn ttyldisc_remove \"const char *name\"> E<.Ft struct "
"linesw *> E<.Fn ttyldisc_lookup \"const char *name\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/linedisc.9:60
msgid ""
"The E<.Nx> TTY line discipline framework allows extensibility.  Modules that "
"need special line disciplines can add them as convenient and do not need to "
"modify tty_conf.c.  Line disciplines are now managed by a string, rather "
"than number."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/linedisc.9:66
msgid ""
"Once the framework has been initialized, a new line discipline can be added "
"by creating and initializing a E<.Fa struct linesw> and calling E<.Fn "
"ttyldisc_add>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/linedisc.9:69
#, no-wrap
msgid "Fn ttyldisc_add"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/linedisc.9:81
msgid ""
"Register a line discipline.  The E<.Fa l_name> field of the E<.Fa struct "
"linesw> should point to a string which is to be the symbolic name of that "
"line discipline.  For compatibility purposes, a line discipline number can "
"be passed in E<.Fa no>, but for new disciplines this should be set to E<.Dv "
"-1>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/linedisc.9:81
#, no-wrap
msgid "Fn ttyldisc_lookup"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/linedisc.9:86
msgid ""
"Look up a line discipline by E<.Fa name>.  E<.Dv NULL> is returned if it can "
"not be found."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/linedisc.9:86
#, no-wrap
msgid "Fn ttyldisc_remove"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/linedisc.9:94
msgid ""
"Remove a line discipline called E<.Fa name> and return a pointer to it.  If "
"the discipline cannot be found or removed E<.Fn ttyldisc_remove> will return "
"E<.Dv NULL>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/linedisc.9:97
msgid "E<.Xr tty 4>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/linedisc.9:102
msgid "The E<.Nm> functions were added in E<.Nx 1.6>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/linedisc.9:107
msgid ""
"The E<.Nx> extensible line discipline framework was created by E<.An Eduardo "
"Horvath> E<.Aq eeh@NetBSD.org>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/lock.9:27
#, no-wrap
msgid "January 30, 2008"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/lock.9:28
#, no-wrap
msgid "LOCK 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/lock.9:44
msgid ""
"E<.Nm lock>, E<.Nm simple_lock_init>, E<.Nm simple_lock>, E<.Nm "
"simple_lock_try>, E<.Nm simple_unlock>, E<.Nm simple_lock_freecheck>, E<.Nm "
"simple_lock_dump>, E<.Nm lockinit>, E<.Nm lockmgr>, E<.Nm lockstatus>, E<.Nm "
"lockmgr_printinfo>, E<.Nm spinlockinit>, E<.Nm spinlockmgr>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/lock.9:44
#, no-wrap
msgid "kernel lock functions"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/lock.9:47
msgid "These interfaces have been obsoleted and removed from the system."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/lock.9:54
msgid ""
"Please see the E<.Xr condvar 9>, E<.Xr mutex 9>, and E<.Xr rwlock 9> manual "
"pages for information on kernel synchronisation primitives."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/lock.9:58
msgid "E<.Xr condvar 9>, E<.Xr mutex 9>, E<.Xr rwlock 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/lock.9:62
msgid ""
"The kernel locking API first appeared in E<.Bx 4.4 Ns -lite2>, and was "
"replaced in E<.Nx 5.0>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/log.9:30
#, no-wrap
msgid "May 12, 1997"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/log.9:31
#, no-wrap
msgid "LOG 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/log.9:35
msgid "E<.Nm log>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/log.9:35
#, no-wrap
msgid "log a message from the kernel through the"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/log.9:38
msgid "E<.Pa /dev/klog> device"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/log.9:39
#, no-wrap
msgid "sys/syslog.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/log.9:46
msgid ""
"E<.Ft void> E<.Fo \"log\"> E<.Fa \"int level\"> E<.Fa \"const char "
"*format\"> E<.Fa \"...\"> E<.Fc>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/log.9:57
msgid ""
"The E<.Fn log> function allows the kernel to send messages to user processes "
"listening on E<.Pa /dev/klog>.  Usually E<.Xr syslogd 8> monitors E<.Pa "
"/dev/klog> for these messages and writes them to a log file."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/log.9:63
msgid ""
"All messages are logged using facility E<.Dv LOG_KERN>.  See E<.Xr syslog 3> "
"for a listing of log levels."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/log.9:65
msgid "E<.Xr syslog 3>, E<.Xr syslogd 8>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/ltsleep.9:30
#, no-wrap
msgid "January 28, 2012"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/ltsleep.9:31
#, no-wrap
msgid "LTSLEEP 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ltsleep.9:37
msgid "E<.Nm ltsleep>, E<.Nm tsleep>, E<.Nm wakeup>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/ltsleep.9:37
#, no-wrap
msgid "process context sleep and wakeup"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ltsleep.9:44
msgid ""
"E<.Ft int> E<.Fn \"tsleep\" \"wchan_t ident\" \"pri_t priority\" \"const "
"char *wmesg\" \"int timo\"> E<.Ft void> E<.Fn \"wakeup\" \"wchan_t ident\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ltsleep.9:47
msgid ""
"E<.Em The interfaces described in this manual page are obsolete> E<.Em and "
"will be removed from a future version of the system.>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ltsleep.9:51
msgid ""
"E<.Em The> E<.Em Fn ltsleep> E<.Em interface has been obsoleted and removed "
"from the system.>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ltsleep.9:58
msgid ""
"E<.Em Please see the> E<.Xr condvar 9>, E<.Xr mutex 9>, E<.Em and> E<.Xr "
"rwlock 9> E<.Em manual pages for information on kernel synchronisation "
"primitives.>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ltsleep.9:63
msgid ""
"These functions implement voluntary context switching.  E<.Fn tsleep> is "
"used throughout the kernel whenever processing in the current context can "
"not continue for any of the following reasons:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ltsleep.9:66
msgid "The current process needs to await the results of a pending I/O operation."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ltsleep.9:70
msgid ""
"The current process needs resources E<.Pq e.g., memory> which are "
"temporarily unavailable."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ltsleep.9:73
msgid ""
"The current process wants access to data-structures which are locked by "
"other processes."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ltsleep.9:83
msgid ""
"The function E<.Fn wakeup> is used to notify sleeping processes of possible "
"changes to the condition that caused them to go to sleep.  Typically, an "
"awakened process will -- after it has acquired a context again -- retry the "
"action that blocked its operation to see if the E<.Dq blocking> condition "
"has cleared."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ltsleep.9:87
msgid "The E<.Fn tsleep> function takes the following arguments:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ltsleep.9:88
#, no-wrap
msgid "Fa ident"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ltsleep.9:100
msgid ""
"An identifier of the E<.Dq wait channel> representing the resource for which "
"the current process needs to wait.  This typically is the virtual address of "
"some kernel data-structure related to the resource for which the process is "
"contending.  The same identifier must be used in a call to E<.Fn wakeup> to "
"get the process going again.  E<.Fa ident> should not be E<.Dv NULL>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ltsleep.9:100
#, no-wrap
msgid "Fa priority"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ltsleep.9:111
msgid ""
"The process priority to be used when the process is awakened and put on the "
"queue of runnable processes.  This mechanism is used to optimize E<.Dq "
"throughput> of processes executing in kernel mode.  If the flag E<.Dv "
"PCATCH> is OR'ed into E<.Fa priority> the process checks for posted signals "
"before and after sleeping."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ltsleep.9:117
msgid ""
"A pointer to a character string indicating the reason a process is "
"sleeping.  The kernel does not use the string, but makes it available E<.Pq "
"through the process structure field Li p_wmesg> for user level utilities "
"such as E<.Xr ps 1>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ltsleep.9:117
#, no-wrap
msgid "Fa timo"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ltsleep.9:129
msgid ""
"If non-zero, the process will sleep for at most E<.Li timo/hz> seconds.  If "
"this amount of time elapses and no E<.Fn wakeup \"ident\"> has occurred, and "
"no signal E<.Pq if Dv PCATCH No was set> was posted, E<.Fn tsleep> will "
"return E<.Er EWOULDBLOCK>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ltsleep.9:150
msgid ""
"The E<.Fn wakeup> function will mark all processes which are currently "
"sleeping on the identifier E<.Fa ident> as runnable.  Eventually, each of "
"the processes will resume execution in the kernel context, causing a return "
"from E<.Fn tsleep>.  Note that processes returning from sleep should always "
"re-evaluate the conditions that blocked them, since a call to E<.Fn wakeup> "
"merely signals a E<.Em possible> change to the blocking conditions.  For "
"example, when two or more processes are waiting for an exclusive-access lock "
"E<.Pq see Xr lock 9>, only one of them will succeed in acquiring the lock "
"when it is released.  All others will have to go back to sleep and wait for "
"the next opportunity."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ltsleep.9:169
msgid ""
"E<.Fn tsleep> returns 0 if it returns as a result of a E<.Fn wakeup>.  If a "
"E<.Fn tsleep> returns as a result of a signal, the return value is E<.Er "
"ERESTART> if the signal has the E<.Dv SA_RESTART> property E<.Pq see Xr "
"sigaction 2>, and E<.Er EINTR> otherwise.  If E<.Fn tsleep> returns because "
"of a timeout it returns E<.Er EWOULDBLOCK>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ltsleep.9:176
msgid ""
"E<.Xr sigaction 2>, E<.Xr condvar 9>, E<.Xr hz 9>, E<.Xr lock 9>, E<.Xr "
"mutex 9>, E<.Xr rwlock 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ltsleep.9:184
msgid ""
"The sleep/wakeup process synchronization mechanism is very old.  It appeared "
"in a very early version of Unix.  E<.Fn tsleep> appeared in E<.Bx 4.4>.  "
"E<.Fn ltsleep> appeared in E<.Nx 1.5>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/m_tag.9:28
#, no-wrap
msgid "September 7, 2004"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/m_tag.9:29
#, no-wrap
msgid "M_TAG 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/m_tag.9:46
msgid ""
"E<.Nm m_tag>, E<.Nm m_tag_get>, E<.Nm m_tag_free>, E<.Nm m_tag_prepend>, "
"E<.Nm m_tag_unlink>, E<.Nm m_tag_delete>, E<.Nm m_tag_delete_chain>, E<.Nm "
"m_tag_delete_nonpersistent>, E<.Nm m_tag_find>, E<.Nm m_tag_copy>, E<.Nm "
"m_tag_copy_chain>, E<.Nm m_tag_init>, E<.Nm m_tag_first>, E<.Nm m_tag_next>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/m_tag.9:46
#, no-wrap
msgid "mbuf tagging interfaces"
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/m_tag.9:77
msgid ""
"E<.Ft struct m_tag *> E<.Fn m_tag_get \"int type\" \"int len\" \"int wait\"> "
"E<.Ft void> E<.Fn m_tag_free \"struct m_tag *t\"> E<.Ft void> E<.Fn "
"m_tag_prepend \"struct mbuf *m\" \"struct m_tag *t\"> E<.Ft void> E<.Fn "
"m_tag_unlink \"struct mbuf *m\" \"struct m_tag *t\"> E<.Ft void> E<.Fn "
"m_tag_delete \"struct mbuf *m\" \"struct m_tag *t\"> E<.Ft void> E<.Fn "
"m_tag_delete_chain \"struct mbuf *m\" \"struct m_tag *t\"> E<.Ft void> E<.Fn "
"m_tag_delete_nonpersistent \"struct mbuf *\"> E<.Ft struct m_tag *> E<.Fn "
"m_tag_find \"struct mbuf *m\" \"int type\" \"struct m_tag *t\"> E<.Ft struct "
"m_tag *> E<.Fn m_tag_copy \"struct m_tag *m\"> E<.Ft int> E<.Fn "
"m_tag_copy_chain \"struct mbuf *to\" \"struct mbuf *from\"> E<.Ft void> "
"E<.Fn m_tag_init \"struct mbuf *m\"> E<.Ft struct m_tag *> E<.Fn m_tag_first "
"\"struct mbuf *m\"> E<.Ft struct m_tag *> E<.Fn m_tag_next \"struct mbuf "
"*m\" \"struct m_tag *t\">"
msgstr ""

#.  XXX PACKET_TAG_*
#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/m_tag.9:85
msgid "The E<.Nm> interface is used to E<.Dq tag> mbufs."
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: It
#: org_netbsd/src/share/man/man9/m_tag.9:88
#, no-wrap
msgid "Fn m_tag_get type len wait"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/m_tag.9:102
msgid ""
"Allocate an mbuf tag.  E<.Fa type> is one of the E<.Dv PACKET_TAG_> macros.  "
"E<.Fa len> is the size of the data associated with the tag, in bytes.  E<.Fa "
"wait> is either E<.Dv M_WAITOK> or E<.Dv M_NOWAIT>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/m_tag.9:102
#, no-wrap
msgid "Fn m_tag_free t"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/m_tag.9:106
msgid "Free the mbuf tag E<.Fa t>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/m_tag.9:106
#, no-wrap
msgid "Fn m_tag_prepend m t"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/m_tag.9:120
msgid ""
"Prepend the mbuf tag E<.Fa t> to the mbuf E<.Fa m>.  E<.Fa t> will become "
"the first tag of the mbuf E<.Fa m>.  When E<.Fa m> is freed, E<.Fa t> will "
"also be freed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/m_tag.9:120
#, no-wrap
msgid "Fn m_tag_unlink m t"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/m_tag.9:126
msgid "Unlink the mbuf tag E<.Fa t> from the mbuf E<.Fa m>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/m_tag.9:126
#, no-wrap
msgid "Fn m_tag_delete m t"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/m_tag.9:132
msgid "The same as E<.Fn m_tag_unlink> followed by E<.Fn m_tag_free>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/m_tag.9:132
#, no-wrap
msgid "Fn m_tag_delete_chain m t"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/m_tag.9:145
msgid ""
"Unlink and free mbuf tags beginning with the mbuf tag E<.Fa t> from the mbuf "
"E<.Fa m>.  If E<.Fa t> is E<.Dv NULL>, E<.Fn m_tag_delete_chain> unlinks and "
"frees all mbuf tags associated with the mbuf E<.Fa m>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/m_tag.9:145
#, no-wrap
msgid "Fn m_tag_delete_nonpersistent m"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/m_tag.9:149
msgid "Unlink and free all non persistent tags associated with the mbuf E<.Fa m>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/m_tag.9:149
#, no-wrap
msgid "Fn m_tag_find m type t"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/m_tag.9:165
msgid ""
"Find an mbuf tag with type E<.Fa type> after the mbuf tag E<.Fa t> in the "
"tag chain associated with the mbuf E<.Fa m>.  If E<.Fa t> is E<.Dv NULL>, "
"search from the first mbuf tag.  If an mbuf tag is found, return a pointer "
"to it.  Otherwise return E<.Dv NULL>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/m_tag.9:165
#, no-wrap
msgid "Fn m_tag_copy t"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/m_tag.9:172
msgid ""
"Copy an mbuf tag E<.Fa t>.  Return a new mbuf tag on success.  Otherwise "
"return E<.Dv NULL>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/m_tag.9:172
#, no-wrap
msgid "Fn m_tag_copy_chain to from"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/m_tag.9:183
msgid ""
"Copy all mbuf tags associated with the mbuf E<.Fa from> to the mbuf E<.Fa "
"to>.  If E<.Fa to> already has any mbuf tags, they will be unlinked and "
"freed beforehand.  Return 1 on success.  Otherwise return 0."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/m_tag.9:183
#, no-wrap
msgid "Fn m_tag_init m"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/m_tag.9:187
msgid "Initialize mbuf tag chain of the mbuf E<.Fa m>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/m_tag.9:187
#, no-wrap
msgid "Fn m_tag_first m"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/m_tag.9:194
msgid ""
"Return the first mbuf tag associated with the mbuf E<.Fa m>.  Return E<.Dv "
"NULL> if no mbuf tags are found."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/m_tag.9:194
#, no-wrap
msgid "Fn m_tag_next m t"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/m_tag.9:205
msgid ""
"Return the next mbuf tag after E<.Fa t> associated with the mbuf E<.Fa m>.  "
"Return E<.Dv NULL> if E<.Fa t> is the last tag in the chain."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/m_tag.9:210
msgid ""
"The mbuf tagging interfaces are implemented within the file E<.Pa "
"sys/kern/uipc_mbuf2.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/m_tag.9:215
msgid "The E<.Dv PACKET_TAG_> macros are defined in the file E<.Pa sys/sys/mbuf.h>."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/m_tag.9:220
msgid "E<.Xr intro 9>, E<.Xr malloc 9>, E<.Xr mbuf 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/m_tag.9:221
msgid "The semantics of the term \"persistent tag\" are vague."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/makeiplcookie.9:28
#, no-wrap
msgid "December 22, 2006"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/makeiplcookie.9:29
#, no-wrap
msgid "MAKEIPLCOOKIE 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/makeiplcookie.9:34
msgid "E<.Nm makeiplcookie>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/makeiplcookie.9:34
#, no-wrap
msgid "compose an ipl cookie"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/makeiplcookie.9:43
msgid "E<.Ft ipl_cookie_t> E<.Fn makeiplcookie \"ipl_t ipl\">"
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/makeiplcookie.9:52
msgid ""
"E<.Fn makeiplcookie> composes a cookie which can be fed into E<.Fa "
"splraiseipl>.  E<.Fa ipl> should be one of E<.Dv IPL_> constants."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/makeiplcookie.9:56
msgid "E<.Fn makeiplcookie> returns a composed cookie."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/makeiplcookie.9:58
msgid "E<.Xr spl 9>, E<.Xr splraiseipl 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/malloc.9:30
#, no-wrap
msgid "December 29, 2008"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/malloc.9:31
#, no-wrap
msgid "MALLOC 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:46
msgid ""
"E<.Nm malloc>, E<.Nm MALLOC>, E<.Nm realloc>, E<.Nm free>, E<.Nm FREE>, "
"E<.Nm malloc_roundup>, E<.Nm malloc_type_attach>, E<.Nm malloc_type_detach>, "
"E<.Nm malloc_type_setlimit>, E<.Nm MALLOC_DEFINE_LIMIT>, E<.Nm "
"MALLOC_DEFINE>, E<.Nm MALLOC_DECLARE>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/malloc.9:46
#, no-wrap
msgid "general-purpose kernel memory allocator"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:64
msgid ""
"E<.Ft void *> E<.Fn malloc \"unsigned long size\" \"struct malloc_type "
"*type\" \"int flags\"> E<.Ft void *> E<.Fn realloc \"void *addr\" \"unsigned "
"long newsize\" \"struct malloc_type *type\" \"int flags\"> E<.Ft void> E<.Fn "
"free \"void *addr\" \"struct malloc_type *type\"> E<.Ft unsigned long> E<.Fn "
"malloc_roundup \"unsigned long size\"> E<.Ft void> E<.Fn malloc_type_attach "
"\"struct malloc_type *type\"> E<.Ft void> E<.Fn malloc_type_detach \"struct "
"malloc_type *type\"> E<.Ft void> E<.Fn malloc_type_setlimit \"struct "
"malloc_type *type\" \"unsigned long limit\">"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/malloc.9:64
#, no-wrap
msgid "sys/mallocvar.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:70
msgid ""
"E<.Fn MALLOC_DEFINE_LIMIT \"type\" \"shortdesc\" \"longdesc\" \"limit\"> "
"E<.Fn MALLOC_JUSTDEFINE_LIMIT \"type\" \"shortdesc\" \"longdesc\" \"limit\"> "
"E<.Fn MALLOC_DEFINE \"type\" \"shortdesc\" \"longdesc\"> E<.Fn "
"MALLOC_JUSTDEFINE \"type\" \"shortdesc\" \"longdesc\"> E<.Fn MALLOC_DECLARE "
"\"type\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:79
msgid ""
"E<.Bf -symbolic> These interfaces are being obsoleted and their new use is "
"discouraged.  For new code, use E<.Xr kmem 9> or E<.Xr pool_cache 9> "
"instead.  E<.Ef>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:100
msgid ""
"The E<.Fn malloc> function allocates uninitialized memory in kernel address "
"space for an object whose size is specified by E<.Fa size>.  E<.Fn "
"malloc_roundup> returns the actual size of the allocation unit for the given "
"value.  E<.Fn free> releases memory at address E<.Fa addr> that was "
"previously allocated by E<.Fn malloc> for re-use.  Unlike E<.Xr free 3>, "
"E<.Fn free> does not accept an E<.Fa addr> argument that is E<.Dv NULL>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:132
msgid ""
"The E<.Fn realloc> function changes the size of the previously allocated "
"memory referenced by E<.Fa addr> to E<.Fa size> and returns a pointer to the "
"E<.Pq possibly moved> object.  The memory contents are unchanged up to the "
"lesser of the new and old sizes.  If the new size is larger, the newly "
"allocated memory is uninitialized.  If the requested memory cannot be "
"allocated, E<.Dv NULL> is returned and the memory referenced by E<.Fa addr> "
"is unchanged.  If E<.Fa addr> is E<.Dv NULL>, then E<.Fn realloc> behaves "
"exactly as E<.Fn malloc>.  If the new size is 0, then E<.Fn realloc> behaves "
"exactly as E<.Fn free>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:136
msgid ""
"Unlike its standard C library counterpart E<.Pq Xr malloc 3>, the kernel "
"version takes two more arguments."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:142
msgid ""
"The E<.Fa flags> argument further qualifies E<.Fn malloc> operational "
"characteristics as follows:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/malloc.9:143
#, no-wrap
msgid "Dv M_NOWAIT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:155
msgid ""
"Causes E<.Fn malloc> to return E<.Dv NULL> if the request cannot be "
"immediately fulfilled due to resource shortage.  If this flag is not set "
"(see E<.Dv M_WAITOK>), E<.Fn malloc> will never return E<.Dv NULL>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/malloc.9:155
#, no-wrap
msgid "Dv M_WAITOK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:167
msgid ""
"By default, E<.Fn malloc> may call E<.Xr cv_wait 9> to wait for resources to "
"be released by other processes, and this flag represents this behaviour.  "
"Note that E<.Dv M_WAITOK> is conveniently defined to be 0, and hence may be "
"or'ed into the E<.Fa flags> argument to indicate that it's ok to wait for "
"resources."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/malloc.9:167
#, no-wrap
msgid "Dv M_ZERO"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:169
msgid "Causes the allocated memory to be set to all zeros."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/malloc.9:169
#, no-wrap
msgid "Dv M_CANFAIL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:178
msgid ""
"Changes behaviour for E<.Dv M_WAITOK> case - if the requested memory size is "
"bigger than E<.Fn malloc> can ever allocate, return failure, rather than "
"calling E<.Xr panic 9>.  This is different to M_NOWAIT, since the call can "
"still wait for resources."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:185
msgid ""
"Rather than depending on E<.Dv M_CANFAIL>, kernel code should do proper "
"bound checking itself.  This flag should only be used in cases where this is "
"not feasible.  Since it can hide real kernel bugs, its usage is E<.Em "
"strongly discouraged>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:193
msgid ""
"The E<.Fa type> argument describes the subsystem and/or use within a "
"subsystem for which the allocated memory was needed, and is commonly used to "
"maintain statistics about kernel memory usage and, optionally, enforce "
"limits on this usage for certain memory types."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:196
msgid ""
"In addition to some built-in generic types defined by the kernel memory "
"allocator, subsystems may define their own types."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:214
msgid ""
"The E<.Fn MALLOC_DEFINE_LIMIT> macro defines a malloc type named E<.Fa type> "
"with the short description E<.Fa shortdesc>, which must be a constant "
"string; this description will be used for kernel memory statistics "
"reporting.  The E<.Fa longdesc> argument, also a constant string, is "
"intended as way to place a comment in the actual type definition, and is not "
"currently stored in the type structure.  The E<.Fa limit> argument specifies "
"the maximum amount of memory, in bytes, that this malloc type can consume."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:224
msgid ""
"The E<.Fn MALLOC_DEFINE> macro is equivalent to the E<.Fn "
"MALLOC_DEFINE_LIMIT> macro with a E<.Fa limit> argument of 0.  If kernel "
"memory statistics are being gathered, the system will choose a reasonable "
"default limit for the malloc type."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:230
msgid ""
"The E<.Fn MALLOC_DECLARE> macro is intended for use in header files which "
"are included by code which needs to use the malloc type, providing the "
"necessary extern declaration."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:241
msgid ""
"Code which includes \\*[Lt]sys/malloc.h\\*[Gt] does not need to include "
"\\*[Lt]sys/mallocvar.h\\*[Gt] to get these macro definitions.  The "
"\\*[Lt]sys/mallocvar.h\\*[Gt] header file is intended for other header files "
"which need to use the E<.Fn MALLOC_DECLARE> macro."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:247
msgid ""
"The E<.Fn malloc_type_attach> function attaches the malloc type E<.Fa type> "
"to the kernel memory allocator."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:254
msgid ""
"The E<.Fn malloc_type_detach> function detaches the malloc type E<.Fa type> "
"previously attached with E<.Fn malloc_type_attach>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:263
msgid ""
"The E<.Fn malloc_type_setlimit> function sets the memory limit of the malloc "
"type E<.Fa type> to E<.Fa limit> bytes.  The type must already be registered "
"with the kernel memory allocator."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:265
msgid "The following generic malloc types are currently defined:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/malloc.9:267
#, no-wrap
msgid "Dv M_DEVBUF"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:269
msgid "Device driver memory."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/malloc.9:269
#, no-wrap
msgid "Dv M_DMAMAP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:272
msgid "E<.Xr bus_dma 9> structures."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/malloc.9:272
#, no-wrap
msgid "Dv M_FREE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:274
msgid "Should be on free list."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/malloc.9:274
#, no-wrap
msgid "Dv M_PCB"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:276
msgid "Protocol control block."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/malloc.9:276
#, no-wrap
msgid "Dv M_SOFTINTR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:278
msgid "Softinterrupt structures."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/malloc.9:278
#, no-wrap
msgid "Dv M_TEMP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:280
msgid "Misc temporary data buffers."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:285
msgid ""
"Other malloc types are defined by the corresponding subsystem; see the "
"documentation for that subsystem for information its available malloc types."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:298
msgid ""
"Statistics based on the E<.Fa type> argument are maintained only if the "
"kernel option E<.Dv KMEMSTATS> is used when compiling the kernel E<.Po> the "
"default in current E<.Nx> kernels E<.Pc> and can be examined by using E<.Sq "
"vmstat -m>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:302
msgid ""
"E<.Fn malloc> returns a kernel virtual address that is suitably aligned for "
"storage of any type of object."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:312
msgid ""
"A kernel compiled with the E<.Dv DIAGNOSTIC> configuration option attempts "
"to detect memory corruption caused by such things as writing outside the "
"allocated area and imbalanced calls to the E<.Fn malloc> and E<.Fn free> "
"functions.  Failing consistency checks will cause a panic or a system "
"console message:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:317
msgid "panic: E<.Dq malloc - bogus type>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:320
msgid "panic: E<.Dq malloc: out of space in kmem_map>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:323
msgid "panic: E<.Dq malloc: allocation too large>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:326
msgid "panic: E<.Dq malloc: wrong bucket>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:329
msgid "panic: E<.Dq malloc: lost data>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:332
msgid "panic: E<.Dq free: unaligned addr>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:335
msgid "panic: E<.Dq free: duplicated free>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:338
msgid "panic: E<.Dq free: multiple frees>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:341
msgid "panic: E<.Dq init: minbucket too small/struct freelist too big>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:343
msgid "E<.Dq multiply freed item Aq addr>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:345
msgid "E<.Dq Data modified on freelist: Aq data object description>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/malloc.9:348
msgid "E<.Xr vmstat 1>, E<.Xr memoryallocators 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/mb.9:30
#, no-wrap
msgid "January 2, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/mb.9:31
#, no-wrap
msgid "MB 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mb.9:38
msgid "E<.Nm mb>, E<.Nm mb_memory>, E<.Nm mb_read>, E<.Nm mb_write>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/mb.9:38
#, no-wrap
msgid "memory barriers"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/mb.9:40 org_netbsd/src/share/man/man9/vnsubr.9:49
#, no-wrap
msgid "sys/lock.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mb.9:47
msgid ""
"E<.Ft void> E<.Fn mb_memory \"void\"> E<.Ft void> E<.Fn mb_read \"void\"> "
"E<.Ft void> E<.Fn mb_write \"void\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mb.9:53
msgid ""
"Many types of processor can execute instructions in a different order than "
"issued by the compiler or assembler.  On a uniprocessor system, out of order "
"execution is transparent to the programmer, operating system and "
"applications, as the processor must ensure that it is self consistent."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mb.9:59
msgid ""
"On multiprocessor systems, out of order execution can present a problem "
"where locks are not used to guarantee atomicity of access, because loads and "
"stores issued by any given processor can appear on the system bus (and thus "
"appear to other processors)  in an unpredictable order."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mb.9:70
msgid ""
"E<.Fn mb_memory>, E<.Fn mb_read>, and E<.Fn mb_write> can be used to control "
"the order in which memory accesses occur, and thus the order in which those "
"accesses become visible to other processors.  They can be used to implement "
"E<.Dq lockless> access to data structures where the necessary barrier "
"conditions are well understood."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mb.9:76
msgid ""
"Memory barriers can be computationally expensive, as they are considered "
"E<.Dq serializing> operations and may stall further execution until the "
"processor has drained internal buffers and re-synchronized."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mb.9:80
msgid ""
"The memory barrier primitives control only the order of memory access.  They "
"provide no guarantee that stores have been flushed to the bus, or that loads "
"have been made from the bus."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mb.9:90
msgid ""
"The memory barrier primitives are guaranteed only to prevent reordering of "
"accesses to main memory.  They do not provide any guarantee of ordering when "
"used with device memory (for example, loads or stores to or from a PCI "
"device).  To guarantee ordering of access to device memory, the E<.Xr "
"bus_dma 9> and E<.Xr bus_space 9> interfaces should be used."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mb.9:92
#, no-wrap
msgid "Fn mb_memory \"\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mb.9:97
msgid ""
"Issue a full memory barrier, ordering all memory accesses.  Causes all loads "
"and stores preceding the call to E<.Fn mb_memory> to complete before further "
"memory accesses can be made."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mb.9:97
#, no-wrap
msgid "Fn mb_read \"\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mb.9:104
msgid ""
"Issue a read memory barrier, ordering all loads from memory.  Causes all "
"loads preceding the call to E<.Fn mb_read> to complete before further loads "
"can be made.  Stores may be reordered ahead of or behind a call to E<.Fn "
"mb_read>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mb.9:104
#, no-wrap
msgid "Fn mb_write \"\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mb.9:111
msgid ""
"Issue a write memory barrier, ordering all stores to memory.  Causes all "
"stores preceding the call to E<.Fn mb_write> to complete before further "
"stores can be made.  Loads may be reordered ahead of or behind a call to "
"E<.Fn mb_write>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mb.9:118
msgid ""
"E<.Xr __insn_barrier 3>, E<.Xr bus_dma 9>, E<.Xr bus_space 9>, E<.Xr mutex "
"9>, E<.Xr rwlock 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mb.9:120
msgid "The memory barrier primitives first appeared in E<.Nx 5.0>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/mbuf.9:30
#, no-wrap
msgid "March 24, 2008"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/mbuf.9:31
#, no-wrap
msgid "MBUF 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:70
msgid ""
"E<.Nm mbuf>, E<.Nm m_get>, E<.Nm m_getclr>, E<.Nm m_gethdr>, E<.Nm "
"m_devget>, E<.Nm m_copym>, E<.Nm m_copypacket>, E<.Nm m_copydata>, E<.Nm "
"m_copyback>, E<.Nm m_copyback_cow>, E<.Nm m_cat>, E<.Nm m_dup>, E<.Nm "
"m_makewritable>, E<.Nm m_prepend>, E<.Nm m_pulldown>, E<.Nm m_pullup>, E<.Nm "
"m_split>, E<.Nm m_adj>, E<.Nm m_apply>, E<.Nm m_free>, E<.Nm m_freem>, E<.Nm "
"mtod>, E<.Nm MGET>, E<.Nm MGETHDR>, E<.Nm MEXTMALLOC>, E<.Nm MEXTADD>, E<.Nm "
"MCLGET>, E<.Nm M_COPY_PKTHDR>, E<.Nm M_MOVE_PKTHDR>, E<.Nm M_ALIGN>, E<.Nm "
"MH_ALIGN>, E<.Nm M_LEADINGSPACE>, E<.Nm M_TRAILINGSPACE>, E<.Nm M_PREPEND>, "
"E<.Nm MCHTYPE>, E<.Nm MFREE>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/mbuf.9:70
#, no-wrap
msgid "functions and macros for managing memory used by networking code"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:143
msgid ""
"E<.Ft struct mbuf *> E<.Fn m_get \"int nowait\" \"int type\"> E<.Ft struct "
"mbuf *> E<.Fn m_getclr \"int nowait\" \"int type\"> E<.Ft struct mbuf *> "
"E<.Fn m_gethdr \"int nowait\" \"int type\"> E<.Ft struct mbuf *> E<.Fn "
"m_devget \"char *buf\" \"int totlen\" \"int off0\" \"struct ifnet *ifp\" "
"\"void (*copy)(const void *, void *, size_t)\"> E<.Ft struct mbuf *> E<.Fn "
"m_copym \"struct mbuf *m\" \"int off0\" \"int len\" \"int wait\"> E<.Ft "
"struct mbuf *> E<.Fn m_copypacket \"struct mbuf *m\" \"int how\"> E<.Ft "
"void> E<.Fn m_copydata \"struct mbuf *m\" \"int off\" \"int len\" \"void "
"*cp\"> E<.Ft void> E<.Fn m_copyback \"struct mbuf *m0\" \"int off\" \"int "
"len\" \"void *cp\"> E<.Ft struct mbuf *> E<.Fn m_copyback_cow \"struct mbuf "
"*m0\" \"int off\" \"int len\" \"void *cp\" \"int how\"> E<.Ft int> E<.Fn "
"m_makewritable \"struct mbuf **mp\" \"int off\" \"int len\" \"int how\"> "
"E<.Ft void> E<.Fn m_cat \"struct mbuf *m\" \"struct mbuf *n\"> E<.Ft struct "
"mbuf *> E<.Fn m_dup \"struct mbuf *m\" \"int off0\" \"int len\" \"int "
"wait\"> E<.Ft struct mbuf *> E<.Fn m_prepend \"struct mbuf *m\" \"int len\" "
"\"int how\"> E<.Ft struct mbuf *> E<.Fn m_pulldown \"struct mbuf *m\" \"int "
"off\" \"int len\" \"int *offp\"> E<.Ft struct mbuf *> E<.Fn m_pullup "
"\"struct mbuf *n\" \"int len\"> E<.Ft struct mbuf *> E<.Fn m_split \"struct "
"mbuf *m0\" \"int len0\" \"int wait\"> E<.Ft void> E<.Fn m_adj \"struct mbuf "
"*mp\" \"int req_len\"> E<.Ft int> E<.Fn m_apply \"struct mbuf *m\" \"int "
"off\" \"int len\" \"int *f(void *, void *, unsigned int)\" \"void *arg\"> "
"E<.Ft struct mbuf *> E<.Fn m_free \"struct mbuf *m\"> E<.Ft void> E<.Fn "
"m_freem \"struct mbuf *m\"> E<.Ft datatype> E<.Fn mtod \"struct mbuf *m\" "
"\"datatype\"> E<.Ft void> E<.Fn MGET \"struct mbuf *m\" \"int how\" \"int "
"type\"> E<.Ft void> E<.Fn MGETHDR \"struct mbuf *m\" \"int how\" \"int "
"type\"> E<.Ft void> E<.Fn MEXTMALLOC \"struct mbuf *m\" \"int len\" \"int "
"how\"> E<.Ft void> E<.Fn MEXTADD \"struct mbuf *m\" \"void *buf\" \"int "
"size\" \"int type\" \"void (*free)(struct mbuf *, void *, size_t, void *)\" "
"\"void *arg\"> E<.Ft void> E<.Fn MCLGET \"struct mbuf *m\" \"int how\"> "
"E<.Ft void> E<.Fn M_COPY_PKTHDR \"struct mbuf *to\" \"struct mbuf *from\"> "
"E<.Ft void> E<.Fn M_MOVE_PKTHDR \"struct mbuf *to\" \"struct mbuf *from\"> "
"E<.Ft void> E<.Fn M_ALIGN \"struct mbuf *m\" \"int len\"> E<.Ft void> E<.Fn "
"MH_ALIGN \"struct mbuf *m\" \"int len\"> E<.Ft int> E<.Fn M_LEADINGSPACE "
"\"struct mbuf *m\"> E<.Ft int> E<.Fn M_TRAILINGSPACE \"struct mbuf *m\"> "
"E<.Ft void> E<.Fn M_PREPEND \"struct mbuf *m\" \"int plen\" \"int how\"> "
"E<.Ft void> E<.Fn MCHTYPE \"struct mbuf *m\" \"int type\"> E<.Ft void> E<.Fn "
"MFREE \"struct mbuf *m\" \"struct mbuf *n\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:165
msgid ""
"The E<.Nm> functions and macros provide an easy and consistent way to handle "
"a networking stack's memory management needs.  An E<.Nm> consists of a "
"header and a data area.  It is of a fixed size, E<.Dv MSIZE> E<.Pq defined "
"in Aq Pa machine/param.h>, which includes overhead.  The header contains a "
"pointer to the next E<.Nm> in the E<.Sq \"mbuf chain\">, a pointer to the "
"next E<.Sq \"mbuf chain\">, a pointer to the data area, the amount of data "
"in this mbuf, its type and a E<.Dv flags> field."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:169
msgid "The E<.Dv type> variable can signify:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:170
#, no-wrap
msgid "Dv MT_FREE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:172
msgid "the mbuf should be on the ``free'' list"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:172
#, no-wrap
msgid "Dv MT_DATA"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:174
msgid "data was dynamically allocated"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:174
#, no-wrap
msgid "Dv MT_HEADER"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:176
msgid "data is a packet header"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:176
#, no-wrap
msgid "Dv MT_SONAME"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:178
msgid "data is a socket name"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:178
#, no-wrap
msgid "Dv MT_SOOPTS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:180
msgid "data is socket options"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:180
#, no-wrap
msgid "Dv MT_FTABLE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:182
msgid "data is the fragment reassembly header"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:182
#, no-wrap
msgid "Dv MT_CONTROL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:184
msgid "mbuf contains ancillary \\&(protocol control\\&) data"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:184
#, no-wrap
msgid "Dv MT_OOBDATA"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:186
msgid "mbuf contains out-of-band data."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:193
msgid ""
"The E<.Dv flags> variable contains information describing the E<.Nm>, "
"notably:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:194
#, no-wrap
msgid "Dv M_EXT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:196
msgid "has external storage"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:196
#, no-wrap
msgid "Dv M_PKTHDR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:198
msgid "is start of record"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:198
#, no-wrap
msgid "Dv M_EOR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:200
msgid "is end of record"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:200
#, no-wrap
msgid "Dv M_CLUSTER"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:202
msgid "external storage is a cluster."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:212
msgid ""
"If an E<.Nm> designates the start of a record E<.Pq Dv M_PKTHDR>, its E<.Dv "
"flags> field may contain additional information describing the content of "
"the record:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:213
#, no-wrap
msgid "Dv M_BCAST"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:215
msgid "sent/received as link-level broadcast"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:215
#, no-wrap
msgid "Dv M_MCAST"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:217
msgid "sent/received as link-level multicast"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:217
#, no-wrap
msgid "Dv M_LINK0 ,"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:218
#, no-wrap
msgid "Dv M_LINK1 ,"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:219
#, no-wrap
msgid "Dv M_LINK2"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:221
msgid "three link-level specific flags."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:235
msgid ""
"An E<.Nm> may add a single E<.Sq \"mbuf cluster\"> of E<.Dv MCLBYTES> bytes "
"E<.Pq also defined in Aq Pa machine/param.h>, which has no additional "
"overhead and is used instead of the internal data area; this is done when at "
"least E<.Dv MINCLSIZE> bytes of data must be stored."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:241
msgid ""
"When the E<.Dv M_EXT> flag is raised for an mbuf, the external storage area "
"could be shared among multiple mbufs.  Be careful when you attempt to "
"overwrite the data content of the mbuf."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:242
#, no-wrap
msgid "Fn m_get \"int nowait\" \"int type\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:254
msgid ""
"Allocates an mbuf and initializes it to contain internal data.  The E<.Fa "
"nowait> parameter is a choice of E<.Dv M_WAIT / M_DONTWAIT> from caller.  "
"E<.Dv M_WAIT> means the call cannot fail, but may take forever.  The E<.Fa "
"type> parameter is an mbuf type."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:254
#, no-wrap
msgid "Fn m_getclr \"int nowait\" \"int type\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:265
msgid ""
"Allocates an mbuf and initializes it to contain internal data, then zeros "
"the data area.  The E<.Fa nowait> parameter is a choice of E<.Dv M_WAIT / "
"M_DONTWAIT> from caller.  The E<.Fa type> parameter is an mbuf type."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:265
#, no-wrap
msgid "Fn m_gethdr \"int nowait\" \"int type\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:276
msgid ""
"Allocates an mbuf and initializes it to contain a packet header and internal "
"data.  The E<.Fa nowait> parameter is a choice of E<.Dv M_WAIT / M_DONTWAIT> "
"from caller.  The E<.Fa type> parameter is an mbuf type."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:276
#, no-wrap
msgid ""
"Fn m_devget \"char *buf\" \"int totlen\" \"int off0\" \"struct ifnet *ifp\" "
"\"void (*copy)(const void *, void *, size_t)\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:287
msgid ""
"Copies E<.Fa len> bytes from device local memory into mbufs using copy "
"routine E<.Fa copy>.  If parameter E<.Fa off> is non-zero, the packet is "
"supposed to be trailer-encapsulated and E<.Fa off> bytes plus the type and "
"length fields will be skipped before copying.  Returns the top of the mbuf "
"chain it created."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:287
#, no-wrap
msgid "Fn m_copym \"struct mbuf *m\" \"int off0\" \"int len\" \"int wait\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:303
msgid ""
"Creates a copy of an mbuf chain starting E<.Fa off0> bytes from the "
"beginning, continuing for E<.Fa len> bytes.  If the E<.Fa len> requested is "
"E<.Dv M_COPYALL>, the complete mbuf chain will be copied.  The E<.Fa wait> "
"parameter is a choice of E<.Dv M_WAIT / M_DONTWAIT> from caller."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:303
#, no-wrap
msgid "Fn m_copypacket \"struct mbuf *m\" \"int how\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:307
msgid ""
"Copies an entire packet, including header (which must be present).  This "
"function is an optimization of the common case E<.Li m_copym(m, 0, Dv "
"M_COPYALL, Fa how>)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:307
#, no-wrap
msgid "Fn m_copydata \"struct mbuf *m\" \"int off\" \"int len\" \"void *cp\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:317
msgid ""
"Copies E<.Fa len> bytes data from mbuf chain E<.Fa m> into the buffer E<.Fa "
"cp>, starting E<.Fa off> bytes from the beginning."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:317
#, no-wrap
msgid "Fn m_copyback \"struct mbuf *m0\" \"int off\" \"int len\" \"void *cp\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:334
msgid ""
"Copies E<.Fa len> bytes data from buffer E<.Fa cp> back into the mbuf chain "
"E<.Fa m0>, starting E<.Fa off> bytes from the beginning of the chain, "
"extending the mbuf chain if necessary.  E<.Fn m_copyback> can only fail when "
"extending the chain.  The caller should check for this kind of failure by "
"checking the resulting length of the chain in that case.  It is an error to "
"use E<.Fn m_copyback> on read-only mbufs."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:334
#, no-wrap
msgid ""
"Fn m_copyback_cow \"struct mbuf *m0\" \"int off\" \"int len\" \"void *cp\" "
"\"int how\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:368
msgid ""
"Copies E<.Fa len> bytes data from buffer E<.Fa cp> back into the mbuf chain "
"E<.Fa m0> as E<.Fn m_copyback> does.  Unlike E<.Fn m_copyback>, it is safe "
"to use E<.Fn m_copyback_cow> on read-only mbufs.  If needed, E<.Fn "
"m_copyback_cow> automatically allocates new mbufs and adjusts the chain.  On "
"success, it returns a pointer to the resulting mbuf chain, and frees the "
"original mbuf E<.Fa m0>.  Otherwise, it returns E<.Dv NULL>.  The E<.Fa how> "
"parameter is a choice of E<.Dv M_WAIT / M_DONTWAIT> from the caller.  Unlike "
"E<.Fn m_copyback>, extending the mbuf chain isn't supported.  It is an error "
"to attempt to extend the mbuf chain using E<.Fn m_copyback_cow>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:368
#, no-wrap
msgid "Fn m_makewritable \"struct mbuf **mp\" \"int off\" \"int len\" \"int how\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:397
msgid ""
"Rearranges an mbuf chain so that E<.Fa len> bytes from offset E<.Fa off> are "
"writable.  When it meets read-only mbufs, it allocates new mbufs, adjusts "
"the chain as E<.Fn m_copyback_cow> does, and copies the original content "
"into them.  E<.Fn m_makewritable> does E<.Em not> guarantee that all E<.Fa "
"len> bytes at E<.Fa off> are consecutive.  The E<.Fa how> parameter is a "
"choice of E<.Dv M_WAIT / M_DONTWAIT> from the caller.  E<.Fn m_makewritable> "
"preserves the contents of the mbuf chain even in the case of failure.  It "
"updates a pointer to the mbuf chain pointed to by E<.Fa mp>.  It returns 0 "
"on success.  Otherwise, it returns an error code, typically E<.Er ENOBUFS>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:397
#, no-wrap
msgid "Fn m_cat \"struct mbuf *m\" \"struct mbuf *n\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:405
msgid ""
"Concatenates mbuf chain E<.Fa n> to E<.Fa m>.  Both chains must be of the "
"same type; packet headers will E<.Em not> be updated if present."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:405
#, no-wrap
msgid "Fn m_dup \"struct mbuf *m\" \"int off0\" \"int len\" \"int wait\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:421
msgid ""
"Similarly to E<.Fn m_copym>, the function creates a copy of an mbuf chain "
"starting E<.Fa off0> bytes from the beginning, continuing for E<.Fa len> "
"bytes.  While E<.Fn m_copym> tries to share external storage for mbufs with "
"E<.Dv M_EXT> flag, E<.Fn m_dup> will deep-copy the whole data content into "
"new mbuf chain and avoids shared external storage."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:421
#, no-wrap
msgid "Fn m_prepend \"struct mbuf *m\" \"int len\" \"int how\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:434
msgid ""
"Lesser-used path for E<.Fn M_PREPEND>: allocates new mbuf E<.Fa m> of size "
"E<.Fa len> to prepend to the chain, copying junk along.  The E<.Fa how> "
"parameter is a choice of E<.Dv M_WAIT / M_DONTWAIT> from caller."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:434
#, no-wrap
msgid "Fn m_pulldown \"struct mbuf *m\" \"int off\" \"int len\" \"int *offp\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:467
msgid ""
"Rearranges an mbuf chain so that E<.Fa len> bytes from offset E<.Fa off> are "
"contiguous and in the data area of an mbuf.  The return value points to an "
"mbuf in the middle of the mbuf chain E<.Fa m>.  If we call the return value "
"E<.Fa n>, the contiguous data region is available at E<.Li \"mtod(n, void *) "
"+ *offp\">, or E<.Li \"mtod(n, void *)\"> if E<.Fa offp> is E<.Dv NULL>.  "
"The top of the mbuf chain E<.Fa m>, and mbufs up to E<.Fa off>, will not be "
"modified.  On successful return, it is guaranteed that the mbuf pointed to "
"by E<.Fa n> does not have a shared external storage, therefore it is safe to "
"update the contiguous region.  Returns E<.Dv NULL> and frees the mbuf chain "
"on failure.  E<.Fa len> must be smaller or equal than E<.Dv MCLBYTES>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:467
#, no-wrap
msgid "Fn m_pullup \"struct mbuf *m\" \"int len\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:488
msgid ""
"Rearranges an mbuf chain so that E<.Fa len> bytes are contiguous and in the "
"data area of an mbuf (so that E<.Fn mtod> will work for a structure of size "
"E<.Fa len>).  Returns the resulting mbuf chain on success, frees it and "
"returns E<.Dv NULL> on failure.  If there is room, it will add up to E<.Dv "
"max_protohdr> - E<.Fa len> extra bytes to the contiguous region to possibly "
"avoid being called again.  E<.Fa len> must be smaller or equal than E<.Dv "
"MHLEN>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:488
#, no-wrap
msgid "Fn m_split \"struct mbuf *m0\" \"int len0\" \"int wait\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:497
msgid ""
"Partitions an mbuf chain in two pieces, returning the tail, which is all but "
"the first E<.Fa len0> bytes.  In case of failure, it returns E<.Dv NULL> and "
"attempts to restore the chain to its original state."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:497
#, no-wrap
msgid "Fn m_adj \"struct mbuf *mp\" \"int req_len\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:508
msgid ""
"Shaves off E<.Fa req_len> bytes from head or tail of the (valid) data area.  "
"If E<.Fa req_len> is greater than zero, front bytes are being shaved off, if "
"it's smaller, from the back (and if it is zero, the mbuf will stay "
"bearded).  This function does not move data in any way, but is used to "
"manipulate the data area pointer and data length variable of the mbuf in a "
"non-clobbering way."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:508
#, no-wrap
msgid ""
"Fn m_apply \"struct mbuf *m\" \"int off\" \"int len\" \"int (*f)(void *, "
"void *, unsigned int)\" \"void *arg\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:536
msgid ""
"Apply function E<.Fa f> to the data in an mbuf chain starting E<.Fa off> "
"bytes from the beginning, continuing for E<.Fa len> bytes.  Neither E<.Fa "
"off> nor E<.Fa len> may be negative.  E<.Fa arg> will be supplied as first "
"argument for E<.Fa f>, the second argument will be the pointer to the data "
"buffer of a packet (starting after E<.Fa off> bytes in the stream), and the "
"third argument is the amount of data in bytes in this call.  If E<.Fa f> "
"returns something not equal to zero E<.Fn m_apply> will bail out, returning "
"the return code of E<.Fa f>.  Upon successful completion it will return "
"zero."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:536
#, no-wrap
msgid "Fn m_free \"struct mbuf *m\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:539
msgid "Frees mbuf E<.Fa m>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:539
#, no-wrap
msgid "Fn m_freem \"struct mbuf *m\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:545
msgid ""
"Frees the mbuf chain beginning with E<.Fa m>.  This function contains the "
"elementary sanity check for a E<.Dv NULL> pointer."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:545
#, no-wrap
msgid "Fn mtod \"struct mbuf *m\" datatype"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:551
msgid ""
"Returns a pointer to the data contained in the specified mbuf E<.Fa m>, "
"type-casted to the specified data type E<.Fa datatype>.  Implemented as a "
"macro."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:551
#, no-wrap
msgid "Fn MGET \"struct mbuf *m\" \"int how\" \"int type\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:558
msgid ""
"Allocates mbuf E<.Fa m> and initializes it to contain internal data.  See "
"E<.Fn m_get>.  Implemented as a macro."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:558
#, no-wrap
msgid "Fn MGETHDR \"struct mbuf *m\" \"int how\" \"int type\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:565
msgid ""
"Allocates mbuf E<.Fa m> and initializes it to contain a packet header.  See "
"E<.Fn m_gethdr>.  Implemented as a macro."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:565
#, no-wrap
msgid "Fn MEXTMALLOC \"struct mbuf *m\" \"int len\" \"int how\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:579
msgid ""
"Allocates external storage of size E<.Fa len> for mbuf E<.Fa m>.  The E<.Fa "
"how> parameter is a choice of E<.Dv M_WAIT / M_DONTWAIT> from caller.  The "
"flag E<.Dv M_EXT> is set upon success.  Implemented as a macro."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:579
#, no-wrap
msgid ""
"Fn MEXTADD \"struct mbuf *m\" \"void *buf\" \"int size\" \"int type\" \"void "
"(*free)(struct mbuf *, void *, size_t, void *)\" \"void *arg\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:611
msgid ""
"Adds pre-allocated external storage E<.Fa buf> to a normal mbuf E<.Fa m>; "
"the parameters E<.Fa size>, E<.Fa type>, E<.Fa free> and E<.Fa arg> describe "
"the external storage.  E<.Fa size> is the size of the storage, E<.Fa type> "
"describes its E<.Xr malloc 9> type, E<.Fa free> is a free routine (if not "
"the usual one), and E<.Fa arg> is a possible argument to the free routine.  "
"The flag E<.Dv M_EXT> is set upon success.  Implemented as a macro.  If a "
"free routine is specified, it will be called when the mbuf is freed.  In the "
"case of former, the first argument for a free routine is the mbuf E<.Fa m> "
"and the routine is expected to free it in addition to the external storage "
"pointed by second argument.  In the case of latter, the first argument for "
"the routine is NULL."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:611
#, no-wrap
msgid "Fn MCLGET \"struct mbuf *m\" \"int how\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:623
msgid ""
"Allocates and adds an mbuf cluster to a normal mbuf E<.Fa m>.  The E<.Fa "
"how> parameter is a choice of E<.Dv M_WAIT / M_DONTWAIT> from caller.  The "
"flag E<.Dv M_EXT> is set upon success.  Implemented as a macro."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:623
#, no-wrap
msgid "Fn M_COPY_PKTHDR \"struct mbuf *to\" \"struct mbuf *from\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:635
msgid ""
"Copies the mbuf pkthdr from mbuf E<.Fa from> to mbuf E<.Fa to>.  E<.Fa from> "
"must have the type flag E<.Dv M_PKTHDR> set, and E<.Fa to> must be empty.  "
"Implemented as a macro."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:635
#, no-wrap
msgid "Fn M_MOVE_PKTHDR \"struct mbuf *to\" \"struct mbuf *from\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:651
msgid ""
"Moves the mbuf pkthdr from mbuf E<.Fa from> to mbuf E<.Fa to>.  E<.Fa from> "
"must have the type flag E<.Dv M_PKTHDR> set, and E<.Fa to> must be empty.  "
"The flag E<.Dv M_PKTHDR> in mbuf E<.Fa from> will be cleared."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:651
#, no-wrap
msgid "Fn M_ALIGN \"struct mbuf *m\" \"int len\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:662
msgid ""
"Sets the data pointer of a newly allocated mbuf E<.Fa m> to E<.Fa len> bytes "
"from the end of the mbuf data area, so that E<.Fa len> bytes of data written "
"to the mbuf E<.Fa m>, starting at the data pointer, will be aligned to the "
"end of the data area.  Implemented as a macro."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:662
#, no-wrap
msgid "Fn MH_ALIGN \"struct mbuf *m\" \"int len\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:673
msgid ""
"Sets the data pointer of a newly allocated packetheader mbuf E<.Fa m> to "
"E<.Fa len> bytes from the end of the mbuf data area, so that E<.Fa len> "
"bytes of data written to the mbuf E<.Fa m>, starting at the data pointer, "
"will be aligned to the end of the data area.  Implemented as a macro."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:673
#, no-wrap
msgid "Fn M_LEADINGSPACE \"struct mbuf *m\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:680
msgid ""
"Returns the amount of space available before the current start of valid data "
"in mbuf E<.Fa m>.  Returns 0 if the mbuf data part is shared across multiple "
"mbufs E<.Pq i.e. not writable>.  Implemented as a macro."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:680
#, no-wrap
msgid "Fn M_TRAILINGSPACE \"struct mbuf *m\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:687
msgid ""
"Returns the amount of space available after the current end of valid data in "
"mbuf E<.Fa m>.  Returns 0 if the mbuf data part is shared across multiple "
"mbufs E<.Pq i.e. not writable>.  Implemented as a macro."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:687
#, no-wrap
msgid "Fn M_PREPEND \"struct mbuf *m\" \"int plen\" \"int how\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:704
msgid ""
"Prepends space of size E<.Fa plen> to mbuf E<.Fa m>.  If a new mbuf must be "
"allocated, E<.Fa how> specifies whether to wait.  If E<.Fa how> is E<.Dv "
"M_DONTWAIT> and allocation fails, the original mbuf chain is freed and E<.Fa "
"m> is set to E<.Dv NULL>.  Implemented as a macro."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:704
#, no-wrap
msgid "Fn MCHTYPE \"struct mbuf *m\" \"int type\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:710
msgid "Change mbuf E<.Fa m> to new type E<.Fa type>.  Implemented as a macro."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mbuf.9:710
#, no-wrap
msgid "Fn MFREE \"struct mbuf *m\" \"struct mbuf *n\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:716
msgid ""
"Frees a single mbuf E<.Fa m> and places the successor, if any, in mbuf E<.Fa "
"n>.  Implemented as a macro."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:725
msgid ""
"The E<.Nm> management functions are implemented within the file E<.Pa "
"sys/kern/uipc_mbuf.c>.  Function prototypes, and the functions implemented "
"as macros are located in E<.Pa sys/sys/mbuf.h>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:736
msgid ""
"E<.Pa /usr/share/doc/smm/18.net>, E<.Xr netstat 1>, E<.Xr m_tag 9>, E<.Xr "
"malloc 9> E<.Rs> E<.%A Jun-ichiro Hagino> E<.%T \"Mbuf issues in 4.4BSD "
"IPv6/IPsec support (experiences from KAME IPv6/IPsec implementation)\"> "
"E<.%B \"Proceedings of the freenix track: 2000 USENIX annual technical "
"conference\"> E<.%D June 2000> E<.Re>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:740
msgid ""
"E<.An -nosplit> The original mbuf data structures were designed by Rob "
"Gurwitz when he did the initial TCP/IP implementation at BBN."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:743
msgid ""
"Further extensions and enhancements were made by Bill Joy, Sam Leffler, and "
"Mike Karels at CSRG."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mbuf.9:749
msgid ""
"Current implementation of external storage by E<.An Matt Thomas> E<.Aq "
"matt@3am-software.com> and E<.An Jason R. Thorpe> E<.Aq thorpej@NetBSD.org>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/mca.9:30 org_netbsd/src/share/man/man9/tc.9:30 org_netbsd/src/share/man/man9/wscons.9:30
#, no-wrap
msgid "October 7, 2001"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/mca.9:31
#, no-wrap
msgid "MCA 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mca.9:40
msgid ""
"E<.Nm MCA>, E<.Nm mca_intr_establish>, E<.Nm mca_intr_disestablish>, E<.Nm "
"mca_intr_evcnt>, E<.Nm mca_conf_read>, E<.Nm mca_conf_write>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/mca.9:40
#, no-wrap
msgid "MicroChannel Architecture bus"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/mca.9:43
#, no-wrap
msgid "dev/mca/mcavar.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/mca.9:44
#, no-wrap
msgid "dev/mca/mcadevs.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mca.9:57
msgid ""
"E<.Ft void *> E<.Fn mca_intr_establish \"mca_chipset_tag_t mc\" "
"\"mca_intr_handle_t hdl\" \"int level\" \"int (*handler)(void *)\" \"void "
"*arg\"> E<.Ft void> E<.Fn mca_intr_disestablish \"mca_chipset_tag_t mc\" "
"\"mca_intr_handle_t hdl\"> E<.Ft const struct evcnt *> E<.Fn mca_intr_evcnt "
"\"mca_chipset_tag_t mc\" \"mca_intr_handle_t hdl\"> E<.Ft int> E<.Fn "
"mca_conf_read \"mca_chipset_tag_t mc\" \"int slot\" \"int reg\"> E<.Ft void> "
"E<.Fn mca_conf_write \"mca_chipset_tag_t mc\" \"int slot\" \"int reg\" \"int "
"data\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mca.9:66
msgid ""
"The E<.Nm> device provides support for IBM's MicroChannel Architecture bus "
"found on IBM PS/2 systems and selected workstations.  It was designed as a "
"replacement bus for the ISA bus found on IBM's older machines.  However, the "
"bus specifications were only available under license, so MCA did not achieve "
"widespread acceptance in the industry."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mca.9:76
msgid ""
"Being a replacement for the ISA bus, the MCA bus does share some similar "
"aspects with the ISA bus.  Some MCA devices can be detected via the usual "
"ISA-style probing.  However, most device detection is done through the "
"Programmable Option Select (POS) registers.  These registers provide a "
"window into a device to determine device-specific properties and "
"configuration.  The configuration of devices and their POS registers is "
"performed using IBM's system configuration software."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mca.9:83
msgid ""
"The MCA bus uses level-triggered interrupts while the ISA bus uses "
"edge-triggered interrupts.  Level triggered interrupts have the advantage "
"that they can be shared among multiple device.  Therefore, most MCA-specific "
"devices should be coded with shared interrupts in mind."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mca.9:86
msgid ""
"Drivers for devices attached to the MCA bus will make use of the following "
"data types:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mca.9:87
#, no-wrap
msgid "Fa mca_chipset_tag_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mca.9:89
msgid "Chipset tag for the MCA bus."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mca.9:89
#, no-wrap
msgid "Fa mca_intr_handle_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mca.9:91 org_netbsd/src/share/man/man9/pci.9:210
msgid "The opaque handle describing an established interrupt handler."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mca.9:91
#, no-wrap
msgid "Fa struct mca_attach_args"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mca.9:94
msgid ""
"A structure use to inform the driver of MCA bus properties.  It contains the "
"following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mca.9:101
#, no-wrap
msgid ""
"\tbus_space_tag_t ma_iot;\t\t/* MCA I/O space tag */\n"
"\tbus_space_tag_t ma_memt;\t/* MCA mem space tag */\n"
"\tbus_dma_tag_t ma_dmat;\t\t/* MCA DMA tag */\n"
"\tint ma_slot;\t\t\t/* MCA slot number */\n"
"\tint ma_pos[8];\t\t\t/* MCA POS values */\n"
"\tint ma_id;\t\t\t/* MCA device */\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mca.9:105
#, no-wrap
msgid "Fn mca_intr_establish mc hdl level handler arg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mca.9:116
msgid ""
"Establish a MCA interrupt handler on the MCA bus specified by E<.Fa mc> for "
"the interrupt described completely by E<.Fa hdl>.  The priority of the "
"interrupt is specified by E<.Fa level>.  When the interrupt occurs the "
"function E<.Fa handler> is called with argument E<.Fa arg>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mca.9:116
#, no-wrap
msgid "Fn mca_intr_disestablish mc hdl"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mca.9:121
msgid ""
"Dis-establish the interrupt handler on the MCA bus specified by E<.Fa mc> "
"for the interrupt described completely E<.Fa hdl>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mca.9:121
#, no-wrap
msgid "Fn mca_intr_evcnt mc hdl"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mca.9:126
msgid ""
"Do interrupt event counting on the MCA bus specified by E<.Fa mc> for the "
"event described completely by E<.Fa hdl>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mca.9:126
#, no-wrap
msgid "Fn mca_conf_read mc slot reg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mca.9:133
msgid ""
"Read the POS register E<.Fa reg> for the device in slot E<.Fa slot> on the "
"MCA bus specified by E<.Fa mc>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mca.9:133
#, no-wrap
msgid "Fn mca_conf_write mc slot reg data"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mca.9:142
msgid ""
"Write data E<.Fa data> to the POS register E<.Fa reg> for the device in slot "
"E<.Fa slot> on the MCA bus specified by E<.Fa mc>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mca.9:160
msgid ""
"The MCA bus is a direct-connection bus.  During autoconfiguration, the "
"parent specifies the MCA device ID for the found device in the E<.Fa ma_id> "
"member of the E<.Em mca_attach_args> structure.  Drivers should match on the "
"device ID.  Device capabilities and configuration information should be read "
"from device POS registers using E<.Fn mca_conf_read>.  Some important "
"configuration information found in the POS registers include the I/O base "
"address, memory base address and interrupt number.  The location of these "
"configurable options with the POS registers are device specific."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mca.9:163
msgid ""
"The MCA bus supports 32-bit, bidirectional DMA transfers.  Currently, no "
"machine-independent support for MCA DMA is available."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mca.9:175
msgid ""
"The MCA subsystem itself is implemented within the file E<.Pa "
"sys/dev/mca/mca_subr.c>.  Machine-dependent portions can be found in E<.Pa "
"sys/arch/\\*[Lt]arch\\*[Gt]/mca/mca_machdep.c>.  The database of known "
"devices exists within the file E<.Fa sys/dev/mca/mcadevs_data.h> and is "
"generated automatically from the file E<.Pa sys/dev/mca/mcadevs>.  New "
"vendor and product identifiers should be added to this file.  The database "
"can be regenerated using the Makefile E<.Pa sys/dev/mca/Makefile.mcadevs>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mca.9:180
msgid ""
"A good source of information about MCA devices is IBM's system configuration "
"disk.  The disk contains .adf files which describe the location of device "
"configuration options in the POS registers."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mca.9:187
msgid ""
"E<.Xr mca 4>, E<.Xr autoconf 9>, E<.Xr bus_dma 9>, E<.Xr bus_space 9>, E<.Xr "
"driver 9>, E<.Xr isa 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mca.9:192
msgid ""
"The machine-independent E<.Nm> driver does not currently support DMA.  MCA "
"devices which require DMA operation currently access the DMA capabilities "
"directly."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/memcmp.9:36
#, no-wrap
msgid "MEMCMP 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memcmp.9:40
msgid "E<.Nm memcmp>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memcmp.9:45
msgid ""
"E<.Ft int> E<.Fn memcmp \"const void *b1\" \"const void *b2\" \"size_t "
"len\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memcmp.9:56
msgid ""
"The E<.Fn memcmp> function compares byte string E<.Fa b1> against byte "
"string E<.Fa b2>.  Both strings are assumed to be E<.Fa len> bytes long."
msgstr ""

#.  .Sh SEE ALSO
#. type: Plain text
#: org_netbsd/src/share/man/man9/memcmp.9:69
msgid ""
"The E<.Fn memcmp> function returns zero if the two strings are identical, "
"otherwise returns the difference between the first two differing bytes "
"(treated as unsigned char values, so that E<.Sq Li \\e200> is greater than "
"E<.Sq Li \\&\\e0>, for example).  Zero-length strings are always identical."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memcmp.9:74
msgid "The E<.Fn memcmp> function conforms to E<.St -ansiC>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/memcpy.9:36
#, no-wrap
msgid "January 2, 2012"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/memcpy.9:37
#, no-wrap
msgid "MEMCPY 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memcpy.9:41
msgid "E<.Nm memcpy>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memcpy.9:46
msgid ""
"E<.Ft void *> E<.Fn memcpy \"void * restrict dst\" \"const void * restrict "
"src\" \"size_t len\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memcpy.9:60
msgid ""
"The E<.Fn memcpy> function copies E<.Fa len> bytes from string E<.Fa src> to "
"string E<.Fa dst>.  The arguments must not overlap -- behavior if the "
"arguments overlap is undefined.  To copy byte strings that overlap, use "
"E<.Xr memmove 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memcpy.9:66
msgid "The E<.Fn memcpy> function returns the original value of E<.Fa dst>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memcpy.9:68
msgid "E<.Xr memmove 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memcpy.9:73
msgid "The E<.Fn memcpy> function conforms to E<.St -isoC-99>."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/memmove.9:36
#, no-wrap
msgid "MEMMOVE 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memmove.9:40
msgid "E<.Nm memmove>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memmove.9:45
msgid ""
"E<.Ft void *> E<.Fn memmove \"void *dst\" \"const void *src\" \"size_t "
"len\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memmove.9:57
msgid ""
"The E<.Fn memmove> function copies E<.Fa len> bytes from string E<.Fa src> "
"to string E<.Fa dst>.  The two strings may overlap; the copy is always done "
"in a non-destructive manner."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memmove.9:62
msgid "The E<.Fn memmove> function returns the original value of E<.Fa dst>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memmove.9:64
msgid "E<.Xr memcpy 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memmove.9:69
msgid "The E<.Fn memmove> function conforms to E<.St -ansiC>."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/memoryallocators.9:29
#, no-wrap
msgid "MEMORYALLOCATORS 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memoryallocators.9:33
msgid "E<.Nm memoryallocators>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/memoryallocators.9:33
#, no-wrap
msgid "introduction to kernel memory allocators"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memoryallocators.9:40
msgid ""
"The E<.Nx> kernel provides several memory allocators, each with different "
"characteristics and purpose.  This document summarizes the main differences "
"between them."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/memoryallocators.9:40
#, no-wrap
msgid "The Kmem Allocator"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memoryallocators.9:44
msgid ""
"The kmem allocator is modelled after an interface of similar name "
"implemented in Solaris.  This is main general purpose allocator in the "
"kernel."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memoryallocators.9:50
msgid ""
"It is implemented on-top of the E<.Xr vmem 9> resource allocator (beyond the "
"scope of this document), meaning it will be using E<.Xr pool_cache 9> "
"internally to speed-up common (small) sized allocations."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memoryallocators.9:52
msgid "It requires no setup, but cannot be used from interrupt context."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memoryallocators.9:56
msgid "See E<.Xr kmem 9> for more details."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/memoryallocators.9:56
#, no-wrap
msgid "The Pool Allocator"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memoryallocators.9:61
msgid ""
"The E<.Xr pool 9> allocator is a fixed-size memory allocator.  It requires "
"setup (to initialize a memory pool) and is interrupt-safe."
msgstr ""

#.  On some architectures (foo, bar) the
#.  .Xr pool 9
#.  allocator will use direct-mapped segments rather than normal page
#.  mappings, which can reduce TLB contentions.
#. .Pp
#. type: Plain text
#: org_netbsd/src/share/man/man9/memoryallocators.9:70
msgid "See E<.Xr pool 9> for more details."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/memoryallocators.9:70
#, no-wrap
msgid "The Pool Cache Allocator"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memoryallocators.9:75
msgid ""
"The pool cache allocator works on-top of the E<.Xr pool 9> allocator, also "
"allowing fixed-size allocation only, requires setup, and is interrupt-safe."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memoryallocators.9:80
msgid ""
"The pool cache allocator is expected to be faster than other allocators, "
"including the E<.Dq normal> pool allocator."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memoryallocators.9:82
msgid "In the future this allocator is expected to have a per-CPU cache."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memoryallocators.9:86
msgid "See E<.Xr pool_cache 9> for more details."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/memoryallocators.9:86
#, no-wrap
msgid "The UVM Kernel Memory Allocator"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memoryallocators.9:91
msgid ""
"This is a low-level memory allocator interface.  It allows variable-sized "
"allocations in multiples of E<.Dv PAGE_SIZE>, and can be used to allocate "
"both wired and pageable kernel memory."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memoryallocators.9:95
msgid "See E<.Xr uvm 9> for more details."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memoryallocators.9:102
msgid ""
"E<.Xr intro 9>, E<.Xr kmem 9>, E<.Xr pool 9>, E<.Xr pool_cache 9>, E<.Xr uvm "
"9>, E<.Xr vmem 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memoryallocators.9:104
msgid ""
"E<.An Elad Efrat Aq elad@NetBSD.org> E<.An YAMAMOTO Takashi Aq "
"yamt@NetBSD.org>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/memset.9:36
#, no-wrap
msgid "MEMSET 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memset.9:40
msgid "E<.Nm memset>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/memset.9:40
#, no-wrap
msgid "write a byte to byte string"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memset.9:45
msgid "E<.Ft void *> E<.Fn memset \"void *b\" \"int c\" \"size_t len\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memset.9:55
msgid ""
"The E<.Fn memset> function writes E<.Fa len> bytes of value E<.Fa c> "
"(converted to an unsigned char) to the string E<.Fa b>."
msgstr ""

#.  .Sh SEE ALSO
#. type: Plain text
#: org_netbsd/src/share/man/man9/memset.9:62
msgid "The E<.Fn memset> function returns the original value of E<.Fa b>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/memset.9:67
msgid "The E<.Fn memset> function conforms to E<.St -ansiC>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/mi_switch.9:30
#, no-wrap
msgid "July 21, 2007"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/mi_switch.9:31
#, no-wrap
msgid "MI_SWITCH 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mi_switch.9:35
msgid "E<.Nm mi_switch>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/mi_switch.9:35
#, no-wrap
msgid "machine independent context switch prelude"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mi_switch.9:39
msgid "E<.Ft int> E<.Fn mi_switch \"struct lwp *l\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mi_switch.9:50
msgid ""
"The E<.Fn mi_switch> function implements the machine-independent prelude to "
"an LWP context switch.  It is called from only a few distinguished places in "
"the kernel code as a result of the principle of non-preemptable kernel mode "
"execution.  The three major uses of E<.Fn mi_switch> can be enumerated as "
"follows:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mi_switch.9:57
msgid ""
"From within E<.Xr cv_wait 9> and associated methods when the current LWP "
"voluntarily relinquishes the CPU to wait for some resource to become "
"available."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mi_switch.9:62
msgid ""
"From within E<.Xr preempt 9> when the current LWP voluntarily relinquishes "
"the CPU or when the kernel prepares a return to user-mode execution."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mi_switch.9:66
msgid ""
"In the signal handling code if a signal is delivered that causes an LWP to "
"stop E<.Pq see Xr issignal 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mi_switch.9:78
msgid ""
"E<.Fn mi_switch> records the amount of time the current LWP has been running "
"in the LWP structure and checks this value against the CPU time limits "
"allocated to the LWP E<.Pq see Xr getrlimit 2>.  Exceeding the soft limit "
"results in a E<.Dv SIGXCPU> signal to be posted to the LWP, while exceeding "
"the hard limit will cause a E<.Dv SIGKILL>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mi_switch.9:93
msgid ""
"Unless E<.Fa l-\\*[Gt]l_switchto> is not E<.Dv NULL>, E<.Fn mi_switch> will "
"call E<.Fn sched_nextlwp> to select a new LWP from the scheduler's runqueue "
"structures.  If no runnable LWP is found, the idle LWP is used.  If the new "
"LWP is not equal to the current one, E<.Fn mi_switch> will hand over control "
"to the machine-dependent function E<.Xr cpu_switchto 9> to switch to the new "
"LWP."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mi_switch.9:102
msgid ""
"E<.Fn mi_switch> has to be called with the LWP lock held (through calling "
"E<.Fn lwp_lock> first) and at the E<.Xr splsched 9> interrupt protection "
"level.  It returns with the LWP lock released."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mi_switch.9:106
msgid ""
"E<.Fn mi_switch> returns 1 if a context switch was performed to a different "
"LWP, 0 otherwise."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mi_switch.9:113
msgid ""
"E<.Xr condvar 9>, E<.Xr cpu_switchto 9>, E<.Xr csf 9>, E<.Xr pmap 9>, E<.Xr "
"ras 9>, E<.Xr sched_4bsd 9>, E<.Xr splsched 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/microseq.9:29 org_netbsd/src/share/man/man9/ppi.9:30
#, no-wrap
msgid "December 29, 2003"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/microseq.9:30
#, no-wrap
msgid "MICROSEQ 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:34
msgid "E<.Nm microseq>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/microseq.9:34
#, no-wrap
msgid "ppbus microseqencer developer's guide"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/microseq.9:37 org_netbsd/src/share/man/man9/ppi.9:39
#, no-wrap
msgid "dev/ppbus/ppbus_conf.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/microseq.9:38
#, no-wrap
msgid "dev/ppbus/ppbus_msq.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:45
msgid ""
"See E<.Xr ppbus 4> for E<.Nm ppbus> description and general info about the "
"microsequencer."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:48
msgid ""
"The purpose of this document is to encourage developers to use the "
"microsequencer mechanism in order to have:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:51
msgid "a uniform programming model"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:53
msgid "efficient code"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:59
msgid ""
"Before using microsequences, you are encouraged to look at the E<.Xr atppc "
"4> microsequencer implementation and an example of how using it in E<.Xr vpo "
"4>."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:59
#, no-wrap
msgid "PPBUS register model"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:60
#, no-wrap
msgid "Background"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:70
msgid ""
"The parallel port model chosen for E<.Xr ppbus 4> is the PC parallel port "
"model.  Thus, any register described later has the same semantic than its "
"counterpart in a PC parallel port.  For more info about ISA/ECP programming, "
"get the Microsoft standard referenced E<.Dq Tn \"Extended Capabilities Port "
"Protocol and ISA interface Standard\">.  Registers described later are "
"standard parallel port registers."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:74
msgid ""
"Mask macros are defined in the standard E<.Xr ppbus 4> include files for "
"each valid bit of parallel port registers."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:74
#, no-wrap
msgid "Data register"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:80
msgid ""
"In compatible or nibble mode, writing to this register will drive data to "
"the parallel port data lines.  In any other mode, drivers may be tri-stated "
"by setting the direction bit (PCD) in the control register.  Reads to this "
"register return the value on the data lines."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:80
#, no-wrap
msgid "Device status register"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:83
msgid "This read-only register reflects the inputs on the parallel port interface."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/microseq.9:85 org_netbsd/src/share/man/man9/microseq.9:99
#, no-wrap
msgid "Em Bit Ta Em Name Ta Em Description"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/microseq.9:86
#, no-wrap
msgid "7 Ta nBUSY Ta \"inverted version of parallel port Busy signal\""
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/microseq.9:87
#, no-wrap
msgid "6 Ta nACK Ta \"version of parallel port nAck signal\""
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/microseq.9:88
#, no-wrap
msgid "5 Ta PERROR Ta \"version of parallel port PERROR signal\""
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/microseq.9:89
#, no-wrap
msgid "4 Ta SELECT Ta \"version of parallel port Select signal\""
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/microseq.9:90
#, no-wrap
msgid "3 Ta nFAULT Ta \"version of parallel port nFault signal\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:94
msgid "Others are reserved and return undefined result when read."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:94
#, no-wrap
msgid "Device control register"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:97
msgid ""
"This register directly controls several output signals as well as enabling "
"some functions."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/microseq.9:100
#, no-wrap
msgid "5 Ta PCD Ta \"direction bit in extended modes\""
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/microseq.9:101
#, no-wrap
msgid "4 Ta IRQENABLE Ta \"1 enables an interrupt on the rising edge of nAck\""
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/microseq.9:102
#, no-wrap
msgid "3 Ta SELECTIN Ta \"inverted and driven as parallel port nSelectin signal\""
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/microseq.9:103
#, no-wrap
msgid "2 Ta nINIT Ta \"driven as parallel port nInit signal\""
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/microseq.9:104
#, no-wrap
msgid "1 Ta AUTOFEED Ta \"inverted and driven as parallel port nAutoFd signal\""
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/microseq.9:105
#, no-wrap
msgid "0 Ta STROBE Ta \"inverted and driven as parallel port nStrobe signal\""
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/microseq.9:107
#, no-wrap
msgid "MICROINSTRUCTIONS"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:108
#, no-wrap
msgid "Description"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:114
msgid ""
"E<.Em Microinstructions> are either parallel port accesses, program "
"iterations, submicrosequence or C calls.  The parallel port must be "
"considered as the logical model described in E<.Xr ppbus 4>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:116
msgid "Available microinstructions are:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:137
#, no-wrap
msgid ""
"#define MS_OP_GET       0\t/* get \\*[Lt]ptr\\*[Gt], "
"\\*[Lt]len\\*[Gt]\t\t\t*/\n"
"#define MS_OP_PUT       1\t/* put \\*[Lt]ptr\\*[Gt], "
"\\*[Lt]len\\*[Gt]\t\t\t*/\n"
"#define MS_OP_RFETCH\t2\t/* rfetch \\*[Lt]reg\\*[Gt], \\*[Lt]mask\\*[Gt], "
"\\*[Lt]ptr\\*[Gt]\t\t*/\n"
"#define MS_OP_RSET\t3\t/* rset \\*[Lt]reg\\*[Gt], \\*[Lt]mask\\*[Gt], "
"\\*[Lt]mask\\*[Gt]\t\t*/\n"
"#define MS_OP_RASSERT\t4\t/* rassert \\*[Lt]reg\\*[Gt], "
"\\*[Lt]mask\\*[Gt]\t\t*/\n"
"#define MS_OP_DELAY     5\t/* delay \\*[Lt]val\\*[Gt]\t\t\t\t*/\n"
"#define MS_OP_SET       6\t/* set \\*[Lt]val\\*[Gt]\t\t\t\t*/\n"
"#define MS_OP_DBRA      7\t/* dbra \\*[Lt]offset\\*[Gt]\t\t\t*/\n"
"#define MS_OP_BRSET     8\t/* brset \\*[Lt]mask\\*[Gt], "
"\\*[Lt]offset\\*[Gt]\t\t*/\n"
"#define MS_OP_BRCLEAR   9\t/* brclear \\*[Lt]mask\\*[Gt], "
"\\*[Lt]offset\\*[Gt]\t\t*/\n"
"#define MS_OP_RET       10\t/* ret \\*[Lt]retcode\\*[Gt]\t\t\t*/\n"
"#define MS_OP_C_CALL\t11\t/* c_call \\*[Lt]function\\*[Gt], "
"\\*[Lt]parameter\\*[Gt]\t*/\n"
"#define MS_OP_PTR\t12\t/* ptr \\*[Lt]pointer\\*[Gt]\t\t\t*/\n"
"#define MS_OP_ADELAY\t13\t/* adelay \\*[Lt]val\\*[Gt]\t\t\t\t*/\n"
"#define MS_OP_BRSTAT\t14\t/* brstat \\*[Lt]mask\\*[Gt], \\*[Lt]mask\\*[Gt], "
"\\*[Lt]offset\\*[Gt]\t*/\n"
"#define MS_OP_SUBRET\t15\t/* subret \\*[Lt]code\\*[Gt]\t\t\t*/\n"
"#define MS_OP_CALL\t16\t/* call \\*[Lt]microsequence\\*[Gt]\t\t\t*/\n"
"#define MS_OP_RASSERT_P\t17\t/* rassert_p \\*[Lt]iter\\*[Gt], "
"\\*[Lt]reg\\*[Gt]\t\t*/\n"
"#define MS_OP_RFETCH_P\t18\t/* rfetch_p \\*[Lt]iter\\*[Gt], "
"\\*[Lt]reg\\*[Gt], \\*[Lt]mask\\*[Gt]\t*/\n"
"#define MS_OP_TRIG\t19\t/* trigger \\*[Lt]reg\\*[Gt], \\*[Lt]len\\*[Gt], "
"\\*[Lt]array\\*[Gt]\t*/\n"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:138
#, no-wrap
msgid "Execution context"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:142
msgid "The E<.Em execution context> of microinstructions is:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:148
msgid ""
"the E<.Em program counter> which points to the next microinstruction to "
"execute either in the main microsequence or in a subcall"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:152
msgid ""
"the current value of E<.Em ptr> which points to the next char to "
"send/receive"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:155
msgid "the current value of the internal E<.Em branch register>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:158
msgid "This data is modified by some of the microinstructions, not all."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:158
#, no-wrap
msgid "MS_OP_GET and MS_OP_PUT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:162
msgid ""
"are microinstructions used to do either predefined standard E<.Tn "
"IEEE1284-1994> transfers or programmed non-standard I/O."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:162
#, no-wrap
msgid "MS_OP_RFETCH - Register FETCH"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:165
msgid ""
"is used to retrieve the current value of a parallel port register, apply a "
"mask and save it in a buffer."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:167 org_netbsd/src/share/man/man9/microseq.9:182 org_netbsd/src/share/man/man9/microseq.9:196
msgid "Parameters:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:170 org_netbsd/src/share/man/man9/microseq.9:185 org_netbsd/src/share/man/man9/microseq.9:199 org_netbsd/src/share/man/man9/microseq.9:377 org_netbsd/src/share/man/man9/microseq.9:390 org_netbsd/src/share/man/man9/microseq.9:408
msgid "register"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:172
msgid "character mask"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:174
msgid "pointer to the buffer"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:177
msgid "Predefined macro: MS_RFETCH(reg,mask,ptr)"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:177
#, no-wrap
msgid "MS_OP_RSET - Register SET"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:180
msgid ""
"is used to assert/clear some bits of a particular parallel port register, "
"two masks are applied."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:187
msgid "mask of bits to assert"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:189
msgid "mask of bits to clear"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:192
msgid "Predefined macro: MS_RSET(reg,assert,clear)"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:192
#, no-wrap
msgid "MS_OP_RASSERT - Register ASSERT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:194
msgid "is used to assert all bits of a particular parallel port register."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:201
msgid "byte to assert"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:204
msgid "Predefined macro: MS_RASSERT(reg,byte)"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:204
#, no-wrap
msgid "MS_OP_DELAY - microsecond DELAY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:206
msgid "is used to delay the execution of the microsequence."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:208 org_netbsd/src/share/man/man9/microseq.9:218 org_netbsd/src/share/man/man9/microseq.9:229 org_netbsd/src/share/man/man9/microseq.9:242 org_netbsd/src/share/man/man9/microseq.9:257 org_netbsd/src/share/man/man9/microseq.9:275 org_netbsd/src/share/man/man9/microseq.9:287 org_netbsd/src/share/man/man9/microseq.9:306 org_netbsd/src/share/man/man9/microseq.9:323 org_netbsd/src/share/man/man9/microseq.9:333
msgid "Parameter:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:211
msgid "delay in microseconds"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:214
msgid "Predefined macro: MS_DELAY(delay)"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:214
#, no-wrap
msgid "MS_OP_SET - SET internal branch register"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:216
msgid "is used to set the value of the internal branch register."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:221
msgid "integer value"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:224
msgid "Predefined macro: MS_SET(accum)"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:224
#, no-wrap
msgid "MS_OP_DBRA - \\*[Am]Do BRAnch"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:227
msgid ""
"is used to branch if internal branch register decremented by one result "
"value is positive."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:234 org_netbsd/src/share/man/man9/microseq.9:249 org_netbsd/src/share/man/man9/microseq.9:263 org_netbsd/src/share/man/man9/microseq.9:346
msgid ""
"integer offset in the current executed (sub)microsequence.  Offset is added "
"to the index of the next microinstruction to execute."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:237
msgid "Predefined macro: MS_DBRA(offset)"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:237
#, no-wrap
msgid "MS_OP_BRSET - BRanch on SET"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:240
msgid ""
"is used to branch if some of the status register bits of the parallel port "
"are set."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:245 org_netbsd/src/share/man/man9/microseq.9:260
msgid "bits of the status register"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:252
msgid "Predefined macro: MS_BRSET(mask,offset)"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:252
#, no-wrap
msgid "MS_OP_BRCLEAR - BRanch on CLEAR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:255
msgid ""
"is used to branch if some of the status register bits of the parallel port "
"are cleared."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:266
msgid "Predefined macro: MS_BRCLEAR(mask,offset)"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:266
#, no-wrap
msgid "MS_OP_RET - RETurn"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:273
msgid ""
"is used to return from a microsequence.  This instruction is mandatory.  "
"This is the only way for the microsequencer to detect the end of the "
"microsequence.  The return code is returned in the integer pointed by the "
"(int *)  parameter of the ppb_MS_microseq()."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:278
msgid "integer return code"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:281
msgid "Predefined macro: MS_RET(code)"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:281
#, no-wrap
msgid "MS_OP_C_CALL - C function CALL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:285
msgid ""
"is used to call C functions from microsequence execution.  This may be "
"useful when a non-standard I/O is performed to retrieve a data character "
"from the parallel port."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:290
msgid "the C function to call"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:292
msgid "the parameter to pass to the function call"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:298
msgid ""
"The C function shall be declared as a E<.Ft int(*)(void *p, char *ptr)>.  "
"The ptr parameter is the current position in the buffer currently scanned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:300
msgid "Predefined macro: MS_C_CALL(func,param)"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:300
#, no-wrap
msgid "MS_OP_PTR - initialize internal PTR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:304
msgid ""
"is used to initialize the internal pointer to the currently scanned buffer.  "
"This pointer is passed to any C call (see above)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:314
msgid ""
"pointer to the buffer that shall be accessed by E<.Fn xxx_P> microsequence "
"calls.  Note that this pointer is automatically incremented during E<.Fn "
"xxx_P> calls."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:317
msgid "Predefined macro: MS_PTR(ptr)"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:317
#, no-wrap
msgid "MS_OP_ADELAY - do an Asynchronous DELAY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:321
msgid "is used to make a E<.Xr cv_timedwait 9> during microsequence execution."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:326
msgid "delay in ms"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:329
msgid "Predefined macro: MS_ADELAY(delay)"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:329
#, no-wrap
msgid "MS_OP_BRSTAT - BRanch on STATe"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:331
msgid "is used to branch on status register state condition."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:338
msgid ""
"mask of asserted bits.  Bits that shall be asserted in the status register "
"are set in the mask"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:342
msgid ""
"mask of cleared bits.  Bits that shall be cleared in the status register are "
"set in the mask"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:349
msgid "Predefined macro: MS_BRSTAT(asserted_bits,clear_bits,offset)"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:349
#, no-wrap
msgid "MS_OP_SUBRET - SUBmicrosequence RETurn"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:354
msgid ""
"is used to return from the submicrosequence call.  This action is mandatory "
"before a RET call.  Some microinstructions (PUT, GET) may not be callable "
"within a submicrosequence."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:356
msgid "No parameter."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:358
msgid "Predefined macro: MS_SUBRET()"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:358
#, no-wrap
msgid "MS_OP_CALL - submicrosequence CALL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:362
msgid ""
"is used to call a submicrosequence.  A submicrosequence is a microsequence "
"with a SUBRET call.  Parameter:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:365
msgid "the submicrosequence to execute"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:368
msgid "Predefined macro: MS_CALL(microseq)"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:368
#, no-wrap
msgid "MS_OP_RASSERT_P - Register ASSERT from internal PTR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:372
msgid ""
"is used to assert a register with data currently pointed by the internal PTR "
"pointer.  Parameter:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:375
msgid "amount of data to write to the register"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:380
msgid "Predefined macro: MS_RASSERT_P(iter,reg)"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:380
#, no-wrap
msgid "MS_OP_RFETCH_P - Register FETCH to internal PTR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:385
msgid ""
"is used to fetch data from a register.  Data is stored in the buffer "
"currently pointed by the internal PTR pointer.  Parameter:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:388 org_netbsd/src/share/man/man9/microseq.9:406
msgid "amount of data to read from the register"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:392
msgid "mask applied to fetched data"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:395
msgid "Predefined macro: MS_RFETCH_P(iter,reg,mask)"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:395
#, no-wrap
msgid "MS_OP_TRIG - TRIG register"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:403
msgid ""
"is used to trigger the parallel port.  This microinstruction is intended to "
"provide a very efficient control of the parallel port.  Triggering a "
"register is writing data, wait a while, write data, wait a while...  This "
"allows to write magic sequences to the port.  Parameter:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:410
msgid "size of the array"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:416
msgid ""
"array of unsigned chars.  Each couple of u_chars define the data to write to "
"the register and the delay in us to wait.  The delay is limited to 255 us to "
"simplify and reduce the size of the array."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:419
msgid "Predefined macro: MS_TRIG(reg,len,array)"
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/microseq.9:419
#, no-wrap
msgid "MICROSEQUENCES"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:420
#, no-wrap
msgid "C structures"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:428
#, no-wrap
msgid ""
"union ppb_insarg {\n"
"     int     i;\n"
"     char    c;\n"
"     void    *p;\n"
"     int     (* f)(void *, char *);\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:433
#, no-wrap
msgid ""
"struct ppb_microseq {\n"
"     int                     opcode;         /* microins. opcode */\n"
"     union ppb_insarg        arg[PPB_MS_MAXARGS];    /* arguments */\n"
"};\n"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:434
#, no-wrap
msgid "Using microsequences"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:441
msgid ""
"To instantiate a microsequence, just declare an array of ppb_microseq "
"structures and initialize it as needed.  You may either use predefined "
"macros or code directly your microinstructions according to the ppb_microseq "
"definition.  For example,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:443
#, no-wrap
msgid "     struct ppb_microseq select_microseq[] = {\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:448
#, no-wrap
msgid ""
"\t     /* parameter list\n"
"\t      */\n"
"\t     #define SELECT_TARGET    MS_PARAM(0, 1, MS_TYP_INT)\n"
"\t     #define SELECT_INITIATOR MS_PARAM(3, 1, MS_TYP_INT)\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:455
#, no-wrap
msgid ""
"\t     /* send the select command to the drive */\n"
"\t     MS_DASS(MS_UNKNOWN),\n"
"\t     MS_CASS(H_nAUTO | H_nSELIN |  H_INIT | H_STROBE),\n"
"\t     MS_CASS( H_AUTO | H_nSELIN |  H_INIT | H_STROBE),\n"
"\t     MS_DASS(MS_UNKNOWN),\n"
"\t     MS_CASS( H_AUTO | H_nSELIN | H_nINIT | H_STROBE),\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:463
#, no-wrap
msgid ""
"\t     /* now, wait until the drive is ready */\n"
"\t     MS_SET(VP0_SELTMO),\n"
"/* loop: */     MS_BRSET(H_ACK, 2 /* ready */),\n"
"\t     MS_DBRA(-2 /* loop */),\n"
"/* error: */    MS_RET(1),\n"
"/* ready: */    MS_RET(0)\n"
"     };\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:471
msgid ""
"Here, some parameters are undefined and must be filled before executing the "
"microsequence.  In order to initialize each microsequence, one should use "
"the E<.Fn ppb_MS_init_msq> function like this:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:475
#, no-wrap
msgid ""
"ppb_MS_init_msq(select_microseq, 2,\n"
"\t\tSELECT_TARGET, 1 \\*[Lt]\\*[Lt] target,\n"
"\t\tSELECT_INITIATOR, 1 \\*[Lt]\\*[Lt] initiator);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:478
msgid "and then execute the microsequence."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/microseq.9:478
#, no-wrap
msgid "The microsequencer"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:493
msgid ""
"The microsequencer is executed either at ppbus or adapter level (see E<.Xr "
"ppbus 4> for info about ppbus system layers).  Most of the microsequencer is "
"executed at E<.Xr atppc 4> level to avoid E<.Xr ppbus 4> to adapter function "
"call overhead.  But some actions like deciding whereas the transfer is E<.Tn "
"IEEE1284-1994> compliant are executed at E<.Xr ppbus 4> layer."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:497
msgid "E<.Xr atppc 4>, E<.Xr ppbus 4>, E<.Xr vpo 4>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:502
msgid "The E<.Nm> manual page first appeared in E<.Fx 3.0>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:511
msgid ""
"This manual page is based on the E<.Fx> E<.Nm microseq> manual page and was "
"update for the E<.Nx> port by E<.An Gary Thorpe>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:513
msgid "Only one level of submicrosequences is allowed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microseq.9:514
msgid "When triggering the port, maximum delay allowed is 255 us."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/microtime.9:57
#, no-wrap
msgid "MICROTIME 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microtime.9:66
msgid ""
"E<.Nm bintime>, E<.Nm getbintime>, E<.Nm microtime>, E<.Nm getmicrotime>, "
"E<.Nm nanotime>, E<.Nm getnanotime>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/microtime.9:66
#, no-wrap
msgid "get the current time"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microtime.9:93
msgid ""
"E<.Ft void> E<.Fo bintime> E<.Fa \"struct bintime *bt\"> E<.Fc> E<.Ft void> "
"E<.Fo getbintime> E<.Fa \"struct bintime *bt\"> E<.Fc> E<.Ft void> E<.Fo "
"\"microtime\"> E<.Fa \"struct timeval *tv\"> E<.Fc> E<.Ft void> E<.Fo "
"getmicrotime> E<.Fa \"struct timeval *tv\"> E<.Fc> E<.Ft void> E<.Fo "
"nanotime> E<.Fa \"struct timespec *ts\"> E<.Fc> E<.Ft void> E<.Fo "
"getnanotime> E<.Fa \"struct timespec *tsp\"> E<.Fc>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microtime.9:117
msgid ""
"The E<.Fn bintime> and E<.Fn getbintime> functions store the system time as "
"a E<.Vt \"struct bintime\"> at the addresses specified by E<.Fa bt>.  The "
"E<.Fn microtime> and E<.Fn getmicrotime> functions perform the same utility, "
"but record the time as a E<.Vt \"struct timeval\"> instead.  Similarly the "
"E<.Fn nanotime> and E<.Fn getnanotime> functions store the time as a E<.Vt "
"\"struct timespec\">.  The structures are described in E<.Xr timeval 3>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microtime.9:133
msgid ""
"The E<.Fn bintime>, E<.Fn microtime>, and E<.Fn nanotime> functions always "
"query the timecounter to return the current time as precisely as possible.  "
"Whereas E<.Fn getbintime>, E<.Fn getmicrotime>, and E<.Fn getnanotime> "
"functions are abstractions which return a less precise, but faster to "
"obtain, time."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microtime.9:148
msgid ""
"The intent of the E<.Fn getbintime>, E<.Fn getmicrotime>, and E<.Fn "
"getnanotime> functions is to enforce the user's preference for timer "
"accuracy versus execution time.  They should be used where a precision of "
"E<.Pf 1/ Em HZ> (e.g., 10 msec on a E<.Pf 100 Em HZ> machine, see E<.Xr hz "
"9>)  is acceptable or where performance is priority."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microtime.9:155
msgid ""
"The system realtime clock is guaranteed to be monotonically increasing at "
"all times.  As such, all calls to these functions are guaranteed to return a "
"system time greater than or equal to the system time returned in any "
"previous calls.  Comparable functions exist to retrieve the time elapsed "
"since boot; see E<.Xr microuptime 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microtime.9:161
msgid ""
"E<.Xr settimeofday 2>, E<.Xr bintime_add 9>, E<.Xr inittodr 9>, E<.Xr "
"time_second 9>, E<.Xr tvtohz 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microtime.9:169
msgid ""
"The implementation of the E<.Fn microtime> family of functions is in E<.Pa "
"sys/kern/kern_tc.c> as a part of the E<.Xr timecounter 9> framework."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microtime.9:175
msgid ""
"The implementation of the time counter sources used by the E<.Xr timecounter "
"9> is machine dependent, hence its location in the source code tree varies "
"from architecture to architecture."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microtime.9:180
msgid ""
"This manual page was written by E<.An Jeremy Cooper> and E<.An Kelly Yancey "
"Aq kbyanc@posi.net>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microtime.9:184
msgid ""
"Despite the guarantee that the system realtime clock will always be "
"monotonically increasing, it is always possible for the system clock to be "
"manually reset by the system administrator to any date."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/microuptime.9:30
#, no-wrap
msgid "MICROUPTIME 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microuptime.9:39
msgid ""
"E<.Nm binuptime>, E<.Nm getbinuptime>, E<.Nm microuptime>, E<.Nm "
"getmicrouptime>, E<.Nm nanouptime>, E<.Nm getnanouptime>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/microuptime.9:39
#, no-wrap
msgid "get the time elapsed since boot"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microuptime.9:54
msgid ""
"E<.Ft void> E<.Fn binuptime \"struct bintime *bt\"> E<.Ft void> E<.Fn "
"getbinuptime \"struct bintime *bt\"> E<.Ft void> E<.Fn microuptime \"struct "
"timeval *tv\"> E<.Ft void> E<.Fn getmicrouptime \"struct timeval *tv\"> "
"E<.Ft void> E<.Fn nanouptime \"struct timespec *ts\"> E<.Ft void> E<.Fn "
"getnanouptime \"struct timespec *tsp\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microuptime.9:78
msgid ""
"The E<.Fn binuptime> and E<.Fn getbinuptime> functions store the time "
"elapsed since boot as a E<.Vt \"struct bintime\"> at the address specified "
"by E<.Fa bt>.  The E<.Fn microuptime> and E<.Fn getmicrouptime> functions "
"perform the same utility, but record the elapsed time as a E<.Vt \"struct "
"timeval\"> instead.  Similarly the E<.Fn nanouptime> and E<.Fn "
"getnanouptime> functions store the elapsed time as a E<.Vt \"struct "
"timespec\">.  The used structures are described in E<.Xr timeval 3>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microuptime.9:94
msgid ""
"The E<.Fn binuptime>, E<.Fn microuptime>, and E<.Fn nanouptime> functions "
"always query the timecounter to return the current time as precisely as "
"possible.  Whereas E<.Fn getbinuptime>, E<.Fn getmicrouptime>, and E<.Fn "
"getnanouptime> functions are abstractions which return a less precise, but "
"faster to obtain, time."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microuptime.9:109
msgid ""
"The intent of the E<.Fn getbinuptime>, E<.Fn getmicrouptime>, and E<.Fn "
"getnanouptime> functions is to enforce the user's preference for timer "
"accuracy versus execution time.  They should be used where a precision of "
"E<.Pf 1/ Em HZ> (e.g., 10 msec on a E<.Pf 100 Em HZ> machine, see E<.Xr hz "
"9>)  is acceptable or where performance is priority."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microuptime.9:113
msgid "E<.Xr microtime 9>, E<.Xr timecounter 9>, E<.Xr tvtohz 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/microuptime.9:115 org_netbsd/src/share/man/man9/tvtohz.9:67
msgid "This manual page was written by E<.An Kelly Yancey Aq kbyanc@posi.net>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/module.9:30
#, no-wrap
msgid "October 18, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/module.9:31
#, no-wrap
msgid "MODULE 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:42
msgid ""
"E<.Nm module>, E<.Nm module_load>, E<.Nm module_autoload>, E<.Nm "
"module_unload>, E<.Nm module_init_class>, E<.Nm module_hold>, E<.Nm "
"module_rele>, E<.Nm module_find_section>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/module.9:42
#, no-wrap
msgid "kernel module loader"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/module.9:44
#, no-wrap
msgid "sys/module.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:69
msgid ""
"E<.Fn MODULE \"class\" \"name\" \"required\"> E<.Ft int> E<.Fn module_load "
"\"const char *name\" \"int flags\" \"prop_dictionary_t props\" \"modclass_t "
"class\"> E<.Ft int> E<.Fn module_autoload \"const char *name\" \"modclass_t "
"class\"> E<.Ft int> E<.Fn module_unload \"const char *name\"> E<.Ft void> "
"E<.Fn module_init_class \"modclass_t class\"> E<.Ft int> E<.Fn module_hold "
"\"const char *name\"> E<.Ft void> E<.Fn module_rele \"const char *\"> E<.Ft "
"int> E<.Fn module_find_section \"const char *\" \"void **\" \"size_t *\"> "
"E<.Ft void> E<.Fn module_init \"void\"> E<.Ft void> E<.Fn "
"module_start_unload_thread \"void\"> E<.Ft void> E<.Fn "
"module_builtin_require_force \"void\"> E<.Ft void> E<.Fn "
"module_load_vfs_init \"void\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:76
msgid ""
"Modules are sections of code that can be independently linked and "
"selectively loaded into or unloaded from a running kernel.  This provides a "
"mechanism to update the module without having to relink the kernel and "
"reboot.  Modules can be loaded from within the kernel image, provided by the "
"boot loader, or loaded from the file system."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:79
msgid "Two data types are relevant for E<.Nm>:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:84
msgid "The E<.Vt module_t> type provides storage to describe a module."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:88
msgid ""
"The E<.Vt modinfo_t> type resides within the module itself, and contains "
"module header info."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:91
msgid "The module subsystem is protected by the global kernconfig_mutex."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:93
#, no-wrap
msgid "Fn MODULE class name required"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:105
msgid ""
"The E<.Fn MODULE> macro creates and initializes a E<.Vt modinfo_t> "
"structure.  In addition to the explicit arguments, the E<.Fn MODULE> macro "
"creates a reference to the module's E<.Fn modcmd> function.  This function "
"is defined as:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:106 org_netbsd/src/share/man/man9/uvm.9:110 org_netbsd/src/share/man/man9/uvm.9:130 org_netbsd/src/share/man/man9/uvm.9:150 org_netbsd/src/share/man/man9/uvm.9:287 org_netbsd/src/share/man/man9/uvm.9:356 org_netbsd/src/share/man/man9/uvm.9:364
#, no-wrap
msgid "Ft int"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:108
msgid "E<.Fn modcmd \"modcmd_t cmd\" \"void *data\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:113
msgid "The E<.Fa cmd> argument requests one of the following operations:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:114
#, no-wrap
msgid "Dv MODULE_CMD_INIT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:116
msgid "Perform module-specific initialization when the module is loaded."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:116
#, no-wrap
msgid "Dv MODULE_CMD_FINI"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:118
msgid "Perform module-specific clean-up before the module is unloaded."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:118
#, no-wrap
msgid "Dv MODULE_CMD_AUTOUNLOAD"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:120
msgid "Notify the module that it is about to be unloaded."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:120
#, no-wrap
msgid "Dv MODULE_CMD_STAT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:122
msgid ""
"Request the module to provide status information (not currently "
"implemented)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:135
msgid ""
"All modules' E<.Fn modcmd> functions must implement the E<.Dv "
"MODULE_CMD_INIT> and E<.Dv MODULE_CMD_FINI> commands.  The other commands "
"are optional, and should return E<.Er ENOTTY> if not implemented."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:147
msgid ""
"For the E<.Dv MODULE_CMD_INIT> command, the E<.Fa data> argument is used to "
"pass a pointer to the module's E<.Xr prop_dictionary 3>.  For the E<.Dv "
"MODULE_CMD_STAT> command, the E<.Fa data> argument points to a buffer where "
"the status information should be placed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:153
msgid ""
"The __link_set mechanism is used to enable the E<.Nm> subsystem to locate "
"the E<.Vt modinfo_t> structure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:153
#, no-wrap
msgid "Fn module_load name flags props class"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:168
msgid ""
"Load a module, link it into the running kernel, and call the module's E<.Fn "
"modcmd> routine with a E<.Fa cmd> argument of E<.Dv MODULE_CMD_INIT>.  If "
"the specified module requires other modules, they are loaded first; if any "
"required module cannot be loaded or if any of their E<.Fn modcmd> control "
"routines returns a non-zero status, loading of this module and the specific "
"required module will fail.  The required modules are marked for automatic "
"unloading.  Thus, if the loading of the module failed, the required modules "
"will be automatically unloaded after a short delay."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:180
msgid ""
"The loader will look first for a built-in module with the specified E<.Fa "
"name> that has not been disabled (see E<.Fn module_unload> below).  If a "
"built-in module with that E<.Fa name> is not found, the list of modules "
"prepared by the boot loader is searched.  If the named module is still not "
"found, an attempt is made to locate the module within the file system, "
"provided it has been mounted by the initialization code."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:184
msgid "The E<.Fa flags> argument can include:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:185
#, no-wrap
msgid "Dv MODCTL_NO_PROP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:188
msgid ""
"When loading a module from the file system, do not attempt to locate a "
"corresponding prop_dictionary file."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:188
#, no-wrap
msgid "Dv MODCTL_LOAD_FORCE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:191
msgid ""
"Force loading of disabled built-in modules and modules built for a different "
"version of the operating system."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:208
msgid ""
"The E<.Fa props> argument points to an externalized property list which is "
"passed to the module's E<.Fn modcmd> routine.  If a module is being loaded "
"from the file system, and the E<.Dv MODCTL_NO_PROP> flag is not set, the "
"system searches for a file with the same name as the module file, but with "
"the suffix E<.Dq Pa .plist>.  If this file is found, the prop_dictionary it "
"contains is loaded and merged with the prop_dictionary from the E<.Fa props> "
"argument."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:212
msgid "The E<.Fa class> argument can be any of:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:214
#, no-wrap
msgid "Dv MODULE_CLASS_ANY"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:215
#, no-wrap
msgid "Dv MODULE_CLASS_DRIVER"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:217
msgid "Device driver"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:217
#, no-wrap
msgid "Dv MODULE_CLASS_EXEC"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:219
msgid "Executable image handler"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:219
#, no-wrap
msgid "Dv MODULE_CLASS_MISC"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:221
msgid "Miscellaneous module"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:221
#, no-wrap
msgid "Dv MODULE_CLASS_SECMODEL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:225
msgid "Security model (see E<.Xr secmodel 9> for more details)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:225
#, no-wrap
msgid "Dv MODULE_CLASS_VFS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:227
msgid "Virtual file system"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:246
msgid ""
"If the class is not E<.Dv MODULE_CLASS_ANY>, the class of the module being "
"loaded must match the requested E<.Fa class>.  Except when verifying a "
"module's class when it is being loaded, module classes other than E<.Dv "
"MODULE_CLASS_SECMODEL> are transparent to the module subsystem.  They are "
"provided only for the benefit of the subsystem's clients.  Modules with "
"class E<.Dv MODULE_CLASS_SECMODEL> are automatically registered with E<.Fn "
"secmodel_register> after being successfully loaded, and automatically "
"deregistered with E<.Fn secmodel_deregister> when being unloaded."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:254
msgid ""
"The E<.Fn module_load> routine is primarily intended as the implementation "
"of the E<.Dv MODCTL_LOAD> option of the E<.Xr modctl 2> system call."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:254
#, no-wrap
msgid "Fn module_autoload name class"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:263
msgid ""
"Auto-load a module, making it available for automatic unloading.  The E<.Fa "
"name> and E<.Fa class> arguments are the same as for the E<.Fn module_load> "
"routine."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:275
msgid ""
"The module subsystem uses a kernel thread to attempt to automatically unload "
"modules a short time (currently, 10 seconds) after being loaded by E<.Fn "
"module_autoload>.  Before the module is unloaded, its E<.Fn modcmd> is "
"called with the E<.Fa cmd> argument specified as E<.Dv "
"MODULE_CMD_AUTOUNLOAD>.  A module can prevent itself from being unloaded by "
"returning a non-zero value."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:281
msgid ""
"The E<.Fn module_autoload> function is intended for use by kernel components "
"to locate and load optional system components.  The function is also used to "
"load modules that are required by other modules."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:294
msgid ""
"The directory from which the module is loaded will be searched for a file "
"with the same name as the module file, but with the suffix E<.Dq Pa "
".plist>.  If this file is found, the prop_dictionary it contains will be "
"loaded and passed to the module's E<.Fn modcmd> routine.  If this "
"prop_dictionary contains a E<.Dq Pa noautoload> property which is set to "
"E<.Dq Pa true> then the system will refuse to load the module."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:294
#, no-wrap
msgid "Fn module_unload name"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:308
msgid ""
"Unload a module.  If the module's reference count is non-zero, the function "
"returns E<.Er EBUSY>.  Otherwise, the module's E<.Fn modcmd> routine is "
"called with a E<.Fa cmd> argument of E<.Dv MODULE_CMD_FINI>.  If the E<.Fn "
"modcmd> routine returns with an error, then the error is returned to the "
"caller otherwise the module is unloaded."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:314
msgid ""
"The reference counts of all modules that were required by this module are "
"decremented, but the required modules are not unloaded by the call to E<.Fn "
"module_unload>.  Instead, the required modules may be unloaded by subsequent "
"calls to E<.Fn module_unload>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:322
msgid ""
"Unloading a built-in module causes the module to be marked as disabled.  "
"This prevents the module from being re-loaded, except by the E<.Fn "
"module_load> function with the E<.Fa flags> argument set to E<.Dv "
"MODULE_FORCE_LOAD>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:330
msgid ""
"The E<.Fn module_unload> function may be called by the E<.Xr modctl 2> "
"system call, by the module subsystem's internal auto-unload thread, or by "
"other kernel facilities.  Generally, other kernel facilities should not be "
"calling this function."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:330
#, no-wrap
msgid "Fn module_init_class class"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:335
msgid ""
"Load and initialize all available modules of the specified E<.Fa class>.  "
"Any built-in modules that have not been disabled, and any modules provided "
"by the boot loader are loaded."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:335
#, no-wrap
msgid "Fn module_hold name"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:338
msgid ""
"Increment the reference count of a module.  A module cannot be unloaded if "
"its reference count is non-zero."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:338
#, no-wrap
msgid "Fn module_rele name"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:340
msgid "Decrement the reference count of a module."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:340
#, no-wrap
msgid "Fn module_find_section name addr size"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:348
msgid ""
"Find the start address and size of linker section E<.Ar name> within a "
"module.  The miniroot module uses this routine to find the address and size "
"of the embedded file system image.  This routine can only examine the linker "
"data for the module that is currently being initialized; it cannot examine "
"data for any other module."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:348
#, no-wrap
msgid "Fn module_init void"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:357
msgid ""
"Initialize the module subsystem.  Creates and initializes various data "
"structures, locates all built-in modules, and establishes the sub-system's "
"E<.Xr sysctl 8> tree.  E<.Fn module_init> is called early in system "
"initialization to facilitate use of security model modules."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:357
#, no-wrap
msgid "Fn module_start_unload_thread void"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:364
msgid ""
"Create the thread that attempts to automatically unload modules that were "
"loaded via the E<.Fn module_autoload> routine.  The function is called only "
"once, after the scheduler and timer functions are initialized."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:364
#, no-wrap
msgid "Fn module_builtin_require_force void"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:374
msgid ""
"Mark as \"disabled\" any built-in modules that have not been successfully "
"initialized.  Modules marked \"disabled\" can only be loaded if the E<.Dv "
"MODCTL_LOAD_FORCE> is specified.  E<.Fn module_builtin_require_force> is "
"called near the end of system initialization, after the E<.Xr init 8> "
"process is created."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/module.9:374
#, no-wrap
msgid "Fn module_load_vfs_init"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:382
msgid ""
"The module subsystem is initialized early, long before any file systems are "
"available.  After the root file system is mounted, E<.Fn "
"module_load_vfs_init> is used to enable loading modules from the file "
"system.  Until this routine is called, modules can only be loaded if they "
"were built-in to the kernel image or provided by the boot loader."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/module.9:383 org_netbsd/src/share/man/man9/secmodel.9:305
#, no-wrap
msgid "PROGRAMMING CONSIDERATIONS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:389
msgid ""
"The module subsystem is designed to be called recursively, but only within a "
"single LWP.  This permits one module's E<.Fn modcmd> routine to load or "
"unload other modules."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:391
msgid "Additional considerations:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:401
msgid ""
"A module is not permitted to load or unload itself.  Attempts to load or "
"unload a module from within its own E<.Fn modcmd> routine will fail with "
"E<.Er EEXIST> or E<.Er EBUSY>, respectively."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:420
msgid ""
"Although a module can be loaded by using either E<.Fn module_load> or E<.Fn "
"module_autoload>, it is not possible for the module's E<.Fn modcmd> routine "
"to distinguish between the two methods.  Any module which needs to ensure "
"that it does not get auto-unloaded must either handle the E<.Dv "
"MODULE_CMD_AUTOUNLOAD> command in its E<.Fn modcmd> routine, or use E<.Fn "
"module_hold> to increment its reference count.  Note however that modules "
"loaded manually with E<.Xr modload 8> are never auto-unloaded."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:426
msgid ""
"The core of the kernel module implementation is in E<.Pa "
"sys/kern/kern_module.c> and E<.Pa sys/kern/kern_module_vfs.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:429
msgid "The routines for linking the module are in E<.Pa sys/kern/subr_kobj.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:432
msgid ""
"The routines for reading a module from the file system are in E<.Pa "
"sys/kern/subr_kobj_vfs.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:434 org_netbsd/src/share/man/man9/pmap.9:198 org_netbsd/src/share/man/man9/secmodel.9:490
msgid "The header file"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/module.9:434
#, no-wrap
msgid "sys/sys/module.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:436 org_netbsd/src/share/man/man9/secmodel.9:492
msgid "describes the public interface."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:449
msgid ""
"In addition, each architecture is expected to provide E<.Fn kobj_machdep>, "
"E<.Fn kobj_reloc>, and E<.Fn module_init_md>.  E<.Fn kobj_machdep> is for "
"any machine dependent actions, such as flushing caches, that are needed when "
"a module is loaded or unloaded.  E<.Fn kobj_reloc> deals with resolution of "
"relocatable symbols.  E<.Fn module_init_md> is for finding modules passed in "
"by the boot loader."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:452
msgid "E<.Xr modctl 2>, E<.Xr module 7>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:458
msgid ""
"The kernel module subsystem first appeared in E<.Nx 5.0>.  It replaces the "
"E<.Dq Tn LKM> subsystem from earlier releases."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/module.9:465
msgid ""
"E<.An -nosplit> The E<.Nm> system was written by E<.An Andrew Doran Aq "
"ad@NetBSD.org>.  This manual page was written by E<.An Paul Goyette Aq "
"pgoyette@NetBSD.org>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/mstohz.9:27 org_netbsd/src/share/man/man9/tvtohz.9:29
#, no-wrap
msgid "October 20, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/mstohz.9:28
#, no-wrap
msgid "MSTOHZ 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mstohz.9:33
msgid "E<.Nm mstohz>, E<.Nm hztoms>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/mstohz.9:33
#, no-wrap
msgid "convert between milliseconds and system clock ticks"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mstohz.9:40
msgid "E<.Ft int> E<.Fn mstohz \"int ms\"> E<.Ft int> E<.Fn hztoms \"int hz\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mstohz.9:51
msgid ""
"The E<.Fn mstohz> macro can be used to convert time in milliseconds to "
"system clock ticks, as used by the E<.Xr callout 9> facility, in an "
"integer-overflow safe way.  Conversely, E<.Fn hztoms> converts system clock "
"ticks to milliseconds."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mstohz.9:59
msgid ""
"These macros are defined in the E<.Aq Em sys/param.h> header.  Individual "
"ports can have a processor-specific, more efficient version implemented in "
"their E<.Aq Em machine/param.h> header as a define."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mstohz.9:62
msgid ""
"The return value is either the number of clock ticks or milliseconds for the "
"specified value."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mstohz.9:66
msgid "E<.Xr param 3>, E<.Xr callout 9>, E<.Xr tvtohz 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mstohz.9:75
msgid ""
"Neither E<.Fn mstohz> nor E<.Fn hztoms> make use of expensive 64-bit integer "
"arithmetic.  The result from E<.Fn mstohz> will be rounded down to one "
"second if the parameter is larger than 131072 milliseconds."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/mutex.9:30
#, no-wrap
msgid "September 14, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/mutex.9:31
#, no-wrap
msgid "MUTEX 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:43
msgid ""
"E<.Nm mutex>, E<.Nm mutex_init>, E<.Nm mutex_destroy>, E<.Nm mutex_enter>, "
"E<.Nm mutex_exit>, E<.Nm mutex_owned>, E<.Nm mutex_spin_enter>, E<.Nm "
"mutex_spin_exit>, E<.Nm mutex_tryenter>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/mutex.9:43
#, no-wrap
msgid "mutual exclusion primitives"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/mutex.9:45
#, no-wrap
msgid "sys/mutex.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:62
msgid ""
"E<.Ft void> E<.Fn mutex_init \"kmutex_t *mtx\" \"kmutex_type_t type\" \"int "
"ipl\"> E<.Ft void> E<.Fn mutex_destroy \"kmutex_t *mtx\"> E<.Ft void> E<.Fn "
"mutex_enter \"kmutex_t *mtx\"> E<.Ft void> E<.Fn mutex_exit \"kmutex_t "
"*mtx\"> E<.Ft int> E<.Fn mutex_owned \"kmutex_t *mtx\"> E<.Ft void> E<.Fn "
"mutex_spin_enter \"kmutex_t *mtx\"> E<.Ft void> E<.Fn mutex_spin_exit "
"\"kmutex_t *mtx\"> E<.Ft int> E<.Fn mutex_tryenter \"kmutex_t *mtx\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:68
msgid ""
"Mutexes are used in the kernel to implement mutual exclusion among LWPs "
"(lightweight processes) and interrupt handlers."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:74
msgid ""
"The E<.Vt kmutex_t> type provides storage for the mutex object.  This should "
"be treated as an opaque object and not examined directly by consumers."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:79
msgid ""
"Mutexes replace the E<.Xr spl 9> system traditionally used to provide "
"synchronization between interrupt handlers and LWPs."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:86
msgid ""
"Kernels compiled with the E<.Dv DIAGNOSTIC> option perform basic sanity "
"checks on mutex operations."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:92
msgid ""
"Kernels compiled with the E<.Dv LOCKDEBUG> option perform potentially CPU "
"intensive sanity checks on mutex operations."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mutex.9:95
#, no-wrap
msgid "Fn mutex_init mtx type ipl"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:98
msgid "Dynamically initialize a mutex for use."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:104
msgid ""
"No other operations can be performed on a mutex until it has been "
"initialized.  Once initialized, all types of mutex are manipulated using the "
"same interface.  Note that E<.Fn mutex_init> may block in order to allocate "
"memory."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:111
msgid ""
"The E<.Fa type> argument must be given as E<.Dv MUTEX_DEFAULT>.  Other "
"constants are defined but are for low-level system use and are not an "
"endorsed, stable part of the interface."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:115
msgid "The type of mutex returned depends on the E<.Fa ipl> argument:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mutex.9:116
#, no-wrap
msgid "IPL_NONE, or one of the IPL_SOFT* constants"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:121
msgid ""
"An adaptive mutex will be returned.  Adaptive mutexes provide mutual "
"exclusion between LWPs, and between LWPs and soft interrupt handlers."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:125
msgid ""
"Adaptive mutexes cannot be acquired from a hardware interrupt handler.  An "
"LWP may either sleep or busy-wait when attempting to acquire an adaptive "
"mutex that is already held."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mutex.9:125
#, no-wrap
msgid "IPL_VM, IPL_SCHED, IPL_HIGH"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:130
msgid ""
"A spin mutex will be returned.  Spin mutexes provide mutual exclusion "
"between LWPs, and between LWPs and interrupt handlers."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:135
msgid ""
"The E<.Fa ipl> argument is used to pass a system interrupt priority level "
"(IPL)  that will block all interrupt handlers that may try to acquire the "
"mutex."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:138
msgid ""
"LWPs that own spin mutexes may not sleep, and therefore must not try to "
"acquire adaptive mutexes or other sleep locks."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:141
msgid ""
"A processor will always busy-wait when attempting to acquire a spin mutex "
"that is already held."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:146
msgid ""
"See E<.Xr spl 9> for further information on interrupt priority levels "
"(IPLs)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mutex.9:147
#, no-wrap
msgid "Fn mutex_destroy mtx"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:153
msgid ""
"Release resources used by a mutex.  The mutex may not be used after it has "
"been destroyed.  E<.Fn mutex_destroy> may block in order to free memory."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mutex.9:153
#, no-wrap
msgid "Fn mutex_enter mtx"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:158
msgid ""
"Acquire a mutex.  If the mutex is already held, the caller will block and "
"not return until the mutex is acquired."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:162
msgid ""
"Mutexes and other types of locks must always be acquired in a consistent "
"order with respect to each other.  Otherwise, the potential for system "
"deadlock exists."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:165
msgid ""
"Adaptive mutexes and other types of lock that can sleep may not be acquired "
"while a spin mutex is held by the caller."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:170
msgid ""
"When acquiring a spin mutex, the IPL of the current CPU will be raised to "
"the level set in E<.Fn mutex_init> if it is not already equal or higher."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mutex.9:170
#, no-wrap
msgid "Fn mutex_exit mtx"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:175
msgid ""
"Release a mutex.  The mutex must have been previously acquired by the "
"caller.  Mutexes may be released out of order as needed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mutex.9:175
#, no-wrap
msgid "Fn mutex_owned mtx"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:181
msgid ""
"For adaptive mutexes, return non-zero if the current LWP holds the mutex.  "
"For spin mutexes, return non-zero if the mutex is held, potentially by the "
"current processor.  Otherwise, return zero."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:185
msgid ""
"E<.Fn mutex_owned> is provided for making diagnostic checks to verify that a "
"lock is held.  For example:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:187
#, no-wrap
msgid "\tKASSERT(mutex_owned(\\*[Am]driver_lock));\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:191
msgid ""
"It should not be used to make locking decisions at run time, or to verify "
"that a lock is not held."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mutex.9:191
#, no-wrap
msgid "Fn mutex_spin_enter mtx"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:200
msgid ""
"Equivalent to E<.Fn mutex_enter>, but may only be used when it is known that "
"E<.Ar mtx> is a spin mutex.  On some architectures, this can substantially "
"reduce the cost of acquring a spin mutex."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mutex.9:200
#, no-wrap
msgid "Fn mutex_spin_exit mtx"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:209
msgid ""
"Equivalent to E<.Fn mutex_exit>, but may only be used when it is known that "
"E<.Ar mtx> is a spin mutex.  On some architectures, this can substantially "
"reduce the cost of releasing a spin mutex."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/mutex.9:209
#, no-wrap
msgid "Fn mutex_tryenter mtx"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:214
msgid ""
"Try to acquire a mutex, but do not block if the mutex is already held.  "
"Returns non-zero if the mutex was acquired, or zero if the mutex was already "
"held."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:222
msgid ""
"E<.Fn mutex_tryenter> can be used as an optimization when acquiring locks in "
"the wrong order.  For example, in a setting where the convention is that "
"E<.Dv first_lock> must be acquired before E<.Dv second_lock>, the following "
"can be used to optimistically lock in reverse order:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:225
#, no-wrap
msgid ""
"\t/* We hold second_lock, but not first_lock. */\n"
"\tKASSERT(mutex_owned(\\*[Am]second_lock));\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:231
#, no-wrap
msgid ""
"\tif (!mutex_tryenter(\\*[Am]first_lock)) {\n"
"\t\t/* Failed to get it - lock in the correct order. */\n"
"\t\tmutex_exit(\\*[Am]second_lock);\n"
"\t\tmutex_enter(\\*[Am]first_lock);\n"
"\t\tmutex_enter(\\*[Am]second_lock);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:238
#, no-wrap
msgid ""
"\t\t/*\n"
"\t\t * We may need to recheck any conditions the code\n"
"\t\t * path depends on, as we released second_lock\n"
"\t\t * briefly.\n"
"\t\t */\n"
"\t}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:243
msgid "The core of the mutex implementation is in E<.Pa sys/kern/kern_mutex.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:248
msgid ""
"The header file E<.Pa sys/sys/mutex.h> describes the public interface, and "
"interfaces that machine-dependent code must provide to support mutexes."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:256
msgid ""
"E<.Xr atomic_ops 3>, E<.Xr membar_ops 3>, E<.Xr lockstat 8>, E<.Xr condvar "
"9>, E<.Xr kpreempt 9>, E<.Xr rwlock 9>, E<.Xr spl 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/mutex.9:267
msgid "The mutex primitives first appeared in E<.Nx 5.0>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/namecache.9:30
#, no-wrap
msgid "July 21, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/namecache.9:31
#, no-wrap
msgid "NAMECACHE 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namecache.9:41
msgid ""
"E<.Nm namecache>, E<.Nm cache_lookup>, E<.Nm cache_revlookup>, E<.Nm "
"cache_enter>, E<.Nm cache_purge>, E<.Nm cache_purgevfs>, E<.Nm "
"namecache_print>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/namecache.9:41
#, no-wrap
msgid "name lookup cache"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/namecache.9:43 org_netbsd/src/share/man/man9/namei.9:43 org_netbsd/src/share/man/man9/pathbuf.9:41 org_netbsd/src/share/man/man9/vnodeops.9:87
#, no-wrap
msgid "sys/namei.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/namecache.9:45 org_netbsd/src/share/man/man9/namei.9:44
#, no-wrap
msgid "sys/uio.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namecache.9:62
msgid ""
"E<.Ft int> E<.Fn cache_lookup \"struct vnode *dvp\" \"struct vnode **vpp\" "
"\"struct componentname *cnp\"> E<.Ft int> E<.Fn cache_revlookup \"struct "
"vnode *vp\" \"struct vnode *dvp\" \"char **bpp\" \"char *bufp\"> E<.Ft void> "
"E<.Fn cache_enter \"struct vnode *dvp\" \"struct vnode *vp\" \"struct "
"componentname *cnp\"> E<.Ft void> E<.Fn cache_purge \"struct vnode *vp\"> "
"E<.Ft void> E<.Fn cache_purgevfs \"struct mount *mp\"> E<.Ft void> E<.Fn "
"namecache_print \"struct vnode *vp\" \"void (*func)(const char *, ...)\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namecache.9:69
msgid ""
"The name lookup cache is the mechanism to allow the file system type "
"dependent algorithms to quickly resolve a file's vnode from its pathname.  "
"The name lookup cache is generally accessed through the higher-level E<.Xr "
"namei 9> interface."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namecache.9:76
msgid ""
"The name of the file is used to lookup an entry associated with the file in "
"the name lookup cache.  If no entry is found, one is created for it.  If an "
"entry is found, the information obtained from the cache lookup contains "
"information about the file which is useful to the file system type dependent "
"functions."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namecache.9:85
msgid ""
"The name lookup cache is managed by a least recently used (LRU)  algorithm "
"so frequently used names will hang around.  The cache itself is a hash table "
"called E<.Va nchashtbl>, containing E<.Em namecache> entries that are "
"allocated dynamically from a kernel memory pool.  Each entry has the "
"following structure:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namecache.9:99
#, no-wrap
msgid ""
"#define NCHNAMLEN\t31\t/* maximum name segment length */\n"
"struct  namecache {\n"
"        LIST_ENTRY(namecache) nc_hash;  /* hash chain */\n"
"        TAILQ_ENTRY(namecache) nc_lru;  /* LRU chain */\n"
"        LIST_ENTRY(namecache) nc_vhash; /* directory hash chain */\n"
"        LIST_ENTRY(namecache) nc_dvlist;\n"
"        struct  vnode *nc_dvp;          /* vnode of parent of name */\n"
"        LIST_ENTRY(namecache) nc_vlist;\n"
"        struct  vnode *nc_vp;           /* vnode the name refers to */\n"
"        int     nc_flags;               /* copy of componentname's "
"ISWHITEOUT */\n"
"        char    nc_nlen;                /* length of name */\n"
"        char    nc_name[NCHNAMLEN];     /* segment name */\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namecache.9:104
msgid ""
"For simplicity (and economy of storage), names longer than a maximum length "
"of NCHNAMLEN are not cached; they occur infrequently in any case, and are "
"almost never of interest."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namecache.9:115
msgid ""
"Each E<.Em namecache> entry can appear on two hash chains in addition to "
"E<.Va nshashtbl>: E<.Em ncvhashtbl> (the name cache directory hash chain), "
"and E<.Em nclruhead> (the name cache LRU chain).  The hash chains are "
"indexed by a hash value obtained from the file's name and the address of its "
"parent directory vnode."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namecache.9:123
msgid ""
"Functions which access to the name cache pass arguments in the partially "
"initialised E<.Em componentname> structure.  See E<.Xr vnodeops 9> for "
"details on this structure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namecache.9:125
#, no-wrap
msgid "Fn cache_lookup dvp vpp cnp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namecache.9:147
msgid ""
"Look for a name in the cache.  E<.Fn cache_lookup> is called with E<.Fa dvp> "
"pointing to the vnode of the directory to search and E<.Fa cnp> pointing to "
"the partially initialised component structure.  E<.Fa cnp-\\*[Gt]cn_nameptr> "
"points to the name of the entry being sought, E<.Fa cnp-\\*[Gt]cn_namelen> "
"tells the length of the name, and E<.Fa cnp-\\*[Gt]cn_hash> contains a hash "
"of the name.  If the lookup succeeds, the vnode is locked, stored in E<.Fa "
"vpp> and a status of zero is returned.  If the locking fails for whatever "
"reason, the vnode is unlocked and the error is returned.  If the lookup "
"determines that the name does not exist any longer, a status of ENOENT is "
"returned.  If the lookup fails, a status of -1 is returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namecache.9:147
#, no-wrap
msgid "Fn cache_revlookup vp dvp bpp bufp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namecache.9:163
msgid ""
"Scan cache looking for name of directory entry pointing at E<.Fa vp> and "
"fill in E<.Fa dvpp>.  If E<.Fa bufp> is E<.Pf non- Dv NULL>, also place the "
"name in the buffer which starts at E<.Fa bufp>, immediately before E<.Fa "
"bpp>, and move bpp backwards to point at the start of it.  If the lookup "
"succeeds, the vnode is referenced.  Returns 0 on success, -1 on cache miss, "
"positive errno on failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namecache.9:163
#, no-wrap
msgid "Fn cache_enter dvp vp cnp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namecache.9:183
msgid ""
"Add an entry to the cache.  E<.Fn cache_enter> is called with E<.Fa dvp> "
"pointing to the vnode of the directory to enter and E<.Fa cnp> pointing to "
"the partially initialised component structure.  If E<.Fa vp> is E<.Dv NULL>, "
"a negative cache entry is created, specifying that the entry does not exist "
"in the file system.  E<.Fa cnp-\\*[Gt]cn_nameptr> points to the name of the "
"entry being entered, E<.Fa cnp-\\*[Gt]cn_namelen> tells the length of the "
"name, and E<.Fa cnp-\\*[Gt]cn_hash> contains a hash of the name."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namecache.9:183
#, no-wrap
msgid "Fn cache_purge vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namecache.9:189
msgid ""
"Flush the cache of a particular vnode E<.Fa vp>.  E<.Fn cache_purge> is "
"called when a vnode is renamed to hide entries that would now be invalid."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namecache.9:189
#, no-wrap
msgid "Fn cache_purgevfs mp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namecache.9:195
msgid ""
"Flush cache of a whole file system E<.Fa mp>.  E<.Fn cache_purgevfs> is "
"called when file system is unmounted to remove entries that would now be "
"invalid."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namecache.9:195
#, no-wrap
msgid "Fn namecache_print vp func"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namecache.9:203
msgid ""
"Print all entries of the name cache.  E<.Fa func> is the E<.Xr printf 9> "
"format.  E<.Fn namecache_print> is only defined if the kernel option DDB is "
"compiled into the kernel."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namecache.9:207
msgid ""
"The name lookup cache is implemented within the file E<.Pa "
"sys/kern/vfs_cache.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namecache.9:212
msgid "E<.Xr intro 9>, E<.Xr namei 9>, E<.Xr vfs 9>, E<.Xr vnode 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namecache.9:215
msgid "The name lookup cache first appeared in E<.Bx 4.2>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namecache.9:216
msgid "The original name lookup cache was written by Robert Elz."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/namei.9:30
#, no-wrap
msgid "November 16, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/namei.9:31
#, no-wrap
msgid "NAMEI 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:41
msgid ""
"E<.Nm namei>, E<.Nm lookup_for_nfsd>, E<.Nm lookup_for_nfsd_index>, E<.Nm "
"relookup>, E<.Nm NDINIT>, E<.Nm namei_simple_kernel>, E<.Nm "
"namei_simple_user>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/namei.9:41
#, no-wrap
msgid "pathname lookup"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:65
msgid ""
"E<.Ft int> E<.Fn namei \"struct nameidata *ndp\"> E<.Ft int> E<.Fn "
"lookup_for_nfsd \"struct nameidata *ndp\" \"struct vnode *startdir\" \"int "
"neverfollow\"> E<.Ft int> E<.Fn lookup_for_nfsd_index \"struct nameidata "
"*ndp\"> E<.Ft int> E<.Fn relookup \"struct vnode *dvp\" \"struct vnode "
"**vpp\" \"struct componentname *cnp\"> E<.Ft void> E<.Fn NDINIT \"struct "
"nameidata *ndp\" \"u_long op\" \"u_long flags\" \"struct pathbuf *pathbuf\"> "
"E<.Ft int> E<.Fn namei_simple_kernel \"const char *path\" "
"\"namei_simple_flags_t sflags\" \"struct vnode **ret\"> E<.Ft int> E<.Fn "
"namei_simple_user \"const char *path\" \"namei_simple_flags_t sflags\" "
"\"struct vnode **ret\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:77
msgid ""
"The E<.Nm> interface is used to convert pathnames to file system vnodes.  "
"The name of the interface is actually a contraction of the words E<.Em name> "
"and E<.Em inode> for name-to-inode conversion, in the days before the E<.Xr "
"vfs 9> interface was implemented."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:83
msgid ""
"Except for the simple forms, the arguments passed to the functions are "
"encapsulated in the E<.Em nameidata> structure.  It has the following "
"structure:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:126
#, no-wrap
msgid ""
"struct nameidata {\n"
"        /*\n"
"         * Arguments to namei/lookup.\n"
"         */\n"
"        const char *ni_dirp;            /* pathname pointer */\n"
"        enum    uio_seg ni_segflg;      /* location of pathname */\n"
"        /*\n"
"         * Arguments to lookup.\n"
"         */\n"
"        struct  vnode *ni_startdir;     /* starting directory */\n"
"        struct  vnode *ni_rootdir;      /* logical root directory */\n"
"        /*\n"
"         * Results: returned from/manipulated by lookup\n"
"         */\n"
"        struct  vnode *ni_vp;           /* vnode of result */\n"
"        struct  vnode *ni_dvp;          /* vnode of intermediate dir */\n"
"        /*\n"
"         * Shared between namei and lookup/commit routines.\n"
"         */\n"
"        size_t  ni_pathlen;             /* remaining chars in path */\n"
"        const char *ni_next;            /* next location in pathname */\n"
"        u_long  ni_loopcnt;             /* count of symlinks encountered "
"*/\n"
"        /*\n"
"         * Lookup parameters\n"
"         */\n"
"        struct componentname {\n"
"                /*\n"
"                 * Arguments to lookup.\n"
"                 */\n"
"                u_long  cn_nameiop;     /* namei operation */\n"
"                u_long  cn_flags;       /* flags to namei */\n"
"                kauth_cred_t cn_cred;   /* credentials */\n"
"                /*\n"
"                 * Shared between lookup and commit routines.\n"
"                 */\n"
"                char    *cn_pnbuf;      /* pathname buffer */\n"
"                const char *cn_nameptr; /* pointer to looked up name */\n"
"                long    cn_namelen;     /* length of looked up component "
"*/\n"
"                u_long  cn_hash;        /* hash value of looked up name */\n"
"                long    cn_consume;     /* chars to consume in lookup() */\n"
"        } ni_cnd;\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:145
msgid ""
"The E<.Nm> interface accesses vnode operations by passing arguments in the "
"partially initialised E<.Em componentname> structure E<.Em ni_cnd>.  This "
"structure describes the subset of information from the nameidata structure "
"that is passed through to the vnode operations.  See E<.Xr vnodeops 9> for "
"more information.  The details of the componentname structure are not "
"absolutely necessary since the members are initialised by the helper macro "
"E<.Fn NDINIT>.  It is useful to know the operations and flags as specified "
"in E<.Xr vnodeops 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:160
msgid ""
"The E<.Nm> interface overloads E<.Em ni_cnd.cn_flags> with some additional "
"flags.  These flags should be specific to the E<.Nm> interface and ignored "
"by vnode operations.  However, due to the historic close relationship "
"between the E<.Nm> interface and the vnode operations, these flags are "
"sometimes used (and set) by vnode operations, particularly E<.Fn "
"VOP_LOOKUP>.  The additional flags are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:162
#, no-wrap
msgid "Dv NOCROSSMOUNT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:164
msgid "do not cross mount points"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:164
#, no-wrap
msgid "Dv RDONLY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:166
msgid "lookup with read-only semantics"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:166
#, no-wrap
msgid "Dv HASBUF"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:169
msgid "caller has allocated pathname buffer E<.Em ni_cnd.cn_pnbuf>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:169
#, no-wrap
msgid "Dv SAVENAME"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:171
msgid "save pathname buffer"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:171
#, no-wrap
msgid "Dv SAVESTART"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:173
msgid "save starting directory"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:173
#, no-wrap
msgid "Dv ISDOTDOT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:175
msgid "current pathname component is .."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:175
#, no-wrap
msgid "Dv MAKEENTRY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:177
msgid "add entry to the name cache"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:177
#, no-wrap
msgid "Dv ISLASTCN"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:179
msgid "this is last component of pathname"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:179
#, no-wrap
msgid "Dv ISSYMLINK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:181
msgid "symlink needs interpretation"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:181
#, no-wrap
msgid "Dv ISWHITEOUT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:183
msgid "found whiteout"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:183
#, no-wrap
msgid "Dv DOWHITEOUT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:185
msgid "do whiteouts"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:185
#, no-wrap
msgid "Dv REQUIREDIR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:187
msgid "must be a directory"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:187
#, no-wrap
msgid "Dv CREATEDIR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:189
msgid "trailing slashes are ok"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:189
#, no-wrap
msgid "Dv PARAMASK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:191
msgid "mask of parameter descriptors"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:218
msgid ""
"If the caller of E<.Fn namei> sets the SAVENAME flag, then it must free the "
"buffer.  If E<.Fn VOP_LOOKUP> sets the flag, then the buffer must be freed "
"by either the commit routine or the E<.Fn VOP_ABORT> routine.  The E<.Dv "
"SAVESTART> flag is set only by the callers of E<.Fn namei>.  It implies "
"E<.Dv SAVENAME> plus the addition of saving the parent directory that "
"contains the name in E<.Em ni_startdir>.  It allows repeated calls to E<.Fn "
"lookup> for the name being sought.  The caller is responsible for releasing "
"the buffer and for invoking E<.Fn vrele> on E<.Em ni_startdir>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:223
msgid ""
"All access to the E<.Nm> interface must be in process context.  Pathname "
"lookups cannot be done in interrupt context."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:225
#, no-wrap
msgid "Fn namei ndp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:239
msgid ""
"Convert a pathname into a pointer to a vnode.  The pathname is specified by "
"E<.Em ndp-\\*[Gt]ni_dirp> and is of length E<.Em ndp-\\*[Gt]ni_pathlen>.  "
"The E<.Em ndp-\\*[Gt]segflg> flags defines whether the name in E<.Em "
"ndp-\\*[Gt]ni_dirp> is an address in kernel space E<.Pq Dv UIO_SYSSPACE> or "
"an address in user space E<.Pq Dv UIO_USERSPACE>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:247
msgid ""
"The vnode for the pathname is returned in E<.Em ndp-\\*[Gt]ni_vp>.  The "
"parent directory is returned locked in E<.Em ndp-\\*[Gt]ni_dvp> iff E<.Dv "
"LOCKPARENT> is specified."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:256
msgid ""
"If E<.Em ndp-\\*[Gt]ni_cnd.cn_flags> has the E<.Dv FOLLOW> flag set then "
"symbolic links are followed when they occur at the end of the name "
"translation process.  Symbolic links are always followed for all other "
"pathname components other than the last."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:269
msgid ""
"Historically E<.Nm> had a sub-function called E<.Fn lookup>.  This function "
"processed a pathname until either running out of material or encountering a "
"symbolic link.  E<.Nm> worked by first setting up the start directory E<.Em "
"ndp-\\*[Gt]ni_startdir> and then calling E<.Fn lookup> repeatedly."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:281
msgid ""
"The semantics of E<.Nm> are altered by the operation specified by E<.Em "
"ndp-\\*[Gt]ni_cnd.cn_nameiop>.  When E<.Dv CREATE>, E<.Dv RENAME>, or E<.Dv "
"DELETE> is specified, information usable in creating, renaming, or deleting "
"a directory entry may be calculated."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:286
msgid ""
"If the target of the pathname exists and LOCKLEAF is set, the target is "
"returned locked in E<.Em ndp-\\*[Gt]ni_vp>, otherwise it is returned "
"unlocked."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:292
msgid ""
"As of this writing the internal function E<.Fn do_lookup> is comparable to "
"the historic E<.Fn lookup> but this code is slated for refactoring."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:292
#, no-wrap
msgid "Fn lookup_for_nfsd ndp startdir neverfollow"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:308
msgid ""
"This is a private entry point into E<.Nm> used by the NFS server code.  It "
"looks up a path starting from E<.Fa startdir>.  If E<.Fa neverfollow> is "
"set, E<.Em any> symbolic link (not just at the end of the path) will cause "
"an error.  Otherwise, it follows symlinks normally.  Its semantics are "
"similar to a symlink-following loop around the historic E<.Fn lookup> "
"function described above.  It should not be used by new code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:308
#, no-wrap
msgid "Fn lookup_for_nfsd_index ndp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:316
msgid ""
"This is a (second) private entry point into E<.Nm> used by the NFS server "
"code.  Its semantics are similar to the historic E<.Fn lookup> function "
"described above.  It should not be used by new code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:316
#, no-wrap
msgid "Fn relookup dvp vpp cnp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:326
msgid ""
"Reacquire a path name component is a directory.  This is a quicker way to "
"lookup a pathname component when the parent directory is known.  The locked "
"parent directory vnode is specified by E<.Fa dvp> and the pathname component "
"by E<.Fa cnp>.  The vnode of the pathname is returned in the address "
"specified by E<.Fa vpp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:326
#, no-wrap
msgid "Fn NDINIT ndp op flags pathbuf"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:352
msgid ""
"Initialise a nameidata structure pointed to by E<.Fa ndp> for use by the "
"E<.Nm> interface.  It saves having to deal with the componentname structure "
"inside E<.Fa ndp>.  The operation and flags are specified by E<.Fa op> and "
"E<.Fa flags> respectively.  These are the values to which E<.Em "
"ndp-\\*[Gt]ni_cnd.cn_nameiop> and E<.Em ndp-\\*[Gt]ni_cnd.cn_flags> are "
"respectively set.  The pathname is passed as a pathbuf structure, which "
"should be initialized using one of the E<.Xr pathbuf 9> operations.  "
"Destroying the pathbuf is the responsibility of the caller; this must not be "
"done until the caller is finished with all of the E<.Nm> results and all of "
"the nameidata contents except for the result vnode."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:361
msgid ""
"This routine stores the credentials of the calling thread E<.Va ( curlwp>)  "
"in E<.Fa ndp>.  In the rare case that another set of credentials is required "
"for the namei operation, E<.Em ndp-\\*[Gt]ni_cnd.cn_cred> must be set "
"manually."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:361
#, no-wrap
msgid "Fn namei_simple_kernel path sflags ret"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:375
msgid ""
"Look up the path E<.Fa path> and translate it to a vnode, returned in E<.Fa "
"ret>.  The E<.Fa path> argument must be a kernel E<.Pq Dv UIO_SYSSPACE> "
"pointer.  The E<.Fa sflags> argument chooses the precise behavior.  It may "
"be set to one of the following symbols:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:376
#, no-wrap
msgid "Dv NSM_NOFOLLOW_NOEMULROOT"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:377
#, no-wrap
msgid "Dv NSM_NOFOLLOW_TRYEMULROOT"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:378
#, no-wrap
msgid "Dv NSM_FOLLOW_NOEMULROOT"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:379
#, no-wrap
msgid "Dv NSM_FOLLOW_TRYEMULROOT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:397
msgid ""
"These select (or not) the E<.Dv FOLLOW/NOFOLLOW> and E<.Dv TRYEMULROOT> "
"flags.  Other flags are not available through this interface, which is "
"nonetheless sufficient for more than half the E<.Fn namei> usage in the "
"kernel.  Note that the encoding of E<.Fa sflags> has deliberately been "
"arranged to be type-incompatible with anything else.  This prevents various "
"possible accidents while the E<.Fn namei> interface is being rototilled."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/namei.9:397
#, no-wrap
msgid "Fn namei_simple_user path sflags ret"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:405
msgid ""
"This function is the same as E<.Fn namei_simple_kernel> except that the "
"E<.Fa path> argument shall be a user pointer E<.Pq Dv UIO_USERSPACE> rather "
"than a kernel pointer."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:409
msgid ""
"The name lookup subsystem is implemented within the file E<.Pa "
"sys/kern/vfs_lookup.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:415
msgid ""
"E<.Xr intro 9>, E<.Xr namecache 9>, E<.Xr vfs 9>, E<.Xr vnode 9>, E<.Xr "
"vnodeops 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/namei.9:421
msgid ""
"It is unfortunate that much of the E<.Nm> interface makes assumptions on the "
"underlying vnode operations.  These assumptions are an artefact of the "
"introduction of the vfs interface to split a file system interface which was "
"historically designed as a tightly coupled module."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/npf_ncode.9:30
#, no-wrap
msgid "December 23, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/npf_ncode.9:31
#, no-wrap
msgid "NPF_NCODE 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:35
msgid "E<.Nm npf_ncode>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/npf_ncode.9:35
#, no-wrap
msgid "NPF n-code processor"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/npf_ncode.9:37
#, no-wrap
msgid "net/npf_ncode.h"
msgstr ""

#.  -----
#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:44
msgid ""
"E<.Ft int> E<.Fn npf_ncode_process \"npf_cache_t *npc\" \"const void "
"*ncode\" \"nbuf_t *nbuf\" \"int layer\"> E<.Ft int> E<.Fn npf_ncode_validate "
"\"const void *ncode\" \"size_t sz\" \"int *errat\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:47
msgid ""
"The NPF n-code processor is a general purpose engine to inspect network "
"packets, which are abstracted as chained buffers."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:63
msgid ""
"E<.Fn npf_ncode_process> performs n-code processing using data of the "
"specified packet.  E<.Fa ncode> is the address to a validated n-code memory "
"block.  N-code memory addresses should be 32-bit word aligned.  E<.Fa nbuf> "
"is an opaque network buffer on which the n-code processor will operate.  "
"E<.Fa layer> specifies at which network layer the buffer is passed, it can "
"be either E<.Dv NPF_LAYER_L2> or E<.Dv NPF_LAYER_L3>.  This value is "
"initially set in the R0 register and can be checked by the n-code.  The "
"contents of other registers are unspecified."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:66
msgid "E<.Fn npf_ncode_process> returns a value from the n-code."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:76
msgid ""
"E<.Fn npf_ncode_validate> performs n-code validation.  E<.Fa ncode> is the "
"address to an n-code memory block.  E<.Fa sz> is the size of the memory "
"block.  E<.Fa errat> is the word number in the n-code where the error is "
"detected.  If no error is found, this value is undefined."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:81
msgid ""
"On successful validation, the E<.Fn npf_ncode_validate> function returns 0.  "
"Otherwise, it may return one of the following error codes:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:82
#, no-wrap
msgid "Bq Er NPF_ERR_OPCODE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:84
msgid "Invalid instruction (unknown opcode)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:84
#, no-wrap
msgid "Bq Er NPF_ERR_JUMP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:86
msgid "Invalid jump, e.g. not to the instruction or out of range."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:86
#, no-wrap
msgid "Bq Er NPF_ERR_REG"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:88
msgid "Invalid register, i.e. incorrect index number."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:88
#, no-wrap
msgid "Bq Er NPF_ERR_INVAL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:90
msgid "Invalid argument value."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:90
#, no-wrap
msgid "Bq Er NPF_ERR_RANGE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:92
msgid "Processing out of range, e.g. missing return path."
msgstr ""

#.  -----
#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:97
msgid ""
"Any untrusted n-code, for example generated by userspace, should be "
"validated (once) before allowing to process it."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/npf_ncode.9:97
#, no-wrap
msgid "PROCESSING"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:101
msgid ""
"There are two instruction sets: RISC-like and CISC-like.  Processing is done "
"in words, therefore both instructions (their codes) and arguments are always "
"32-bit long words."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:107
msgid ""
"There are four general purpose registers: R0, R1, R2, R3.  Each can store "
"32-bit long words.  Registers are mainly to store values for operations "
"using RISC-like instructions.  CISC-like instructions, however, use them to "
"store return values."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:116
msgid ""
"Processing begins from the first word until it reaches an E<.Dv "
"NPF_OPCODE_RET> instruction with a return value.  The instruction pointer "
"can be changed using jump operations, which always take relative addresses, "
"in words.  The result of last comparison is tracked internally and jump "
"operations should be performed immediately after comparison or certain "
"CISC-like instructions."
msgstr ""

#.  -----
#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:126
msgid ""
"CISC-like instructions and E<.Dv NPF_OPCODE_LOAD> can be used to load data "
"from network buffers.  They operate at the current network buffer offset, "
"which is initially at the beginning of the network buffer.  The E<.Dv "
"NPF_OPCODE_ADVR> instruction can be used to advance the current network "
"buffer offset."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/npf_ncode.9:126
#, no-wrap
msgid "CACHING"
msgstr ""

#.  -----
#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:136
msgid ""
"Various packet data is cached during execution of CISC-like instructions and "
"further instruction calls may retrieve information from the cache.  If "
"n-code changes the packet data, information in the cache might no longer "
"reflect the changes.  In such case, it is n-code's responsibility to "
"invalidate the cache (if necessary) by executing the E<.Dv NPF_OPCODE_INVL> "
"instruction."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/npf_ncode.9:136
#, no-wrap
msgid "INSTRUCTIONS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:138
msgid "Return, advance, jump, and tag operations."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:139
#, no-wrap
msgid "Sy 0x00 NPF_OPCODE_RET E<lt>return valueE<gt>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:141
msgid "Finish processing and return passed value."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:141
#, no-wrap
msgid "Sy 0x01 NPF_OPCODE_ADVR E<lt>registerE<gt>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:145
msgid ""
"Advance current network buffer offset by a value, passed in the specified "
"register.  Value represents bytes and cannot be negative or zero."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:145
#, no-wrap
msgid "Sy 0x02 NPF_OPCODE_J E<lt>relative addressE<gt>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:149
msgid ""
"Jump processor to a relative address (from this instruction).  The address "
"value is the amount of words forwards or backwards.  It can point only to a "
"valid instruction, at valid boundaries."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:149
#, no-wrap
msgid "Sy 0x03 NPF_OPCODE_INVL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:151
msgid "Invalidate all data in the packet cache."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:151
#, no-wrap
msgid "Sy 0x04 NPF_OPCODE_TAG E<lt>keyE<gt> E<lt>valueE<gt>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:153
msgid "Add a tag with specified key and value to the primary network buffer (nbuf)."
msgstr ""

#.  ---
#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:157
msgid "Set and load operations."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:158
#, no-wrap
msgid "Sy 0x10 NPF_OPCODE_MOVE E<lt>valueE<gt>, E<lt>registerE<gt>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:160
msgid "Set the specified value to a register."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:160
#, no-wrap
msgid "Sy 0x11 NPF_OPCODE_LW E<lt>lengthE<gt>, E<lt>registerE<gt>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:168
msgid ""
"Load specified length of packet data into the register.  The data is read "
"starting from the current network buffer offset.  The operation does not "
"advance the offset after read, however.  The value of E<.Fa length> "
"represents bytes and must be in the range from 1 to 4.  Returned data is in "
"network byte order."
msgstr ""

#.  ---
#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:172
msgid "Compare and jump operations."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:173
#, no-wrap
msgid "Sy 0x21 NPF_OPCODE_CMP E<lt>valueE<gt>, E<lt>registerE<gt>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:176
msgid ""
"Compare the specified value and value in a register.  The result is stored "
"internally and can be tested by jump instructions."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:176
#, no-wrap
msgid "Sy 0x22 NPF_OPCODE_CMPR E<lt>registerE<gt>, E<lt>registerE<gt>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:179
msgid ""
"Compare values of two registers.  The result is stored internally and can be "
"tested by jump instructions."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:179
#, no-wrap
msgid "Sy 0x23 NPF_OPCODE_BEQ E<lt>relative addressE<gt>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:182
msgid ""
"Jump if the result of the last comparison was \"equal\".  Otherwise, "
"continue processing with the next instruction."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:182
#, no-wrap
msgid "Sy 0x24 NPF_OPCODE_BNE E<lt>relative addressE<gt>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:185
msgid ""
"Jump if the result of last comparison was \"not equal\".  Otherwise, "
"continue processing with the next instruction."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:185
#, no-wrap
msgid "Sy 0x25 NPF_OPCODE_BGT E<lt>relative addressE<gt>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:188
msgid ""
"Jump if the result of last comparison was \"greater than\".  Otherwise, "
"continue processing with the next instruction."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:188
#, no-wrap
msgid "Sy 0x26 NPF_OPCODE_BLT E<lt>relative addressE<gt>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:191
msgid ""
"Jump if the result of last comparison was \"less than\".  Otherwise, "
"continue processing with the next instruction."
msgstr ""

#.  ---
#.  Arithmetic operations.
#.  .Bl -tag -width indent
#.  .It Sy 0x30 NPF_OPCODE_ADD
#.  .It Sy 0x31 NPF_OPCODE_SUB
#.  .It Sy 0x32 NPF_OPCODE_MULT
#.  .It Sy 0x33 NPF_OPCODE_DIV
#.  .El
#.  .Pp
#.  ---
#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:204
msgid "Bitwise operations."
msgstr ""

#.  .It Sy 0x40 NPF_OPCODE_NOT
#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:206
#, no-wrap
msgid "Sy 0x41 NPF_OPCODE_AND E<lt>valueE<gt>, E<lt>registerE<gt>"
msgstr ""

#.  .It Sy 0x42 NPF_OPCODE_OR
#.  .It Sy 0x43 NPF_OPCODE_XOR
#.  .It Sy 0x44 NPF_OPCODE_SLL
#.  .It Sy 0x45 NPF_OPCODE_SRL
#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:215
msgid ""
"Perform bitwise E<.Dv AND> with a specified value and the value in the "
"register.  The result is stored in the register."
msgstr ""

#.  -----
#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:219
msgid "CISC-like n-code instructions."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:220
#, no-wrap
msgid ""
"Sy 0x80 NPF_OPCODE_ETHER E<lt>s/dE<gt>, E<lt>_reservedE<gt>, E<lt>ether "
"typeE<gt>"
msgstr ""

#.  -
#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:225
msgid ""
"Read Ethernet type in the frame, handle possible VLAN and match with the "
"value passed in the argument.  Return value to advance to layer 3 header in "
"R3."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:225
#, no-wrap
msgid ""
"Sy 0x90 NPF_OPCODE_IP4MASK E<lt>s/dE<gt>, E<lt>network addressE<gt>, "
"E<lt>subnetE<gt>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:231
msgid ""
"Match passed network address with subnet against source or destination "
"address in the IPv4 header.  Address and mask should be in network byte "
"order.  Value of first argument indicates whether source (if 0x1) or "
"destination (if 0x0) address should be matched."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:231
#, no-wrap
msgid "Sy 0x91 NPF_OPCODE_TABLE E<lt>s/dE<gt>, E<lt>table idE<gt>"
msgstr ""

#.  -
#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:237
msgid ""
"Match the source or destination address with NPF table contents specified by "
"table ID.  Value of the first argument indicates whether source (if 0x1) or "
"destination (if 0x0) address should be matched."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:237
#, no-wrap
msgid "Sy 0x92 NPF_OPCODE_ICMP4 E<lt>type/codeE<gt>"
msgstr ""

#.  -
#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:245
msgid ""
"Match that packet is ICMP and compare type and code values, if required.  "
"Highest 32nd and 31st bits indicate whether the type and code values, "
"accordingly, should be compared.  If comparison is required, the type and "
"code values are represented by lower 16 bits.  The higher 8 bits represent "
"type, and the lower 8 bits code number."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:245
#, no-wrap
msgid ""
"Sy 0x93 NPF_OPCODE_IP6MASK E<lt>s/dE<gt>, E<lt>network addressE<gt>, "
"E<lt>subnetE<gt>"
msgstr ""

#.  -
#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:252
msgid ""
"Match passed network address with subnet against source or destination "
"address in the IPv6 header.  Address and mask should be in network byte "
"order.  Value of first argument indicates whether source (if 0x1) or "
"destination (if 0x0) address should be matched."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:252
#, no-wrap
msgid "Sy 0xa0 NPF_OPCODE_TCP_PORTS E<lt>s/dE<gt>, E<lt>port rangeE<gt>"
msgstr ""

#.  -
#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:261
msgid ""
"Match the TCP source or destination port with a specified port range.  The "
"higher 16 bits of the second argument represent the \"from\" and the lower "
"16 bits represent the \"to\" values of the range.  The 32-bit port range "
"value is in host byte order, however the actual \"from\" and \"to\" values "
"should be in network byte order.  The value of the first argument indicates "
"whether source (if 0x1) or destination (if 0x0) port should be matched."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:261
#, no-wrap
msgid "Sy 0xa1 NPF_OPCODE_UDP_PORTS E<lt>s/dE<gt>, E<lt>port rangeE<gt>"
msgstr ""

#.  -
#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:266
msgid "Equivalent of E<.Dv NPF_OPCODE_TCP_PORT>, but for UDP protocol."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/npf_ncode.9:266
#, no-wrap
msgid "Sy 0xa2 NPF_OPCODE_TCP_FLAGS E<lt>fl/maskE<gt>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:270
msgid ""
"Match the TCP flags with the a specified flags and mask, represented by the "
"lower 16 bits.  The higher 8 bits represent flags and the lower 8 bits mask "
"to apply."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:277
msgid ""
"The E<.Nm> is implemented within the file E<.Pa "
"sys/net/npf/npf_processor.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:280
msgid "E<.Xr npf.conf 5>, E<.Xr npfctl 8>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/npf_ncode.9:282
msgid "The NPF n-code processor first appeared in E<.Nx 6.0>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/nullop.9:30
#, no-wrap
msgid "July 25, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/nullop.9:31
#, no-wrap
msgid "NULLOP 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/nullop.9:35
msgid "E<.Nm nullop>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/nullop.9:35
#, no-wrap
msgid "dummy functions"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/nullop.9:52
msgid ""
"E<.Ft int> E<.Fn nullop \"void *v\"> E<.Ft void> E<.Fn voidop \"void\"> "
"E<.Ft int> E<.Fn enodev \"void\"> E<.Ft int> E<.Fn enxio \"void\"> E<.Ft "
"int> E<.Fn enoioctl \"void\"> E<.Ft int> E<.Fn enosys \"void\"> E<.Ft int> "
"E<.Fn eopnotsupp \"void\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/nullop.9:61
msgid ""
"The E<.Fn nullop> function provides a generic E<.Dq null operation>.  It "
"always returns the value 0.  The E<.Fn voidop> function takes no arguments "
"and does nothing."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/nullop.9:77
msgid ""
"The E<.Fn enodev>, E<.Fn enxio>, E<.Fn enoioctl>, E<.Fn enosys>, and E<.Fn "
"eopnotsupp> functions always fail, returning E<.Er ENODEV>, E<.Er ENXIO>, "
"E<.Er ENOTTY>, E<.Er ENOSYS>, and E<.Er EOPNOTSUPP>, respectively."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/nullop.9:81
msgid "The following example demonstrates a case where E<.Fn nullop> may be useful:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/nullop.9:83
#, no-wrap
msgid "uint64_t xc;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/nullop.9:85 org_netbsd/src/share/man/man9/roundup.9:93 org_netbsd/src/share/man/man9/setbit.9:74
#, no-wrap
msgid "\\&...\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/nullop.9:88
#, no-wrap
msgid ""
"xc = xc_broadcast(0, (xcfunc_t)nullop, NULL, NULL);\n"
"xc_wait(xc);\n"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/opencrypto.9:19
#, no-wrap
msgid "September 17, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/opencrypto.9:20
#, no-wrap
msgid "OPENCRYPTO 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:36
msgid ""
"E<.Nm opencrypto>, E<.Nm crypto_get_driverid>, E<.Nm crypto_register>, E<.Nm "
"crypto_kregister>, E<.Nm crypto_unregister>, E<.Nm crypto_done>, E<.Nm "
"crypto_kdone>, E<.Nm crypto_newsession>, E<.Nm crypto_freesession>, E<.Nm "
"crypto_dispatch>, E<.Nm crypto_kdispatch>, E<.Nm crypto_getreq>, E<.Nm "
"crypto_freereq>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/opencrypto.9:36
#, no-wrap
msgid "API for cryptographic services in the kernel"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/opencrypto.9:38
#, no-wrap
msgid "opencrypto/cryptodev.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:63
msgid ""
"E<.Ft int32_t> E<.Fn crypto_get_driverid \"u_int32_t\"> E<.Ft int> E<.Fn "
"crypto_register \"u_int32_t\" \"int\" \"u_int16_t\" \"u_int32_t\" \"int "
"(*)(void *, u_int32_t *, struct cryptoini *)\" \"int (*)(void *, u_int32_t "
"*)\" \"int (*)(u_int64_t)\" \"int (*)(struct cryptop *)\" \"void *\"> E<.Ft "
"int> E<.Fn crypto_kregister \"u_int32_t\" \"int\" \"u_int32_t\" \"int "
"(*)(void *, struct cryptkop *, int)\" \"void *\"> E<.Ft int> E<.Fn "
"crypto_unregister \"u_int32_t\" \"int\"> E<.Ft void> E<.Fn crypto_done "
"\"struct cryptop *\"> E<.Ft void> E<.Fn crypto_kdone \"struct cryptkop *\"> "
"E<.Ft int> E<.Fn crypto_newsession \"u_int64_t *\" \"struct cryptoini *\" "
"\"int\"> E<.Ft int> E<.Fn crypto_freesession \"u_int64_t\"> E<.Ft int> E<.Fn "
"crypto_dispatch \"struct cryptop *\"> E<.Ft int> E<.Fn crypto_kdispatch "
"\"struct cryptkop *\"> E<.Ft struct cryptop *> E<.Fn crypto_getreq \"int\"> "
"E<.Ft void> E<.Fn crypto_freereq \"struct cryptop *\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:66
#, no-wrap
msgid "#define EALG_MAX_BLOCK_LEN      16\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:75
#, no-wrap
msgid ""
"struct cryptoini {\n"
"\tint                cri_alg;\n"
"\tint                cri_klen;\n"
"\tint                cri_rnd;\n"
"\tvoid            *cri_key;\n"
"\tu_int8_t           cri_iv[EALG_MAX_BLOCK_LEN];\n"
"\tstruct cryptoini  *cri_next;\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:84
#, no-wrap
msgid ""
"struct cryptodesc {\n"
"\tint                crd_skip;\n"
"\tint                crd_len;\n"
"\tint                crd_inject;\n"
"\tint                crd_flags;\n"
"\tstruct cryptoini   CRD_INI;\n"
"\tstruct cryptodesc *crd_next;\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:98
#, no-wrap
msgid ""
"struct cryptop {\n"
"\tTAILQ_ENTRY(cryptop) crp_next;\n"
"\tu_int64_t          crp_sid;\n"
"\tint                crp_ilen;\n"
"\tint                crp_olen;\n"
"\tint                crp_etype;\n"
"\tint                crp_flags;\n"
"\tvoid            *crp_buf;\n"
"\tvoid            *crp_opaque;\n"
"\tstruct cryptodesc *crp_desc;\n"
"\tint              (*crp_callback)(struct cryptop *);\n"
"\tvoid            *crp_mac;\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:103
#, no-wrap
msgid ""
"struct crparam {\n"
"        void         *crp_p;\n"
"        u_int           crp_nbits;\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:105
#, no-wrap
msgid "#define CRK_MAXPARAM    8\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:116
#, no-wrap
msgid ""
"struct cryptkop {\n"
"\tTAILQ_ENTRY(cryptkop) krp_next;\n"
"        u_int              krp_op;         /* i.e. CRK_MOD_EXP or other */\n"
"        u_int              krp_status;     /* return status */\n"
"        u_short            krp_iparams;    /* # of input parameters */\n"
"        u_short            krp_oparams;    /* # of output parameters */\n"
"\tu_int32_t\t   krp_hid;\n"
"        struct crparam     krp_param[CRK_MAXPARAM];\t  /* kvm */\n"
"        int               (*krp_callback)(struct cryptkop *);\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:133
msgid ""
"E<.Nm> is a framework for drivers of cryptographic hardware to register with "
"the kernel so E<.Dq consumers> (other kernel subsystems, and eventually "
"users through an appropriate device) are able to make use of it.  Drivers "
"register with the framework the algorithms they support, and provide entry "
"points (functions) the framework may call to establish, use, and tear down "
"sessions.  Sessions are used to cache cryptographic information in a "
"particular driver (or associated hardware), so initialization is not needed "
"with every request.  Consumers of cryptographic services pass a set of "
"descriptors that instruct the framework (and the drivers registered with it) "
"of the operations that should be applied on the data (more than one "
"cryptographic operation can be requested)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:138
msgid ""
"Keying operations are supported as well.  Unlike the symmetric operators "
"described above, these sessionless commands perform mathematical operations "
"using input and output parameters."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:157
msgid ""
"Since the consumers may not be associated with a process, drivers may not "
"use condition variables: E<.Xr condvar 9>.  The same holds for the "
"framework.  Thus, a callback mechanism is used to notify a consumer that a "
"request has been completed (the callback is specified by the consumer on an "
"per-request basis).  The callback is invoked by the framework whether the "
"request was successfully completed or not.  An error indication is provided "
"in the latter case.  A specific error code, E<.Er EAGAIN>, is used to "
"indicate that a session number has changed and that the request may be "
"re-submitted immediately with the new session number.  Errors are only "
"returned to the invoking function if not enough information to call the "
"callback is available (meaning, there was a fatal error in verifying the "
"arguments).  No callback mechanism is used for session initialization and "
"teardown."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:171
msgid ""
"The E<.Fn crypto_newsession> routine is called by consumers of cryptographic "
"services (such as the E<.Xr ipsec 4> stack) that wish to establish a new "
"session with the framework.  On success, the first argument will contain the "
"Session Identifier (SID).  The second argument contains all the necessary "
"information for the driver to establish the session.  The third argument "
"indicates whether a hardware driver should be used (1) or not (0).  The "
"various fields in the E<.Fa cryptoini> structure are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:172
#, no-wrap
msgid "Fa cri_alg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:175
msgid "Contains an algorithm identifier.  Currently supported algorithms are:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:209
#, no-wrap
msgid ""
"CRYPTO_DES_CBC\n"
"CRYPTO_3DES_CBC\n"
"CRYPTO_BLF_CBC\n"
"CRYPTO_CAST_CBC\n"
"CRYPTO_CAMELLIA_CBC\n"
"CRYPTO_SKIPJACK_CBC\n"
"CRYPTO_ARC4\n"
"CRYPTO_AES_CBC\n"
"CRYPTO_AES_CTR\n"
"CRYPTO_AES_GCM_16\n"
"CRYPTO_AES_GMAC\n"
"CRYPTO_AES_128_GMAC\n"
"CRYPTO_AES_192_GMAC\n"
"CRYPTO_AES_256_GMAC\n"
"CRYPTO_AES_XCBC_MAC_96\n"
"CRYPTO_MD5\n"
"CRYPTO_MD5_HMAC\n"
"CRYPTO_MD5_HMAC_96\n"
"CRYPTO_MD5_KPDK\n"
"CRYPTO_NULL_CBC\n"
"CRYPTO_NULL_HMAC\n"
"CRYPTO_SHA1\n"
"CRYPTO_SHA1_HMAC\n"
"CRYPTO_SHA1_HMAC_96\n"
"CRYPTO_SHA1_KPDK\n"
"CRYPTO_SHA2_256_HMAC\n"
"CRYPTO_SHA2_384_HMAC\n"
"CRYPTO_SHA2_512_HMAC\n"
"CRYPTO_RIPEMD160_HMAC\n"
"CRYPTO_RIPEMD160_HMAC_96\n"
"CRYPTO_DEFLATE_COMP\n"
"CRYPTO_DEFLATE_COMP_NOGROW\n"
"CRYPTO_GZIP_COMP\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:211
#, no-wrap
msgid "Fa cri_klen"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:214
msgid "Specifies the length of the key in bits, for variable-size key algorithms."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:214
#, no-wrap
msgid "Fa cri_rnd"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:217
msgid ""
"Specifies the number of rounds to be used with the algorithm, for "
"variable-round algorithms."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:217
#, no-wrap
msgid "Fa cri_key"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:219
msgid "Contains the key to be used with the algorithm."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:219
#, no-wrap
msgid "Fa cri_iv"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:225
msgid ""
"Contains an explicit initialization vector (IV), if it does not prefix the "
"data.  This field is ignored during initialization.  If no IV is explicitly "
"passed (see below on details), a random IV is used by the device driver "
"processing the request."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:225
#, no-wrap
msgid "Fa cri_next"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:232
msgid ""
"Contains a pointer to another E<.Fa cryptoini> structure.  Multiple such "
"structures may be linked to establish multi-algorithm sessions E<.Pf ( Xr "
"ipsec 4> is an example consumer of such a feature)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:241
msgid ""
"The E<.Fa cryptoini> structure and its contents will not be modified by the "
"framework (or the drivers used).  Subsequent requests for processing that "
"use the SID returned will avoid the cost of re-initializing the hardware (in "
"essence, SID acts as an index in the session cache of the driver)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:246
msgid ""
"E<.Fn crypto_freesession> is called with the SID returned by E<.Fn "
"crypto_newsession> to disestablish the session."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:252
msgid ""
"E<.Fn crypto_dispatch> is called to process a request.  The various fields "
"in the E<.Fa cryptop> structure are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:253
#, no-wrap
msgid "Fa crp_sid"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:255
msgid "Contains the SID."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:255
#, no-wrap
msgid "Fa crp_ilen"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:257
msgid "Indicates the total length in bytes of the buffer to be processed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:257
#, no-wrap
msgid "Fa crp_olen"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:261
msgid ""
"On return, contains the length of the result, not including E<.Fa "
"crd_skip>.  For symmetric crypto operations, this will be the same as the "
"input length."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:261
#, no-wrap
msgid "Fa crp_alloctype"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:267
msgid ""
"Indicates the type of buffer, as used in the kernel E<.Xr malloc 9> "
"routine.  This will be used if the framework needs to allocate a new buffer "
"for the result (or for re-formatting the input)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:267
#, no-wrap
msgid "Fa crp_callback"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:279
msgid ""
"This routine is invoked upon completion of the request, whether successful "
"or not.  It is invoked through the E<.Fn crypto_done> routine.  If the "
"request was not successful, an error code is set in the E<.Fa crp_etype> "
"field.  It is the responsibility of the callback routine to set the "
"appropriate E<.Xr spl 9> level."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:279
#, no-wrap
msgid "Fa crp_etype"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:292
msgid ""
"Contains the error type, if any errors were encountered, or zero if the "
"request was successfully processed.  If the E<.Er EAGAIN> error code is "
"returned, the SID has changed (and has been recorded in the E<.Fa crp_sid> "
"field).  The consumer should record the new SID and use it in all subsequent "
"requests.  In this case, the request may be re-submitted immediately.  This "
"mechanism is used by the framework to perform session migration (move a "
"session from one driver to another, because of availability, performance, or "
"other considerations)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:302
msgid ""
"Note that this field only makes sense when examined by the callback routine "
"specified in E<.Fa crp_callback>.  Errors are returned to the invoker of "
"E<.Fn crypto_process> only when enough information is not present to call "
"the callback routine (i.e., if the pointer passed is E<.Dv NULL> or if no "
"callback routine was specified)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:302
#, no-wrap
msgid "Fa crp_flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:305
msgid ""
"Is a bitmask of flags associated with this request.  Currently defined flags "
"are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:306
#, no-wrap
msgid "Dv CRYPTO_F_IMBUF"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:310
msgid "The buffer pointed to by E<.Fa crp_buf> is an mbuf chain."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:312
#, no-wrap
msgid "Fa crp_buf"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:321
msgid ""
"Points to the input buffer.  On return (when the callback is invoked), it "
"contains the result of the request.  The input buffer may be an mbuf chain "
"or a contiguous buffer (of a type identified by E<.Fa crp_alloctype>), "
"depending on E<.Fa crp_flags>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:321
#, no-wrap
msgid "Fa crp_opaque"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:324
msgid ""
"This is passed through the crypto framework untouched and is intended for "
"the invoking application's use."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:324
#, no-wrap
msgid "Fa crp_desc"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:330
msgid ""
"This is a linked list of descriptors.  Each descriptor provides information "
"about what type of cryptographic operation should be done on the input "
"buffer.  The various fields are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:331
#, no-wrap
msgid "Fa crd_skip"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:333
msgid "The offset in the input buffer where processing should start."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:333
#, no-wrap
msgid "Fa crd_len"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:337
msgid "How many bytes, after E<.Fa crd_skip>, should be processed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:337
#, no-wrap
msgid "Fa crd_inject"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:345
msgid ""
"Offset from the beginning of the buffer to insert any results.  For "
"encryption algorithms, this is where the initialization vector (IV) will be "
"inserted when encrypting or where it can be found when decrypting (subject "
"to E<.Fa crd_flags>).  For MAC algorithms, this is where the result of the "
"keyed hash will be inserted."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:345
#, no-wrap
msgid "Fa crd_flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:348
msgid ""
"For adjusting general operation from userland, the following flags are "
"defined:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:349
#, no-wrap
msgid "Dv CRD_F_ENCRYPT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:352
msgid ""
"For encryption algorithms, this bit is set when encryption is required (when "
"not set, decryption is performed)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:352
#, no-wrap
msgid "Dv CRD_F_IV_PRESENT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:368
msgid ""
"For encryption algorithms, this bit is set when the IV already precedes the "
"data, so the E<.Fa crd_inject> value will be ignored and no IV will be "
"written in the buffer.  Otherwise, the IV used to encrypt the packet will be "
"written at the location pointed to by E<.Fa crd_inject>.  Some applications "
"that do special E<.Dq IV cooking>, such as the half-IV mode in E<.Xr ipsec "
"4>, can use this flag to indicate that the IV should not be written on the "
"packet.  This flag is typically used in conjunction with the E<.Dv "
"CRD_F_IV_EXPLICIT> flag."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:368
#, no-wrap
msgid "Dv CRD_F_IV_EXPLICIT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:383
msgid ""
"For encryption algorithms, this bit is set when the IV is explicitly "
"provided by the consumer in the E<.Fa crd_iv> fields.  Otherwise, for "
"encryption operations the IV is provided for by the driver used to perform "
"the operation, whereas for decryption operations it is pointed to by the "
"E<.Fa crd_inject> field.  This flag is typically used when the IV is "
"calculated E<.Dq on the fly> by the consumer, and does not precede the data "
"(some E<.Xr ipsec 4> configurations, and the encrypted swap are two such "
"examples)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:383
#, no-wrap
msgid "Dv CRD_F_COMP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:386
msgid ""
"For compression algorithms, this bit is set when compression is required "
"(when not set, decompression is performed)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:387
#, no-wrap
msgid "Fa CRD_INI"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:397
msgid ""
"This E<.Fa cryptoini> structure will not be modified by the framework or the "
"device drivers.  Since this information accompanies every cryptographic "
"operation request, drivers may re-initialize state on-demand (typically an "
"expensive operation).  Furthermore, the cryptographic framework may re-route "
"requests as a result of full queues or hardware failure, as described above."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:397
#, no-wrap
msgid "Fa crd_next"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:403
msgid ""
"Point to the next descriptor.  Linked operations are useful in protocols "
"such as E<.Xr ipsec 4>, where multiple cryptographic transforms may be "
"applied on the same block of data."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:412
msgid ""
"E<.Fn crypto_getreq> allocates a E<.Fa cryptop> structure with a linked list "
"of as many E<.Fa cryptodesc> structures as were specified in the argument "
"passed to it."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:424
msgid ""
"E<.Fn crypto_freereq> deallocates a structure E<.Fa cryptop> and any E<.Fa "
"cryptodesc> structures linked to it.  Note that it is the responsibility of "
"the callback routine to do the necessary cleanups associated with the opaque "
"field in the E<.Fa cryptop> structure."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:430
msgid ""
"E<.Fn crypto_kdispatch> is called to perform a keying operation.  The "
"various fields in the E<.Fa crytokop> structure are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:431
#, no-wrap
msgid "Fa krp_op"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:433
msgid "Operation code, such as CRK_MOD_EXP."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:433
#, no-wrap
msgid "Fa krp_status"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:437
msgid ""
"Return code.  This errno-style variable indicates whether there were lower "
"level reasons for operation failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:437
#, no-wrap
msgid "Fa krp_iparams"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:440
msgid ""
"Number of input parameters to the specified operation.  Note that each "
"operation has a (typically hardwired) number of such parameters."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:440
#, no-wrap
msgid "Fa krp_oparams"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:443
msgid ""
"Number of output parameters from the specified operation.  Note that each "
"operation has a (typically hardwired) number of such parameters."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:443
#, no-wrap
msgid "Fa krp_kvp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:445
msgid "An array of kernel memory blocks containing the parameters."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:445
#, no-wrap
msgid "Fa krp_hid"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:447
msgid "Identifier specifying which low-level driver is being used."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:447
#, no-wrap
msgid "Fa krp_callback"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:449
msgid "Callback called on completion of a keying operation."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:453
msgid ""
"The following sysctl entries exist to adjust the behaviour of the system "
"from userland:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:454
#, no-wrap
msgid "kern.usercrypto"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:457
msgid "Allow (1) or forbid (0) userland access to E<.Pa /dev/crypto>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:457
#, no-wrap
msgid "kern.userasymcrypto"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:460
msgid "Allow (1) or forbid (0) userland access to do asymmetric crypto requests."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:460
#, no-wrap
msgid "kern.cryptodevallowsoft"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:462
msgid "Enable/disable access to hardware versus software operations:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:463
#, no-wrap
msgid "\\*[Lt] 0"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:465
msgid "Force userlevel requests to use software operations, always."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:465
#, no-wrap
msgid "= 0"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:468
msgid ""
"Use hardware if present, grant userlevel requests for non-accelerated "
"operations (handling the latter in software)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:468
#, no-wrap
msgid "\\*[Gt] 0"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:470
msgid "Allow user requests only for operations which are hardware-accelerated."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/opencrypto.9:472
#, no-wrap
msgid "DRIVER-SIDE API"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:515
msgid ""
"The E<.Fn crypto_get_driverid>, E<.Fn crypto_register>, E<.Fn "
"crypto_kregister>, E<.Fn crypto_unregister>, and E<.Fn crypto_done> routines "
"are used by drivers that provide support for cryptographic primitives to "
"register and unregister with the kernel crypto services framework.  Drivers "
"must first use the E<.Fn crypto_get_driverid> function to acquire a driver "
"identifier, specifying the E<.Fa flags> as an argument (normally 0, but "
"software-only drivers should specify E<.Dv CRYPTOCAP_F_SOFTWARE>).  For each "
"algorithm the driver supports, it must then call E<.Fn crypto_register>.  "
"The first argument is the driver identifier.  The second argument is an "
"array of E<.Dv CRYPTO_ALGORITHM_MAX + 1> elements, indicating which "
"algorithms are supported.  The last three arguments are pointers to three "
"driver-provided functions that the framework may call to establish new "
"cryptographic context with the driver, free already established context, and "
"ask for a request to be processed (encrypt, decrypt, etc.)  E<.Fn "
"crypto_unregister> is called by drivers that wish to withdraw support for an "
"algorithm.  The two arguments are the driver and algorithm identifiers, "
"respectively.  Typically, drivers for E<.Xr pcmcia 4> crypto cards that are "
"being ejected will invoke this routine for all algorithms supported by the "
"card.  If called with E<.Dv CRYPTO_ALGORITHM_ALL>, all algorithms registered "
"for a driver will be unregistered in one go and the driver will be disabled "
"(no new sessions will be allocated on that driver, and any existing sessions "
"will be migrated to other drivers).  The same will be done if all algorithms "
"associated with a driver are unregistered one by one."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:517
msgid "The calling convention for the three driver-supplied routines is:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:521
#, no-wrap
msgid ""
"int (*newsession) (void *, u_int32_t *, struct cryptoini *);\n"
"int (*freesession) (void *, u_int64_t);\n"
"int (*process) (void *, struct cryptop *, int);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:531
msgid ""
"On invocation, the first argument to E<.Fn newsession> contains the driver "
"identifier obtained via E<.Fn crypto_get_driverid>.  On successfully "
"returning, it should contain a driver-specific session identifier.  The "
"second argument is identical to that of E<.Fn crypto_newsession>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:538
msgid ""
"The E<.Fn freesession> routine takes as argument the SID (which is the "
"concatenation of the driver identifier and the driver-specific session "
"identifier).  It should clear any context associated with the session (clear "
"hardware registers, memory, etc.)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:560
msgid ""
"The E<.Fn process> routine is invoked with a request to perform crypto "
"processing.  This routine must not block, but should queue the request and "
"return immediately.  Upon processing the request, the callback routine "
"should be invoked.  In case of error, the error indication must be placed in "
"the E<.Fa crp_etype> field of the E<.Fa cryptop> structure.  The E<.Fa hint> "
"argument can be set to E<.Dv CRYPTO_HINT_MORE> when there will be more "
"request right after this request.  When the request is completed, or an "
"error is detected, the E<.Fn process> routine should invoke E<.Fn "
"crypto_done>.  Session migration may be performed, as mentioned previously."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:576
msgid ""
"The E<.Fn kprocess> routine is invoked with a request to perform crypto key "
"processing.  This routine must not block, but should queue the request and "
"return immediately.  Upon processing the request, the callback routine "
"should be invoked.  In case of error, the error indication must be placed in "
"the E<.Fa krp_status> field of the E<.Fa cryptkop> structure.  When the "
"request is completed, or an error is detected, the E<.Fn kprocess> routine "
"should invoke E<.Fn crypto_kdone>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:601
msgid ""
"E<.Fn crypto_register>, E<.Fn crypto_kregister>, E<.Fn crypto_unregister>, "
"E<.Fn crypto_newsession>, and E<.Fn crypto_freesession> return 0 on success, "
"or an error code on failure.  E<.Fn crypto_get_driverid> returns a "
"non-negative value on error, and \\-1 on failure.  E<.Fn crypto_getreq> "
"returns a pointer to a E<.Fa cryptop> structure and E<.Dv NULL> on failure.  "
"E<.Fn crypto_dispatch> returns E<.Er EINVAL> if its argument or the callback "
"function was E<.Dv NULL>, and 0 otherwise.  The callback is provided with an "
"error code in case of failure, in the E<.Fa crp_etype> field."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/opencrypto.9:601 org_netbsd/src/share/man/man9/rnd.9:210 org_netbsd/src/share/man/man9/scsipi.9:575 org_netbsd/src/share/man/man9/tcp_congctl.9:89 org_netbsd/src/share/man/man9/veriexec.9:293
#, no-wrap
msgid "FILES"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:603
#, no-wrap
msgid "Pa sys/opencrypto/crypto.c"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:605
msgid "most of the framework code"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/opencrypto.9:605
#, no-wrap
msgid "Pa sys/crypto"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:607
msgid "crypto algorithm implementations"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:622
msgid ""
"E<.Xr ipsec 4>, E<.Xr pcmcia 4>, E<.Xr condvar 9>, E<.Xr malloc 9> E<.Rs> "
"E<.%A \"Angelos D. Keromytis\"> E<.%A \"Jason L. Wright\"> E<.%A \"Theo de "
"Raadt\"> E<.%T \"The Design of the OpenBSD Cryptographic Framework\"> E<.%I "
"\"Usenix\"> E<.%N \"2003\"> E<.%D \"June 2003\"> E<.Re>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:627
msgid ""
"The cryptographic framework first appeared in E<.Ox 2.7> and was written by "
"E<.An Angelos D. Keromytis Aq angelos@openbsd.org>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:632
msgid ""
"E<.An Sam Leffler> ported the crypto framework to E<.Fx> and made "
"performance improvements."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:641
msgid ""
"E<.An Jonathan Stone Aq jonathan@NetBSD.org> ported the cryptoframe from "
"E<.Fx> to E<.Nx>.  E<.Nm opencrypto> first appeared in E<.Nx 2.0>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:646
msgid ""
"The framework currently assumes that all the algorithms in a E<.Fn "
"crypto_newsession> operation must be available by the same driver.  If "
"that's not the case, session initialization will fail."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:650
msgid ""
"The framework also needs a mechanism for determining which driver is best "
"for a specific set of algorithms associated with a session.  Some type of "
"benchmarking is in order here."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:656
msgid ""
"Multiple instances of the same algorithm in the same session are not "
"supported.  Note that 3DES is considered one algorithm (and not three "
"instances of DES).  Thus, 3DES and DES could be mixed in the same request."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:662
msgid ""
"A queue for completed operations should be implemented and processed at some "
"software E<.Xr spl 9> level, to avoid overall system latency issues, and "
"potential kernel stack exhaustion while processing a callback."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/opencrypto.9:665
msgid ""
"When SMP time comes, we will support use of a second processor (or more) as "
"a crypto device (this is actually AMP, but we need the same basic support)."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/optstr.9:30
#, no-wrap
msgid "August 11, 2007"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/optstr.9:31
#, no-wrap
msgid "OPTSTR 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/optstr.9:35
msgid "E<.Nm optstr_get>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/optstr.9:35
#, no-wrap
msgid "Options string management"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/optstr.9:37
#, no-wrap
msgid "sys/optstr.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/optstr.9:40
msgid ""
"E<.Ft bool> E<.Fn optstr_get \"const char *optstr\" \"const char *key\" "
"\"char *buf\" \"size_t bufsize\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/optstr.9:46
msgid ""
"An options string is a list of key/value pairs represented in textual form.  "
"Each pair is expressed as E<.Sq 'key=value'> and is separated from other "
"pairs by one or more spaces.  For example:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/optstr.9:48
#, no-wrap
msgid "key1=value1 key2=value2 key3=value3\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/optstr.9:53
msgid ""
"Options strings are used to pass information between userland programs and "
"the kernel in a binary-agnostic way.  This makes them endianness and ABI "
"independent."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/optstr.9:55
msgid "The following functions are provided to manage options strings:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/optstr.9:56
#, no-wrap
msgid "Fn optstr_get optstr key buf bufsize"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/optstr.9:73
msgid ""
"Scans the E<.Va optstr> options string looking for the key E<.Va key> and "
"stores its value in the buffer pointed to by E<.Va buf> copying a maximum of "
"E<.Va bufsize> bytes.  Returns E<.Sq true> if the key was found or E<.Sq "
"false> otherwise, in which case E<.Va buf> is left unmodified."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/optstr.9:79
msgid ""
"The options string management functions are implemented within the files "
"E<.Pa sys/kern/subr_optstr.c> and E<.Pa sys/sys/optstr.h>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/optstr.9:81
msgid "Options strings appeared in E<.Nx 4.0>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/panic.9:30
#, no-wrap
msgid "September 29, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/panic.9:31
#, no-wrap
msgid "PANIC 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/panic.9:35
msgid "E<.Nm panic>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/panic.9:35
#, no-wrap
msgid "Bring down system on fatal error"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/panic.9:43
msgid ""
"E<.Ft void> E<.Fn vpanic \"const char *fmt\" \"va_list ap\"> E<.Ft void> "
"E<.Fn panic \"const char *fmt\" \"...\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/panic.9:61
msgid ""
"The E<.Fn panic> and E<.Fn vpanic> functions terminate the E<.Nx> system.  "
"The message E<.Fa fmt> is a E<.Xr printf 3> style format string which is "
"printed to the console and saved in the variable E<.Va panicstr> for later "
"retrieval via core dump inspection.  A newline character is added at the end "
"automatically, and is thus not needed in the format string."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/panic.9:79
msgid ""
"If a kernel debugger is installed, control is passed to it after the message "
"is printed.  If the kernel debugger is E<.Xr ddb 4>, control may be passed "
"to it, depending on the value of E<.Em ddb.onpanic>.  See E<.Xr options 4> "
"for more details on setting E<.Em ddb.onpanic>.  If control is not passed "
"through to E<.Xr ddb 4>, a E<.Xr ddb 4 Ns -specific> function is used to "
"print the kernel stack trace, and then control returns to E<.Fn panic>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/panic.9:84
msgid ""
"If control remains in E<.Fn panic>, an attempt is made to save an image of "
"system memory on the configured dump device."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/panic.9:90
msgid ""
"If during the process of handling the panic, E<.Fn panic> is called again "
"E<.Pq from the filesystem synchronization routines, for example>, the system "
"is rebooted immediately without synchronizing any filesystems."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/panic.9:98
msgid ""
"E<.Fn panic> is meant to be used in situations where something unexpected "
"has happened and it is difficult to recover the system to a stable state, or "
"in situations where proceeding might make the things worse, leading to data "
"corruption/loss.  It is not meant to be used in scenarios where the system "
"could easily ignore and/or isolate the condition/subsystem and proceed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/panic.9:102
msgid ""
"In general developers should try to reduce the number of E<.Fn panic> calls "
"in the kernel to improve stability."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/panic.9:106
msgid "The E<.Fn panic> function does not return."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/panic.9:113
msgid ""
"E<.Xr sysctl 3>, E<.Xr ddb 4>, E<.Xr ipkdb 4>, E<.Xr options 4>, E<.Xr "
"savecore 8>, E<.Xr swapctl 8>, E<.Xr sysctl 8>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/pathbuf.9:30
#, no-wrap
msgid "November 30, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/pathbuf.9:31
#, no-wrap
msgid "PATHBUF 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pathbuf.9:39
msgid ""
"E<.Nm pathbuf>, E<.Nm pathbuf_create>, E<.Nm pathbuf_assimilate>, E<.Nm "
"pathbuf_copyin>, E<.Nm pathbuf_destroy>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/pathbuf.9:39
#, no-wrap
msgid "path buffer abstraction"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pathbuf.9:50
msgid ""
"E<.Ft struct pathbuf *> E<.Fn pathbuf_create \"const char *path\"> E<.Ft "
"struct pathbuf *> E<.Fn pathbuf_assimilate \"char *pnbuf\"> E<.Ft int> E<.Fn "
"pathbuf_copyin \"const char *userpath\" \"struct pathbuf **ret\"> E<.Ft "
"void> E<.Fn pathbuf_destroy \"struct pathbuf *path\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pathbuf.9:62
msgid ""
"The E<.Nm> interface is used to carry around pathnames.  This helps simplify "
"the E<.Xr namei 9> interface.  A pathbuf should be thought of as a path name "
"string combined with whatever flags and metadata are needed to interpret it "
"correctly.  It is an abstract type; the internals are hidden within the "
"E<.Xr namei 9> implementation."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pathbuf.9:75
msgid ""
"The E<.Fn pathbuf_create> function allocates and initializes a new pathbuf "
"containing a copy of the path string E<.Fa path>, which should be a kernel "
"pointer.  The return value should be checked for being E<.Dv NULL> in case "
"the system is out of memory.  Passing a path name larger than E<.Dv "
"PATH_MAX> will cause an assertion failure."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pathbuf.9:82
msgid ""
"The E<.Fn pathbuf_copyin> function allocates and initializes a new pathbuf "
"containing a path string copied from user space with E<.Xr copyinstr 9>.  It "
"returns an error code."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pathbuf.9:99
msgid ""
"The E<.Fn pathbuf_assimilate> function creates a pathbuf using the string "
"buffer provided as E<.Fa pnbuf>.  This buffer must be of size E<.Dv "
"PATH_MAX> and must have been allocated with E<.Fn PNBUF_GET>.  The buffer is "
"E<.Dq taken over> by the returned pathbuf and will be released when the "
"pathbuf is destroyed.  Note: to avoid confusion and pointer bugs, E<.Fn "
"pathbuf_assimilate> should only be used where absolutely necessary; e.g. the "
"NFS server code uses it to generate pathbufs from strings fetched from "
"mbufs."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pathbuf.9:109
msgid ""
"The E<.Fn pathbuf_destroy> function deallocates a pathbuf.  Caution: because "
"calling E<.Xr namei 9> loads pointers to memory belonging to the pathbuf "
"into the nameidata structure, a pathbuf should only be destroyed by the "
"E<.Fn namei> caller once all manipulations of the nameidata are complete."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pathbuf.9:115
msgid ""
"Also note that calling E<.Fn namei> destroys the contents of the pathbuf.  "
"Do not reuse a pathbuf for a second call to E<.Fn namei>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pathbuf.9:120
msgid ""
"The E<.Nm> code is part of the name lookup code in E<.Pa "
"sys/kern/vfs_lookup.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pathbuf.9:122
msgid "E<.Xr namei 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pathbuf.9:130
msgid ""
"There are cases where it is necessary to get the path string left behind "
"after E<.Fn namei> has run.  This produces an effect similar to E<.Xr "
"realpath 3>.  The interface for doing this is, for the time being, "
"intentionally undocumented and subject to change."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/pci.9:30
#, no-wrap
msgid "January 30, 2012"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/pci.9:31
#, no-wrap
msgid "PCI 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:65
msgid ""
"E<.Nm PCI>, E<.Nm pci_activate>, E<.Nm pci_bus_devorder>, E<.Nm "
"pci_chipset_tag_create>, E<.Nm pci_chipset_tag_destroy>, E<.Nm "
"pci_conf_read>, E<.Nm pci_conf_write>, E<.Nm pci_conf_print>, E<.Nm "
"pci_conf_capture>, E<.Nm pci_conf_restore>, E<.Nm pci_find_device>, E<.Nm "
"pci_get_capability>, E<.Nm pci_mapreg_type>, E<.Nm pci_mapreg_map>, E<.Nm "
"pci_mapreg_info>, E<.Nm pci_intr_map>, E<.Nm pci_intr_string>, E<.Nm "
"pci_intr_evcnt>, E<.Nm pci_intr_establish>, E<.Nm pci_intr_disestablish>, "
"E<.Nm pci_get_powerstate>, E<.Nm pci_set_powerstate>, E<.Nm pci_vpd_read>, "
"E<.Nm pci_vpd_write>, E<.Nm pci_make_tag>, E<.Nm pci_decompose_tag>, E<.Nm "
"pci_findvendor>, E<.Nm pci_devinfo>, E<.Nm PCI_VENDOR>, E<.Nm PCI_PRODUCT>, "
"E<.Nm PCI_REVISION>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/pci.9:65
#, no-wrap
msgid "Peripheral Component Interconnect"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/pci.9:68 org_netbsd/src/share/man/man9/pci_intr.9:41 org_netbsd/src/share/man/man9/pci_intr.9:59
#, no-wrap
msgid "dev/pci/pcivar.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/pci.9:69
#, no-wrap
msgid "dev/pci/pcireg.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/pci.9:70
#, no-wrap
msgid "dev/pci/pcidevs.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:156
msgid ""
"E<.Ft int> E<.Fn pci_bus_devorder \"pci_chipset_tag_t pc\" \"int bus\" "
"\"uint8_t *devs\" \"int maxdevs\"> E<.Ft int> E<.Fn pci_activate "
"\"pci_chipset_tag_t pc\" \"pcitag_t tag\" \"device_t dev\" \"int "
"(*wakeup)(pci_chipset_tag_t pc, pcitag_t tag\" \"\\t\\tdevice_t dev, "
"pcireg_t reg)\"> E<.Ft int> E<.Fn pci_chipset_tag_create \"pci_chipset_tag_t "
"opc\" \"uint64_t present\" \"const struct pci_overrides *ov\" \"void *ctx\" "
"\"pci_chipset_tag_t *pcp\"> E<.Ft void> E<.Fn pci_chipset_tag_destroy "
"\"pci_chipset_tag_t pc\"> E<.Ft pcireg_t> E<.Fn pci_conf_read "
"\"pci_chipset_tag_t pc\" \"pcitag_t tag\" \"int reg\"> E<.Ft void> E<.Fn "
"pci_conf_write \"pci_chipset_tag_t pc\" \"pcitag_t tag\" \"int reg\" "
"\"pcireg_t val\"> E<.Ft void> E<.Fn pci_conf_print \"pci_chipset_tag_t pc\" "
"\"pcitag_t tag\" \"void (*func)(pci_chipset_tag_t, pcitag_t, const pcireg_t "
"*)\"> E<.Ft void> E<.Fn pci_conf_capture \"pci_chipset_tag_t pc\" \"pcitag_t "
"tag\" \"struct pci_conf_state *\"> E<.Ft void> E<.Fn pci_conf_restore "
"\"pci_chipset_tag_t pc\" \"pcitag_t tag\" \"struct pci_conf_state *\"> E<.Ft "
"int> E<.Fn pci_find_device \"struct pci_attach_args *pa\" \"int "
"(*func)(const struct pci_attach_args *)\"> E<.Ft int> E<.Fn "
"pci_get_capability \"pci_chipset_tag_t pc\" \"pcitag_t tag\" \"int capid\" "
"\"int *offsetp\" \"pcireg_t *valuep\"> E<.Ft pcireg_t> E<.Fn pci_mapreg_type "
"\"pci_chipset_tag_t pc\" \"pcitag_t tag\" \"int reg\"> E<.Ft int> E<.Fn "
"pci_mapreg_map \"const struct pci_attach_args *pa\" \"int reg\" \"pcireg_t "
"type\" \"int busflags\" \"bus_space_tag_t *tagp\" \"bus_space_handle_t "
"*handlep\" \"bus_addr_t *basep\" \"bus_size_t *sizep\"> E<.Ft int> E<.Fn "
"pci_mapreg_info \"pci_chipset_tag_t pc\" \"pcitag_t tag\" \"int reg\" "
"\"pcireg_t type\" \"bus_addr_t *basep\" \"bus_size_t *sizep\" \"int "
"*flagsp\"> E<.Ft int> E<.Fn pci_find_rom \"const struct pci_attach_args "
"*pa\" \"bus_space_tag_t bst\" \"bus_space_handle_t bsh\" \"int code\" "
"\"bus_space_handle_t *handlep\" \"bus_space_size_t *sizep\"> E<.Ft int> "
"E<.Fn pci_intr_map \"const struct pci_attach_args *pa\" \"pci_intr_handle_t "
"*ih\"> E<.Ft const char *> E<.Fn pci_intr_string \"pci_chipset_tag_t pc\" "
"\"pci_intr_handle_t ih\"> E<.Ft const struct evcnt *> E<.Fn pci_intr_evcnt "
"\"pci_chipset_tag_t pc\" \"pci_intr_handle_t ih\"> E<.Ft void *> E<.Fn "
"pci_intr_establish \"pci_chipset_tag_t pc\" \"pci_intr_handle_t ih\" \"int "
"level\" \"int (*handler)(void *)\" \"void *arg\"> E<.Ft void> E<.Fn "
"pci_intr_disestablish \"pci_chipset_tag_t pc\" \"void *ih\"> E<.Ft int> "
"E<.Fn pci_set_powerstate \"pci_chipset_tag_t pc\" \"pcitag_t tag\" "
"\"pcireg_t newstate\"> E<.Ft int> E<.Fn pci_get_powerstate "
"\"pci_chipset_tag_t pc\" \"pcitag_t tag\" \"pcireg_t *state\"> E<.Ft int> "
"E<.Fn pci_vpd_read \"pci_chipset_tag_t pc\" \"pcitag_t tag\" \"int offset\" "
"\"int count\" \"pcireg_t *data\"> E<.Ft int> E<.Fn pci_vpd_write "
"\"pci_chipset_tag_t pc\" \"pcitag_t tag\" \"int offset\" \"int count\" "
"\"pcireg_t *data\"> E<.Ft pcitag_t> E<.Fn pci_make_tag \"pci_chipset_tag_t "
"pc\" \"int bus\" \"int device\" \"int function\"> E<.Ft void> E<.Fn "
"pci_decompose_tag \"pci_chipset_tag_t pc\" \"pcitag_t tag\" \"int *busp\" "
"\"int *devicep\" \"int *functionp\"> E<.Ft char *> E<.Fn pci_findvendor "
"\"pcireg_t id\"> E<.Ft void> E<.Fn pci_devinfo \"pcireg_t id\" \"pcireg_t "
"class\" \"int show\" \"char *cp\" \"size_t len\"> E<.Ft void> E<.Fn "
"pci_aprint_devinfo \"struct pci_attach_args *pa\" \"const char *naive\"> "
"E<.Ft int> E<.Fn PCI_VENDOR \"pcireg_t id\"> E<.Ft int> E<.Fn PCI_PRODUCT "
"\"pcireg_t id\"> E<.Ft int> E<.Fn PCI_REVISION \"pcireg_t id\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:160
msgid "The machine-independent E<.Nm> subsystem provides support for PCI devices."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:166
msgid ""
"The PCI bus was initially developed by Intel in the early 1990's to replace "
"the ISA bus for interfacing with their Pentium processor.  The PCI "
"specification is widely regarded as well designed, and the PCI bus has found "
"widespread acceptance in machines ranging from Apple's PowerPC-based systems "
"to Sun's UltraSPARC-based machines."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:174
msgid ""
"The PCI bus is a multiplexed bus, allowing addresses and data on the same "
"pins for a reduced number of pins.  Data transfers can be 8-bit, 16-bit or "
"32-bit.  A 64-bit extended PCI bus is also defined.  Multi-byte transfers "
"are little-endian.  The PCI bus operates up to 33MHz and any device on the "
"bus can be the bus master."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:177
msgid ""
"AGP is a version of PCI optimised for high-throughput data rates, "
"particularly for accelerated frame buffers."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:192
msgid ""
"The PCI bus is a \"plug and play\" bus, in the sense that devices can be "
"configured dynamically by software.  The PCI interface chip on a PCI device "
"bus presents a small window of registers into the PCI configuration space.  "
"These registers contain information about the device such as the vendor and "
"a product ID.  The configuration registers can also be written to by "
"software to alter how the device interfaces to the PCI bus.  An important "
"register in the configuration space is the Base Address Register (BAR).  The "
"BAR is written to by software to map the device registers into a window of "
"processor address space.  Once this mapping is done, the device registers "
"can be accessed relative to the base address."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:197
#, no-wrap
msgid "Fa pcireg_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:199
msgid "Configuration space register."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:199
#, no-wrap
msgid "Fa pci_chipset_tag_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:201
msgid "Chipset tag for the PCI bus."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:201
#, no-wrap
msgid "Fa pcitag_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:208
msgid ""
"Configuration tag describing the location and function of the PCI device.  "
"It contains the tuple E<.Ao> bus, device, function E<.Ac>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:208
#, no-wrap
msgid "Fa pci_intr_handle_t"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:210
#, no-wrap
msgid "Fa struct pci_attach_args"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:222
#, no-wrap
msgid ""
"\tbus_space_tag_t pa_iot;\t\t/* pci i/o space tag */\n"
"\tbus_space_tag_t pa_memt;\t/* pci mem space tag */\n"
"\tbus_dma_tag_t pa_dmat;\t\t/* DMA tag */\n"
"\tpci_chipset_tag_t pa_pc;\n"
"\tint pa_flags;\t\t\t/* flags */\n"
"\tpcitag_t pa_tag;\n"
"\tpcireg_t pa_id;\n"
"\tpcireg_t pa_class;\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:223
#, no-wrap
msgid "Fa struct pci_conf_state"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:226
msgid ""
"Stores the PCI configuration state of a device.  It contains the following "
"member:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:228
#, no-wrap
msgid "\tpcireg_t reg[16];\t\t\t/* pci conf register */\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:229
#, no-wrap
msgid "Fa struct pci_overrides"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:237
msgid ""
"Stores pointers to functions that override the architecture's default E<.Xr "
"pci 9> and E<.Xr pci_intr 9> implementation.  It contains the following "
"members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:257
#, no-wrap
msgid ""
"\tpcireg_t (*ov_conf_read)(void *,\n"
"\t    pci_chipset_tag_t, pcitag_t, int);\n"
"\tvoid (*ov_conf_write)(void *,\n"
"\t    pci_chipset_tag_t, pcitag_t, int, pcireg_t);\n"
"\tint (*ov_intr_map)(void *,\n"
"\t   const struct pci_attach_args *, pci_intr_handle_t *);\n"
"\tconst char *(*ov_intr_string)(void *,\n"
"\t    pci_chipset_tag_t, pci_intr_handle_t);\n"
"\tconst struct evcnt *(*ov_intr_evcnt)(void *,\n"
"\t    pci_chipset_tag_t, pci_intr_handle_t);\n"
"\tvoid *(*ov_intr_establish)(void *,\n"
"\t    pci_chipset_tag_t, pci_intr_handle_t,\n"
"\t    int, int (*)(void *), void *);\n"
"\tvoid (*ov_intr_disestablish)(void *,\n"
"\t    pci_chipset_tag_t, void *);\n"
"\tpcitag_t (*ov_make_tag)(void *,\n"
"\t    pci_chipset_tag_t, int, int, int);\n"
"\tvoid (*ov_decompose_tag)(void *,\n"
"\t    pci_chipset_tag_t, pcitag_t, int *, int *, int *);\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:261
#, no-wrap
msgid "Fn pci_bus_devorder pc bus devs maxdevs"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:282
msgid ""
"Tell how many devices a PCI bus driver should probe and in what order.  If "
"E<.Fa maxdevs> is less than or equal to zero, return 0 and do not modify "
"E<.Fa devs>.  Otherwise, return E<.Fa maxdevs> or the number of devices on "
"E<.Fa bus> to probe, whichever is less, and copy to E<.Fa devs> each of the "
"PCI device numbers to probe in the order that they should be probed.  E<.Fn "
"pci_bus_devorder> will not copy more than E<.Fa maxdevs> device numbers to "
"E<.Fa devs>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:282
#, no-wrap
msgid "Fn pci_activate pc tag dev fun"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:292
msgid ""
"Attempt to bring the device to state D0.  If the device is not in the D0 "
"state call E<.Fa fun> to restore its state.  If E<.Fa fun> is E<.Dv NULL> "
"then restoring from state D3 is going to fail."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:292
#, no-wrap
msgid "Fn pci_chipset_tag_create opc present ov ctx pcp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:306
msgid ""
"Create a copy of the tag E<.Fa opc> at E<.Fa *pcp>.  Except for the behavior "
"overridden by E<.Fa ov>, E<.Fa *pcp> inherits the behavior of E<.Fa opc> "
"under E<.Nm> calls."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:318
msgid ""
"E<.Fa ov> contains function pointers corresponding to E<.Nm> routines.  Each "
"function pointer has a corresponding bit in E<.Fa present>, and if that bit "
"is 1, the function pointer overrides the corresponding E<.Nm> call for the "
"new tag.  Any combination of these bits may be set in E<.Fa present>:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:320
#, no-wrap
msgid "Dv PCI_OVERRIDE_CONF_READ"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:321
#, no-wrap
msgid "Dv PCI_OVERRIDE_CONF_WRITE"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:322
#, no-wrap
msgid "Dv PCI_OVERRIDE_INTR_MAP"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:323
#, no-wrap
msgid "Dv PCI_OVERRIDE_INTR_STRING"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:324
#, no-wrap
msgid "Dv PCI_OVERRIDE_INTR_EVCNT"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:325
#, no-wrap
msgid "Dv PCI_OVERRIDE_INTR_ESTABLISH"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:326
#, no-wrap
msgid "Dv PCI_OVERRIDE_INTR_DISESTABLISH"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:327
#, no-wrap
msgid "Dv PCI_OVERRIDE_MAKE_TAG"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:328
#, no-wrap
msgid "Dv PCI_OVERRIDE_DECOMPOSE_TAG"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:341
msgid ""
"E<.Fn pci_chipset_tag_create> does not copy E<.Fa ov>.  After a new tag is "
"created by E<.Fn pci_chipset_tag_create>, E<.Fa ov> must not be destroyed "
"until after the tag is destroyed by E<.Fn pci_chipset_tag_destroy>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:367
msgid ""
"Return 0 if the call succeeds.  Return E<.Dv EOPNOTSUPP> if the architecture "
"does not support overrides.  Return E<.Dv EINVAL> if E<.Fa present> is 0, if "
"E<.Fa ov> is E<.Dv NULL>, or if E<.Fa present> indicates that an override is "
"present, but the corresponding override in E<.Fa ov> is E<.Dv NULL>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:371
msgid "If the call does not succeed, E<.Fa *pcp> is undefined."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:371
#, no-wrap
msgid "Fn pci_chipset_tag_destroy pc"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:384
msgid ""
"Destroy a tag, E<.Fa pc>, created by a prior call to E<.Fn "
"pci_chipset_tag_create>.  If E<.Fa pc> was not created by E<.Fn "
"pci_chipset_tag_create>, results are undefined.  If E<.Fa pc> was already "
"destroyed, results are undefined."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:384
#, no-wrap
msgid "Fn pci_conf_read pc tag reg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:392
msgid ""
"Read from register E<.Fa reg> in PCI configuration space.  The argument "
"E<.Fa tag> is the PCI tag for the current device attached to PCI chipset "
"E<.Fa pc>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:392
#, no-wrap
msgid "Fn pci_conf_write pc tag reg val"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:400
msgid ""
"Write to register E<.Fa reg> in PCI configuration space.  The argument E<.Fa "
"tag> is the PCI tag for the current device attached to PCI chipset E<.Fa "
"pc>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:400
#, no-wrap
msgid "Fn pci_conf_print pc tag func"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:414
msgid ""
"Print out most of the registers in the PCI configuration for the device.  "
"The argument E<.Fa tag> is the PCI tag for the current device attached to "
"PCI chipset E<.Fa pc>.  The argument E<.Fa func> is a function called by "
"E<.Fn pci_conf_print> to print the device-dependent registers.  This "
"function is only useful for driver development and is usually wrapped in "
"pre-processor declarations."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:414
#, no-wrap
msgid "Fn pci_conf_capture pc tag pcs"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:422
msgid ""
"Capture PCI configuration space into structure E<.Fa pcs>.  The argument "
"E<.Fa tag> is the PCI tag for the current device attached to the PCI chipset "
"E<.Fa pc>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:422
#, no-wrap
msgid "Fn pci_conf_restore pc tag pcs"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:430
msgid ""
"Restores PCI configuration space from structure E<.Fa pcs>.  The argument "
"E<.Fa tag> is the PCI tag for the current device attached to the PCI chipset "
"E<.Fa pc>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:430
#, no-wrap
msgid "Fn pci_find_device pa func"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:444
msgid ""
"Find a device using a match function on all probed busses.  The argument "
"E<.Fa func> is called by E<.Fn pci_find_device> to match a device.  The "
"argument E<.Fa pa> is filled in if the device is matched.  E<.Fn "
"pci_find_device> returns 1 if the device is matched, and zero otherwise.  "
"This function is specifically for use by kernel modules and its use "
"otherwise is strongly discouraged."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:444
#, no-wrap
msgid "Fn pci_get_capability pc tag capid offsetp valuep"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:466
msgid ""
"Parse the device capability list in configuration space looking for "
"capability E<.Fa capid>.  If E<.Fa offsetp> is not NULL, the register offset "
"in configuration space is returned in E<.Fa offsetp>.  If E<.Fa valuep> is "
"not NULL, the value of the capability is returned in E<.Fa valuep>.  The "
"argument E<.Fa tag> is the PCI tag for the current device attached to PCI "
"chipset E<.Fa pc>.  This function returns 1 if the capability was found.  If "
"the capability was not found, it returns zero, and E<.Fa offsetp> and E<.Fa "
"valuep> remain unchanged."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:466
#, no-wrap
msgid "Fn pci_mapreg_type pc tag reg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:472
msgid ""
"Interrogates the Base Address Register (BAR) in configuration space "
"specified by E<.Fa reg> and returns the default (or current) mapping type.  "
"Valid returns values are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:473 org_netbsd/src/share/man/man9/pci.9:506
#, no-wrap
msgid "Dv PCI_MAPREG_TYPE_IO"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:475
msgid "The mapping is to I/O address space."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:475 org_netbsd/src/share/man/man9/pci.9:508
#, no-wrap
msgid "Dv PCI_MAPREG_TYPE_MEM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:477
msgid "The mapping is to memory address space."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:477
#, no-wrap
msgid "Dv PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:479
msgid "The mapping is to 64-bit memory address space."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:479 org_netbsd/src/share/man/man9/pci.9:510
#, no-wrap
msgid "Dv PCI_MAPREG_TYPE_ROM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:485
msgid ""
"The mapping is to ROM.  Note that in the current implementation, E<.Dv "
"PCI_MAPREG_TYPE_ROM> has the same numeric value as E<.Dv "
"PCI_MAPREG_TYPE_MEM>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:491
msgid ""
"The argument E<.Fa tag> is the PCI tag for the current device attached to "
"PCI chipset E<.Fa pc>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:491
#, no-wrap
msgid "Fn pci_mapreg_map pa reg type busflags tagp handlep basep sizep"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:505
msgid ""
"Maps the register windows for the device into kernel virtual address space.  "
"This function is generally only called during the driver attach step and "
"takes a pointer to the E<.Em struct pci_attach_args> in E<.Fa pa>.  The "
"physical address of the mapping is in the Base Address Register (BAR) in "
"configuration space specified by E<.Fa reg>.  Valid values for the type of "
"mapping E<.Fa type> are:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:508
msgid "The mapping should be to I/O address space."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:510
msgid "The mapping should be to memory address space."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:516
msgid ""
"The mapping is to access ROM.  This type of mapping is only permitted when "
"the value for E<.Fa reg> is E<.Dv PCI_MAPREG_ROM>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:545
msgid ""
"The argument E<.Fa busflags> are bus-space flags passed to E<.Fn "
"bus_space_map> to perform the mapping (see E<.Xr bus_space 9>).  The "
"bus-space tag and handle for the mapped register window are returned in "
"E<.Fa tagp> and E<.Fa handlep> respectively.  The bus-address and size of "
"the mapping are returned in E<.Fa basep> and E<.Fa sizep> respectively.  If "
"any of E<.Fa tagp>, E<.Fa handlep>, E<.Fa basep>, or E<.Fa sizep> are NULL "
"then E<.Fn pci_mapreg_map> does not define their return value.  This "
"function returns zero on success and non-zero on error."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:545
#, no-wrap
msgid "Fn pci_mapreg_info pc tag reg type basep sizep flagsp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:564
msgid ""
"Performs the same operations as E<.Fn pci_mapreg_map> but doesn't actually "
"map the register window into kernel virtual address space.  Returns the "
"bus-address, size and bus flags in E<.Fa basep>, E<.Fa sizep> and E<.Fa "
"flagsp> respectively.  These return values can be used by E<.Fn "
"bus_space_map> to actually map the register window into kernel virtual "
"address space.  This function is useful for setting up the registers in "
"configuration space and deferring the mapping to a later time, such as in a "
"bus-independent attachment routine.  E<.Fa pci_mapreg_info> returns zero on "
"success and non-zero on failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:564
#, no-wrap
msgid "Fn pci_find_rom pa bst bsh code handlep sizep"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:578
msgid ""
"Locates a suitable ROM image within a PCI expansion ROM previously mapped "
"with E<.Fn pci_mapreg_map> and creates a subregion for it with E<.Fn "
"bus_space_subregion>.  The E<.Fa bst> and E<.Fa bsh> arguments are the bus "
"tag and handle obtained with the prior call to E<.Fn pci_mapreg_map>.  Valid "
"values for the image type E<.Fa code> are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:579
#, no-wrap
msgid "Dv PCI_ROM_CODE_TYPE_X86"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:581
msgid "Find a ROM image containing i386 executable code for use by PC BIOS."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:581
#, no-wrap
msgid "Dv PCI_ROM_CODE_TYPE_OFW"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:583
msgid "Find a ROM image containing Forth code for use by Open Firmware."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:583
#, no-wrap
msgid "Dv PCI_ROM_CODE_TYPE_HPPA"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:585
msgid "Find a ROM image containing HP PA/RISC executable code."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:596
msgid ""
"The created subregion will cover the entire selected ROM image, including "
"header data.  The handle to this subregion is returned in E<.Fa handlep>.  "
"The size of the image (and the corresponding subregion) is returned in E<.Fa "
"sizep>.  This function can only be used with expansion ROMs located at the "
"E<.Dv PCI_MAPREG_ROM> base address register (BAR)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:596
#, no-wrap
msgid "Fn pci_intr_map pa ih"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:599 org_netbsd/src/share/man/man9/pci.9:602 org_netbsd/src/share/man/man9/pci.9:605 org_netbsd/src/share/man/man9/pci.9:608 org_netbsd/src/share/man/man9/pci.9:611
msgid "See E<.Xr pci_intr 9>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:599
#, no-wrap
msgid "Fn pci_intr_string pc ih"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:602
#, no-wrap
msgid "Fn pci_intr_evcnt pc ih"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:605
#, no-wrap
msgid "Fn pci_intr_establish pc ih level handler arg"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:608
#, no-wrap
msgid "Fn pci_intr_disestablish pc ih"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:611
#, no-wrap
msgid "Fn pci_set_powerstate pc tag newstate"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:616
msgid ""
"Set power state of the device to newstate.  Valid values for E<.Fa newstate> "
"are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:618
#, no-wrap
msgid "Dv PCI_PMCSR_STATE_D0"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:619
#, no-wrap
msgid "Dv PCI_PMCSR_STATE_D1"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:620
#, no-wrap
msgid "Dv PCI_PMCSR_STATE_D2"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:621
#, no-wrap
msgid "Dv PCI_PMCSR_STATE_D3"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:623
#, no-wrap
msgid "Fn pci_get_powerstate pc tag state"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:625
msgid "Get current power state of the device."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:625
#, no-wrap
msgid "Fn pci_vpd_read pc tag offset count data"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:634
msgid ""
"Read E<.Fa count> 32-bit words of Vital Product Data for the device starting "
"at offset E<.Fa offset> into the buffer pointed to by E<.Fa data>.  Returns "
"0 on success or non-zero if the device has no Vital Product Data capability "
"or if reading the Vital Product Data fails."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:634
#, no-wrap
msgid "Fn pci_vpd_write pc tag offset count data"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:643
msgid ""
"Write E<.Fa count> 32-bit words of Vital Product Data for the device "
"starting at offset E<.Fa offset> from the buffer pointed to by E<.Fa data>.  "
"Returns 0 on success or non-zero if the device has no Vital Product Data "
"capability of if writing the Vital Product Data fails."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:643
#, no-wrap
msgid "Fn pci_make_tag pc bus device function"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:651
msgid ""
"Create a new PCI tag for the PCI device specified by the tuple E<.Ao> bus, "
"device, function E<.Ac>.  This function is not useful to the usual PCI "
"device driver.  It is generally used by drivers of multi-function devices "
"when attaching other PCI device drivers to each function."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:651
#, no-wrap
msgid "Fn pci_decompose_tag pc tag busp devicep fnp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:661
msgid ""
"Decompose the PCI tag E<.Fa tag> generated by E<.Fn pci_make_tag> into its "
"E<.Ao> bus, device, function E<.Ac> tuple."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:661
#, no-wrap
msgid "Fn pci_findvendor id"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:664
msgid "Return the string of the vendor name for the device specified by E<.Fa id>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:664
#, no-wrap
msgid "Fn pci_devinfo id class show cp len"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:678
msgid ""
"Returns the description string from the in-kernel PCI database for the "
"device described by E<.Fa id> and E<.Fa class>.  The description string is "
"returned in E<.Fa cp>; the size of that storage is given in E<.Fa len>.  The "
"argument E<.Fa show> specifies whether the PCI subsystem should report the "
"string to the console."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:678
#, no-wrap
msgid "Fn pci_aprint_devinfo pa naive"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:692
msgid ""
"Print device information to the console and system log, using the E<.Xr "
"aprint_normal 9> and E<.Xr aprint_naive 9> functions.  For the device "
"information, the E<.Dq pci_devinfo> function above is used, or the E<.Ar "
"naive> argument in the E<.Dq AB_QUIET> case.  This function is intended to "
"be used early in device attach."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:692
#, no-wrap
msgid "Fn PCI_VENDOR id"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:695
msgid "Return the PCI vendor id for device E<.Fa id>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:695
#, no-wrap
msgid "Fn PCI_PRODUCT id"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:698
msgid "Return the PCI product id for device E<.Fa id>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci.9:698
#, no-wrap
msgid "Fn PCI_REVISION id"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:701
msgid "Return the PCI product revision for device E<.Fa id>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:715
msgid ""
"During autoconfiguration, a E<.Nm> driver will receive a pointer to E<.Fa "
"struct pci_attach_args> describing the device attaches to the PCI bus.  "
"Drivers match the device using the E<.Fa pa_id> member using E<.Fn "
"PCI_VENDOR>.  E<.Fn PCI_PRODUCT> and E<.Fn PCI_REVISION>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:726
msgid ""
"During the driver attach step, drivers can read the device configuration "
"space using E<.Fn pci_conf_read>.  The meaning attached to registers in the "
"PCI configuration space are device-dependent, but will usually contain "
"physical addresses of the device register windows.  Device options can also "
"be stored into the PCI configuration space using E<.Fn pci_conf_write>.  For "
"example, the driver can request support for bus-mastering DMA by writing the "
"option to the PCI configuration space."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:731
msgid ""
"Device capabilities can be queried using E<.Fn pci_get_capability>, and "
"returns device-specific information which can be found in the PCI "
"configuration space to alter device operation."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:739
msgid ""
"After reading the physical addresses of the device register windows from "
"configuration space, these windows must be mapped into kernel virtual "
"address space using E<.Fn pci_mapreg_map>.  Device registers can now be "
"accessed using the standard bus-space API (see E<.Xr bus_space 9>)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:742
msgid "Details of using PCI interrupts is described in E<.Xr pci_intr 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:749
msgid ""
"The PCI bus supports bus-mastering operations from any device on the bus.  "
"The DMA facilities are accessed through the standard E<.Xr bus_dma 9> "
"interface.  To support DMA transfers from the device to the host, it is "
"necessary to enable bus-mastering in the PCI configuration space for the "
"device."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:753
msgid ""
"During system shutdown, it is necessary to abort any DMA transfers in "
"progress by registering a shutdown hook (see E<.Xr pmf 9>)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:763
msgid ""
"The PCI subsystem itself is implemented within the files E<.Pa "
"sys/dev/pci/pci.c>, E<.Pa sys/dev/pci/pci_subr.c>, E<.Pa "
"sys/dev/pci/pci_map.c>, E<.Pa sys/dev/pci/pci_quirks.c>, and E<.Pa "
"sys/dev/pci/pciconf.c>.  Machine-dependent portions are implemented within "
"the file E<.Pa sys/arch/\\*[Lt]arch\\*[Gt]/pci/pci_machdep.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:771
msgid ""
"The database of known devices exists within the file E<.Pa "
"sys/dev/pci/pcidevs_data.h> and is generated automatically from the file "
"E<.Pa sys/dev/pci/pcidevs>.  New vendor and product identifiers should be "
"added to this file.  The database can be regenerated using the Makefile "
"E<.Pa sys/dev/pci/Makefile.pcidevs>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:780
msgid ""
"E<.Xr pci 4>, E<.Xr autoconf 9>, E<.Xr bus_dma 9>, E<.Xr bus_space 9>, E<.Xr "
"driver 9>, E<.Xr pci_configure_bus 9>, E<.Xr pci_intr 9>, E<.Xr pmf 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci.9:782
msgid "The machine-independent PCI subsystem appeared in E<.Nx 1.2>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:36
#, no-wrap
msgid "February 21, 2006"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:37
#, no-wrap
msgid "PCI_CONFIGURE_BUS 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:43
msgid "E<.Nm pci_configure_bus>, E<.Nm pci_conf_hook>, E<.Nm pci_conf_interrupt>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:43
#, no-wrap
msgid "perform PCI bus configuration"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:45
#, no-wrap
msgid "dev/pci/pciconf.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:55
msgid ""
"E<.Ft int> E<.Fo pci_configure_bus> E<.Fa \"pci_chipset_tag_t pc\"> E<.Fa "
"\"struct extent *ioext\"> E<.Fa \"struct extent *memext\"> E<.Fa \"struct "
"extent *pmemext\"> E<.Fa \"int firstbus\"> E<.Fa \"int cacheline_size\"> "
"E<.Fc>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:60
msgid ""
"The E<.Fn pci_configure_bus> function configures a PCI bus for use.  This "
"involves:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:63
msgid "Defining bus numbers for all busses on the system,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:65
msgid "Setting the Base Address Registers for all devices,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:67
msgid "Setting up the interrupt line register for all devices,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:69
msgid "Configuring bus latency timers for all devices, and"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:71
msgid "Configuring cacheline sizes for all devices."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:77
msgid ""
"In traditional PCs and Alpha systems, the BIOS or firmware takes care of "
"this task, but that is not the case for all systems.  E<.Fn "
"pci_configure_bus> should be called prior to the autoconfiguration of the "
"bus."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:115
msgid ""
"The E<.Fa pc> argument is a machine-dependent tag used to specify the PCI "
"chipset to the system.  This should be the same value used with E<.Fn "
"pci_make_tag>.  The extent arguments define memory extents from which the "
"address space for the cards will be taken.  These addresses should be in the "
"PCI address space.  The E<.Fa ioext> extent is for PCI I/O accesses.  The "
"E<.Fa memext> extent is for PCI memory accesses that might have side "
"effects.  I.e., that can not be cached.  The E<.Fa pmemext> extent is for "
"PCI memory accesses that can be cached.  The E<.Fa pmemext> extent will be "
"used for any ROMs and any memory regions that are marked as E<.Dq "
"prefetchable> in their BAR.  If an implementation does not distinguish "
"between prefetchable and non-prefetchable memory, it may pass NULL for E<.Fa "
"pmemext>.  In this case, prefetchable memory allocations will be made from "
"the non-prefetchable region.  The E<.Fa firstbus> argument indicates the "
"number of the first bus to be configured.  The E<.Fa cacheline_size> "
"argument is used to configure the PCI Cache Line Size Register; it should be "
"the size, in bytes, of the largest D-cache line on the system."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:122
msgid ""
"An implementation may choose to not have full configuration performed by "
"E<.Fn pci_configure_bus> on certain PCI devices, such as PCI host bridges or "
"PCI bus analyzers which are instantiated as devices on the bus.  In order "
"for this to take place, the header"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:122 org_netbsd/src/share/man/man9/pci_intr.9:57
#, no-wrap
msgid "machine/pci_machdep.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:130
msgid ""
"must define the E<.Dv __HAVE_PCI_CONF_HOOK> symbol (without a value), and a "
"machine-dependent function E<.Fn pci_conf_hook> (declared in the same "
"header)  must be defined.  The prototype for this function is"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:133
msgid ""
"E<.Fn \"int pci_conf_hook\" \"pci_chipset_tag_t pc\" \"int bus\" \"int "
"device\" \"int function\" \"pcireg_t id\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:147
msgid ""
"In this function, E<.Fa bus>, E<.Fa device>, and E<.Fa function> uniquely "
"identify the item being configured; in addition to this, the value of the "
"device's PCI identification register is passed in E<.Fa id>.  For each "
"device E<.Fn pci_conf_hook> can then decide upon the amount of configuration "
"to be performed by returning a bitwise inclusive-or of the following flags:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:148
#, no-wrap
msgid "Dv PCI_CONF_MAP_IO"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:150
msgid "Configure Base Address Registers that map I/O space"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:150
#, no-wrap
msgid "Dv PCI_CONF_MAP_MEM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:152
msgid "Configure Base Address Registers that map memory space"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:152
#, no-wrap
msgid "Dv PCI_CONF_MAP_ROM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:154
msgid "Configure Expansion ROM Base Address register"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:154
#, no-wrap
msgid "Dv PCI_CONF_ENABLE_IO"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:156
msgid "Enable I/O space accesses"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:156
#, no-wrap
msgid "Dv PCI_CONF_ENABLE_MEM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:158
msgid "Enable memory space accesses"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:158
#, no-wrap
msgid "Dv PCI_CONF_ENABLE_BM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:160
msgid "Enable bus mastering"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:165
msgid "In addition, E<.Dv PCI_CONF_ALL> specifies all of the above."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:176
msgid ""
"One of the functions of E<.Fn pci_configure_bus> is to configure interrupt "
"E<.Dq line> information.  This must be done on a machine-dependent basis, so "
"a machine-dependent function E<.Fn pci_conf_interrupt> must be defined.  The "
"prototype for this function is"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:179
msgid ""
"E<.Fn \"void pci_conf_interrupt\" \"pci_chipset_tag_t pc\" \"int bus\" \"int "
"device\" \"int pin\" \"int swiz\" \"int *iline\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:197
msgid ""
"In this function, E<.Fa bus>, E<.Fa device>, and E<.Fa pin>, uniquely "
"identify the item being configured.  The E<.Fa swiz> argument is a E<.Dq "
"swizzle>, a sum of the device numbers of the primary interface of the "
"bridges between the host bridge and the current device.  The function is "
"responsible for setting the value of E<.Fa iline>.  See chapter 9 of the "
"E<.Dq PCI-to-PCI Bridge Architecture Specification> for more information on "
"swizzling (also known as interrupt routing)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:204
msgid ""
"If successful E<.Fn pci_configure_bus> returns 0.  A non-zero return value "
"means that the bus was not completely configured for some reason.  A "
"description of the failure will be displayed on the console."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:211
msgid ""
"The E<.Fn pci_configure_bus> function is only included in the kernel if the "
"kernel is compiled with the E<.Dv PCI_NETBSD_CONFIGURE> option enabled."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:215
msgid ""
"The E<.Fn pci_conf_hook> function in evbppc's walnut implementation looks "
"like:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:221
#, no-wrap
msgid ""
"int\n"
"pci_conf_hook(pci_chipset_tag_t pc, int bus, int dev, int func,\n"
"    pcireg_t id)\n"
"{\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:231
#, no-wrap
msgid ""
"\tif ((PCI_VENDOR(id) == PCI_VENDOR_IBM \\*[Am]\\*[Am]\n"
"\t     PCI_PRODUCT(id) == PCI_PRODUCT_IBM_405GP) ||\n"
"\t    (PCI_VENDOR(id) == PCI_VENDOR_INTEL \\*[Am]\\*[Am]\n"
"\t     PCI_PRODUCT(id) == PCI_PRODUCT_INTEL_80960_RP)) {\n"
"\t\t/* Don't configure the bridge and PCI probe. */\n"
"\t\treturn 0;\n"
"\t}\n"
"\treturn (PCI_CONF_ALL \\*[Am] ~PCI_CONF_MAP_ROM);\n"
"}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:236
msgid ""
"The E<.Fn pci_conf_interrupt> function in the sandpoint implementation looks "
"like:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:248
#, no-wrap
msgid ""
"void\n"
"pci_conf_interrupt(pci_chipset_tag_t pc, int bus, int dev, int pin,\n"
"    int swiz, int *iline)\n"
"{\n"
"\tif (bus == 0) {\n"
"\t\t*iline = dev;\n"
"\t} else {\n"
"\t\t*iline = 13 + ((swiz + dev + 3) \\*[Am] 3);\n"
"\t}\n"
"}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:256
msgid ""
"The BeBox has nearly 1GB of PCI I/O memory starting at processor address "
"0x81000000 (PCI I/O address 0x01000000), and nearly 1GB of PCI memory "
"starting at 0xC0000000 (PCI memory address 0x00000000).  The E<.Fn "
"pci_configure_bus> function might be called as follows:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:270
#, no-wrap
msgid ""
"\tstruct extent *ioext, *memext;\n"
"\t...\n"
"\tioext  = extent_create(\"pciio\",  0x01000000, 0x0fffffff, M_DEVBUF,\n"
"\t    NULL, 0, EX_NOWAIT);\n"
"\tmemext = extent_create(\"pcimem\", 0x00000000, 0x0fffffff, M_DEVBUF,\n"
"\t    NULL, 0, EX_NOWAIT);\n"
"\t...\n"
"\tpci_configure_bus(0, ioext, memext, NULL);\n"
"\t...\n"
"\textent_destroy(ioext);\n"
"\textent_destroy(memext);\n"
"\t...\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:277
msgid "E<.Xr pci 4>, E<.Xr extent 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_configure_bus.9:280
msgid "E<.Fn pci_configure_bus> was added in E<.Nx 1.6>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/pci_intr.9:30
#, no-wrap
msgid "April 5, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/pci_intr.9:31
#, no-wrap
msgid "PCI_INTR 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_intr.9:39
msgid ""
"E<.Nm pci_intr>, E<.Nm pci_intr_map>, E<.Nm pci_intr_string>, E<.Nm "
"pci_intr_establish>, E<.Nm pci_intr_disestablish>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/pci_intr.9:39
#, no-wrap
msgid "PCI bus interrupt manipulation functions"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_intr.9:51
msgid ""
"E<.Ft int> E<.Fn pci_intr_map \"const struct pci_attach_args *pa\" "
"\"pci_intr_handle_t *ih\"> E<.Ft const char *> E<.Fn pci_intr_string "
"\"pci_chipset_t *pc\" \"pci_intr_handle_t ih\"> E<.Ft void *> E<.Fn "
"pci_intr_establish \"pci_chipset_t *pc\" \"pci_intr_handle_t ih\" \"int "
"ipl\" \"int (*intrhand)(void *)\" \"void *intrarg\"> E<.Ft void> E<.Fn "
"pci_intr_disestablish \"pci_chipset_t *pc\" \"void *ih\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_intr.9:57
msgid ""
"The E<.Nm> functions exist to allow device drivers machine-independent "
"access to PCI bus interrupts.  The functions described in this page are "
"typically declared in a port's"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_intr.9:59
msgid "header file; however, drivers should generally include"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_intr.9:61
msgid "to get other PCI-specific declarations as well."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_intr.9:72
msgid ""
"Each driver has an E<.Fn attach> function which has a bus-specific E<.Ft "
"attach_args> structure.  Each driver for a PCI device is passed a pointer to "
"an object of type E<.Ft struct pci_attach_args> which contains, among other "
"things, information about the location of the device in the PCI bus topology "
"sufficient to allow interrupts from the device to be handled."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_intr.9:83
msgid ""
"If a driver wishes to establish an interrupt handler for the device, it "
"should pass the E<.Ft struct pci_attach_args *> to the E<.Fn pci_intr_map> "
"function, which returns zero on success, and nonzero on failure.  The "
"function sets the E<.Ft pci_intr_handle_t> pointed at by its second argument "
"to a machine-dependent value which identifies a particular interrupt source."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_intr.9:87
msgid ""
"If the driver wishes to refer to the interrupt source in an attach or error "
"message, it should use the value returned by E<.Fn pci_intr_string>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_intr.9:97
msgid ""
"Subsequently, when the driver is prepared to receive interrupts, it should "
"call E<.Fn pci_intr_establish> to actually establish the handler; when the "
"device interrupts, E<.Fa intrhand> will be called with a single argument "
"E<.Fa intrarg>, and will run at the interrupt priority level E<.Fa ipl>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_intr.9:104
msgid ""
"The return value of E<.Fn pci_intr_establish> may be saved and passed to "
"E<.Fn pci_intr_disestablish> to disable the interrupt handler when the "
"driver is no longer interested in interrupts from the device."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/pci_intr.9:104
#, no-wrap
msgid "PORTING"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_intr.9:110
msgid ""
"A port's implementation of E<.Fn pci_intr_map> may use the following members "
"of E<.Ft struct pci_attach_args> to determine how the device's interrupts "
"are routed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_intr.9:117
#, no-wrap
msgid ""
"\tpci_chipset_tag_t pa_pc;\n"
"\tpcitag_t pa_tag;\n"
"\tpcitag_t pa_intrtag; /* intr. appears to come from here */\n"
"\tpci_intr_pin_t pa_intrpin; /* intr. appears on this pin */\n"
"\tpci_intr_line_t pa_intrline; /* intr. routing information */\n"
"\tpci_intr_pin_t pa_rawintrpin; /* unswizzled pin */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_intr.9:131
msgid ""
"PCI-PCI bridges swizzle (permute) interrupt wiring.  Depending on "
"implementation details, it may be more convenient to use either original or "
"the swizzled interrupt parameters.  The original device tag and interrupt "
"pin can be found in E<.Ft pa_tag> and E<.Ft pa_rawintrpin> respectively, "
"while the swizzled tag and pin can be found in E<.Ft pa_intrtag> and E<.Ft "
"pa_intrpin>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pci_intr.9:144
msgid ""
"When a device is attached to a primary bus, both pairs of fields contain the "
"same values.  When a device is found behind one or more pci-pci bridges, "
"E<.Ft pa_intrpin> contains the E<.Dq swizzled> interrupt pin number, while "
"E<.Ft pa_rawintrpin> contains the original interrupt pin; E<.Ft pa_tag> "
"contains the PCI tag of the device itself, and E<.Ft pa_intrtag> contains "
"the PCI tag of the uppermost bridge device."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/pckbport.9:28
#, no-wrap
msgid "August 5, 2004"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/pckbport.9:29
#, no-wrap
msgid "PCKBPORT 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:45
msgid ""
"E<.Nm pckbport>, E<.Nm pckbport_attach>, E<.Nm pckbport_attach_slot>, E<.Nm "
"pckbport_cnattach>, E<.Nm pckbportintr>, E<.Nm pckbport_set_inputhandler>, "
"E<.Nm pckbport_flush>, E<.Nm pckbport_poll_cmd>, E<.Nm "
"pckbport_enqueue_cmd>, E<.Nm pckbport_poll_data>, E<.Nm pckbport_set_poll>, "
"E<.Nm pckbport_xt_translation>, E<.Nm pckbport_slot_enable>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/pckbport.9:45
#, no-wrap
msgid "PC keyboard port interface"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/pckbport.9:47
#, no-wrap
msgid "dev/pckbport/pckbportvar.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:76
msgid ""
"E<.Ft pckbport_tag_t> E<.Fn pckbport_attach \"void *\" \"struct "
"pckbport_accessops const *\"> E<.Ft \"struct device *\"> E<.Fn "
"pckbport_attach_slot \"struct device *\" pckbport_tag_t pckbport_slot_t> "
"E<.Ft int> E<.Fn pckbport_cnattach \"void *\" \"struct pckbport_accessops "
"const *\" pckbport_slot_t> E<.Ft void> E<.Fn pckbportintr pckbport_tag_t "
"pckbport_slot_t int> E<.Ft void> E<.Fn pckbport_set_inputhandler "
"pckbport_tag_t pckbport_slot_t pckbport_inputfcn \"void *\" \"char *\"> "
"E<.Ft void> E<.Fn pckbport_flush pckbport_tag_t pckbport_slot_t> E<.Ft int> "
"E<.Fn pckbport_poll_cmd pckbport_tag_t pckbport_slot_t \"u_char *\" int int "
"\"u_char *\" int> E<.Ft int> E<.Fn pckbport_enqueue_cmd pckbport_tag_t "
"pckbport_slot_t \"u_char *\" int int int \"u_char *\"> E<.Ft int> E<.Fn "
"pckbport_poll_data pckbport_tag_t pckbport_slot_t> E<.Ft void> E<.Fn "
"pckbport_set_poll pckbport_tag_t pckbport_slot_t int> E<.Ft int> E<.Fn "
"pckbport_xt_translation pckbport_tag_t pckbport_slot_t int> E<.Ft void> "
"E<.Fn pckbport_slot_enable pckbport_tag_t pckbport_slot_t int>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:89
msgid ""
"The machine-independent E<.Nm> subsystem provides an interface layer "
"corresponding to the serial keyboard and mouse interface used on the E<.Tn "
"IBM PS/2> and many other machines.  It interfaces a controller driver such "
"as E<.Xr pckbc 4> to device drivers such as E<.Xr pckbd 4> and E<.Xr pms 4>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:101
msgid ""
"A single controller can have up to two ports (known as E<.Dq slots>), and "
"these are identified by values of type E<.Fa pckbport_slot_t>.  The values "
"E<.Dv PCKBPORT_KBD_SLOT> and E<.Dv PCKBPORT_AUX_SLOT> should be used for "
"keyboard and mouse ports respectively.  Each controller is identified by an "
"opaque value of type E<.Fa pckbport_tag_t>."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/pckbport.9:101
#, no-wrap
msgid "Controller interface"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:125
msgid ""
"A PC keyboard controller registers itself by calling E<.Fn pckbport_attach "
"cookie ops>, with E<.Fa ops> being a pointer to a E<.Fa struct "
"pckbport_accessops> containing pointers to functions for driving the "
"controller, which will all be called with E<.Fa cookie> as their first "
"argument.  E<.Fn pckbport_attach> returns the E<.Fa pckbport_tag_t> assigned "
"to the controller.  The controller is then expected to call E<.Fn "
"pckbport_attach_slot> for each slot with which it is equipped, passing the "
"E<.Fa \"struct device *\"> corresponding to the controller.  This function "
"returns a pointer to the child device attached to the slot, or E<.Dv NULL> "
"if no such device was attached."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:134
msgid ""
"The elements of E<.Fa \"struct pckbport_accessops\"> each take as their "
"first two arguments the E<.Fa cookie> passed to E<.Fn pckbport_attach> and "
"the slot in question.  The elements are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pckbport.9:135
#, no-wrap
msgid ""
"Fa int Fn (*t_xt_translation) \"void *cookie\" \"pckbport_slot_t slot\" "
"\"int on\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:143
msgid ""
"If E<.Fa on> is non-zero, enable, otherwise disable, AT-to-XT keycode "
"translation on the slot specified.  Returns 1 on success, 0 on failure (or "
"if the controller does not support such translation)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pckbport.9:143
#, no-wrap
msgid ""
"Fa int Fn (*t_send_devcmd) \"void *cookie\" \"pckbport_slot_t slot\" "
"\"u_char byte\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:149
msgid ""
"Send a single E<.Fa byte> to the device without waiting for completion.  "
"Returns 1 on success, 0 on failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pckbport.9:149
#, no-wrap
msgid "Fa int Fn (*t_poll_data1) \"void *cookie\" \"pckbport_slot_t slot\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:155
msgid ""
"Wait for and return one byte of data from the device, without using "
"interrupts.  This function will only be called after E<.Fn "
"\"(*t_set_poll)\"> has been used to put the slot in polling mode.  If no "
"data are forthcoming from the device after about 100ms, return \\-1."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pckbport.9:155
#, no-wrap
msgid ""
"Fa void Fn (*t_slot_enable) \"void *cookie\" \"pckbport_slot_t slot\" \"int "
"on\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:162
msgid ""
"If E<.Fa on> is non-zero, enable, otherwise disable, the slot.  If a slot is "
"disabled, it can be powered down, and is not expected to generate any "
"interrupts.  When first attached, ports should be disabled."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pckbport.9:162
#, no-wrap
msgid "Fa void Fn (*t_intr_establish) \"void *cookie\" \"pckbport_slot_t slot\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:165
msgid ""
"Set up an interrupt handler for the slot.  Called when a device gets "
"attached to it."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pckbport.9:165
#, no-wrap
msgid ""
"Fa void Fn (*t_set_poll) \"void *cookie\" \"pckbport_slot_t slot\" \"int "
"on\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:182
msgid ""
"If E<.Fa on> is non-zero, enable, otherwise disable, polling mode on the "
"slot.  In polling mode, data received from the device are provided to E<.Fn "
"(*t_poll_data1)> and not passed to E<.Fn pckbportintr>, whether or not "
"interrupts are enabled.  In non-polling mode, data from the device are "
"expected to cause interrupts.  The controller interrupt handler should call "
"E<.Fn pckbportintr tag slot byte> once for each E<.Va byte> received from "
"the device.  When first attached, a port should be in non-polling mode."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/pckbport.9:183
#, no-wrap
msgid "Device interface"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:203
msgid ""
"Devices that attach to E<.Nm> controllers do so using the normal E<.Xr "
"autoconf 9> mechanism.  Their E<.Fn (*ca_match)> and E<.Fn (*ca_attach)> "
"functions get passed a E<.Fa \"struct pckbport_attach_args\"> which contains "
"the controller and slot number where the device was found.  Device drivers "
"can use the following functions to communicate with the controller.  Each "
"takes E<.Fa tag> and E<.Fa slot> arguments to specify the slot to be acted "
"on."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pckbport.9:204
#, no-wrap
msgid "Fn pckbport_set_inputhandler tag slot fn arg name"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:212
msgid ""
"Arrange for E<.Fa fn> to be called with argument E<.Fa arg> whenever an "
"unsolicited byte is received from the slot.  The function will be called at "
"E<.Fn spltty>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pckbport.9:212
#, no-wrap
msgid "Fn pckbport_flush tag slot"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:214
msgid "Ensure that there is no pending input from the slot."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pckbport.9:214
#, no-wrap
msgid "Fn pckbport_poll_cmd tag slot cmd len responselen respbuf slow"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:232
msgid ""
"Issue a complete device command, E<.Fa cmd>, E<.Fa len> bytes long, "
"expecting a response E<.Fa responselen> bytes long, which will be placed in "
"E<.Fa respbuf>.  If E<.Fa slow> is true, the command is expected to take "
"over a second to execute.  E<.Fn pckbport_poll_cmd> handles getting an "
"acknowledgement from the device and retrying the command if necessary.  "
"Returns 0 on success, and an error value on failure.  This function should "
"only be called during autoconfiguration or when the slot has been placed "
"into polling mode by E<.Fn pckbport_set_poll>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pckbport.9:232
#, no-wrap
msgid "Fn pckbport_enqueue_cmd tag slot cmd len responselen sync respbuf"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:254
msgid ""
"Issue a complete device command, E<.Fa cmd>, E<.Fa len> bytes long, "
"expecting a response E<.Fa responselen> bytes long, which will be places in "
"E<.Fa respbuf>.  If E<.Fa sync> is true, E<.Fn pckbport_enqueue_cmd> waits "
"for the command to complete before returning, otherwise it returns "
"immediately.  It is not safe to set E<.Fa sync> when calling from an "
"interrupt context.  The E<.Nm pckbport> layer handles getting an "
"acknowledgement from the device and retrying the command if necessary.  "
"Returns 0 on success, and an error value on failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pckbport.9:254
#, no-wrap
msgid "Fn pckbport_poll_data tag slot"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:258
msgid ""
"Low-level command to poll for a single byte of data from the device, but "
"ignoring bytes that are part of the response to a command issued through "
"E<.Fn pckbport_enqueue_command>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pckbport.9:258
#, no-wrap
msgid "Fn pckbport_set_poll tag slot on"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:273
msgid ""
"If E<.Fa on> is true, enable polling on the slot, otherwise disable it.  In "
"polling mode, E<.Fn pckbport_poll_cmd> can be used to issue commands and "
"E<.Fn pckbport_poll_data> to read unsolicited data, without enabling "
"interrupts.  In non-polling mode, commands should be issued using E<.Fn "
"pckbport_enqueue_cmd>, unsolicited data are handled by the input function, "
"and disabling interrupts will suspend E<.Nm> operation."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pckbport.9:273
#, no-wrap
msgid "Fn pckbport_xt_translation tag slot on"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:277
msgid "Passthrough of E<.Fn (*t_xt_translation)> (see above)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pckbport.9:277
#, no-wrap
msgid "Fn pckbport_slot enable tag slot on"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:281
msgid "Passthrough of E<.Fn (*t_slot_enable)> (see above)."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/pckbport.9:282
#, no-wrap
msgid "Console interface"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:304
msgid ""
"On systems that can attach consoles through E<.Nm>, the controller's console "
"attachment function (called very early in autoconfiguration) calls E<.Fn "
"pckbport_cnattach cookie ops slot>.  The first two arguments are the same as "
"for E<.Fn pckbport_attach>, while the third indicates which slot the console "
"keyboard is attached to.  E<.Fn pckbport_cnattach> either calls E<.Fn "
"pckbd_cnattach>, if it is available, or E<.Fn pckbport_machdep_cnattach>.  "
"The latter allows machine-dependent keyboard drivers to attach themselves, "
"but it is only called if a device with the E<.Ql pckbport_machdep_cnattach> "
"attribute is configured into the system.  E<.Fn pckbport_cnattach> returns 0 "
"on success and an error value on failure.  E<.Fn pckbport_machdep_cnattach> "
"is expected to do the same."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:313
msgid ""
"The E<.Nm> code, and the E<.Xr pckbd 4> and E<.Xr pms 4> device drivers are "
"in E<.Pa sys/dev/pckbport>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:319
msgid ""
"E<.Xr pckbc 4>, E<.Xr pckbd 4>, E<.Xr pms 4>, E<.Xr autoconf 9>, E<.Xr spl "
"9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pckbport.9:330
msgid ""
"The E<.Nm> system appeared in E<.Nx 2.0>.  Before that, E<.Xr pckbd 4> and "
"E<.Xr pms 4> attached directly to E<.Xr pckbc 4> without any sensible way of "
"using a different controller."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/pcmcia.9:31
#, no-wrap
msgid "PCMCIA 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:54
msgid ""
"E<.Nm PCMCIA> E<.Nm pcmcia_function_init>, E<.Nm pcmcia_function_enable>, "
"E<.Nm pcmcia_function_disable>, E<.Nm pcmcia_io_alloc>, E<.Nm "
"pcmcia_io_free>, E<.Nm pcmcia_io_map>, E<.Nm pcmcia_io_unmap>, E<.Nm "
"pcmcia_mem_alloc>, E<.Nm pcmcia_mem_free>, E<.Nm pcmcia_mem_map>, E<.Nm "
"pcmcia_mem_unmap>, E<.Nm pcmcia_intr_establish>, E<.Nm "
"pcmcia_intr_disestablish>, E<.Nm pcmcia_cis_read_1>, E<.Nm "
"pcmcia_cis_read_2>, E<.Nm pcmcia_cis_read_3>, E<.Nm pcmcia_cis_read_4>, "
"E<.Nm pcmcia_cis_read_n>, E<.Nm pcmcia_scan_cis>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/pcmcia.9:54
#, no-wrap
msgid "support for PCMCIA PC-Card devices"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/pcmcia.9:57
#, no-wrap
msgid "dev/pcmcia/pcmciareg.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/pcmcia.9:58
#, no-wrap
msgid "dev/pcmcia/pcmciavar.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/pcmcia.9:59
#, no-wrap
msgid "dev/pcmcia/pcmciadevs.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:108
msgid ""
"E<.Ft void> E<.Fn pcmcia_function_init \"struct pcmcia_function *pf\" "
"\"struct pcmcia_config_entry *cfe\"> E<.Ft int> E<.Fn pcmcia_function_enable "
"\"struct pcmcia_function *pf\"> E<.Ft void> E<.Fn pcmcia_function_disable "
"\"struct pcmcia_function *pf\"> E<.Ft int> E<.Fn pcmcia_io_alloc \"struct "
"pcmcia_function *pf\" \"bus_addr_t start\" \"bus_size_t size\" \"bus_size_t "
"align\" \"struct pcmcia_io_handle *pciop\"> E<.Ft void> E<.Fn pcmcia_io_free "
"\"struct pcmcia_function *pf\" \"struct pcmcia_io_handle *pcihp\"> E<.Ft "
"int> E<.Fn pcmcia_io_map \"struct pcmcia_function *pf\" \"int width\" "
"\"struct pcmcia_io_handle *pcihp\" \"int *windowp\"> E<.Ft void> E<.Fn "
"pcmcia_io_unmap \"struct pcmcia_function *pf\" \"int window\"> E<.Ft int> "
"E<.Fn pcmcia_mem_alloc \"struct pcmcia_function *pf\" \"bus_size_t size\" "
"\"struct pcmcia_mem_handle *pcmhp\"> E<.Ft void> E<.Fn pcmcia_mem_free "
"\"struct pcmcia_function *pf\" \"struct pcmcia_mem_handle *pcmhp\"> E<.Ft "
"int> E<.Fn pcmcia_mem_map \"struct pcmcia_function *pf\" \"int width\" "
"\"bus_addr_t card_addr\" \"bus_size_t size\" \"struct pcmcia_mem_handle "
"*pcmhp\" \"bus_size_t *offsetp\" \"int *windowp\"> E<.Ft void> E<.Fn "
"pcmcia_mem_unmap \"struct pcmcia_function *pf\" \"int window\"> E<.Ft void "
"*> E<.Fn pcmcia_intr_establish \"struct pcmcia_function *pf\" \"int level\" "
"\"int (*handler)(void *)\" \"void *arg\"> E<.Ft void> E<.Fn "
"pcmcia_intr_disestablish \"struct pcmcia_function *pf\" \"void *ih\"> E<.Ft "
"uint8_t> E<.Fn pcmcia_cis_read_1 \"struct pcmcia_tuple *tuple\" \"int "
"index\"> E<.Ft uint16_t> E<.Fn pcmcia_cis_read_2 \"struct pcmcia_tuple "
"*tuple\" \"int index\"> E<.Ft uint32_t> E<.Fn pcmcia_cis_read_3 \"struct "
"pcmcia_tuple *tuple\" \"int index\"> E<.Ft uint32_t> E<.Fn pcmcia_cis_read_4 "
"\"struct pcmcia_tuple *tuple\" \"int index\"> E<.Ft uint32_t> E<.Fn "
"pcmcia_cis_read_n \"struct pcmcia_tuple *tuple\" \"int number\" \"int "
"index\"> E<.Ft int> E<.Fn pcmcia_scan_cis \"struct device *dev\" \"int "
"(*func)(struct pcmcia_tuple *, void *)\" \"void *arg\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:120
msgid ""
"The machine-independent E<.Nm> subsystem provides support for PC-Card "
"devices defined by the Personal Computer Memory Card International "
"Assocation (PCMCIA).  The E<.Nm> bus supports insertion and removal of cards "
"while a system is powered-on (ie, dynamic reconfiguration).  The socket must "
"be powered-off when a card is not present.  To the user, this appears as "
"though the socket is \"hot\" during insertion and removal events."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:126
msgid ""
"A PCMCIA controller interfaces the PCMCIA bus with the ISA or PCI busses on "
"the host system.  The controller is responsible for detecting and enabling "
"devices and for allocating and mapping resources such as memory and "
"interrupts to devices on the PCMCIA bus."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:133
msgid ""
"Each device has a table called the Card Information Structure (CIS)  which "
"contains configuration information.  The tuples in the CIS are used by the "
"controller to uniquely identify the device.  Additional information may be "
"present in the CIS, such as the ethernet MAC address, that can be accessed "
"and used within a device driver."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:138
msgid ""
"Devices on the PCMCIA bus are uniquely identified by a 32-bit manufacturer "
"ID and a 32-bit product ID.  Additionally, devices can perform multiple "
"functions (such as ethernet and modem) and these functions are identified by "
"a function ID."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:141
msgid ""
"PCMCIA devices do not support DMA, however memory on the device can be "
"mapped into the address space of the host."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:145 org_netbsd/src/share/man/man9/vme.9:120
msgid ""
"Drivers attached to the E<.Nm> bus will make use of the following data "
"types:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:146
#, no-wrap
msgid "Fa struct pcmcia_card"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:149
msgid ""
"Devices (cards) have their identity recorded in this structure.  It contains "
"the following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:155
#, no-wrap
msgid ""
"\tchar\t\t*cis1_info[4];\n"
"        int32_t         manufacturer;\n"
"        int32_t         product;\n"
"        uint16_t       error;\n"
"        SIMPLEQ_HEAD(, pcmcia_function)\tpf_head;\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:156
#, no-wrap
msgid "Fa struct pcmcia_function"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:161
msgid ""
"Identifies the function of the devices.  A device can have multiple "
"functions.  Consider it an opaque type for identifying a particular function "
"of a device."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:161
#, no-wrap
msgid "struct pcmcia_config_entry"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:164
msgid ""
"Contains information about the resources requested by the device.  It "
"contains the following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:183
#, no-wrap
msgid ""
"        int             number;\n"
"        uint32_t       flags;\n"
"        int     \tiftype;\n"
"        int   \t\tnum_iospace;\n"
"        u_long \t\tiomask;\n"
"        struct {\n"
"                u_long  length;\n"
"                u_long  start;\n"
"        } iospace[4];\n"
"        uint16_t       irqmask;\n"
"        int             num_memspace;\n"
"        struct {\n"
"                u_long  length;\n"
"                u_long  cardaddr;\n"
"                u_long  hostaddr;\n"
"        } \t\tmemspace[2];\n"
"        int             maxtwins;\n"
"\tSIMPLEQ_ENTRY(pcmcia_config_entry) cfe_list;\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:184
#, no-wrap
msgid "Fa struct pcmcia_tuple"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:186
msgid "A handle for identifying an entry in the CIS."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:186
#, no-wrap
msgid "Fa struct pcmcia_io_handle"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:189
msgid ""
"A handle for mapping and allocating I/O address spaces.  It contains the tag "
"and handle for accessing the bus-space."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:189
#, no-wrap
msgid "Fa struct pcmcia_mem_handle"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:192
msgid ""
"A handle for mapping and allocating memory address spaces.  It contains the "
"tag and handle for accessing the bus-space."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:192
#, no-wrap
msgid "Fa struct pcmcia_attach_args"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:201
#, no-wrap
msgid ""
"\tint32_t\t\t\tmanufacturer;\n"
"\tint32_t\t\t\tproduct;\n"
"\tstruct pcmcia_card\t*card;\n"
"\tstruct pcmcia_function\t*pf;\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:205
#, no-wrap
msgid "Fn pcmcia_function_init pf cfe"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:210
msgid ""
"Initialise the machine-independent E<.Nm> state with the config entry E<.Fa "
"cfe>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:210
#, no-wrap
msgid "Fn pcmcia_function_enable pf"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:214
msgid ""
"Provide power to the socket containing the device specified by device "
"function E<.Fa pf>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:214
#, no-wrap
msgid "Fn pcmcia_function_disable pf"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:218
msgid ""
"Remove power from the socket containing the device specified by device "
"function E<.Fa pf>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:218
#, no-wrap
msgid "Fn pcmcia_io_alloc pf start size align pciop"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:229
msgid ""
"Request I/O space for device function E<.Fa pf> at address E<.Fa start> of "
"size E<.Fa size>.  Alignment is specified by E<.Fa align>.  A handle for the "
"I/O space is returned in E<.Fa pciop>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:229
#, no-wrap
msgid "Fn pcmcia_io_free pf pcihp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:234
msgid "Release I/O space with handle E<.Fa pcihp> for device function E<.Fa pf>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:234
#, no-wrap
msgid "Fn pcmcia_io_map pf width pcihp windowp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:242
msgid ""
"Map device I/O for device function E<.Fa pf> to the I/O space with handle "
"E<.Fa pcihp>.  The width of data access is specified by E<.Fa width>.  Valid "
"values for the width are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:243
#, no-wrap
msgid "PCMCIA_WIDTH_AUTO"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:245
msgid "Use the largest I/O width reported by the device."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:245
#, no-wrap
msgid "PCMCIA_WIDTH_IO8"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:247
msgid "Force 8-bit I/O width."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:247
#, no-wrap
msgid "PCMCIA_WIDTH_IO16"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:249
msgid "Force 16-bit I/O width."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:253
msgid "A handle for the mapped I/O window is returned in E<.Fa windowp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:253
#, no-wrap
msgid "Fn pcmcia_io_unmap pf window"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:258
msgid "Unmap the I/O window E<.Fa window> for device function E<.Fa pf>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:258
#, no-wrap
msgid "Fn pcmcia_mem_alloc pf size pcmhp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:265
msgid ""
"Request memory space for device function E<.Fa pf> of size E<.Fa size>.  A "
"handle for the memory space is returned in E<.Fa pcmhp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:265
#, no-wrap
msgid "Fn pcmcia_mem_free pf pcmhp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:270
msgid "Release memory space with handle E<.Fa pcmhp> for device function E<.Fa pf>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:270
#, no-wrap
msgid "Fn pcmcia_mem_map pf width card_addr size pcmhp offsetp windowp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:283
msgid ""
"Map device memory for device function E<.Fa pf> to the memory space with "
"handle E<.Fa pcmhp>.  The address of the device memory starts at E<.Fa "
"card_addr> and is size E<.Fa size>.  The width of data access is specified "
"by E<.Fa width>.  Valid values for the width are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:284
#, no-wrap
msgid "PCMCIA_WIDTH_MEM8"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:286
msgid "Force 8-bit memory width."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:286
#, no-wrap
msgid "PCMCIA_WIDTH_MEM16"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:288
msgid "Force 16-bit memory width."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:294
msgid ""
"A handle for the mapped memory window is returned in E<.Fa windowp> and a "
"bus-space offset into the memory window is returned in E<.Fa offsetp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:294
#, no-wrap
msgid "Fn pcmcia_mem_unmap pf window"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:299
msgid "Unmap the memory window E<.Fa window> for device function E<.Fa pf>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:299
#, no-wrap
msgid "Fn pcmcia_intr_establish pf level handler arg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:312
msgid ""
"Establish an interrupt handler for device function E<.Fa pf>.  The priority "
"of the interrupt is specified by E<.Fa level>.  When the interrupt occurs "
"the function E<.Fa handler> is called with argument E<.Fa arg>.  The return "
"value is a handle for the interrupt handler.  E<.Fn pcmcia_intr_establish> "
"returns an opaque handle to an event descriptor if it succeeds, and returns "
"NULL on failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:312
#, no-wrap
msgid "Fn pcmcia_intr_disestablish pf ih"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:319
msgid ""
"Dis-establish the interrupt handler for device function E<.Fa pf> with "
"handle E<.Fa ih>.  The handle was returned from E<.Fn "
"pcmcia_intr_establish>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:319
#, no-wrap
msgid "Fn pcmcia_cis_read_1 tuple index"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:325
msgid "Read one byte from tuple E<.Fa tuple> at index E<.Fa index> in the CIS."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:325
#, no-wrap
msgid "Fn pcmcia_cis_read_2 tuple index"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:331
msgid "Read two bytes from tuple E<.Fa tuple> at index E<.Fa index> in the CIS."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:331
#, no-wrap
msgid "Fn pcmcia_cis_read_3 tuple index"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:337
msgid "Read three bytes from tuple E<.Fa tuple> at index E<.Fa index> in the CIS."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:337
#, no-wrap
msgid "Fn pcmcia_cis_read_4 tuple index"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:343
msgid "Read four bytes from tuple E<.Fa tuple> at index E<.Fa index> in the CIS."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:343
#, no-wrap
msgid "Fn pcmcia_cis_read_n tuple number index"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:351
msgid ""
"Read E<.Fa n> bytes from tuple E<.Fa tuple> at index E<.Fa index> in the "
"CIS."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcmcia.9:351
#, no-wrap
msgid "Fn pcmcia_scan_cis dev func arg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:361
msgid ""
"Scan the CIS for device E<.Fa dev>.  For each tuple in the CIS, function "
"E<.Fa func> is called with the tuple and the argument E<.Fa arg>.  E<.Fa "
"func> should return 0 if the tuple it was called with is the one it was "
"looking for, or 1 otherwise."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:373
msgid ""
"During autoconfiguration, a E<.Nm> driver will receive a pointer to E<.Fa "
"struct pcmcia_attach_args> describing the device attached to the PCMCIA "
"bus.  Drivers match the device using the E<.Em manufacturer> and E<.Em "
"product> members."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:397
msgid ""
"During the driver attach step, drivers will use the pcmcia function E<.Em "
"pf>.  The driver should traverse the list of config entries searching for a "
"useful configuration.  This config entry is passed to E<.Fn "
"pcmcia_function_init> to initialise the machine-independent interface.  I/O "
"and memory resources should be initialised using E<.Fn pcmcia_io_alloc> and "
"E<.Fn pcmcia_mem_alloc> using the specified resources in the config entry.  "
"These resources can then be mapped into processor bus space using E<.Fn "
"pcmcia_io_map> and E<.Fn pcmcia_mem_map> respectively.  Upon successful "
"allocation of resources, power can be applied to the device with E<.Fn "
"pcmcia_function_enable> so that device-specific interrogation can be "
"performed.  Finally, power should be removed from the device using E<.Fn "
"pcmcia_function_disable>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:404
msgid ""
"Since PCMCIA devices support dynamic configuration, drivers should make use "
"of E<.Xr pmf 9> framework.  Power can be applied and the interrupt handler "
"should be established through this interface."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:406
msgid "PCMCIA devices do not support DMA."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:416
msgid ""
"The PCMCIA subsystem itself is implemented within the file E<.Pa "
"sys/dev/pcmcia/pcmcia.c>.  The database of known devices exists within the "
"file E<.Pa sys/dev/pcmcia/pcmciadevs_data.h> and is generated automatically "
"from the file E<.Pa sys/dev/pcmcia/pcmciadevs>.  New manufacturer and "
"product identifiers should be added to this file.  The database can be "
"regenerated using the Makefile E<.Pa sys/dev/pcmcia/Makefile.pcmciadevs>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:429
msgid ""
"E<.Xr pcic 4>, E<.Xr pcmcia 4>, E<.Xr tcic 4>, E<.Xr autoconf 9>, E<.Xr "
"bus_dma 9>, E<.Xr bus_space 9>, E<.Xr driver 9> E<.Rs> E<.%A Personal "
"Computer Memory Card International Association (PCMCIA)> E<.%T \"PC Card 95 "
"Standard\"> E<.%D 1995> E<.Re>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcmcia.9:431
msgid "The machine-independent PCMCIA subsystem appeared in E<.Nx 1.3>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/pcq.9:30
#, no-wrap
msgid "January 22, 2012"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/pcq.9:31
#, no-wrap
msgid "PCQ 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcq.9:35
msgid "E<.Nm pcq>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/pcq.9:35
#, no-wrap
msgid "producer/consumer queue"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/pcq.9:37
#, no-wrap
msgid "sys/pcq.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcq.9:50
msgid ""
"E<.Ft pcq_t *> E<.Fn pcq_create \"size_t maxlen\" \"km_flags_t kmflags\"> "
"E<.Ft void> E<.Fn pcq_destroy \"pcq_t *pcq\"> E<.Ft void *> E<.Fn pcq_get "
"\"pcq_t *pcq\"> E<.Ft size_t> E<.Fn pcq_maxitems \"pcq_t *pcq\"> E<.Ft void "
"*> E<.Fn pcq_peek \"pcq_t *pcq\"> E<.Ft bool> E<.Fn pcq_put \"pcq_t *pcq\" "
"\"void *item\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcq.9:78
msgid ""
"The machine-independent E<.Nm> interface provides lockless producer/consumer "
"queues.  A queue E<.Po> E<.Vt pcq_t> E<.Pc> allows multiple writers E<.Pq "
"producers>, but only a single reader E<.Pq consumer>.  The consumer is "
"expected to be protected by a lock that covers the structure that the E<.Vt "
"pcq_t> is embedded into E<.Po> e.g., socket lock, ifnet hwlock E<.Pc>.  "
"These queues operate in a first-in, first-out E<.Pq FIFO> manner.  The act "
"of inserting or removing an item from a E<.Vt pcq_t> does not modify the "
"item in any way.  E<.Nm> does not prevent an item from being inserted "
"multiple times into a single E<.Vt pcq_t>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcq.9:80
#, no-wrap
msgid "Fn pcq_create maxlen kmflags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcq.9:94
msgid ""
"Create a queue that can store at most E<.Fa maxlen> items at one time.  "
"E<.Fa kmflags> should be either E<.Dv KM_SLEEP>, if E<.Fn pcq_create> is "
"allowed to sleep until resources are available, or E<.Dv KM_NOSLEEP> if it "
"should return E<.Dv NULL> immediately, if resources are unavailable."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcq.9:94
#, no-wrap
msgid "Fn pcq_destroy pcq"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcq.9:97
msgid "Free the resources held by E<.Fa pcq>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcq.9:97
#, no-wrap
msgid "Fn pcq_get pcq"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcq.9:103
msgid ""
"Remove the next item to be consumed from the queue and return it.  If the "
"queue is empty, return E<.Dv NULL>.  The caller must prevent concurrent gets "
"from occuring."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcq.9:103
#, no-wrap
msgid "Fn pcq_maxitems pcq"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcq.9:106
msgid "Return the maximum number of items that the queue can store at any one time."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcq.9:106
#, no-wrap
msgid "Fn pcq_peek pcq"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcq.9:112
msgid ""
"Return the next item to be consumed from the queue but do not remove it from "
"the queue.  If the queue is empty, return E<.Dv NULL>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pcq.9:112
#, no-wrap
msgid "Fn pcq_put pcq item"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcq.9:120
msgid ""
"Place an item at the end of the queue.  If there is no room in the queue for "
"the item, return E<.Dv false>; otherwise, return E<.Dv true>.  The item must "
"not have the value of E<.Dv NULL>."
msgstr ""

#.  .Sh EXAMPLES
#. type: Plain text
#: org_netbsd/src/share/man/man9/pcq.9:127
msgid ""
"The E<.Nm> interface is implemented within the file E<.Pa "
"sys/kern/subr_pcq.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pcq.9:130
msgid "E<.Xr atomic_ops 3>, E<.Xr queue 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/percpu.9:30
#, no-wrap
msgid "January 23, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/percpu.9:31
#, no-wrap
msgid "PERCPU 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/percpu.9:40
msgid ""
"E<.Nm percpu>, E<.Nm percpu_alloc>, E<.Nm percpu_free>, E<.Nm "
"percpu_getref>, E<.Nm percpu_putref>, E<.Nm percpu_foreach>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/percpu.9:40
#, no-wrap
msgid "per-CPU storage allocator"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/percpu.9:42
#, no-wrap
msgid "sys/percpu.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/percpu.9:54
msgid ""
"E<.Vt typedef void (*percpu_callback_t)(void *, void *, struct cpu_info *);> "
"E<.Ft percpu_t *> E<.Fn percpu_alloc \"size_t size\"> E<.Ft void> E<.Fn "
"percpu_free \"percpu_t *pc\" \"size_t size\"> E<.Ft void *> E<.Fn "
"percpu_getref \"percpu_t *pc\"> E<.Ft void> E<.Fn percpu_putref \"percpu_t "
"*pc\"> E<.Ft void> E<.Fn percpu_foreach \"percpu_t *pc\" \"percpu_callback_t "
"cb\" \"void *arg\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/percpu.9:78
msgid ""
"The machine-independent E<.Nm> interface provides per-CPU, CPU-local memory "
"reservations to kernel subsystems.  E<.Fo percpu_alloc> E<.Fa size> E<.Fc> "
"reserves on each CPU an independent memory region of E<.Fa size> bytes that "
"is local to that CPU, returning a handle E<.Po> E<.Vt percpu_t> E<.Pc> to "
"those regions.  A thread may subsequently ask for a pointer, E<.Fa p>, to "
"the region held by the E<.Vt percpu_t> on the thread's current CPU.  Until "
"the thread relinquishes the pointer, or voluntarily sleeps, the thread may "
"read or write the region at E<.Fa p> without causing interprocessor memory "
"synchronization."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/percpu.9:80
#, no-wrap
msgid "Fn percpu_alloc size"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/percpu.9:90
msgid ""
"Call this in thread context to allocate E<.Fa size> bytes of local storage "
"on each CPU.  The storage is initialized with zeroes.  Treat this as an "
"expensive operation.  E<.Fn percpu_alloc> returns E<.Dv NULL> on failure, "
"and a handle for the per-CPU storage on success."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/percpu.9:90
#, no-wrap
msgid "Fn percpu_free pc size"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/percpu.9:105
msgid ""
"Call this in thread context to return to the system the per-CPU storage held "
"by E<.Fa pc>.  E<.Fa size> should match the E<.Fa size> passed to E<.Fn "
"percpu_alloc>.  When E<.Fn percpu_free> returns, E<.Fa pc> is undefined.  "
"Treat this as an expensive operation."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/percpu.9:105
#, no-wrap
msgid "Fn percpu_getref pc"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/percpu.9:116
msgid ""
"Disable preemption and return a pointer to the storage held by E<.Fa pc> on "
"the local CPU.  Use E<.Fn percpu_getref> in either thread or interrupt "
"context.  Follow each E<.Fn percpu_getref> call with a matching call to "
"E<.Fn percpu_putref>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/percpu.9:116
#, no-wrap
msgid "Fn percpu_putref pc"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/percpu.9:122
msgid ""
"Indicate that the thread is finished with the pointer returned by the "
"matching call to E<.Fn percpu_getref>.  Re-enables preemption."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/percpu.9:122
#, no-wrap
msgid "Fn percpu_foreach pc cb arg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/percpu.9:143
msgid ""
"On each CPU, for E<.Fa ci> the corresponding E<.Vt \"struct cpu_info *\"> "
"and E<.Fa \"p\"> the CPU-local storage held by E<.Fa pc>, run E<.Fo "
"\"(*cb)\"> E<.Fa \"p\"> E<.Fa \"arg\"> E<.Fa \"ci\"> E<.Fc>.  Call this in "
"thread context.  E<.Fa cb> should be non-blocking and fast.  Do not rely on "
"E<.Fa cb> to be run on the CPUs in any particular order."
msgstr ""

#.  .Sh EXAMPLES
#. type: Plain text
#: org_netbsd/src/share/man/man9/percpu.9:150
msgid ""
"The E<.Nm> interface is implemented within the file E<.Pa "
"sys/kern/subr_percpu.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/percpu.9:156
msgid ""
"E<.Xr atomic_ops 3>, E<.Xr kmem 9>, E<.Xr pcq 9>, E<.Xr pool_cache 9>, E<.Xr "
"xcall 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/percpu.9:162 org_netbsd/src/share/man/man9/man9.x86/nmi.9:132
msgid "E<.An YAMAMOTO Takashi Aq yamt@NetBSD.org>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/pfil.9:27
#, no-wrap
msgid "January 8, 2006"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/pfil.9:28
#, no-wrap
msgid "PFIL 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pfil.9:39
msgid ""
"E<.Nm pfil>, E<.Nm pfil_head_register>, E<.Nm pfil_head_unregister>, E<.Nm "
"pfil_head_get>, E<.Nm pfil_hook_get>, E<.Nm pfil_add_hook>, E<.Nm "
"pfil_remove_hook>, E<.Nm pfil_run_hooks>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/pfil.9:39
#, no-wrap
msgid "packet filter interface"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/pfil.9:44
#, no-wrap
msgid "net/pfil.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pfil.9:61
msgid ""
"E<.Ft int> E<.Fn pfil_head_register \"struct pfil_head *ph\"> E<.Ft int> "
"E<.Fn pfil_head_unregister \"struct pfil_head *ph\"> E<.Ft struct pfil_head "
"*> E<.Fn pfil_head_get \"int af\" \"u_long dlt\"> E<.Ft struct "
"packet_filter_hook *> E<.Fn pfil_hook_get \"int dir\" \"struct pfil_head "
"*ph\"> E<.Ft int> E<.Fn pfil_add_hook \"int (*func)()\" \"void *arg\" \"int "
"flags\" \"struct pfil_head *ph\"> E<.Ft int> E<.Fn pfil_remove_hook \"int "
"(*func)()\" \"void *arg\" \"int flags\" \"struct pfil_head *ph\"> E<.Ft int> "
"E<.Fn (*func) \"void *arg\" \"struct mbuf **mp\" \"struct ifnet *\" \"int "
"dir\"> E<.Ft int> E<.Fn pfil_run_hooks \"struct pfil_head *ph\" \"struct "
"mbuf **mp\" \"struct ifnet *ifp\" \"int dir\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pfil.9:68
msgid ""
"The E<.Nm> framework allows for a specified function to be invoked for every "
"incoming or outgoing packet for a particular network I/O stream.  These "
"hooks may be used to implement a firewall or perform packet transformations."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pfil.9:85
msgid ""
"Packet filtering points are registered with E<.Fn pfil_head_register>.  "
"Filtering points are identified by a key (void *) and a data link type (int) "
"in the E<.Em pfil_head> structure.  Packet filters use the key and data link "
"type to look up the filtering point with which they register themselves.  "
"The key is unique to the filtering point.  The data link type is a E<.Xr bpf "
"4> DLT constant indicating what kind of header is present on the packet at "
"the filtering point.  Filtering points may be unregistered with the E<.Fn "
"pfil_head_unregister> function."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pfil.9:98
msgid ""
"Packet filters register/unregister themselves with a filtering point with "
"the E<.Fn pfil_add_hook> and E<.Fn pfil_remove_hook> functions, "
"respectively.  The head is looked up using the E<.Fn pfil_head_get> "
"function, which takes the key and data link type that the packet filter "
"expects.  Filters may provide an argument to be passed to the filter when "
"invoked on a packet."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pfil.9:114
msgid ""
"When a filter is invoked, the packet appears just as if it E<.Dq came off "
"the wire>.  That is, all protocol fields are in network byte order.  The "
"filter is called with its specified argument, the pointer to the pointer to "
"the mbuf containing the packet, the pointer to the network interface that "
"the packet is traversing, and the direction E<.Dv ( PFIL_IN> or E<.Dv "
"PFIL_OUT>, see also below) that the packet is traveling.  The filter may "
"change which mbuf the mbuf ** argument references.  The filter returns an "
"errno if the packet processing is to stop, or 0 if the processing is to "
"continue.  If the packet processing is to stop, it is the responsibility of "
"the filter to free the packet."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pfil.9:123
msgid ""
"The E<.Em flags> parameter, used in the E<.Fn pfil_add_hook> and E<.Fn "
"pfil_remove_hook> functions, indicates when the filter should be called.  "
"The flags are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pfil.9:124
#, no-wrap
msgid "PFIL_IN"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pfil.9:126
msgid "call me on incoming packets"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pfil.9:126
#, no-wrap
msgid "PFIL_OUT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pfil.9:128
msgid "call me on outgoing packets"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pfil.9:128
#, no-wrap
msgid "PFIL_ALL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pfil.9:130
msgid "call me on all of the above"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pfil.9:130
#, no-wrap
msgid "PFIL_IFADDR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pfil.9:132
msgid "call me on interface reconfig (mbuf ** is ioctl #)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pfil.9:132
#, no-wrap
msgid "PFIL_IFNET"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pfil.9:137
msgid ""
"call me on interface attach/detach (mbuf ** is either E<.Dv "
"PFIL_IFNET_ATTACH> or E<.Dv PFIL_IFNET_DETACH>)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pfil.9:137
#, no-wrap
msgid "PFIL_WAITOK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pfil.9:139
msgid "OK to call malloc with M_WAITOK."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pfil.9:146
msgid ""
"The E<.Nm> interface is enabled in the kernel via the E<.Sy PFIL_HOOKS> "
"option."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pfil.9:156
msgid ""
"The E<.Nm> interface first appeared in E<.Nx 1.3>.  The E<.Nm> input and "
"output lists were originally implemented as"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/pfil.9:156
#, no-wrap
msgid "sys/queue.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pfil.9:166
msgid ""
"E<.Dv LIST> structures; however this was changed in E<.Nx 1.4> to E<.Dv "
"TAILQ> structures.  This change was to allow the input and output filters to "
"be processed in reverse order, to allow the same path to be taken, in or out "
"of the kernel."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pfil.9:175
msgid ""
"The E<.Nm> interface was changed in 1.4T to accept a 3rd parameter to both "
"E<.Fn pfil_add_hook> and E<.Fn pfil_remove_hook>, introducing the capability "
"of per-protocol filtering.  This was done primarily in order to support "
"filtering of IPv6."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pfil.9:180
msgid ""
"In 1.5K, the E<.Nm> framework was changed to work with an arbitrary number "
"of filtering points, as well as be less IP-centric."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pfil.9:187
msgid ""
"The E<.Nm> interface was designed and implemented by Matthew R. Green, with "
"help from Darren Reed, Jason R. Thorpe and Charles M. Hannum.  Darren Reed "
"added support for IPv6 in addition to IPv4.  Jason R. Thorpe added support "
"for multiple hooks and other clean up."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pfil.9:190
msgid ""
"The current E<.Nm> implementation will need changes to suit a threaded "
"kernel model."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/physio.9:31
#, no-wrap
msgid "PHYSIO 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/physio.9:35
msgid "E<.Nm physio>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/physio.9:35
#, no-wrap
msgid "initiate I/O on raw devices"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/physio.9:46
msgid ""
"E<.Ft int> E<.Fo \"physio\"> E<.Fa \"(*strategy)(struct buf *)\"> E<.Fa "
"\"struct buf *bp\"> E<.Fa \"dev_t dev\"> E<.Fa \"int flags\"> E<.Fa "
"\"(*minphys)(struct buf *)\"> E<.Fa \"struct uio *uio\"> E<.Fc>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/physio.9:62
msgid ""
"The E<.Fn physio> is a helper function typically called from character "
"device read and write routines to start E<.Tn I/O> on a user process "
"buffer.  It calls back on the provided E<.Fa strategy> routine one or more "
"times to complete the transfer described by E<.Fa uio>.  The maximum amount "
"of data to transfer with each call to E<.Fa strategy> is determined by the "
"E<.Fa minphys> routine."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/physio.9:83
msgid ""
"Since E<.Fa uio> normally describes user space addresses, E<.Fn physio> "
"needs to lock the appropriate data area into memory before each transaction "
"with E<.Fa strategy> (see E<.Xr uvm_vslock 9> and E<.Xr uvm_vsunlock 9>).  "
"The E<.Fn physio> function always awaits the completion of the entire "
"requested transfer before returning, unless an error condition is detected "
"earlier.  In all cases, the buffer passed in E<.Fa bp> is locked (marked as "
"E<.Dq busy>)  for the duration of the entire transfer."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/physio.9:85
msgid "A break-down of the arguments follows:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/physio.9:86
#, no-wrap
msgid "Fa strategy"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/physio.9:90
msgid ""
"The device strategy routine to call for each chunk of data to initiate "
"device E<.Tn I/O>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/physio.9:90
#, no-wrap
msgid "Fa bp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/physio.9:101
msgid ""
"The buffer to use with the strategy routine.  The buffer flags will have "
"E<.Dv B_BUSY>, E<.Dv B_PHYS>, and E<.Dv B_RAW> set when passed to the "
"strategy routine.  If E<.Dv NULL>, a buffer is allocated from a system pool."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/physio.9:101
#, no-wrap
msgid "Fa dev"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/physio.9:103
msgid "The device number identifying the device to interact with."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/physio.9:108
msgid ""
"Direction of transfer; the only valid settings are E<.Dv B_READ> or E<.Dv "
"B_WRITE>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/physio.9:108
#, no-wrap
msgid "Fa minphys"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/physio.9:111
msgid ""
"A device specific routine called to determine the maximum transfer size that "
"the device's strategy routine can handle."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/physio.9:111
#, no-wrap
msgid "Fa uio"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/physio.9:120
msgid ""
"The description of the entire transfer as requested by the user process.  "
"Currently, the results of passing a E<.Fa uio> structure with the E<.Sq "
"uio_segflg> set to anything other than E<.Dv UIO_USERSPACE>, are undefined."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/physio.9:141
msgid ""
"If successful E<.Fn physio> returns 0.  E<.Er EFAULT> is returned if the "
"address range described by E<.Fa uio> is not accessible by the requesting "
"process.  E<.Fn physio> will return any error resulting from calls to the "
"device strategy routine, by examining the E<.Dv B_ERROR> buffer flag and the "
"E<.Sq b_error> field.  Note that the actual transfer size may be less than "
"requested by E<.Fa uio> if the device signals an E<.Dq end of file> "
"condition."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/physio.9:143
msgid "E<.Xr read 2>, E<.Xr write 2>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/pmap.9:31
#, no-wrap
msgid "PMAP 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:35
msgid "E<.Nm pmap>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/pmap.9:35
#, no-wrap
msgid "machine-dependent portion of the virtual memory system"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/pmap.9:38
#, no-wrap
msgid "uvm/uvm_extern.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:109
msgid ""
"E<.Ft void> E<.Fn \"pmap_init\" \"void\"> E<.Ft void> E<.Fn "
"\"pmap_virtual_space\" \"vaddr_t *vstartp\" \"vaddr_t *vendp\"> E<.Ft "
"vaddr_t> E<.Fn \"pmap_steal_memory\" \"vsize_t size\" \"vaddr_t *vstartp\" "
"\"vaddr_t *vendp\"> E<.Ft pmap_t> E<.Fn \"pmap_kernel\" \"void\"> E<.Ft "
"pmap_t> E<.Fn \"pmap_create\" \"void\"> E<.Ft void> E<.Fn \"pmap_destroy\" "
"\"pmap_t pmap\"> E<.Ft void> E<.Fn \"pmap_reference\" \"pmap_t pmap\"> E<.Ft "
"void> E<.Fn \"pmap_fork\" \"pmap_t src_map\" \"pmap_t dst_map\"> E<.Ft long> "
"E<.Fn \"pmap_resident_count\" \"pmap_t pmap\"> E<.Ft long> E<.Fn "
"\"pmap_wired_count\" \"pmap_t pmap\"> E<.Ft vaddr_t> E<.Fn "
"\"pmap_growkernel\" \"vaddr_t maxkvaddr\"> E<.Ft int> E<.Fn \"pmap_enter\" "
"\"pmap_t pmap\" \"vaddr_t va\" \"paddr_t pa\" \"vm_prot_t prot\" \"u_int "
"flags\"> E<.Ft void> E<.Fn \"pmap_remove\" \"pmap_t pmap\" \"vaddr_t sva\" "
"\"vaddr_t eva\"> E<.Ft void> E<.Fn \"pmap_remove_all\" \"pmap_t pmap\"> "
"E<.Ft void> E<.Fn \"pmap_protect\" \"pmap_t pmap\" \"vaddr_t sva\" \"vaddr_t "
"eva\" \"vm_prot_t prot\"> E<.Ft void> E<.Fn \"pmap_unwire\" \"pmap_t pmap\" "
"\"vaddr_t va\"> E<.Ft bool> E<.Fn \"pmap_extract\" \"pmap_t pmap\" \"vaddr_t "
"va\" \"paddr_t *pap\"> E<.Ft void> E<.Fn \"pmap_kenter_pa\" \"vaddr_t va\" "
"\"paddr_t pa\" \"vm_prot_t prot\" \"u_int flags\"> E<.Ft void> E<.Fn "
"\"pmap_kremove\" \"vaddr_t va\" \"vsize_t size\"> E<.Ft void> E<.Fn "
"\"pmap_copy\" \"pmap_t dst_map\" \"pmap_t src_map\" \"vaddr_t dst_addr\" "
"\"vsize_t len\" \"vaddr_t src_addr\"> E<.Ft void> E<.Fn \"pmap_update\" "
"\"pmap_t pmap\"> E<.Ft void> E<.Fn \"pmap_activate\" \"struct lwp *l\"> "
"E<.Ft void> E<.Fn \"pmap_deactivate\" \"struct lwp *l\"> E<.Ft void> E<.Fn "
"\"pmap_zero_page\" \"paddr_t pa\"> E<.Ft void> E<.Fn \"pmap_copy_page\" "
"\"paddr_t src\" \"paddr_t dst\"> E<.Ft void> E<.Fn \"pmap_page_protect\" "
"\"struct vm_page *pg\" \"vm_prot_t prot\"> E<.Ft bool> E<.Fn "
"\"pmap_clear_modify\" \"struct vm_page *pg\"> E<.Ft bool> E<.Fn "
"\"pmap_clear_reference\" \"struct vm_page *pg\"> E<.Ft bool> E<.Fn "
"\"pmap_is_modified\" \"struct vm_page *pg\"> E<.Ft bool> E<.Fn "
"\"pmap_is_referenced\" \"struct vm_page *pg\"> E<.Ft paddr_t> E<.Fn "
"\"pmap_phys_address\" \"paddr_t cookie\"> E<.Ft vaddr_t> E<.Fn "
"\"PMAP_MAP_POOLPAGE\" \"paddr_t pa\"> E<.Ft paddr_t> E<.Fn "
"\"PMAP_UNMAP_POOLPAGE\" \"vaddr_t va\"> E<.Ft void> E<.Fn \"PMAP_PREFER\" "
"\"vaddr_t hint\" \"vaddr_t *vap\" \"vsize_t sz\" \"int td\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:127
msgid ""
"The E<.Nm> module is the machine-dependent portion of the E<.Nx> virtual "
"memory system E<.Xr uvm 9>.  The purpose of the E<.Nm> module is to manage "
"physical address maps, to program the memory management hardware on the "
"system, and perform any cache operations necessary to ensure correct "
"operation of the virtual memory system.  The E<.Nm> module is also "
"responsible for maintaining certain information required by E<.Xr uvm 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:154
msgid ""
"In order to cope with hardware architectures that make the invalidation of "
"virtual address mappings expensive (e.g., TLB invalidations, TLB shootdown "
"operations for multiple processors), the E<.Nm> module is allowed to delay "
"mapping invalidation or protection operations until such time as they are "
"actually necessary.  The functions that are allowed to delay such actions "
"are E<.Fn pmap_enter>, E<.Fn pmap_remove>, E<.Fn pmap_protect>, E<.Fn "
"pmap_kenter_pa>, and E<.Fn pmap_kremove>.  Callers of these functions must "
"use the E<.Fn pmap_update> function to notify the E<.Nm> module that the "
"mappings need to be made correct.  Since the E<.Nm> module is provided with "
"information as to which processors are using a given physical map, the "
"E<.Nm> module may use whatever optimizations it has available to reduce the "
"expense of virtual-to-physical mapping synchronization."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/pmap.9:154
#, no-wrap
msgid "HEADER FILES AND DATA STRUCTURES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:156
msgid "Machine-dependent code must provide the header file"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/pmap.9:156 org_netbsd/src/share/man/man9/pmap.9:751 org_netbsd/src/share/man/man9/pmap.9:966 org_netbsd/src/share/man/man9/pmap.9:1002 org_netbsd/src/share/man/man9/pmap.9:1031 org_netbsd/src/share/man/man9/pmap.9:1050 org_netbsd/src/share/man/man9/pmap.9:1076 org_netbsd/src/share/man/man9/pmap.9:1109 org_netbsd/src/share/man/man9/pmap.9:1123
#, no-wrap
msgid "machine/pmap.h ."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:160
msgid "This file contains the definition of the E<.Dv pmap> structure:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:165
#, no-wrap
msgid ""
"struct pmap {\n"
"        /* Contents defined by pmap implementation. */\n"
"};\n"
"typedef struct pmap *pmap_t;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:170
msgid ""
"This header file may also define other data structures that the E<.Nm> "
"implementation uses."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:174
msgid ""
"Note that all prototypes for E<.Nm> interface functions are provided by the "
"header file"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/pmap.9:174
#, no-wrap
msgid "uvm/uvm_pmap.h ."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:186
msgid ""
"It is possible to override this behavior by defining the C pre-processor "
"macro E<.Dv PMAP_EXCLUDE_DECLS>.  This may be used to add a layer of "
"indirection to E<.Nm> API calls, for handling different MMU types in a "
"single E<.Nm> module, for example.  If the E<.Dv PMAP_EXCLUDE_DECLS> macro "
"is defined,"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/pmap.9:186
#, no-wrap
msgid "machine/pmap.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:189
msgid "E<.Em must> provide function prototypes in a block like so:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:195
#, no-wrap
msgid ""
"#ifdef _KERNEL /* not exposed to user namespace */\n"
"__BEGIN_DECLS  /* make safe for C++ */\n"
"/* Prototypes go here. */\n"
"__END_DECLS\n"
"#endif /* _KERNEL */\n"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/pmap.9:198
#, no-wrap
msgid "uvm/uvm_pmap.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:203
msgid ""
"defines a structure for tracking E<.Nm> statistics (see below).  This "
"structure is defined as:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:208
#, no-wrap
msgid ""
"struct pmap_statistics {\n"
"        long        resident_count; /* number of mapped pages */\n"
"        long        wired_count;    /* number of wired pages */\n"
"};\n"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/pmap.9:209
#, no-wrap
msgid "WIRED MAPPINGS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:231
msgid ""
"The E<.Nm> module is based on the premise that all information contained in "
"the physical maps it manages is redundant.  That is, physical map "
"information may be E<.Dq forgotten> by the E<.Nm> module in the event that "
"it is necessary to do so; it can be rebuilt by E<.Xr uvm 9> by taking a page "
"fault.  There is one exception to this rule: so-called E<.Dq wired> mappings "
"may not be forgotten.  Wired mappings are those for which either no "
"high-level information exists with which to rebuild the mapping, or mappings "
"which are needed by critical sections of code where taking a page fault is "
"unacceptable.  Information about which mappings are wired is provided to the "
"E<.Nm> module when a mapping is established."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/pmap.9:231
#, no-wrap
msgid "MODIFIED/REFERENCED INFORMATION"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:240
msgid ""
"The E<.Nm> module is required to keep track of whether or not a page managed "
"by the virtual memory system has been referenced or modified.  This "
"information is used by E<.Xr uvm 9> to determine what happens to the page "
"when scanned by the pagedaemon."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:249
msgid ""
"Many CPUs provide hardware support for tracking modified/referenced "
"information.  However, many CPUs, particularly modern RISC CPUs, do not.  On "
"CPUs which lack hardware support for modified/referenced tracking, the "
"E<.Nm> module must emulate it in software.  There are several strategies for "
"doing this, and the best strategy depends on the CPU."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:262
msgid ""
"The E<.Dq referenced> attribute is used by the pagedaemon to determine if a "
"page is E<.Dq active>.  Active pages are not candidates for re-use in the "
"page replacement algorithm.  Accurate referenced information is not required "
"for correct operation; if supplying referenced information for a page is not "
"feasible, then the E<.Nm> implementation should always consider the E<.Dq "
"referenced> attribute to be E<.Dv false>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:272
msgid ""
"The E<.Dq modified> attribute is used by the pagedaemon to determine if a "
"page needs to be cleaned (written to backing store; swap space, a regular "
"file, etc.).  Accurate modified information E<.Em must> be provided by the "
"E<.Nm> module for correct operation of the virtual memory system."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:304
msgid ""
"Note that modified/referenced information is only tracked for pages managed "
"by the virtual memory system (i.e., pages for which a vm_page structure "
"exists).  In addition, only E<.Dq managed> mappings of those pages have "
"modified/referenced tracking.  Mappings entered with the E<.Fn pmap_enter> "
"function are E<.Dq managed> mappings.  It is possible for E<.Dq unmanaged> "
"mappings of a page to be created, using the E<.Fn pmap_kenter_pa> function.  "
"The use of E<.Dq unmanaged> mappings should be limited to code which may "
"execute in interrupt context (for example, the kernel memory allocator), or "
"to enter mappings for physical addresses which are not managed by the "
"virtual memory system.  E<.Dq Unmanaged> mappings may only be entered into "
"the kernel's virtual address space.  This constraint is placed on the "
"callers of the E<.Fn pmap_kenter_pa> and E<.Fn pmap_kremove> functions so "
"that the E<.Nm> implementation need not block interrupts when manipulating "
"data structures or holding locks."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:331
msgid ""
"Also note that the modified/referenced information must be tracked on a "
"per-page basis; they are not attributes of a mapping, but attributes of a "
"page.  Therefore, even after all mappings for a given page have been "
"removed, the modified/referenced information for that page E<.Em must> be "
"preserved.  The only time the modified/referenced attributes may be cleared "
"is when the virtual memory system explicitly calls the E<.Fn "
"pmap_clear_modify> and E<.Fn pmap_clear_reference> functions.  These "
"functions must also change any internal state necessary to detect the page "
"being modified or referenced again after the modified or referenced state is "
"cleared.  (Prior to E<.Nx 1.6>, E<.Nm> implementations could get away "
"without this because UVM (and Mach VM before that) always called E<.Fn "
"pmap_page_protect> before clearing the modified or referenced state, but UVM "
"has been changed to not do this anymore, so all E<.Nm> implementations must "
"now handle this.)"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/pmap.9:331
#, no-wrap
msgid "STATISTICS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:339
msgid ""
"The E<.Nm> is required to keep statistics as to the number of E<.Dq "
"resident> pages and the number of E<.Dq wired> pages."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:348
msgid ""
"A E<.Dq resident> page is one for which a mapping exists.  This statistic is "
"used to compute the resident size of a process and enforce resource limits.  "
"Only pages (whether managed by the virtual memory system or not)  which are "
"mapped into a physical map should be counted in the resident count."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:353
msgid ""
"A E<.Dq wired> page is one for which a wired mapping exists.  This statistic "
"is used to enforce resource limits."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:366
msgid ""
"Note that it is recommended (though not required) that the E<.Nm> "
"implementation use the E<.Dv pmap_statistics> structure in the tracking of "
"E<.Nm> statistics by placing it inside the E<.Dv pmap> structure and "
"adjusting the counts when mappings are established, changed, or removed.  "
"This avoids potentially expensive data structure traversals when the "
"statistics are queried."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/pmap.9:366
#, no-wrap
msgid "REQUIRED FUNCTIONS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:370
msgid ""
"This section describes functions that a E<.Nm> module must provide to the "
"virtual memory system."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:371
#, no-wrap
msgid "void Fn pmap_init void"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:379
msgid ""
"This function initializes the E<.Nm> module.  It is called by E<.Fn "
"uvm_init> to initialize any data structures that the module needs to manage "
"physical maps."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:379
#, no-wrap
msgid "pmap_t Fn pmap_kernel void"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:384
msgid ""
"A machine independent macro which expands to E<.Va kernel_pmap_ptr>.  This "
"variable must be exported by the platform's pmap module and it must point to "
"the kernel pmap."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:384
#, no-wrap
msgid "void Fn pmap_virtual_space \"vaddr_t *vstartp\" \"vaddr_t *vendp\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:398
msgid ""
"The E<.Fn pmap_virtual_space> function is called to determine the initial "
"kernel virtual address space beginning and end.  These values are used to "
"create the kernel's virtual memory map.  The function must set E<.Fa "
"*vstartp> to the first kernel virtual address that will be managed by E<.Xr "
"uvm 9>, and must set E<.Fa *vendp> to the last kernel virtual address that "
"will be managed by E<.Xr uvm 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:415
msgid ""
"If the E<.Fn pmap_growkernel> feature is used by a E<.Nm> implementation, "
"then E<.Fa *vendp> should be set to the maximum kernel virtual address "
"allowed by the implementation.  If E<.Fn pmap_growkernel> is not used, then "
"E<.Fa *vendp> E<.Em must> be set to the maximum kernel virtual address that "
"can be mapped with the resources currently allocated to map the kernel "
"virtual address space."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:415
#, no-wrap
msgid "pmap_t Fn pmap_create void"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:418
msgid ""
"Create a physical map and return it to the caller.  The reference count on "
"the new map is 1."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:418
#, no-wrap
msgid "void Fn pmap_destroy \"pmap_t pmap\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:426
msgid ""
"Drop the reference count on the specified physical map.  If the reference "
"count drops to 0, all resources associated with the physical map are "
"released and the physical map destroyed.  In the case of a drop-to-0, no "
"mappings will exist in the map.  The E<.Nm> implementation may assert this."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:426
#, no-wrap
msgid "void Fn pmap_reference \"pmap_t pmap\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:428
msgid "Increment the reference count on the specified physical map."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:428
#, no-wrap
msgid "long Fn pmap_resident_count \"pmap_t pmap\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:433
msgid "Query the E<.Dq resident pages> statistic for E<.Fa pmap>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:435 org_netbsd/src/share/man/man9/pmap.9:442 org_netbsd/src/share/man/man9/pmap.9:852 org_netbsd/src/share/man/man9/pmap.9:869 org_netbsd/src/share/man/man9/pmap.9:876 org_netbsd/src/share/man/man9/pmap.9:883 org_netbsd/src/share/man/man9/pmap.9:898
msgid "Note that this function may be provided as a C pre-processor macro."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:435
#, no-wrap
msgid "long Fn pmap_wired_count \"pmap_t pmap\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:440
msgid "Query the E<.Dq wired pages> statistic for E<.Fa pmap>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:442
#, no-wrap
msgid ""
"int Fn pmap_enter \"pmap_t pmap\" \"vaddr_t va\" \"paddr_t pa\" \"vm_prot_t "
"prot\" \"u_int flags\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:452
msgid ""
"Create a mapping in physical map E<.Fa pmap> for the physical address E<.Fa "
"pa> at the virtual address E<.Fa va> with protection specified by bits in "
"E<.Fa prot>:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:453 org_netbsd/src/share/man/man9/pmap.9:634
#, no-wrap
msgid "VM_PROT_READ"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:455 org_netbsd/src/share/man/man9/pmap.9:636
msgid "The mapping must allow reading."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:455 org_netbsd/src/share/man/man9/pmap.9:636
#, no-wrap
msgid "VM_PROT_WRITE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:457 org_netbsd/src/share/man/man9/pmap.9:638
msgid "The mapping must allow writing."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:457 org_netbsd/src/share/man/man9/pmap.9:638
#, no-wrap
msgid "VM_PROT_EXECUTE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:460 org_netbsd/src/share/man/man9/pmap.9:641
msgid ""
"The page mapped contains instructions that will be executed by the "
"processor."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:473
msgid ""
"The E<.Fa flags> argument contains protection bits (the same bits as used in "
"the E<.Fa prot> argument) indicating the type of access that caused the "
"mapping to be created.  This information may be used to seed "
"modified/referenced information for the page being mapped, possibly avoiding "
"redundant faults on platforms that track modified/referenced information in "
"software.  Other information provided by E<.Fa flags>:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:474
#, no-wrap
msgid "PMAP_WIRED"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:476
msgid "The mapping being created is a wired mapping."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:476
#, no-wrap
msgid "PMAP_CANFAIL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:488
msgid ""
"The call to E<.Fn pmap_enter> is allowed to fail.  If this flag is E<.Em "
"not> set, and the E<.Fn pmap_enter> call is unable to create the mapping, "
"perhaps due to insufficient resources, the E<.Nm> module must panic."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:488 org_netbsd/src/share/man/man9/pmap.9:646
#, no-wrap
msgid "PMAP_NOCACHE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:494 org_netbsd/src/share/man/man9/pmap.9:652
msgid ""
"The mapping being created is E<.Em not> cached.  Write accesses have a "
"write-through policy.  No speculative memory accesses."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:494 org_netbsd/src/share/man/man9/pmap.9:652
#, no-wrap
msgid "PMAP_WRITE_COMBINE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:500 org_netbsd/src/share/man/man9/pmap.9:658
msgid ""
"The mapping being created is E<.Em not> cached.  Writes are combined and "
"done in one burst.  Speculative read accesses may be allowed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:500 org_netbsd/src/share/man/man9/pmap.9:658
#, no-wrap
msgid "PMAP_WRITE_BACK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:504 org_netbsd/src/share/man/man9/pmap.9:662
msgid ""
"All accesses to the created mapping are cached.  On reads, cachelines become "
"shared or exclusive if allocated on cache miss.  On writes, cachelines "
"become modified on a cache miss."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:504 org_netbsd/src/share/man/man9/pmap.9:662
#, no-wrap
msgid "PMAP_NOCACHE_OVR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:506 org_netbsd/src/share/man/man9/pmap.9:664
msgid "Same as PMAP_NOCACHE but mapping is overrideable (e.g. on x86 by MTRRs)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:527
msgid ""
"The access type provided in the E<.Fa flags> argument will never exceed the "
"protection specified by E<.Fa prot>.  The E<.Nm> implementation may assert "
"this.  Note that on systems that do not provide hardware support for "
"tracking modified/referenced information, modified/referenced information "
"for the page E<.Em must> be seeded with the access type provided in E<.Fa "
"flags> if the E<.Dv PMAP_WIRED> flag is set.  This is to prevent a fault for "
"the purpose of tracking modified/referenced information from occurring while "
"the system is in a critical section where a fault would be unacceptable."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:534
msgid ""
"Note that E<.Fn pmap_enter> is sometimes called to enter a mapping at a "
"virtual address for which a mapping already exists.  In this situation, the "
"implementation must take whatever action is necessary to invalidate the "
"previous mapping before entering the new one."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:541
msgid ""
"Also note that E<.Fn pmap_enter> is sometimes called to change the "
"protection for a pre-existing mapping, or to change the E<.Dq wired> "
"attribute for a pre-existing mapping."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:546
msgid ""
"The E<.Fn pmap_enter> function returns 0 on success or an error code "
"indicating the mode of failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:546
#, no-wrap
msgid "void Fn pmap_remove \"pmap_t pmap\" \"vaddr_t sva\" \"vaddr_t eva\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:552
msgid ""
"Remove mappings from the virtual address range E<.Fa sva> to E<.Fa eva> from "
"the specified physical map."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:552
#, no-wrap
msgid "void Fn pmap_remove_all \"pmap_t pmap\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:574
msgid ""
"This function is a hint to the E<.Nm pmap> implementation that all entries "
"in E<.Fa pmap> will be removed before any more entries are entered.  "
"Following this call, there will be E<.Fn pmap_remove> calls resulting in "
"every mapping being removed, followed by either E<.Fn pmap_destroy> or E<.Fn "
"pmap_update>.  No other E<.Nm pmap> interfaces which take E<.Fa pmap> as an "
"argument will be called during this process.  Other interfaces which might "
"need to access E<.Fa pmap> (such as E<.Fn pmap_page_protect>)  are permitted "
"during this process."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:584
msgid ""
"The E<.Nm pmap> implementation is free to either remove all the E<.Nm pmap "
"Ns 's> mappings immediately in E<.Fn pmap_remove_all>, or to use the "
"knowledge of the upcoming E<.Fn pmap_remove> calls to optimize the removals "
"(or to just ignore this call)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:585
#, no-wrap
msgid ""
"void Fn pmap_protect \"pmap_t pmap\" \"vaddr_t sva\" \"vaddr_t eva\" "
"\"vm_prot_t prot\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:592
msgid ""
"Set the protection of the mappings in the virtual address range E<.Fa sva> "
"to E<.Fa eva> in the specified physical map."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:592
#, no-wrap
msgid "void Fn pmap_unwire \"pmap_t pmap\" \"vaddr_t va\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:597
msgid ""
"Clear the E<.Dq wired> attribute on the mapping for virtual address E<.Fa "
"va>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:597
#, no-wrap
msgid "bool Fn pmap_extract \"pmap_t pmap\" \"vaddr_t va\" \"paddr_t *pap\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:606
msgid ""
"This function extracts a mapping from the specified physical map.  It serves "
"two purposes: to determine if a mapping exists for the specified virtual "
"address, and to determine what physical address is mapped at the specified "
"virtual address.  The E<.Fn pmap_extract> should return the physical address "
"for any kernel-accessible address, including KSEG-style direct-mapped kernel "
"addresses."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:623
msgid ""
"The E<.Fn pmap_extract> function returns E<.Dv false> if a mapping for E<.Fa "
"va> does not exist.  Otherwise, it returns E<.Dv true> and places the "
"physical address mapped at E<.Fa va> into E<.Fa *pap> if the E<.Fa pap> "
"argument is non-NULL."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:623
#, no-wrap
msgid ""
"void Fn pmap_kenter_pa \"vaddr_t va\" \"paddr_t pa\" \"vm_prot_t prot\" "
"\"u_int flags\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:633
msgid ""
"Enter an E<.Dq unmanaged> mapping for physical address E<.Fa pa> at virtual "
"address E<.Fa va> with protection specified by bits in E<.Fa prot>:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:645
msgid "Information provided by E<.Fa flags>:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:688
msgid ""
"Mappings of this type are always E<.Dq wired>, and are unaffected by "
"routines that alter the protection of pages (such as E<.Fn "
"pmap_page_protect>).  Such mappings are also not included in the gathering "
"of modified/referenced information about a page.  Mappings entered with "
"E<.Fn pmap_kenter_pa> by machine-independent code E<.Em must not> have "
"execute permission, as the data structures required to track execute "
"permission of a page may not be available to E<.Fn pmap_kenter_pa>.  "
"Machine-independent code is not allowed to enter a mapping with E<.Fn "
"pmap_kenter_pa> at a virtual address for which a valid mapping already "
"exists.  Mappings created with E<.Fn pmap_kenter_pa> may be removed only "
"with a call to E<.Fn pmap_kremove>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:696
msgid ""
"Note that E<.Fn pmap_kenter_pa> must be safe for use in interrupt context.  "
"E<.Fn splvm> blocks interrupts that might cause E<.Fn pmap_kenter_pa> to be "
"called."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:696
#, no-wrap
msgid "void Fn pmap_kremove \"vaddr_t va\" \"vsize_t size\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:707
msgid ""
"Remove all mappings starting at virtual address E<.Fa va> for E<.Fa size> "
"bytes from the kernel physical map.  All mappings that are removed must be "
"the E<.Dq unmanaged> type created with E<.Fn pmap_kenter_pa>.  The "
"implementation may assert this."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:707
#, no-wrap
msgid ""
"void Fn pmap_copy \"pmap_t dst_map\" \"pmap_t src_map\" \"vaddr_t dst_addr\" "
"\"vsize_t len\" \"vaddr_t src_addr\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:719
msgid ""
"This function copies the mappings starting at E<.Fa src_addr> in E<.Fa "
"src_map> for E<.Fa len> bytes into E<.Fa dst_map> starting at E<.Fa "
"dst_addr>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:729
msgid ""
"Note that while this function is required to be provided by a E<.Nm> "
"implementation, it is not actually required to do anything.  E<.Fn "
"pmap_copy> is merely advisory (it is used in the E<.Xr fork 2> path to E<.Dq "
"pre-fault> the child's address space)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:729
#, no-wrap
msgid "void Fn pmap_update \"pmap_t pmap\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:744
msgid ""
"This function is used to inform the E<.Nm> module that all physical "
"mappings, for the specified pmap, must now be correct.  That is, all delayed "
"virtual-to-physical mappings updates (such as TLB invalidation or address "
"space identifier updates) must be completed.  This routine must be used "
"after calls to E<.Fn pmap_enter>, E<.Fn pmap_remove>, E<.Fn pmap_protect>, "
"E<.Fn pmap_kenter_pa>, and E<.Fn pmap_kremove> in order to ensure correct "
"operation of the virtual memory system."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:751
msgid ""
"If a E<.Nm> implementation does not delay virtual-to-physical mapping "
"updates, E<.Fn pmap_update> has no operation.  In this case, the call may be "
"deleted using a C pre-processor macro in"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:752
#, no-wrap
msgid "void Fn pmap_activate \"struct lwp *l\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:767
msgid ""
"Activate the physical map used by the process behind lwp E<.Fa l>.  This is "
"called by the virtual memory system when the virtual memory context for a "
"process is changed, and is also often used by machine-dependent context "
"switch code to program the memory management hardware with the process's "
"page table base, etc.  Note that E<.Fn pmap_activate> may not always be "
"called when E<.Fa l> is the current lwp.  E<.Fn pmap_activate> must be able "
"to handle this scenario."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:767
#, no-wrap
msgid "void Fn pmap_deactivate \"struct lwp *l\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:778
msgid ""
"Deactivate the physical map used by the process behind lwp E<.Fa l>.  It is "
"generally used in conjunction with E<.Fn pmap_activate>.  Like E<.Fn "
"pmap_activate>, E<.Fn pmap_deactivate> may not always be called when E<.Fa "
"l> is the current lwp."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:778
#, no-wrap
msgid "void Fn pmap_zero_page \"paddr_t pa\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:789
msgid ""
"Zero the PAGE_SIZE sized region starting at physical address E<.Fa pa>.  The "
"E<.Nm> implementation must take whatever steps are necessary to map the page "
"to a kernel-accessible address and zero the page.  It is suggested that "
"implementations use an optimized zeroing algorithm, as the performance of "
"this function directly impacts page fault performance.  The implementation "
"may assume that the region is PAGE_SIZE aligned and exactly PAGE_SIZE bytes "
"in length."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:803
msgid ""
"Note that the cache configuration of the platform should also be considered "
"in the implementation of E<.Fn pmap_zero_page>.  For example, on systems "
"with a physically-addressed cache, the cache load caused by zeroing the page "
"will not be wasted, as the zeroing is usually done on-demand.  However, on "
"systems with a virtually-addressed cached, the cache load caused by zeroing "
"the page E<.Em will> be wasted, as the page will be mapped at a virtual "
"address which is different from that used to zero the page.  In the "
"virtually-addressed cache case, care should also be taken to avoid cache "
"alias problems."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:803
#, no-wrap
msgid "void Fn pmap_copy_page \"paddr_t src\" \"paddr_t dst\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:817
msgid ""
"Copy the PAGE_SIZE sized region starting at physical address E<.Fa src> to "
"the same sized region starting at physical address E<.Fa dst>.  The E<.Nm> "
"implementation must take whatever steps are necessary to map the source and "
"destination pages to a kernel-accessible address and perform the copy.  It "
"is suggested that implementations use an optimized copy algorithm, as the "
"performance of this function directly impacts page fault performance.  The "
"implementation may assume that both regions are PAGE_SIZE aligned and "
"exactly PAGE_SIZE bytes in length."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:822
msgid ""
"The same cache considerations that apply to E<.Fn pmap_zero_page> apply to "
"E<.Fn pmap_copy_page>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:822
#, no-wrap
msgid "void Fn pmap_page_protect \"struct vm_page *pg\" \"vm_prot_t prot\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:835
msgid ""
"Lower the permissions for all mappings of the page E<.Fa pg> to E<.Fa "
"prot>.  This function is used by the virtual memory system to implement "
"copy-on-write (called with VM_PROT_READ set in E<.Fa prot>)  and to revoke "
"all mappings when cleaning a page (called with no bits set in E<.Fa prot>).  "
"Access permissions must never be added to a page as a result of this call."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:835
#, no-wrap
msgid "bool Fn pmap_clear_modify \"struct vm_page *pg\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:840
msgid "Clear the E<.Dq modified> attribute on the page E<.Fa pg>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:850
msgid ""
"The E<.Fn pmap_clear_modify> function returns E<.Dv true> or E<.Dv false> "
"indicating whether or not the E<.Dq modified> attribute was set on the page "
"before it was cleared."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:852
#, no-wrap
msgid "bool Fn pmap_clear_reference \"struct vm_page *pg\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:857
msgid "Clear the E<.Dq referenced> attribute on the page E<.Fa pg>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:867
msgid ""
"The E<.Fn pmap_clear_reference> function returns E<.Dv true> or E<.Dv false> "
"indicating whether or not the E<.Dq referenced> attribute was set on the "
"page before it was cleared."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:869
#, no-wrap
msgid "bool Fn pmap_is_modified \"struct vm_page *pg\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:874
msgid "Test whether or not the E<.Dq modified> attribute is set on page E<.Fa pg>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:876
#, no-wrap
msgid "bool Fn pmap_is_referenced \"struct vm_page *pg\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:881
msgid ""
"Test whether or not the E<.Dq referenced> attribute is set on page E<.Fa "
"pg>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:883
#, no-wrap
msgid "paddr_t Fn pmap_phys_address \"paddr_t cookie\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:896
msgid ""
"Convert a cookie returned by a device E<.Fn mmap> function into a physical "
"address.  This function is provided to accommodate systems which have "
"physical address spaces larger than can be directly addressed by the "
"platform's E<.Fa paddr_t> type.  The existence of this function is highly "
"dubious, and it is expected that this function will be removed from the "
"E<.Nm pmap> API in a future release of E<.Nx>."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/pmap.9:899
#, no-wrap
msgid "OPTIONAL FUNCTIONS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:903
msgid "This section describes several optional functions in the E<.Nm> API."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:904
#, no-wrap
msgid ""
"vaddr_t Fn pmap_steal_memory \"vsize_t size\" \"vaddr_t *vstartp\" \"vaddr_t "
"*vendp\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:926
msgid ""
"This function is a bootstrap memory allocator, which may be provided as an "
"alternative to the bootstrap memory allocator used within E<.Xr uvm 9> "
"itself.  It is particularly useful on systems which provide for example a "
"direct-mapped memory segment.  This function works by stealing pages from "
"the (to be) managed memory pool, which has already been provided to E<.Xr "
"uvm 9> in the vm_physmem[] array.  The pages are then mapped, or otherwise "
"made accessible to the kernel, in a machine-dependent way.  The memory must "
"be zeroed by E<.Fn pmap_steal_memory>.  Note that memory allocated with "
"E<.Fn pmap_steal_memory> will never be freed, and mappings made by E<.Fn "
"pmap_steal_memory> must never be E<.Dq forgotten>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:940
msgid ""
"Note that E<.Fn pmap_steal_memory> should not be used as a general-purpose "
"early-startup memory allocation routine.  It is intended to be used only by "
"the E<.Fn uvm_pageboot_alloc> routine and its supporting routines.  If you "
"need to allocate memory before the virtual memory system is initialized, use "
"E<.Fn uvm_pageboot_alloc>.  See E<.Xr uvm 9> for more information."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:946
msgid ""
"The E<.Fn pmap_steal_memory> function returns the kernel-accessible address "
"of the allocated memory.  If no memory can be allocated, or if allocated "
"memory cannot be mapped, the function must panic."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:960
msgid ""
"If the E<.Fn pmap_steal_memory> function uses address space from the range "
"provided to E<.Xr uvm 9> by the E<.Fn pmap_virtual_space> call, then E<.Fn "
"pmap_steal_memory> must adjust E<.Fa *vstartp> and E<.Fa *vendp> upon "
"return."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:966
msgid ""
"The E<.Fn pmap_steal_memory> function is enabled by defining the C "
"pre-processor macro E<.Dv PMAP_STEAL_MEMORY> in"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:967
#, no-wrap
msgid "vaddr_t Fn pmap_growkernel \"vaddr_t maxkvaddr\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:973
msgid ""
"Management of the kernel virtual address space is complicated by the fact "
"that it is not always safe to wait for resources with which to map a kernel "
"virtual address.  However, it is not always desirable to pre-allocate all "
"resources necessary to map the entire kernel virtual address space."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:988
msgid ""
"The E<.Fn pmap_growkernel> interface is designed to help alleviate this "
"problem.  The virtual memory startup code may choose to allocate an initial "
"set of mapping resources (e.g., page tables) and set an internal variable "
"indicating how much kernel virtual address space can be mapped using those "
"initial resources.  Then, when the virtual memory system wishes to map "
"something at an address beyond that initial limit, it calls E<.Fn "
"pmap_growkernel> to pre-allocate more sources with which to create the "
"mapping.  Note that once additional kernel virtual address space mapping "
"resources have been allocated, they should not be freed; it is likely they "
"will be needed again."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:996
msgid ""
"The E<.Fn pmap_growkernel> function returns the new maximum kernel virtual "
"address that can be mapped with the resources it has available.  If new "
"resources cannot be allocated, E<.Fn pmap_growkernel> must panic."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1002
msgid ""
"The E<.Fn pmap_growkernel> function is enabled by defining the C "
"pre-processor macro E<.Dv PMAP_GROWKERNEL> in"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:1003
#, no-wrap
msgid "void Fn pmap_fork \"pmap_t src_map\" \"pmap_t dst_map\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1012
msgid ""
"Some E<.Nm> implementations may need to keep track of other information not "
"directly related to the virtual address space.  For example, on the i386 "
"port, the Local Descriptor Table state of a process is associated with the "
"pmap (this is due to the fact that applications manipulate the Local "
"Descriptor Table directly expect it to be logically associated with the "
"virtual memory state of the process)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1025
msgid ""
"The E<.Fn pmap_fork> function is provided as a way to associate information "
"from E<.Fa src_map> with E<.Fa dst_map> when a E<.Dv vmspace> is forked.  "
"E<.Fn pmap_fork> is called from E<.Fn uvmspace_fork>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1031
msgid ""
"The E<.Fn pmap_fork> function is enabled by defining the C pre-processor "
"macro E<.Dv PMAP_FORK> in"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:1032
#, no-wrap
msgid "vaddr_t Fn PMAP_MAP_POOLPAGE \"paddr_t pa\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1042
msgid ""
"This function is used by the E<.Xr pool 9> memory pool manager.  Pools "
"allocate backing pages one at a time.  This is provided as a means to use "
"hardware features such as a direct-mapped memory segment to map the pages "
"used by the E<.Xr pool 9> allocator.  This can lead to better performance by "
"e.g. reducing TLB contention."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1046
msgid ""
"E<.Fn PMAP_MAP_POOLPAGE> returns the kernel-accessible address of the page "
"being mapped.  It must always succeed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1050
msgid ""
"The use of E<.Fn PMAP_MAP_POOLPAGE> is enabled by defining it as a C "
"pre-processor macro in"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1056
msgid ""
"If E<.Fn PMAP_MAP_POOLPAGE> is defined, E<.Fn PMAP_UNMAP_POOLPAGE> must also "
"be defined."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1059
msgid "The following is an example of how to define E<.Fn PMAP_MAP_POOLPAGE>:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1061
#, no-wrap
msgid "#define PMAP_MAP_POOLPAGE(pa)   MIPS_PHYS_TO_KSEG0((pa))\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1065
msgid ""
"This takes the physical address of a page and returns the KSEG0 address of "
"that page on a MIPS processor."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:1065
#, no-wrap
msgid "paddr_t Fn PMAP_UNMAP_POOLPAGE \"vaddr_t va\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1068
msgid "This function is the inverse of E<.Fn PMAP_MAP_POOLPAGE>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1072
msgid ""
"E<.Fn PMAP_UNMAP_POOLPAGE> returns the physical address of the page "
"corresponding to the provided kernel-accessible address."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1076
msgid ""
"The use of E<.Fn PMAP_UNMAP_POOLPAGE> is enabled by defining it as a C "
"pre-processor macro in"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1082
msgid ""
"If E<.Fn PMAP_UNMAP_POOLPAGE> is defined, E<.Fn PMAP_MAP_POOLPAGE> must also "
"be defined."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1085
msgid "The following is an example of how to define E<.Fn PMAP_UNMAP_POOLPAGE>:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1087
#, no-wrap
msgid "#define PMAP_UNMAP_POOLPAGE(pa) MIPS_KSEG0_TO_PHYS((va))\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1091
msgid ""
"This takes the KSEG0 address of a previously-mapped pool page and returns "
"the physical address of that page on a MIPS processor."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:1091
#, no-wrap
msgid ""
"void Fn PMAP_PREFER \"vaddr_t hint\" \"vaddr_t *vap\" \"vsize_t sz\" \"int "
"td\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1105
msgid ""
"This function is used by E<.Xr uvm_map 9> to adjust a virtual address being "
"allocated in order to avoid cache alias problems.  If necessary, the virtual "
"address pointed by E<.Fa vap> will be advanced.  E<.Fa hint> is an object "
"offset which will be mapped into the resulting virtual address, and E<.Fa "
"sz> is size of the object.  E<.Fa td> indicates if the machine dependent "
"pmap uses the topdown VM."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1109
msgid ""
"The use of E<.Fn PMAP_PREFER> is enabled by defining it as a C pre-processor "
"macro in"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmap.9:1111
#, no-wrap
msgid "void Fn pmap_procwr \"struct proc *p\" \"vaddr_t va\" \"vsize_t size\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1117
msgid ""
"Synchronize CPU instruction caches of the specified range.  The address "
"space is designated by E<.Fa p>.  This function is typically used to flush "
"instruction caches after code modification."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1123
msgid ""
"The use of E<.Fn pmap_procwr> is enabled by defining a C pre-processor macro "
"E<.Dv PMAP_NEED_PROCWR> in"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1127
msgid "E<.Xr uvm 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1137
msgid ""
"The E<.Nm> module was originally part of the design of the virtual memory "
"system in the Mach Operating System.  The goal was to provide a clean "
"separation between the machine-independent and the machine-dependent "
"portions of the virtual memory system, in stark contrast to the original "
"E<.Bx 3> virtual memory system, which was specific to the VAX."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1149
msgid ""
"Between E<.Bx 4.3> and E<.Bx 4.4>, the Mach virtual memory system, including "
"the E<.Nm> API, was ported to E<.Bx> and included in the E<.Bx 4.4> release."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1167
msgid ""
"E<.Nx> inherited the E<.Bx> version of the Mach virtual memory system.  "
"E<.Nx 1.4> was the first E<.Nx> release with the new E<.Xr uvm 9> virtual "
"memory system, which included several changes to the E<.Nm> API.  Since the "
"introduction of E<.Xr uvm 9>, the E<.Nm> API has evolved further."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1174
msgid ""
"The original Mach VAX E<.Nm> module was written by E<.An Avadis Tevanian, "
"Jr.> and E<.An Michael Wayne Young>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1181
msgid ""
"E<.An Mike Hibler> did the integration of the Mach virtual memory system "
"into E<.Bx 4.4> and implemented a E<.Nm> module for the Motorola "
"68020+68851/68030/68040."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1196
msgid ""
"The E<.Nm> API as it exists in E<.Nx> is derived from E<.Bx 4.4>, and has "
"been modified by E<.An Chuck Cranor>, E<.An Charles M. Hannum>, E<.An Chuck "
"Silvers>, E<.An Wolfgang Solfrank>, E<.An Bill Sommerfeld>, and E<.An Jason "
"R. Thorpe>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1200
msgid ""
"The author of this document is E<.An Jason R. Thorpe> E<.Aq "
"thorpej@NetBSD.org>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1206
msgid ""
"The use and definition of E<.Fn pmap_activate> and E<.Fn pmap_deactivate> "
"needs to be reexamined."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmap.9:1222
msgid ""
"The use of E<.Fn pmap_copy> needs to be reexamined.  Empirical evidence "
"suggests that performance of the system suffers when E<.Fn pmap_copy> "
"actually performs its defined function.  This is largely due to the fact "
"that the copy of the virtual-to-physical mappings is wasted if the process "
"calls E<.Xr execve 2> after E<.Xr fork 2>.  For this reason, it is "
"recommended that E<.Nm> implementations leave the body of the E<.Fn "
"pmap_copy> function empty for now."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/pmatch.9:26
#, no-wrap
msgid "October 12, 2003"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/pmatch.9:27
#, no-wrap
msgid "PMATCH 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmatch.9:31
msgid "E<.Nm pmatch>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/pmatch.9:31
#, no-wrap
msgid "performs pattern matching on strings"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmatch.9:36
msgid ""
"E<.Ft int> E<.Fn pmatch \"const char *string\" \"const char *pattern\" "
"\"const char **estr\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmatch.9:45
msgid ""
"Extract substring matching E<.Fa pattern> from E<.Fa string>.  If not E<.Dv "
"NULL>, E<.Fa estr> points to the end of the longest exact or substring "
"match."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmatch.9:48
msgid "E<.Fn pmatch> uses the following metacharacters:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmatch.9:49
#, no-wrap
msgid "Li \\&?"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmatch.9:51
msgid "match any single character."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmatch.9:51
#, no-wrap
msgid "Li *"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmatch.9:53
msgid "match any character 0 or more times."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmatch.9:53
#, no-wrap
msgid "Li \\&["
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmatch.9:64
msgid ""
"define a range of characters that will match.  The range is defined by 2 "
"characters separated by a E<.Sq Li \\&->.  The range definition has to end "
"with a E<.Sq Li \\&]>.  A E<.Sq Li ^> following the E<.Sq Li \\&[> will "
"negate the range."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmatch.9:68
msgid ""
"E<.Fn pmatch> will return 2 for an exact match, 1 for a substring match, 0 "
"for no match and \\-1 if an error occurs."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/pmc.9:36
#, no-wrap
msgid "May 14, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/pmc.9:37
#, no-wrap
msgid "PMC 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:57
msgid ""
"E<.Nm pmc>, E<.Nm pmc_get_num_counters>, E<.Nm pmc_get_counter_type>, E<.Nm "
"pmc_save_context>, E<.Nm pmc_restore_context>, E<.Nm pmc_enable_counter>, "
"E<.Nm pmc_disable_counter>, E<.Nm pmc_counter_isrunning>, E<.Nm "
"pmc_counter_isconfigured>, E<.Nm pmc_configure_counter>, E<.Nm "
"pmc_get_counter_value>, E<.Nm pmc_accumulate>, E<.Nm "
"pmc_alloc_kernel_counter>, E<.Nm pmc_free_kernel_counter>, E<.Nm "
"pmc_start_profiling>, E<.Nm pmc_stop_profiling>, E<.Nm PMC_ENABLED>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/pmc.9:57
#, no-wrap
msgid "Hardware Performance Monitoring Interface"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/pmc.9:59
#, no-wrap
msgid "sys/pmc.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:94
msgid ""
"E<.Ft int> E<.Fn pmc_get_num_counters \"void\"> E<.Ft int> E<.Fn "
"pmc_get_counter_type \"int ctr\"> E<.Ft void> E<.Fn pmc_save_context "
"\"struct lwp *l\"> E<.Ft void> E<.Fn pmc_restore_context \"struct lwp *l\"> "
"E<.Ft int> E<.Fn pmc_enable_counter \"struct lwp *l\" \"int ctr\"> E<.Ft "
"int> E<.Fn pmc_disable_counter \"struct lwp *l\" \"int ctr\"> E<.Ft int> "
"E<.Fn pmc_counter_isrunning \"struct lwp *l\" \"int ctr\"> E<.Ft int> E<.Fn "
"pmc_counter_isconfigured \"struct lwp *l\" \"int ctr\"> E<.Ft int> E<.Fn "
"pmc_configure_counter \"struct lwp *l\" \"int ctr\" \"struct pmc_counter_cfg "
"*cfg\"> E<.Ft int> E<.Fn pmc_get_counter_value \"struct lwp *l\" \"int ctr\" "
"\"int flags\" \"uint64_t *pval\"> E<.Ft int> E<.Fn pmc_accumulate \"struct "
"lwp *l_parent\" \"struct lwp *l_exiting\"> E<.Ft int> E<.Fn "
"pmc_alloc_kernel_counter \"int ctr\" \"struct pmc_counter_cfg *cfg\"> E<.Ft "
"int> E<.Fn pmc_free_kernel_counter \"int ctr\"> E<.Ft int> E<.Fn "
"pmc_start_profiling \"int ctr\" \"struct pmc_counter_cfg *cfg\"> E<.Ft int> "
"E<.Fn pmc_stop_profiling \"int ctr\"> E<.Ft int> E<.Fn PMC_ENABLED \"struct "
"lwp *l\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:102
msgid ""
"Provides a machine-independent interface to the hardware performance "
"counters which are available on several CPU families.  The capabilities of "
"these counters vary from CPU to CPU, but they basically count hardware "
"events such as data cache hits or misses, branches taken, branched "
"mispredicted, and so forth.  Some can interrupt the processor when a certain "
"threshold has been reached.  Some can count events in user space and kernel "
"space independently."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:109
msgid ""
"The E<.Nm> interface is intended to allow monitoring from within the kernel "
"as well as monitoring of userland applications.  If the hardware can "
"interrupt the CPU in a specific implementation, then it may also be used as "
"a profiling source instead of the clock."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:115
msgid ""
"All function calls in this interface may be defined as E<.Xr cpp 1> macros.  "
"If any function is not implemented as a macro, its prototype must be defined "
"by the port-specific header"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/pmc.9:115
#, no-wrap
msgid "machine/pmc.h ."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:125
msgid ""
"Counters are numbered from 0 to E<.Dv N\\-1> where E<.Dv N> is the number of "
"counters available on the system (see E<.Fn pmc_get_num_counters> below)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:127
msgid "Upon a process fork, implementations must"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:130
msgid "Zero performance counters for the new process, and"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:132
msgid "Inherit any enabled performance counters."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:135
msgid "Each implementation must specify two new types:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmc.9:136
#, no-wrap
msgid "Fa pmc_evid_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:138
msgid "An integer type which can contain the event IDs for a given processor."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmc.9:138
#, no-wrap
msgid "Fa pmc_ctr_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:141
msgid ""
"An integer type defining the value which may be contained in a given counter "
"register."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:146
msgid ""
"Counters are configured with the E<.Fa struct pmc_counter_cfg>.  This "
"structure is defined as"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:152
#, no-wrap
msgid ""
"struct pmc_counter_cfg {\n"
"\tpmc_evid_t\tevent_id;\n"
"\tpmc_ctr_t\treset_value;\n"
"\tuint32_t\tflags;\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:156
msgid "E<.Fa flags> are currently unused."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmc.9:158
#, no-wrap
msgid "Fn pmc_get_num_counters void"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:164
msgid ""
"Returns the number of counters present on the current system.  Valid values "
"for E<.Fa ctr> in the interface entry points below are from zero to one less "
"than the return value from this function."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmc.9:164
#, no-wrap
msgid "Fn pmc_get_counter_type \"int ctr\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:172
msgid ""
"Returns an implementation-dependent type describing the specified counter.  "
"If E<.Fa ctr> is specified as \\-1, returns a machine-dependent type "
"describing the CPU or counter configuration.  For example, on an ia32 "
"architecture, it may distinguish between 586-, 686-, and K7-style counters."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmc.9:172
#, no-wrap
msgid "Fn pmc_save_context \"struct lwp *l\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:177
msgid ""
"Saves the PMC context for the current process.  This is called just before "
"E<.Xr cpu_switch 9>.  If there is kernel PMC state, it must be maintained "
"across this call."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmc.9:177
#, no-wrap
msgid "Fn pmc_restore_context \"struct lwp *l\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:183
msgid ""
"Restores the PMC context for the current process.  This is called just after "
"E<.Xr cpu_switch 9> returns.  If there is kernel PMC state, it must be "
"maintained across this call."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmc.9:183
#, no-wrap
msgid "Fn pmc_enable_counter \"struct lwp *l\" \"int ctr\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:191
msgid ""
"Enables counter E<.Fa ctr> for the specified process.  The counter should "
"have already been configured with a call to E<.Fn pmc_configure_counter>.  "
"This starts the counter running if it is not already started and enables any "
"interrupts, as appropriate."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmc.9:191
#, no-wrap
msgid "Fn pmc_disable_counter \"struct lwp *l\" \"int ctr\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:197
msgid ""
"Disables counter E<.Fa ctr> for the specified process.  This stops the "
"counter from running, and disables any interrupts, as appropriate."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmc.9:197
#, no-wrap
msgid "Fn pmc_counter_isrunning \"struct lwp *l\" \"int ctr\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:200
msgid ""
"Returns non-zero if the specified counter in the specified process is "
"running or if the counter is running in the kernel."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmc.9:200
#, no-wrap
msgid "Fn pmc_counter_isconfigured \"struct lwp *l\" \"int ctr\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:203
msgid ""
"Returns non-zero if the specified counter in the specified process is "
"configured or if the counter is in use by the kernel."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmc.9:203
#, no-wrap
msgid ""
"Fn pmc_configure_counter \"struct lwp *l\" \"int ctr\" \"struct "
"pmc_counter_cfg *cfg\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:209
msgid ""
"Configures counter E<.Fa ctr> according to the configuration information "
"stored in E<.Fa cfg>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmc.9:209
#, no-wrap
msgid ""
"Fn pmc_get_counter_value \"struct lwp *l\" \"int ctr\" \"int flags\" "
"\"uint64_t *pval\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:219
msgid ""
"Returns the value of counter E<.Fa ctr> in the space pointed to by E<.Fa "
"pval>.  The only recognized flag is E<.Fa PMC_VALUE_FLAGS_CHILDREN> which "
"specifies that the returned counts should be accumulated values for any "
"exited child processes."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmc.9:219
#, no-wrap
msgid "Fn pmc_accumulate \"struct lwp *l_parent\" \"struct lwp *l_exiting\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:224
msgid ""
"Accumulates any counter data from the exiting process E<.Fa p_exiting> into "
"the counters for the parent process E<.Fa p_parent>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmc.9:224
#, no-wrap
msgid "Fn pmc_alloc_kernel_counter \"int ctr\" \"struct pmc_counter_cfg *cfg\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:229
msgid ""
"Allocates counter E<.Fa ctr> for use by the kernel and configures it with "
"E<.Fa cfg>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmc.9:229
#, no-wrap
msgid "Fn pmc_free_kernel_counter \"int ctr\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:233
msgid ""
"Returns counter E<.Fa ctr> to the available pool of counters that may be "
"used by processes."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmc.9:233
#, no-wrap
msgid "Fn pmc_start_profiling \"int ctr\" \"struct pmc_counter_cfg *cfg\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:238
msgid ""
"Allocates counter E<.Fa ctr> for use by the kernel for profiling and "
"configures it with E<.Fa cfg>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmc.9:238
#, no-wrap
msgid "Fn pmc_stop_profiling \"int ctr\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:241
msgid "Stops profiling with counter E<.Fa ctr>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmc.9:241
#, no-wrap
msgid "Fn PMC_ENABLED \"struct lwp *l\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:243
msgid "Returns non-zero if the given process or the kernel is using the PMC at all."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:248
msgid "E<.Xr pmc 1>, E<.Xr pmc_control 2>, E<.Xr pmc_get_info 2>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:253
msgid "The E<.Nm> interface appeared in E<.Nx 2.0>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmc.9:259
msgid ""
"The E<.Nm> interface was designed and implemented by Allen Briggs for Wasabi "
"Systems, Inc.  Additional input on the E<.Nm> design was provided by Jason "
"R. Thorpe."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/pmf.9:27
#, no-wrap
msgid "February 25, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/pmf.9:28
#, no-wrap
msgid "PMF 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:51
msgid ""
"E<.Nm PMF>, E<.Nm pmf_device_register>, E<.Nm pmf_device_register1>, E<.Nm "
"pmf_device_deregister>, E<.Nm pmf_device_suspend>, E<.Nm pmf_device_resume>, "
"E<.Nm pmf_device_recursive_suspend>, E<.Nm pmf_device_recursive_resume>, "
"E<.Nm pmf_device_resume_subtree>, E<.Nm pmf_class_network_register>, E<.Nm "
"pmf_class_input_register>, E<.Nm pmf_class_display_register>, E<.Nm "
"pmf_system_suspend>, E<.Nm pmf_system_resume>, E<.Nm pmf_system_shutdown>, "
"E<.Nm pmf_event_register>, E<.Nm pmf_event_deregister>, E<.Nm "
"pmf_event_inject>, E<.Nm pmf_set_platform>, E<.Nm pmf_get_platform>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/pmf.9:51
#, no-wrap
msgid "power management and inter-driver messaging framework"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:92
msgid ""
"E<.Ft bool> E<.Fn pmf_device_register \"device_t dev\" \"bool "
"(*suspend)(device_t dev, const pmf_qual_t *qual)\" \"bool (*resume)(device_t "
"dev, const pmf_qual_t *qual)\"> E<.Ft bool> E<.Fn pmf_device_register1 "
"\"device_t dev\" \"bool (*suspend)(device_t dev, const pmf_qual_t *qual)\" "
"\"bool (*resume)(device_t dev, const pmf_qual_t *qual)\" \"bool "
"(*shutdown)(device_t dev, int how)\"> E<.Ft void> E<.Fn "
"pmf_device_deregister \"device_t dev\"> E<.Ft bool> E<.Fn pmf_device_suspend "
"\"device_t dev\" \"const pmf_qual_t *qual\"> E<.Ft bool> E<.Fn "
"pmf_device_resume \"device_t dev\" \"const pmf_qual_t *qual\"> E<.Ft bool> "
"E<.Fn pmf_device_recursive_suspend \"device_t dev\" \"const pmf_qual_t "
"*qual\"> E<.Ft bool> E<.Fn pmf_device_recursive_resume \"device_t dev\" "
"\"const pmf_qual_t *qual\"> E<.Ft bool> E<.Fn pmf_device_subtree_resume "
"\"device_t dev\" \"const pmf_qual_t *qual\"> E<.Ft void> E<.Fn "
"pmf_class_network_register \"device_t dev\" \"struct ifnet *ifp\"> E<.Ft "
"bool> E<.Fn pmf_class_input_register \"device_t dev\"> E<.Ft bool> E<.Fn "
"pmf_class_display_register \"device_t dev\"> E<.Ft bool> E<.Fn "
"pmf_system_suspend \"const pmf_qual_t *qual\"> E<.Ft bool> E<.Fn "
"pmf_system_resume \"const pmf_qual_t *qual\"> E<.Ft void> E<.Fn "
"pmf_system_shutdown \"int\"> E<.Ft bool> E<.Fn pmf_event_register \"device_t "
"dev\" \"pmf_generic_event_t ev\" \"void (*handler)(device_t dev)\" \"bool "
"global\"> E<.Ft void> E<.Fn pmf_event_deregister \"device_t dev\" "
"\"pmf_generic_event_t ev\" \"void (*handler)(device_t dev)\" \"bool "
"global\"> E<.Ft bool> E<.Fn pmf_event_inject \"device_t dev\" "
"\"pmf_generic_event_t ev\"> E<.Ft bool> E<.Fn pmf_set_platform \"const char "
"*key\" \"const char *value\"> E<.Ft const char *> E<.Fn pmf_get_platform "
"\"const char *key\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:97
msgid ""
"The machine-independent E<.Nm> framework provides power management and "
"inter-driver messaging support for device drivers."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:101
msgid ""
"Drivers for devices implementing E<.Nm> may make use of the following data "
"type:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmf.9:102
#, no-wrap
msgid "Fa pmf_qual_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:106
msgid "An opaque aggregate of qualifications on a E<.Nm> suspend or resume call."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmf.9:106
#, no-wrap
msgid "Fa pmf_generic_event_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:110
msgid ""
"A device driver can register as a listener for specific events, or inject "
"events into the message queue.  The following message types are defined:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:113
msgid "E<.Dv PMFE_DISPLAY_ON>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:115
msgid "E<.Dv PMFE_DISPLAY_REDUCED>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:117
msgid "E<.Dv PMFE_DISPLAY_STANDBY>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:119
msgid "E<.Dv PMFE_DISPLAY_SUSPEND>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:121
msgid "E<.Dv PMFE_DISPLAY_OFF>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:123
msgid "E<.Dv PMFE_DISPLAY_BRIGHTNESS_UP>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:125
msgid "E<.Dv PMFE_DISPLAY_BRIGHTNESS_DOWN>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:127
msgid "E<.Dv PMFE_AUDIO_VOLUME_UP>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:129
msgid "E<.Dv PMFE_AUDIO_VOLUME_DOWN>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:131
msgid "E<.Dv PMFE_AUDIO_VOLUME_TOGGLE>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:133
msgid "E<.Dv PMFE_CHASSIS_LID_CLOSE>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:135
msgid "E<.Dv PMFE_CHASSIS_LID_OPEN>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmf.9:139
#, no-wrap
msgid "Fn pmf_device_register dev suspend resume"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:165
msgid ""
"Register a device with the power management framework.  E<.Fa suspend> and "
"E<.Fa resume> are passed E<.Fa dev> and a E<.Fa pmf_qual_t>; they return "
"E<.Dv true> on success and E<.Dv false> on failure.  If either E<.Fa "
"suspend> or E<.Fa resume> is E<.Dv NULL> then it is assumed that device "
"state does not need to be captured and resumed on a power transition.  Bus "
"and class-level power management will still be performed.  Returns E<.Dv "
"false> if there was an error."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmf.9:165
#, no-wrap
msgid "Fn pmf_device_register1 dev suspend resume shutdown"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:185
msgid ""
"Like E<.Fn pmf_device_register>, but additionally registers a shutdown "
"handler.  During system shutdown, E<.Fn pmf_system_shutdown> calls E<.Fa "
"shutdown> on E<.Fa dev> with the E<.Xr reboot 2> E<.Dq howto> in the second "
"argument.  E<.Fa shutdown> should return E<.Dv true> on success and E<.Dv "
"false> on failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmf.9:185
#, no-wrap
msgid "Fn pmf_device_deregister dev"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:187
msgid "Deregister a device with the power management framework."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmf.9:187
#, no-wrap
msgid "Fn pmf_device_suspend dev qual"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:190
msgid ""
"Suspend a device by first calling the class suspend handler, followed by the "
"driver suspend handler, and finally the bus suspend handler."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmf.9:190
#, no-wrap
msgid "Fn pmf_device_resume dev qual"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:193
msgid ""
"Resume a device by first calling the bus resume handler, followed by the "
"driver resume handler, and finally the class resume handler."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmf.9:193
#, no-wrap
msgid "Fn pmf_device_recursive_suspend dev qual"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:199
msgid ""
"As E<.Fn pmf_device_suspend>, but ensures that all child devices of E<.Fa "
"dev> are suspended."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmf.9:199
#, no-wrap
msgid "Fn pmf_device_recursive_resume dev qual"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:205
msgid ""
"As E<.Fn pmf_device_resume>, but ensures that all parent devices of E<.Fa "
"dev> are resumed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmf.9:205
#, no-wrap
msgid "Fn pmf_device_subtree_resume dev qual"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:211
msgid ""
"As E<.Fn pmf_device_resume>, but ensures that all child devices of E<.Fa "
"dev> are resumed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmf.9:211
#, no-wrap
msgid "Fn pmf_class_network_register dev ifp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:214
msgid ""
"Register a device with the power management framework as a network-class "
"device."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmf.9:214
#, no-wrap
msgid "Fn pmf_class_input_register dev"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:217
msgid ""
"Register a device with the power management framework as an input-class "
"device."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmf.9:217
#, no-wrap
msgid "Fn pmf_class_display_register dev"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:220
msgid ""
"Register a device with the power management framework as a display-class "
"device."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmf.9:220
#, no-wrap
msgid "Fn pmf_system_suspend qual"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:226
msgid ""
"Suspend all attached devices.  Devices are suspended by traversing the "
"autoconfiguration tree beginning with the leaf nodes.  This function will "
"fail if any attached drivers do not support the power management framework."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmf.9:226
#, no-wrap
msgid "Fn pmf_system_resume qual"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:232
msgid ""
"Resume all attached devices.  Devices are resumed by traversing the "
"autoconfiguration tree beginning with devices that do not have a parent.  "
"This function will fail if any attached drivers do not support the power "
"management framework."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmf.9:232
#, no-wrap
msgid "Fn pmf_system_shutdown int"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:243
msgid ""
"Shutdown all attached devices.  Devices are shut down by traversing the "
"autoconfiguration tree beginning with the leaf nodes.  The integer argument "
"is passed to the driver shutdown functions.  It should contain the E<.Xr "
"reboot 2> E<.Dq howto> argument.  This function ignores the presence of "
"attached drivers that do not support the power management framework."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmf.9:243
#, no-wrap
msgid "Fn pmf_event_register dev ev handler global"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:256
msgid ""
"Register the callback E<.Fa handler> to be called whenever an E<.Fa ev> "
"event is triggered.  If E<.Fa global> is E<.Dv true>, E<.Fa handler> accepts "
"anonymous events from E<.Fn pmf_event_inject>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmf.9:256
#, no-wrap
msgid "Fn pmf_event_deregister dev ev handler global"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:259
msgid ""
"Deregister the callback previously registered with E<.Fn "
"pmf_event_register>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmf.9:259
#, no-wrap
msgid "Fn pmf_event_inject dev ev"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:269
msgid ""
"Inject an inter-driver message into the message queue.  If E<.Fa dev> is "
"E<.Dv NULL>, the event is considered to be anonymous and one or more drivers "
"may handle this event, otherwise the event is delivered directly to the "
"callback registered by E<.Fa dev>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmf.9:269
#, no-wrap
msgid "Fn pmf_set_platform key value"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:271
msgid "Insert a name-value pair into the platform information database."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pmf.9:271
#, no-wrap
msgid "Fn pmf_get_platform key"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:278
msgid ""
"Retrieve the value for E<.Fa key> from the platform information database.  "
"Returns E<.Dv NULL> if the key is not present."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:286
msgid ""
"The power management framework is implemented within the files E<.Pa "
"sys/sys/pmf.h>, E<.Pa sys/sys/device.h>, E<.Pa sys/kern/kern_pmf.c>, and "
"E<.Pa sys/kern/subr_autoconf.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:294
msgid "The E<.Nm> framework appeared in E<.Nx 5.0>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pmf.9:296
msgid ""
"E<.An Jared D. McNeill Aq jmcneill@NetBSD.org> E<.An Joerg Sonnenberger Aq "
"joerg@NetBSD.org>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/pool.9:30
#, no-wrap
msgid "November 14, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/pool.9:31
#, no-wrap
msgid "POOL 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:42
msgid ""
"E<.Nm pool_init>, E<.Nm pool_destroy>, E<.Nm pool_get>, E<.Nm pool_put>, "
"E<.Nm pool_prime>, E<.Nm pool_sethiwat>, E<.Nm pool_setlowat>, E<.Nm "
"pool_sethardlimit>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/pool.9:42
#, no-wrap
msgid "resource-pool manager"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/pool.9:44 org_netbsd/src/share/man/man9/pool_cache.9:76
#, no-wrap
msgid "sys/pool.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:71
msgid ""
"E<.Ft void> E<.Fo pool_init> E<.Fa \"struct pool *pp\"> E<.Fa \"size_t "
"size\"> E<.Fa \"u_int align\"> E<.Fa \"u_int align_offset\"> E<.Fa \"int "
"flags\"> E<.Fa \"const char *wchan\"> E<.Fa \"struct pool_allocator "
"*palloc\"> E<.Fa \"int ipl\"> E<.Fc> E<.Ft void> E<.Fn pool_destroy \"struct "
"pool *pp\"> E<.Ft void *> E<.Fn pool_get \"struct pool *pp\" \"int flags\"> "
"E<.Ft void> E<.Fn pool_put \"struct pool *pp\" \"void *item\"> E<.Ft int> "
"E<.Fn pool_prime \"struct pool *pp\" \"int nitems\"> E<.Ft void> E<.Fn "
"pool_sethiwat \"struct pool *pp\" \"int n\"> E<.Ft void> E<.Fn pool_setlowat "
"\"struct pool *pp\" \"int n\"> E<.Ft void> E<.Fn pool_sethardlimit \"struct "
"pool *pp\" \"int n\" \"const char *warnmess\" \"int ratecap\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:80
msgid ""
"These utility routines provide management of pools of fixed-sized areas of "
"memory.  Resource pools set aside an amount of memory for exclusive use by "
"the resource pool owner.  This can be used by applications to guarantee the "
"availability of a minimum amount of memory needed to continue operation "
"independent of the memory resources currently available from the system-wide "
"memory allocator E<.Pq Xr malloc 9>."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/pool.9:80
#, no-wrap
msgid "INITIALIZING A POOL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:85
msgid ""
"The function E<.Fn pool_init> initializes a resource pool.  The arguments "
"are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pool.9:87 org_netbsd/src/share/man/man9/pool.9:151 org_netbsd/src/share/man/man9/pool.9:197 org_netbsd/src/share/man/man9/pool.9:214 org_netbsd/src/share/man/man9/pool.9:250 org_netbsd/src/share/man/man9/pool.9:265 org_netbsd/src/share/man/man9/pool.9:278
#, no-wrap
msgid "Fa pp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:89 org_netbsd/src/share/man/man9/pool.9:153 org_netbsd/src/share/man/man9/pool.9:199 org_netbsd/src/share/man/man9/pool.9:216 org_netbsd/src/share/man/man9/pool.9:252 org_netbsd/src/share/man/man9/pool.9:267 org_netbsd/src/share/man/man9/pool.9:280
msgid "The handle identifying the pool resource instance."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:91 org_netbsd/src/share/man/man9/pool_cache.9:160
msgid "Specifies the size of the memory items managed by the pool."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pool.9:91 org_netbsd/src/share/man/man9/pool_cache.9:160 org_netbsd/src/share/man/man9/vmem.9:213
#, no-wrap
msgid "Fa align"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:97
msgid ""
"Specifies the memory address alignment of the items returned by E<.Fn "
"pool_get>.  This argument must be a power of two.  If zero, the alignment "
"defaults to an architecture-specific natural alignment."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pool.9:97 org_netbsd/src/share/man/man9/pool_cache.9:167
#, no-wrap
msgid "Fa align_offset"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:101 org_netbsd/src/share/man/man9/pool_cache.9:172
msgid "The offset within an item to which the E<.Fa align> parameter applies."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:108 org_netbsd/src/share/man/man9/pool_cache.9:180
msgid ""
"Should be set to zero or E<.Dv PR_NOTOUCH>.  If E<.Dv PR_NOTOUCH> is given, "
"free items are never used to keep internal state so that the pool can be "
"used for non memory backed objects."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pool.9:108
#, no-wrap
msgid "Fa wchan"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:116
msgid ""
"The E<.Sq wait channel> passed on to E<.Xr cv_wait 9> if E<.Fn pool_get> "
"must wait for items to be returned to the pool."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pool.9:116 org_netbsd/src/share/man/man9/pool_cache.9:183
#, no-wrap
msgid "Fa palloc"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:125
msgid ""
"Can be set to E<.Dv NULL> or E<.Dv pool_allocator_kmem>, in which case the "
"default kernel memory allocator will be used.  It can also be set to E<.Dv "
"pool_allocator_nointr> when the pool will never be accessed from interrupt "
"context."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pool.9:125 org_netbsd/src/share/man/man9/pool_cache.9:191 org_netbsd/src/share/man/man9/vmem.9:176 org_netbsd/src/share/man/man9/workqueue.9:76
#, no-wrap
msgid "Fa ipl"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:128
msgid ""
"Specifies an interrupt priority level that will block all interrupt handlers "
"that could potentially access the pool."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:139
msgid ""
"The E<.Fn POOL_INIT> macro can be used to both declare and initialize a "
"resource pool.  The E<.Fn POOL_INIT> macro has the same arguments as the "
"E<.Fn pool_init> function and the resource pool will be initialized "
"automatically during system startup."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/pool.9:139
#, no-wrap
msgid "DESTROYING A POOL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:146
msgid ""
"The function E<.Fn pool_destroy> destroys a resource pool.  It takes a "
"single argument E<.Fa pp> identifying the pool resource instance."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/pool.9:146
#, no-wrap
msgid "ALLOCATING ITEMS FROM A POOL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:150
msgid ""
"E<.Fn pool_get> allocates an item from the pool and returns a pointer to "
"it.  The arguments are:"
msgstr ""

#. Undefined behaviour results if
#. .Dv PR_MALLOCOK
#. is specified on a pool handle that was created using client-provided
#. storage.
#.  a bunch of other flags aren't documented.
#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:181
msgid ""
"The flags can be used to define behaviour in case the pooled resources are "
"depleted.  If no resources are available and E<.Dv PR_NOWAIT> is given, "
"E<.Fn pool_get> returns E<.Dv NULL>.  If E<.Dv PR_WAITOK> is given and "
"allocation is attempted with no resources available, the function will sleep "
"until items are returned to the pool.  If both E<.Dv PR_LIMITFAIL> and E<.Dv "
"PR_WAITOK> are specified, and the pool has reached its hard limit, E<.Fn "
"pool_get> will return E<.Dv NULL> without waiting, allowing the caller to do "
"its own garbage collection; however, it will still wait if the pool is not "
"yet at its hard limit."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/pool.9:182
#, no-wrap
msgid "RETURNING ITEMS TO A POOL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:196
msgid ""
"E<.Fn pool_put> returns the pool item pointed at by E<.Fa item> to the "
"resource pool identified by the pool handle E<.Fa pp>.  If the number of "
"available items in the pool exceeds the maximum pool size set by E<.Fn "
"pool_sethiwat> and there are no outstanding requests for pool items, the "
"excess items will be returned to the system.  The arguments to E<.Fn "
"pool_put> are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pool.9:199
#, no-wrap
msgid "Fa item"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:202
msgid "A pointer to a pool item previously obtained by E<.Fn pool_get>."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/pool.9:203
#, no-wrap
msgid "PRIMING A POOL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:209
msgid ""
"E<.Fn pool_prime> adds items to the pool.  Storage space for the items is "
"allocated by using the page allocation routine specified to E<.Fn "
"pool_create>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:213
msgid "The arguments to E<.Fn pool_prime> are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pool.9:216
#, no-wrap
msgid "Fa nitems"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:218
msgid "The number of items to add to the pool."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:225
msgid ""
"This function may return E<.Dv ENOMEM> in case the requested number of items "
"could not be allocated.  Otherwise, the return value is 0."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/pool.9:225
#, no-wrap
msgid "SETTING POOL RESOURCE WATERMARKS AND LIMITS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:231
msgid ""
"A pool will attempt to increase its resource usage to keep up with the "
"demand for its items.  Conversely, it will return unused memory to the "
"system should the number of accumulated unused items in the pool exceed a "
"programmable limit."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:240
msgid ""
"The limits for the minimum and maximum number of items which a pool should "
"keep at hand are known as the high and low E<.Sy watermarks>.  The functions "
"E<.Fn pool_sethiwat> and E<.Fn pool_setlowat> set a pool's high and low "
"watermarks, respectively."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:247
msgid ""
"The hard limit represents the maximum number of items a pool is allowed to "
"allocate at any given time.  Unless modified via E<.Fn pool_sethardlimit>, "
"the hard limit defaults to E<.Dv UINT_MAX>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:249
msgid "E<.Fn pool_sethiwat>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pool.9:252 org_netbsd/src/share/man/man9/pool.9:267 org_netbsd/src/share/man/man9/pool.9:280
#, no-wrap
msgid "Fa n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:261
msgid ""
"The maximum number of items to keep in the pool.  As items are returned and "
"the total number of pages in the pool is larger than the maximum set by this "
"function, any completely unused pages are released immediately.  If this "
"function is not used to specify a maximum number of items, the pages will "
"remain associated with the pool until the system runs low on memory, at "
"which point the VM system will try to reclaim unused pages."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:264
msgid "E<.Fn pool_setlowat>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:274
msgid ""
"The minimum number of items to keep in the pool.  The number pages in the "
"pool will not decrease below the required value to accommodate the minimum "
"number of items specified by this function.  Unlike E<.Fn pool_prime>, this "
"function does not allocate the necessary memory up-front."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:277
msgid "E<.Fn pool_sethardlimit>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:283
msgid ""
"The maximum number of items to be allocated from the pool (i.e. the hard "
"limit)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pool.9:283
#, no-wrap
msgid "Fa warnmess"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:285
msgid "The warning message that will be logged when the hard limit is reached."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pool.9:285
#, no-wrap
msgid "Fa ratecap"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:288
msgid ""
"The minimal interval (in seconds) after which another warning message is "
"issued when the pool hits its hard limit again."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/pool.9:289
#, no-wrap
msgid "POTENTIAL PITFALLS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:292
msgid ""
"Note that undefined behaviour results when mixing the storage providing "
"methods supported by the pool resource routines."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:302
msgid ""
"The pool resource code uses a per-pool lock to protect its internal state.  "
"If any pool functions are called in an interrupt context, the caller must "
"block all interrupts that might cause the code to be reentered.  "
"Additionally, the functions E<.Fn pool_init> and E<.Fn pool_destroy> should "
"never be called in interrupt context."
msgstr ""

#.  .Sh RETURN VALUES
#.  .Sh EXAMPLES
#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:307
msgid ""
"Pool usage logs can be enabled by defining the compile-time option E<.Dv "
"POOL_DIAGNOSTIC>."
msgstr ""

#.  .Sh AUTHOR
#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:311
msgid "The pool manager is implemented in the file E<.Pa sys/kern/subr_pool.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:317
msgid ""
"E<.Xr free 9>, E<.Xr malloc 9>, E<.Xr memoryallocators 9>, E<.Xr pool_cache "
"9>, E<.Xr uvm 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool.9:321
msgid "The E<.Nx> pool manager appeared in E<.Nx 1.4>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/pool_cache.9:56
#, no-wrap
msgid "November 15, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/pool_cache.9:57
#, no-wrap
msgid "POOL_CACHE 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:73
msgid ""
"E<.Nm pool_cache>, E<.Nm pool_cache_init>, E<.Nm pool_cache_destroy>, E<.Nm "
"pool_cache_get_paddr>, E<.Nm pool_cache_get>, E<.Nm pool_cache_put_paddr>, "
"E<.Nm pool_cache_put>, E<.Nm pool_cache_destruct_object>, E<.Nm "
"pool_cache_invalidate>, E<.Nm pool_cache_sethiwat>, E<.Nm "
"pool_cache_setlowat>, E<.Nm pool_cache_sethardlimit>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/pool_cache.9:73
#, no-wrap
msgid "resource-pool cache manager"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:122
msgid ""
"E<.Ft pool_cache_t> E<.Fn pool_cache_init \"size_t size\" \"u_int align\" "
"\"u_int align_offset\" \"int flags\" \"const char *name\" \"struct "
"pool_allocator *palloc\" \"int ipl\" \"int (*ctor)(void *, void *, int)\" "
"\"void (*dtor)(void *, void *)\" \"void *arg\"> E<.Ft void> E<.Fn "
"pool_cache_destroy \"pool_cache_t pc\"> E<.Ft void *> E<.Fn "
"pool_cache_get_paddr \"pool_cache_t pc\" \"int flags\" \"paddr_t *pap\"> "
"E<.Ft void *> E<.Fn pool_cache_get \"pool_cache_t pc\" \"int flags\"> E<.Ft "
"void> E<.Fn pool_cache_put_paddr \"pool_cache_t pc\" \"void *object\" "
"\"paddr_t pa\"> E<.Ft void> E<.Fn pool_cache_put \"pool_cache_t pc\" \"void "
"*object\"> E<.Ft void> E<.Fn pool_cache_destruct_object \"pool_cache_t pc\" "
"\"void *object\"> E<.Ft void> E<.Fn pool_cache_invalidate \"pool_cache_t "
"pc\"> E<.Ft void> E<.Fn pool_cache_sethiwat \"pool_cache_t pc\" \"int "
"nitems\"> E<.Ft void> E<.Fn pool_cache_setlowat \"pool_cache_t pc\" \"int "
"nitems\"> E<.Ft void> E<.Fn pool_cache_sethardlimit \"pool_cache_t pc\" "
"\"int nitems\" \"const char *warnmess\" \"int ratecap\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:130
msgid ""
"These utility routines provide management of pools of fixed-sized areas of "
"memory.  Resource pools set aside an amount of memory for exclusive use by "
"the resource pool owner.  This can be used by applications to guarantee the "
"availability of a minimum amount of memory needed to continue operation "
"independent of the memory resources currently available from the system-wide "
"memory allocator."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:147
msgid ""
"E<.Nm> follows the E<.Xr pool 9> API closely and offers routines that are "
"functionally equivalent to their E<.Xr pool 9> counterparts.  In addition, "
"E<.Nm> provides object management functions used to manipulate objects "
"allocated from the pool.  It also maintains global and per-CPU caches, both "
"levels of cache work together to allow for low overhead allocation and "
"release of objects, and improved L1/L2/L3 hardware cache locality in "
"multiprocessor systems."
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: It
#: org_netbsd/src/share/man/man9/pool_cache.9:150
#, no-wrap
msgid ""
"Fn pool_cache_init size align align_offset flags name palloc ipl ctor dtor "
"arg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:155
msgid "Allocate and initialize a pool cache.  The arguments are:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:167
msgid ""
"Specifies the memory address alignment of the items returned by E<.Fn "
"pool_cache_get>.  This argument must be a power of two.  If zero, the "
"alignment defaults to an architecture-specific natural alignment."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pool_cache.9:180 org_netbsd/src/share/man/man9/secmodel.9:99 org_netbsd/src/share/man/man9/vmem.9:80 org_netbsd/src/share/man/man9/workqueue.9:66
#, no-wrap
msgid "Fa name"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:183
msgid "The name used to identify the object in diagnostic output."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:191
msgid ""
"Should be typically be set to NULL, instructing E<.Fn pool_cache_init> to "
"select an appropriate back-end allocator.  Alternate allocators can be used "
"to partition space from arbitrary sources.  Use of alternate allocators is "
"not documented here as it is not a stable, endorsed part of the API."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:201
msgid ""
"Specifies an interrupt priority level that will block all interrupt handlers "
"that could potentially access the pool.  The E<.Nm> facility provides its "
"own synchronization.  The users of any given E<.Nm> need not provide "
"additional synchronization for access to it."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pool_cache.9:201
#, no-wrap
msgid "Fa ctor"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:212
msgid ""
"Specifies a constructor used to initialize newly allocated objects.  If no "
"constructor is required, specify E<.Dv NULL>.  The first argument to E<.Fa "
"ctor> is E<.Fa arg>, the second is the new object, and the third is E<.Fa "
"flags>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pool_cache.9:212
#, no-wrap
msgid "Fa dtor"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:223
msgid ""
"Specifies a destructor used to destroy cached objects prior to their release "
"to backing store.  If no destructor is required, specify E<.Dv NULL>.  The "
"first argument to E<.Fa dtor> is E<.Fa arg>, and the second is the object."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:227
msgid ""
"This value of this argument will be passed to both the constructor and "
"destructor routines."
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: It
#: org_netbsd/src/share/man/man9/pool_cache.9:229
#, no-wrap
msgid "Fn pool_cache_destroy pc"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:236
msgid ""
"Destroy a pool cache E<.Fa pc>.  All other access to the cache must be "
"stopped before this call can be made."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pool_cache.9:236
#, no-wrap
msgid "Fn pool_cache_get_paddr pc flags pap"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:255
msgid ""
"Get an object from a pool cache E<.Fa pc>.  If E<.Fa pap> is not E<.Dv "
"NULL>, physical address of the object or E<.Dv POOL_PADDR_INVALID> will be "
"returned via it.  E<.Fa flags> will be passed to E<.Fn pool_get> function of "
"the backing E<.Xr pool 9> and the object constructor specified when the pool "
"cache is created by E<.Fn pool_cache_init>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pool_cache.9:255
#, no-wrap
msgid "Fn pool_cache_get pc flags"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:266
msgid ""
"E<.Fn pool_cache_get> is the same as E<.Fn pool_cache_get_paddr> with E<.Dv "
"NULL> E<.Fa pap> argument.  It's implemented as a macro."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pool_cache.9:266
#, no-wrap
msgid "Fn pool_cache_put_paddr pc object pa"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:284
msgid ""
"Put an object E<.Fa object> back to the pool cache E<.Fa pc>.  E<.Fa pa> "
"should be physical address of the object E<.Fa object> or E<.Dv "
"POOL_PADDR_INVALID>.  E<.Fa pp>.  If the number of available items in the "
"backing pool exceeds the maximum pool size set by E<.Fn pool_cache_sethiwat> "
"and there are no outstanding requests for pool items, the excess items will "
"be returned to the system."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pool_cache.9:284
#, no-wrap
msgid "Fn pool_cache_put pc object"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:295
msgid ""
"E<.Fn pool_cache_put> is the same as E<.Fn pool_cache_put_paddr> with E<.Dv "
"POOL_PADDR_INVALID> E<.Fa pa> argument.  It's implemented as a macro."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pool_cache.9:295
#, no-wrap
msgid "Fn pool_cache_destruct_object pc object"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:301
msgid ""
"Force destruction of an object E<.Fa object> and release it back into the "
"pool."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pool_cache.9:301
#, no-wrap
msgid "Fn pool_cache_invalidate pc"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:311
msgid ""
"Invalidate a pool cache E<.Fa pc>.  All objects in the cache will be "
"destructed and freed back to the pool backing the cache.  For pool caches "
"that vend constructed objects, consumers of this API must take care to "
"provide proper synchronization between the input to the constructor and "
"cache invalidation."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pool_cache.9:311
#, no-wrap
msgid "Fn pool_cache_sethiwat pc nitems"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:321
msgid ""
"A pool will attempt to increase its resource usage to keep up with the "
"demand for its items.  Conversely, it will return unused memory to the "
"system should the number of accumulated unused items in the pool exceed a "
"programmable limit.  The limits for the minimum and maximum number of items "
"which a pool should keep at hand are known as the high and low E<.Sy "
"watermarks>."
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:333
msgid ""
"The function E<.Fn pool_cache_sethiwat> sets the backing pool's high water "
"mark.  As items are returned and the total number of pages in the pool is "
"larger than the maximum set by this function, any completely unused pages "
"are released immediately.  If this function is not used to specify a maximum "
"number of items, the pages will remain associated with the pool until the "
"system runs low on memory, at which point the VM system will try to reclaim "
"unused pages."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pool_cache.9:333
#, no-wrap
msgid "Fn pool_cache_setlowat pc nitems"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:339
msgid ""
"Set the minimum number of items to keep in the pool.  The number pages in "
"the pool will not decrease below the required value to accommodate the "
"minimum number of items specified by this function."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pool_cache.9:339
#, no-wrap
msgid "Fn pool_cache_sethardlimit pc nitems warnmess ratecap"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:350
msgid ""
"Set the hard limit for the backing E<.Xr pool 9> to E<.Fa nitems>.  When the "
"hard limit is reached, the warning message E<.Fa warnmess> will be logged.  "
"E<.Fa ratecap> represents the minimal interval (in seconds) after which "
"another warning message is issued when the pool hits its hard limit again."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:357
msgid ""
"The E<.Nm> subsystem is implemented within the file E<.Pa "
"sys/kern/subr_pool.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pool_cache.9:362
msgid ""
"E<.Xr intro 9>, E<.Xr kmem 9>, E<.Xr memoryallocators 9>, E<.Xr percpu 9>, "
"E<.Xr pool 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/powerhook_establish.9:30 org_netbsd/src/share/man/man9/shutdownhook_establish.9:35
#, no-wrap
msgid "May 14, 2009"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/powerhook_establish.9:31
#, no-wrap
msgid "POWERHOOK_ESTABLISH 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/powerhook_establish.9:36
msgid "E<.Nm powerhook_establish>, E<.Nm powerhook_disestablish>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/powerhook_establish.9:36
#, no-wrap
msgid "add or remove a power change hook"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/powerhook_establish.9:43
msgid ""
"E<.Ft void *> E<.Fn powerhook_establish \"const char *name\" \"void "
"(*fn)(int why, void *a)\" \"void *arg\"> E<.Ft void> E<.Fn "
"powerhook_disestablish \"void *cookie\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/powerhook_establish.9:47 org_netbsd/src/share/man/man9/shutdownhook_establish.9:51
msgid "E<.Em The> E<.Nm> E<.Em API is deprecated.>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/powerhook_establish.9:60
msgid ""
"The E<.Fn powerhook_establish> function adds E<.Fa fn> of the list of hooks "
"invoked by E<.Xr dopowerhooks 9> at power change.  When invoked, the hook "
"function E<.Fa fn> will be passed the new power state as the first argument "
"and E<.Fa arg> as its second argument."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/powerhook_establish.9:71
msgid ""
"The E<.Fn powerhook_disestablish> function removes the hook described by the "
"opaque pointer E<.Fa cookie> from the list of hooks to be invoked at power "
"change.  If E<.Fa cookie> is invalid, the result of E<.Fn "
"powerhook_disestablish> is undefined."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/powerhook_establish.9:78
msgid ""
"Power hooks should be used to perform activities that must happen when the "
"power situation to the computer changes.  Because of the environment in "
"which they are run, power hooks cannot rely on many system services "
"(including file systems, and timeouts and other interrupt-driven services).  "
"The power hooks are typically executed from an interrupt context."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/powerhook_establish.9:97
msgid ""
"The different reasons for calling the power hooks are: suspend, standby, and "
"resume.  The reason is reflected in the E<.Fa why> argument and the values "
"E<.Dv PWR_SOFTSUSPEND>, E<.Dv PWR_SUSPEND>, E<.Dv PWR_SOFTSTANDBY>, E<.Dv "
"PWR_STANDBY>, E<.Dv PWR_SOFTRESUME>, and E<.Dv PWR_RESUME>.  It calls with "
"PWR_SOFTxxx in the normal priority level while the other callings are "
"protected with E<.Xr splhigh 9>.  At suspend the system is going to lose "
"(almost) all power, standby retains some power (e.g., minimal power to USB "
"devices), and at resume power is back to normal."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/powerhook_establish.9:103
msgid ""
"If successful, E<.Fn powerhook_establish> returns an opaque pointer "
"describing the newly-established power hook.  Otherwise, it returns NULL."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/powerhook_establish.9:104
msgid "E<.Xr dopowerhooks 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/ppi.9:31
#, no-wrap
msgid "PPI 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ppi.9:35
msgid "E<.Nm ppi>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/ppi.9:35
#, no-wrap
msgid "user-space interface to ppbus parallel port"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/ppi.9:38
#, no-wrap
msgid "dev/ppbus/ppi.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ppi.9:50
msgid ""
"All I/O on the E<.Nm> interface is performed using E<.Fn ioctl> calls.  Each "
"command takes a single E<.Ft uint8_t> argument, transferring one byte of "
"data.  The following commands are available:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ppi.9:51
#, no-wrap
msgid "Dv PPIGDATA , PPISDATA"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ppi.9:53
msgid "Get and set the contents of the data register."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ppi.9:53
#, no-wrap
msgid "Dv PPIGSTATUS , PPISSTATUS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ppi.9:55
msgid "Get and set the contents of the status register."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ppi.9:55
#, no-wrap
msgid "Dv PPIGCTRL , PPISCTRL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ppi.9:60
msgid ""
"Get and set the contents of the control register.  The following defines "
"correspond to bits in this register.  Setting a bit in the control register "
"drives the corresponding output low."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ppi.9:61
#, no-wrap
msgid "Dv STROBE"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ppi.9:62
#, no-wrap
msgid "Dv AUTOFEED"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ppi.9:63
#, no-wrap
msgid "Dv nINIT"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ppi.9:64
#, no-wrap
msgid "Dv SELECTIN"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ppi.9:65
#, no-wrap
msgid "Dv PCD"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ppi.9:67
#, no-wrap
msgid "Dv PPIGEPP , PPISEPP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ppi.9:69
msgid "Get and set the contents of the EPP control register."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ppi.9:69
#, no-wrap
msgid "Dv PPIGECR , PPISECR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ppi.9:71
msgid "Get and set the contents of the ECP control register."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ppi.9:71
#, no-wrap
msgid "Dv PPIGFIFO , PPISFIFO"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ppi.9:73
msgid "Read and write the ECP FIFO (8-bit operations only)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ppi.9:77
msgid ""
"To present the value 0x5a to the data port, drive STROBE low and then high "
"again, the following code fragment can be used:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ppi.9:80
#, no-wrap
msgid ""
"\tint\t\tfd;\n"
"\tuint8_t\tval;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ppi.9:88
#, no-wrap
msgid ""
"\tval = 0x5a;\n"
"\tioctl(fd, PPISDATA, \\*[Am]val);\n"
"\tioctl(fd, PPIGCTRL, \\*[Am]val);\n"
"\tval |= STROBE;\n"
"\tioctl(fd, PPISCTRL, \\*[Am]val);\n"
"\tval \\*[Am]= ~STROBE;\n"
"\tioctl(fd, PPISCTRL, \\*[Am]val);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ppi.9:96
msgid "E<.Xr ioctl 2>, E<.Xr atppc 4>, E<.Xr io 4>, E<.Xr ppbus 4>, E<.Xr ppi 4>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ppi.9:100
msgid "E<.Nm> originally appeared in E<.Fx>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ppi.9:108
msgid ""
"This manual page is based on the E<.Fx> E<.Nm ppi> manual page and was "
"updated for the E<.Nx> port by E<.An Gary Thorpe>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ppi.9:110
msgid "The inverse sense of signals is confusing."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ppi.9:114
msgid ""
"The E<.Fn ioctl> interface is slow, and there is no way (yet) to chain "
"multiple operations together."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ppi.9:116
msgid ""
"The headers required for user applications are not installed as part of the "
"standard system."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/ppsratecheck.9:30
#, no-wrap
msgid "August 3, 2000"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/ppsratecheck.9:31
#, no-wrap
msgid "PPSRATECHECK 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ppsratecheck.9:35
msgid "E<.Nm ppsratecheck>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/ppsratecheck.9:35 org_netbsd/src/share/man/man9/ratecheck.9:35
#, no-wrap
msgid "function to help implement rate-limited actions"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ppsratecheck.9:40
msgid ""
"E<.Ft int> E<.Fn ppsratecheck \"struct timeval *lasttime\" \"int *curpps\" "
"\"int maxpps\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ppsratecheck.9:51
msgid ""
"The E<.Fn ppsratecheck> function provides easy way to perform "
"packet-per-sec, or event-per-sec, rate limitation.  The motivation for "
"implementing E<.Fn ppsratecheck> was to provide a mechanism that could be "
"used to add rate limitation to network packet output.  For certain network "
"packets, we may want to impose rate limitation, to avoid denial-of-service "
"attack possibilities."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ppsratecheck.9:70
msgid ""
"E<.Fa maxpps> specifies maximum permitted packets, or events, per second.  "
"If E<.Fn ppsratecheck> is called more than E<.Fa maxpps> times in a given "
"one second period, the function will return 0, indicating that we exceeded "
"the limit.  If we are below the limit, the function will return 1.  If E<.Fa "
"maxpps> is set to 0, the function will always return 0 E<.Pq no "
"packets/events are permitted>.  Negative E<.Fa maxpps> indicates that rate "
"limitation is disabled, and E<.Fa ppsratecheck> will always return 1."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ppsratecheck.9:79
msgid ""
"E<.Fa curpps> and E<.Fa lasttime> are used to maintain the number of recent "
"calls.  E<.Fa curpps> will be incremented every time E<.Fn ppsratecheck> is "
"called, and will be reset whenever necessary."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ppsratecheck.9:84
msgid "E<.Xr log 9>, E<.Xr printf 9>, E<.Xr ratecheck 9>, E<.Xr time_second 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ppsratecheck.9:88
msgid "The E<.Fn ppsratecheck> function appeared in E<.Nx 1.5>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/preempt.9:30
#, no-wrap
msgid "July 3, 2007"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/preempt.9:31
#, no-wrap
msgid "PREEMPT 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/preempt.9:36
msgid "E<.Nm preempt>, E<.Nm yield>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/preempt.9:36
#, no-wrap
msgid "general preempt and yield functions"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/preempt.9:41
msgid "E<.Ft void> E<.Fn preempt \"void\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/preempt.9:44
msgid "E<.Ft void> E<.Fn yield \"void\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/preempt.9:54
msgid ""
"The E<.Fn preempt> function puts the current LWP back on the system run "
"queue and performs an involuntary context switch.  The E<.Fn yield> function "
"is mostly same as E<.Fn preempt>, except that it performs a voluntary "
"context switch."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/preempt.9:56
msgid ""
"These functions drop the kernel lock before switching and re-acquire it "
"before returning."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/proc_find.9:31
#, no-wrap
msgid "PROC_FIND 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/proc_find.9:36
msgid "E<.Nm proc_find>, E<.Nm pgrp_find>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/proc_find.9:36
#, no-wrap
msgid "find process or process group"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/proc_find.9:43
msgid ""
"E<.Ft struct proc *> E<.Fn proc_find \"pid_t pid\"> E<.Ft struct pgrp *> "
"E<.Fn pgrp_find \"pid_t pgid\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/proc_find.9:45
msgid "E<.Va extern kmutex_t *proc_lock;>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/proc_find.9:60
msgid ""
"The E<.Fn proc_find> and E<.Fn pgrp_find> functions retrieve process and "
"process group structures from process E<.Tn ID> E<.Fa pid> and process group "
"E<.Tn ID> E<.Fa pgid>.  Both functions must be called by holding a E<.Xr "
"mutex 9> on E<.Va proc_lock>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/proc_find.9:70
msgid ""
"Upon successful completion, the described functions return a pointer to "
"either E<.Em struct proc> or E<.Em struct pgrp>.  Otherwise, if the "
"requested E<.Tn ID> was not found, E<.Dv NULL> is returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/proc_find.9:71
msgid "E<.Xr curproc 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/pserialize.9:27
#, no-wrap
msgid "July 30, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/pserialize.9:28
#, no-wrap
msgid "PSERIALIZE 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pserialize.9:32
msgid "E<.Nm pserialize>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/pserialize.9:32
#, no-wrap
msgid "passive serialization mechanism"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/pserialize.9:34
#, no-wrap
msgid "sys/pserialize.h"
msgstr ""

#.  -----
#. type: Plain text
#: org_netbsd/src/share/man/man9/pserialize.9:46
msgid ""
"E<.Ft pserialize_t> E<.Fn pserialize_create \"void\"> E<.Ft void> E<.Fn "
"pserialize_destroy \"pserialize_t psz\"> E<.Ft int> E<.Fn "
"pserialize_read_enter \"void\"> E<.Ft void> E<.Fn pserialize_read_exit \"int "
"s\"> E<.Ft void> E<.Fn pserialize_perform \"pserialize_t psz\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pserialize.9:51
msgid ""
"Passive serialization is a reader / writer synchronisation mechanism "
"designed for lock-less read operations.  The read operations may happen from "
"software interrupt at E<.Dv IPL_SOFTCLOCK>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pserialize.9:53
#, no-wrap
msgid "Fn pserialize_create"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pserialize.9:55
msgid "Allocate a new synchronisation object."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pserialize.9:55
#, no-wrap
msgid "Fn pserialize_destroy"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pserialize.9:58
msgid ""
"Destroy the synchronisation object.  No synchronisation activity should "
"happen at this point."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pserialize.9:58
#, no-wrap
msgid "Fn pserialize_read_enter"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pserialize.9:63
msgid ""
"Enter the critical path of the reader side.  Returns an IPL value, which "
"must be passed to E<.Xr pserialize_read_exit 9>.  Protected code path is not "
"allowed to block."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pserialize.9:63
#, no-wrap
msgid "Fn pserialize_read_exit"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pserialize.9:67
msgid ""
"Exit the critical path of the reader side.  Takes the IPL value returned by "
"E<.Xr pserialize_read_enter 9>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/pserialize.9:67
#, no-wrap
msgid "Fn pserialize_perform"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pserialize.9:74
msgid ""
"Perform the passive serialization on the writer side.  Passing of this "
"function ensures that no readers are in action.  Writers must be "
"additionally serialized with a separate mechanism, e.g.  E<.Xr mutex 9>.  "
"Operation blocks and it may only be performed from thread context."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pserialize.9:78
msgid "Typical code fragment in the writer side:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pserialize.9:89
#, no-wrap
msgid ""
"\tmutex_enter(\\*[Am]writer_psz_lock);\n"
"\t/*\n"
"\t * Perform the updates (e.g. remove data items from a list).\n"
"\t */\n"
"\t...\n"
"\tpserialize_perform(object-\\*[Gt]psz);\n"
"\t/*\n"
"\t * At this point it is safe to destroy old data items.\n"
"\t */\n"
"\tmutex_exit(\\*[Am]writer_psz_lock);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pserialize.9:96
msgid "The E<.Nm> is implemented within the file E<.Pa sys/kern/subr_pserialize.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pserialize.9:108
msgid ""
"E<.Xr membar_ops 3>, E<.Xr condvar 9>, E<.Xr mutex 9>, E<.Xr rwlock 9> "
"E<.Rs> E<.%A Hennessy, et al.> E<.%T \"Passive serialization in a "
"multitasking environment\"> E<.%I US Patent and Trademark Office> E<.%D "
"February 28, 1989> E<.%N US Patent 4809168> E<.Re>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/pserialize.9:110
msgid "Passive serialization mechanism first appeared in E<.Nx 6.0>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/putter.9:27
#, no-wrap
msgid "November 21, 2007"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/putter.9:28
#, no-wrap
msgid "PUTTER 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/putter.9:32
msgid "E<.Nm putter>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/putter.9:32
#, no-wrap
msgid "Pass-to-Userspace Transporter"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/putter.9:43
msgid ""
"The E<.Nm> subsystem is used for request-response handling of userspace "
"components.  It currently provides routines for associating a file "
"descriptor with a subsystem data structure instance and I/O routines.  Users "
"of the facility must fill out the callbacks in E<.Va struct putter_ops> to "
"integrate with E<.Nm>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/putter.9:46
msgid "E<.Xr pud 4>, E<.Xr puffs 4>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/putter.9:48
msgid "Under construction.  Interfaces may and will change."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/radio.9:28
#, no-wrap
msgid "RADIO 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/radio.9:32
msgid "E<.Nm radio>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/radio.9:32
#, no-wrap
msgid "interface between low and high level radio drivers"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/radio.9:40
msgid ""
"The radio device driver is divided into a high level, hardware independent "
"layer, and a low level hardware dependent layer.  The interface between "
"these is the E<.Va radio_hw_if> structure."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/radio.9:48
#, no-wrap
msgid ""
"struct radio_hw_if {\n"
"\tint\t(*open)(void *, int, int, struct lwp *);\n"
"\tint\t(*close)(void *, int, int, struct lwp *);\n"
"\tint     (*get_info)(void *, struct radio_info *);\n"
"\tint     (*set_info)(void *, struct radio_info *);\n"
"\tint     (*search)(void *, int);\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/radio.9:54
msgid ""
"The high level radio driver attaches to the low level driver when the latter "
"calls E<.Va radio_attach_mi>.  This call should be"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/radio.9:60
#, no-wrap
msgid ""
"    void\n"
"    radio_attach_mi(rhwp, hdlp, dev)\n"
"\tstruct radio_hw_if *rhwp;\n"
"\tvoid *hdlp;\n"
"\tstruct device *dev;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/radio.9:73
msgid ""
"The E<.Va radio_hw_if> struct is as shown above.  The E<.Va hdlp> argument "
"is a handle to some low level data structure.  It is sent as the first "
"argument to all the functions in E<.Va radio_hw_if> when the high level "
"driver calls them.  E<.Va dev> is the device struct for the hardware device."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/radio.9:77
msgid "The fields of E<.Va radio_hw_if> are described in some more detail below."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/radio.9:82
#, no-wrap
msgid ""
"int open (void *, int flags, int fmt, struct lwp *p);\n"
"  Optional.\n"
"  Is called when the radio device is opened.\n"
"  Returns 0 on success, otherwise an error code.\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/radio.9:87
#, no-wrap
msgid ""
"int close (void *, int flags, int fmt, struct lwp *p);\n"
"  Optional.\n"
"  Is called when the radio device is closed.\n"
"  Returns 0 on success, otherwise an error code.\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/radio.9:91
#, no-wrap
msgid ""
"int get_info (void *, struct radio_info *);\n"
"  Fill the radio_info struct.\n"
"  Returns 0 on success, otherwise an error code.\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/radio.9:95
#, no-wrap
msgid ""
"int set_info (void *, struct radio_info *);\n"
"  Set values from the radio_info struct.\n"
"  Returns 0 on success, otherwise an error code.\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/radio.9:98
#, no-wrap
msgid ""
"int search (void *, int);\n"
"  Returns 0 on success, otherwise an error code.\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/radio.9:100
msgid "E<.Xr radio 4>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/ras.9:30
#, no-wrap
msgid "April 17, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/ras.9:31
#, no-wrap
msgid "RAS 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ras.9:37
msgid "E<.Nm ras_lookup>, E<.Nm ras_fork>, E<.Nm ras_purgeall>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/ras.9:37
#, no-wrap
msgid "restartable atomic sequences"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/ras.9:41
#, no-wrap
msgid "sys/ras.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ras.9:48
msgid ""
"E<.Ft void *> E<.Fn ras_lookup \"struct proc *p\" \"void *addr\"> E<.Ft int> "
"E<.Fn ras_fork \"struct proc *p1\" \"struct proc *p2\"> E<.Ft int> E<.Fn "
"ras_purgeall \"struct proc *p\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ras.9:58
msgid ""
"Restartable atomic sequences are user code sequences which are guaranteed to "
"execute without preemption.  This property is assured by checking the set of "
"restartable atomic sequences registered for a process during E<.Xr "
"cpu_switchto 9>.  If a process is found to have been preempted during a "
"restartable sequence, then its execution is rolled-back to the start of the "
"sequence by resetting its program counter saved in its process control block "
"E<.Pq Tn PCB>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ras.9:68
msgid ""
"The E<.Tn RAS> functionality is provided by a combination of the "
"machine-independent routines discussed in this page and a machine-dependent "
"component in E<.Xr cpu_switchto 9>.  A port which supports restartable "
"atomic sequences will define E<.Dv __HAVE_RAS> in"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/ras.9:68 org_netbsd/src/share/man/man9/setjmp.9:38
#, no-wrap
msgid "machine/types.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ras.9:70
msgid "for machine-independent code to conditionally provide RAS support."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ras.9:79
msgid ""
"A complicated side-effect of restartable atomic sequences is their "
"interaction with the machine-dependent E<.Xr ptrace 2> support.  "
"Specifically, single-step traps and/or the emulation of single-stepping must "
"carefully consider the effect on restartable atomic sequences.  A general "
"solution is to ignore these traps or disable them within restartable atomic "
"sequences."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ras.9:81
msgid "The functions which operate on restartable atomic sequences are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ras.9:83
#, no-wrap
msgid "Fn ras_lookup p addr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ras.9:96
msgid ""
"This function searches the registered restartable atomic sequences for "
"process E<.Fa p> which contain the user address E<.Fa addr>.  If the address "
"E<.Fa addr> is found within a E<.Tn RAS>, then the restart address of the "
"E<.Tn RAS> is returned, otherwise \\-1 is returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ras.9:96
#, no-wrap
msgid "Fn ras_fork p1 p2"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ras.9:105
msgid ""
"This function is used to copy all registered restartable atomic sequences "
"for process E<.Fa p1> to process E<.Fa p2>.  It is primarily called from "
"E<.Xr fork1 9> when the sequences are inherited from the parent by the "
"child."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ras.9:105
#, no-wrap
msgid "Fn ras_purgeall p"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ras.9:114
msgid ""
"This function is used to remove all registered restartable atomic sequences "
"for process E<.Fa p>.  It is primarily used to remove all registered "
"restartable atomic sequences for a process during E<.Xr exec 3> and by E<.Xr "
"rasctl 2>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ras.9:120
msgid ""
"The RAS framework itself is implemented within the file E<.Pa "
"sys/kern/kern_ras.c>.  Data structures and function prototypes for the "
"framework are located in"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/ras.9:120
#, no-wrap
msgid "sys/ras.h ."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ras.9:125
msgid ""
"Machine-dependent portions are implemented within E<.Xr cpu_switchto 9> in "
"the machine-dependent file E<.Pa "
"sys/arch/\\*[Lt]arch\\*[Gt]/\\*[Lt]arch\\*[Gt]/locore.S>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ras.9:139
msgid ""
"E<.Xr rasctl 2>, E<.Xr cpu_switchto 9>, E<.Xr fork1 9> E<.Rs> E<.%A Gregory "
"McGarry> E<.%T \"An Implementation of User-level Restartable Atomic "
"Sequences on the NetBSD Operating System\"> E<.%I USENIX Association> E<.%B "
"Proceedings of the FREENIX Track: 2003 USENIX Annual Technical Conference> "
"E<.%P 311-322> E<.%D June 9-14, 2003> E<.%U "
"http://www.usenix.org/publications/library/proceedings/usenix03/tech/freenix03/full_papers/mcgarry/mcgarry.pdf> "
"E<.Re>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ras.9:141
msgid "The RAS functionality first appeared in E<.Nx 2.0>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/rasops.9:30 org_netbsd/src/share/man/man9/wsfont.9:30
#, no-wrap
msgid "January 13, 2012"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/rasops.9:31
#, no-wrap
msgid "RASOPS 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:37
msgid "E<.Nm rasops>, E<.Nm rasops_init>, E<.Nm rasops_reconfig>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/rasops.9:37
#, no-wrap
msgid "raster display operations"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/rasops.9:39 org_netbsd/src/share/man/man9/wsdisplay.9:42
#, no-wrap
msgid "dev/wscons/wsdisplayvar.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/rasops.9:40
#, no-wrap
msgid "dev/rasops/rasops.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:45
msgid ""
"E<.Ft int> E<.Fn rasops_init \"struct rasops_info *ri\" \"int wantrows\" "
"\"int wantcols\"> E<.Ft int> E<.Fn rasops_reconfig \"struct rasops_info "
"*ri\" \"int wantrows\" \"int wantcols\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:50
msgid "The E<.Nm> subsystem is a set of raster operations for E<.Xr wscons 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:55
msgid ""
"The primary data type for using the raster operations is the E<.Em "
"rasops_info> structure in E<.Pa dev/rasops/rasops.h>:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:57
#, no-wrap
msgid "struct rasops_info {\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:66
#, no-wrap
msgid ""
"\t/*\n"
"\t * These must be filled in by the caller\n"
"\t */\n"
"\tint\tri_depth;\t/* depth in bits */\n"
"\tu_char\t*ri_bits;\t/* ptr to bits */\n"
"\tint\tri_width;\t/* width (pels) */\n"
"\tint\tri_height;\t/* height (pels) */\n"
"\tint\tri_stride;\t/* stride in bytes */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:72
#, no-wrap
msgid ""
"\t/*\n"
"\t * If you want shadow framebuffer support, point ri_hwbits\n"
"\t * to the real framebuffer, and ri_bits to the shadow framebuffer\n"
"\t */\n"
"\tu_char\t*ri_hwbits;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:83
#, no-wrap
msgid ""
"\t/*\n"
"\t * These can optionally be left zeroed out. If you fill ri_font,\n"
"\t * but aren't using wsfont, set ri_wsfcookie to -1.\n"
"\t */\n"
"\tstruct\twsdisplay_font *ri_font;\n"
"\tint\tri_wsfcookie;\t/* wsfont cookie */\n"
"\tvoid\t*ri_hw;\t\t/* driver private data */\n"
"\tint\tri_crow;\t/* cursor row */\n"
"\tint\tri_ccol;\t/* cursor column */\n"
"\tint\tri_flg;\t\t/* various operational flags */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:95
#, no-wrap
msgid ""
"\t/*\n"
"\t * These are optional and will default if zero. Meaningless\n"
"\t * on depths other than 15, 16, 24 and 32 bits per pel. On\n"
"\t * 24 bit displays, ri_{r,g,b}num must be 8.\n"
"\t */\n"
"\tu_char\tri_rnum;\t/* number of bits for red */\n"
"\tu_char\tri_gnum;\t/* number of bits for green */\n"
"\tu_char\tri_bnum;\t/* number of bits for blue */\n"
"\tu_char\tri_rpos;\t/* which bit red starts at */\n"
"\tu_char\tri_gpos;\t/* which bit green starts at */\n"
"\tu_char\tri_bpos;\t/* which bit blue starts at */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:113
#, no-wrap
msgid ""
"\t/*\n"
"\t * These are filled in by rasops_init()\n"
"\t */\n"
"\tint\tri_emuwidth;\t/* width we actually care about */\n"
"\tint\tri_emuheight;\t/* height we actually care about */\n"
"\tint\tri_emustride;\t/* bytes per row we actually care about */\n"
"\tint\tri_rows;\t/* number of rows (characters) */\n"
"\tint\tri_cols;\t/* number of columns (characters) */\n"
"\tint\tri_delta;\t/* row delta in bytes */\n"
"\tint\tri_pelbytes;\t/* bytes per pel (may be zero) */\n"
"\tint\tri_fontscale;\t/* fontheight * fontstride */\n"
"\tint\tri_xscale;\t/* fontwidth * pelbytes */\n"
"\tint\tri_yscale;\t/* fontheight * stride */\n"
"\tu_char\t*ri_origbits;\t/* where screen bits actually start */\n"
"\tint\tri_xorigin;\t/* where ri_bits begins (x) */\n"
"\tint\tri_yorigin;\t/* where ri_bits begins (y) */\n"
"\tint32_t\tri_devcmap[16]; /* color -\\*[Gt] framebuffer data */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:119
#, no-wrap
msgid ""
"\t/*\n"
"\t * The emulops you need to use, and the screen caps for wscons\n"
"\t */\n"
"\tstruct\twsdisplay_emulops ri_ops;\n"
"\tint\tri_caps;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:125
#, no-wrap
msgid ""
"\t/*\n"
"\t * Callbacks so we can share some code\n"
"\t */\n"
"\tvoid\t(*ri_do_cursor)(struct rasops_info *);\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:130
msgid "Valid values for the E<.Em ri_flg> member are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rasops.9:132
#, no-wrap
msgid "Dv RI_FULLCLEAR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:135
msgid "E<.Fn eraserows> hack to clear full screen"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rasops.9:135
#, no-wrap
msgid "Dv RI_FORCEMONO"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:137
msgid "monochrome output even if we can do color"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rasops.9:137
#, no-wrap
msgid "Dv RI_BSWAP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:139
msgid "framebuffer endianness doesn't match CPU"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rasops.9:139
#, no-wrap
msgid "Dv RI_CURSOR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:141
msgid "cursor is switched on"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rasops.9:141
#, no-wrap
msgid "Dv RI_CLEAR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:143
msgid "clear display on startup"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rasops.9:143
#, no-wrap
msgid "Dv RI_CENTER"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:145
msgid "center onscreen output"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rasops.9:145
#, no-wrap
msgid "Dv RI_CURSORCLIP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:147
msgid "cursor is currently clipped"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rasops.9:147
#, no-wrap
msgid "Dv RI_CFGDONE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:150
msgid "E<.Fn rasops_reconfig> completed successfully"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rasops.9:150
#, no-wrap
msgid "Dv RI_NO_AUTO"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:154
msgid ""
"do not generate box drawing characters for ISO fonts.  Use this when it is "
"not safe to allocate memory, for example when setting up an early console."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rasops.9:154
#, no-wrap
msgid "Dv RI_ENABLE_ALPHA"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:159
msgid ""
"set this if the caller supports anti-aliased fonts in the given colour "
"depth.  Without this flag E<.Fn rasops_init> will only pick bitmap fonts."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rasops.9:159
#, no-wrap
msgid "Dv RI_8BIT_IS_RGB"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:164
msgid ""
"set this if the caller uses an R3G3B2 colour map in 8 bit.  E<.Fn "
"rasops_init> will generate an appropriate ri_devcmap[] but the caller still "
"needs to set up the actual colour map."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rasops.9:167
#, no-wrap
msgid "Fn rasops_init ri wantrows wantcols"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:178
msgid ""
"Initialise a E<.Em rasops_info> descriptor.  The arguments E<.Fa wantrows> "
"and E<.Fa wantcols> are the number of rows and columns we'd like.  In terms "
"of optimization, fonts that are a multiple of 8 pixels wide work the best."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rasops.9:178
#, no-wrap
msgid "Fn rasops_reconfig ri wantrows wantcols"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:189
msgid ""
"Reconfigure a E<.Em rasops_info> descriptor because parameters have changed "
"in some way.  The arguments E<.Fa wantrows> and E<.Fa wantcols> are the "
"number of rows and columns we'd like.  Passing zero for either one of them "
"uses the default - normally 80x25 but it can be changed with"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:192
#, no-wrap
msgid ""
"options RASOPS_DEFAULT_WIDTH=80\n"
"options RASOPS_DEFAULT_HEIGHT=25\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:198
msgid ""
"If calling E<.Fn rasops_reconfig> to change the font and ri_wsfcookie "
"\\*[Ge] 0, you must call E<.Fn wsfont_unlock> on it, and reset it to -1 (or "
"a new, valid cookie)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:206
msgid ""
"The rasops subsystem is implemented within the directory E<.Pa "
"sys/dev/rasops>.  The E<.Nm> module itself is implemented within the file "
"E<.Pa sys/dev/rasops/rasops.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:211
msgid "E<.Xr intro 9>, E<.Xr wscons 9>, E<.Xr wsdisplay 9>, E<.Xr wsfont 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:216
msgid "The E<.Nm> subsystem appeared in E<.Nx 1.5>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rasops.9:221
msgid ""
"The E<.Nm> subsystem was written by E<.An Andrew Doran> E<.Aq "
"ad@NetBSD.org>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/ratecheck.9:30
#, no-wrap
msgid "February 2, 2000"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/ratecheck.9:31
#, no-wrap
msgid "RATECHECK 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ratecheck.9:35
msgid "E<.Nm ratecheck>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ratecheck.9:40
msgid ""
"E<.Ft int> E<.Fn ratecheck \"struct timeval *lasttime\" \"const struct "
"timeval *mininterval\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ratecheck.9:56
msgid ""
"The E<.Fn ratecheck> function provides a simple time interval check which "
"can be used when implementing time-based rate-limited actions.  If the "
"difference between the current monotonically-increasing system time E<.Pq Va "
"mono_time> and E<.Fa lasttime> is less than the value given by the E<.Fa "
"mininterval> argument, zero is returned.  Otherwise, E<.Fa lasttime> is set "
"to the current time and a non-zero value is returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ratecheck.9:65
msgid ""
"The motivation for implementing E<.Fn ratecheck> was to provide a mechanism "
"that could be used to add rate limiting to diagnostic message output.  If "
"printed too often, diagnostic messages can keep the system from doing useful "
"work.  If the repeated messages can be caused by deliberate user action or "
"network events, they can be exploited to cause denial of system service."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ratecheck.9:72
msgid ""
"Note that using a very short time interval (less than a second)  for E<.Fa "
"mininterval> defeats the purpose of this function.  (It doesn't take much to "
"flood a 9600 baud serial console with output, for instance.)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ratecheck.9:76
msgid "Here is a simple example of use of the E<.Fn ratecheck> function:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ratecheck.9:85
#, no-wrap
msgid ""
"/*\n"
" * The following variables could be global, in a device softc, etc.,\n"
" * depending on the exact usage.\n"
" */\n"
"struct timeval drv_lasterr1time;   /* time of last err1 message */\n"
"long drv_err1count;                /* # of err1 errs since last msg */\n"
"struct timeval drv_lasterr2time;   /* time of last err2 message */\n"
"long drv_err2count;                /* # of err2 errs since last msg */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ratecheck.9:93
#, no-wrap
msgid ""
"/*\n"
" * The following variable will often be global or shared by all\n"
" * instances of a driver.  It should be initialized, so it can be\n"
" * patched.  Allowing it to be set via an option might be nice,\n"
" * but could lead to an insane proliferation of options.\n"
" */\n"
"struct timeval drv_errintvl = { 5, 0 };         /* 5 seconds */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ratecheck.9:98
#, no-wrap
msgid ""
"/* error handling/reporting function */\n"
"void\n"
"drv_errhandler(int err1, int err2)\n"
"{\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ratecheck.9:106
#, no-wrap
msgid ""
"\t/*\n"
"\t * Note that you should NOT use the same last-event\n"
"\t * time variable for dissimilar messages!\n"
"\t */\n"
"\tif (err1) {\n"
"\t\t/* handle err1 condition */\n"
"\t\t...\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ratecheck.9:118
#, no-wrap
msgid ""
"\t\tdrv_err1count++;\n"
"\t\tif (ratecheck(\\*[Am]drv_lasterr1notice,\n"
"\t\t    \\*[Am]drv_errinterval)) {\n"
"\t\t\tprintf(\"drv: %ld err1 errors occurred\",\n"
"\t\t\t    drv_err1count);\n"
"\t\t\tdrv_err1count = 0;\n"
"\t\t}\n"
"\t}\n"
"\tif (err2) {\n"
"\t\t/* handle err2 condition */\n"
"\t\t...\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ratecheck.9:128
#, no-wrap
msgid ""
"\t\tdrv_err2count++;\n"
"\t\tif (ratecheck(\\*[Am]drv_lasterr2notice,\n"
"\t\t    \\*[Am]drv_errinterval)) {\n"
"\t\t\tprintf(\"drv: %ld err2 errors occurred\",\n"
"\t\t\t    drv_err2count);\n"
"\t\t\tdrv_err2count = 0;\n"
"\t\t}\n"
"\t}\n"
"}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ratecheck.9:134
msgid "E<.Xr log 9>, E<.Xr ppsratecheck 9>, E<.Xr printf 9>, E<.Xr time_second 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ratecheck.9:139
msgid "The E<.Fn ratecheck> function appeared in E<.Nx 1.5>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ratecheck.9:144
msgid ""
"E<.Fn ratecheck> may not work as expected, if E<.Fa mininterval> is less "
"than the hardware clock interrupt interval E<.Pq Li 1/hz>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/resettodr.9:35
#, no-wrap
msgid "March 2, 2006"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/resettodr.9:36
#, no-wrap
msgid "RESETTODR 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/resettodr.9:40
msgid "E<.Nm resettodr>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/resettodr.9:40
#, no-wrap
msgid "set battery-backed clock from system time"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/resettodr.9:44
msgid "E<.Ft void> E<.Fn resettodr \"void\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/resettodr.9:49
msgid ""
"The E<.Fn resettodr> function sets the system's battery-backed clock based "
"on the current system time."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/resettodr.9:52
msgid "E<.Xr clock_secs_to_ymdhms 9>, E<.Xr inittodr 9>, E<.Xr time_second 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/rnd.9:31
#, no-wrap
msgid "RND 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:39
msgid ""
"E<.Nm RND>, E<.Nm rnd_attach_source>, E<.Nm rnd_detach_source>, E<.Nm "
"rnd_add_data>, E<.Nm rnd_add_uint32>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/rnd.9:39
#, no-wrap
msgid "functions to make a device available for entropy collection"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/rnd.9:41
#, no-wrap
msgid "sys/rnd.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:50
msgid ""
"E<.Ft void> E<.Fn rnd_attach_source \"rndsource_element_t *rnd_source\" "
"\"char *devname\" \"uint32_t source_type\" \"uint32_t flags\"> E<.Ft void> "
"E<.Fn rnd_detach_source \"rndsource_element_t *rnd_source\"> E<.Ft void> "
"E<.Fn rnd_add_data \"rndsource_element_t *rnd_source\" \"void *data\" "
"\"uint32_t len\" \"uint32_t entropy\"> E<.Ft void> E<.Fn rnd_add_uint32 "
"\"rndsource_element_t *rnd_source\" \"uint32_t datum\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:60
msgid ""
"These E<.Nm> functions make a device available for entropy collection for "
"the kernel entropy pool, which provides key material for the E<.Xr cprng 9> "
"and E<.Xr rnd 4> E<.Pa ( /dev/random>)  interfaces."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:69
msgid ""
"Ideally the first argument E<.Fa rnd_source> of these functions gets "
"included in the devices' entity struct, but any means to permanently "
"(statically) attach one such argument to one incarnation of the device is "
"ok.  Do not share E<.Fa rnd_source> structures between two devices."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rnd.9:71
#, no-wrap
msgid ""
"Fn rnd_attach_source \"rndsource_element_t *rnd_source\" \"char *devname\" "
"\"uint32_t source_type\" \"uint32_t flags\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:76
msgid ""
"This function announces the availability of a device for entropy "
"collection.  It must be called before the source struct pointed to by E<.Fa "
"rnd_source> is used in any of the following functions."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:82
msgid ""
"E<.Fa devname> is the name of the device.  It is used to print a message (if "
"the kernel is compiled with ``options RND_VERBOSE'') and also for status "
"information printed with E<.Xr rndctl 8>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:98
msgid ""
"E<.Fa source_type> is E<.Dv RND_TYPE_NET> for network devices, E<.Dv "
"RND_TYPE_DISK> for physical disks, E<.Dv RND_TYPE_TAPE> for a tape drive, "
"E<.Dv RND_TYPE_TTY> for a tty, and E<.Dv RND_TYPE_RNG> for a random number "
"generator.  E<.Dv RND_TYPE_UNKNOWN> is not to be used as a type.  It is used "
"internally to the rnd system."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:110
msgid ""
"E<.Fa flags> are the logical OR of E<.Dv RND_FLAG_NO_COLLECT> (don't collect "
"or estimate)  E<.Dv RND_FLAG_NO_ESTIMATE> (don't estimate)  to control the "
"default setting for collection and estimation.  Note that devices of type "
"E<.Dv RND_TYPE_NET> default to E<.Dv RND_FLAG_NO_ESTIMATE>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rnd.9:111
#, no-wrap
msgid "Fn rnd_detach_source \"rndsource_element_t *rnd_source\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:113
msgid "This function disconnects the device from entropy collection."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rnd.9:113
#, no-wrap
msgid "Fn rnd_add_uint32 \"rndsource_element_t *rnd_source\" \"uint32_t datum\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:120
msgid ""
"This function adds the value of E<.Va datum> to the entropy pool.  No "
"entropy is assumed to be collected from this value, it merely helps stir the "
"entropy pool.  All entropy is gathered from jitter between the timing of "
"events."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:128
msgid ""
"Note that using a constant for E<.Va datum> does not weaken security, but it "
"does not help.  Try to use something that can change, such as an interrupt "
"status register which might have a bit set for receive ready or transmit "
"ready, or other device status information."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:133
msgid ""
"To allow the system to gather the timing information accurately, this call "
"should be placed within the actual hardware interrupt service routine.  Care "
"must be taken to ensure that the interrupt was actually serviced by the "
"interrupt handler, since on some systems interrupts can be shared."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:137
msgid ""
"This function loses nearly all usefulness if it is called from a scheduled "
"software interrupt.  If that is the only way to add the device as an entropy "
"source, don't."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:146
msgid ""
"If it is desired to mix in the E<.Va datum> and to add in a timestamp, but "
"not to actually estimate entropy from a source of randomness, passing E<.Dv "
"NULL> for E<.Va rnd_source> is permitted, and the device does not need to be "
"attached."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rnd.9:146
#, no-wrap
msgid ""
"Fn rnd_add_data \"rndsource_element_t *rnd_source\" \"void *data\" "
"\"uint32_t len\" \"uint32_t entropy\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:162
msgid ""
"adds (hopefully) random E<.Fa data> to the entropy pool.  E<.Fa len> is the "
"number of bytes in E<.Fa data> and E<.Fa entropy> is an \"entropy quality\" "
"measurement.  If every bit of E<.Fa data> is known to be random, E<.Fa "
"entropy> is the number of bits in E<.Fa data>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:165
msgid ""
"Timing information is also used to add entropy into the system, using "
"inter-event timings."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:174
msgid ""
"If it is desired to mix in the E<.Va data> and to add in a timestamp, but "
"not to actually estimate entropy from a source of randomness, passing E<.Dv "
"NULL> for E<.Va rnd_source> is permitted, and the device does not need to be "
"attached."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/rnd.9:175
#, no-wrap
msgid "INTERNAL ENTROPY POOL MANAGEMENT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:182
msgid ""
"When a hardware event occurs (such as completion of a hard drive transfer or "
"an interrupt from a network device) a timestamp is generated.  This "
"timestamp is compared to the previous timestamp recorded for the device, and "
"the first, second, and third order differentials are calculated."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:188
msgid ""
"If any of these differentials is zero, no entropy is assumed to have been "
"gathered.  If all are non-zero, one bit is assumed.  Next, data is mixed "
"into the entropy pool using an LFSR (linear feedback shift register)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:193
msgid ""
"To extract data from the entropy pool, a cryptographically strong hash "
"function is used.  The output of this hash is mixed back into the pool using "
"the LFSR, and then folded in half before being returned to the caller."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:199
msgid ""
"Mixing the actual hash into the pool causes the next extraction to return a "
"different value, even if no timing events were added to the pool.  Folding "
"the data in half prevents the caller to derive the actual hash of the pool, "
"preventing some attacks."
msgstr ""

#.  .Sh ERRORS
#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:210
msgid ""
"In the E<.Nx> kernel, values should be extracted from the entropy pool E<.Em "
"only> via the E<.Xr cprng 9> interface.  Direct access to the entropy pool "
"is unsupported and may be dangerous.  There is no supported API for direct "
"access to the output of the entropy pool."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:213
msgid ""
"These functions are declared in src/sys/sys/rnd.h and defined in "
"src/sys/dev/rnd.c."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:217
msgid "E<.Xr rnd 4>, E<.Xr rndctl 8>, E<.Xr cprng 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:220
msgid "The random device was introduced in E<.Nx 1.3>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:224
msgid ""
"This implementation was written by Michael Graff "
"\\*[Lt]explorer@flame.org\\*[Gt] using ideas and algorithms gathered from "
"many sources, including the driver written by Ted Ts'o."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rnd.9:227
msgid ""
"The only good sources of randomness are quantum mechanical, and most "
"computers avidly avoid having true sources of randomness included.  Don't "
"expect to surpass \"pretty good\"."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/roundup.9:30 org_netbsd/src/share/man/man9/uvm.9:27
#, no-wrap
msgid "June 1, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/roundup.9:31
#, no-wrap
msgid "ROUNDUP 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/roundup.9:35
msgid "E<.Nm roundup>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/roundup.9:35
#, no-wrap
msgid "macros for counting and rounding"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/roundup.9:48
msgid ""
"E<.Ft size> E<.Fn howmany \"x\" \"size\"> E<.Ft size> E<.Fn roundup \"x\" "
"\"size\"> E<.Ft size> E<.Fn rounddown \"x\" \"size\"> E<.Ft size> E<.Fn "
"roundup2 \"x\" \"size\"> E<.Ft int> E<.Fn powerof2 \"x\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/roundup.9:64
msgid ""
"The E<.Fn roundup> and E<.Fn rounddown> macros return an integer from "
"rounding E<.Fa x> up and down, respectively, to the next E<.Fa size>.  The "
"E<.Fn howmany> macro in turn reveals how many times E<.Fa size> fits into "
"E<.Fa x>, rounding the residual up."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/roundup.9:75
msgid ""
"The E<.Fn roundup2> macro also rounds up, but with the assumption that E<.Fa "
"size> is a power of two.  If E<.Fa x> is indeed a power of two, E<.Fn "
"powerof2> return 1."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/roundup.9:85
msgid ""
"The return value is an integer from the respective operation.  If E<.Fa x> "
"is 0, all macros except E<.Fn powerof2> return 0.  The behavior is undefined "
"if E<.Fa size> is 0."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/roundup.9:89
msgid "The following example rounds the variable E<.Va rx> to a 32-bit boundary:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/roundup.9:91
#, no-wrap
msgid "uint16_t rx;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/roundup.9:95
#, no-wrap
msgid "rx = roundup2(rx, sizeof(uint32_t));\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/roundup.9:100
msgid "E<.Xr ilog2 3>, E<.Xr param 3>, E<.Xr imax 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/roundup.9:102
msgid ""
"All described macros make no assumptions about the type of the parameters.  "
"These are implicitly assumed to be unsigned integers."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/rssadapt.9:30
#, no-wrap
msgid "March 23, 2004"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/rssadapt.9:31
#, no-wrap
msgid "RSSADAPT 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:40
msgid ""
"E<.Nm rssadapt>, E<.Nm ieee80211_rssadapt_choose>, E<.Nm "
"ieee80211_rssadapt_input>, E<.Nm ieee80211_rssadapt_lower_rate>, E<.Nm "
"ieee80211_rssadapt_raise_rate>, E<.Nm ieee80211_rssadapt_updatestats>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/rssadapt.9:40
#, no-wrap
msgid "rate adaptation based on received signal strength"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/rssadapt.9:43
#, no-wrap
msgid "net80211/ieee80211_rssadapt.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:60
msgid ""
"E<.Ft void> E<.Fn ieee80211_rssadapt_input \"struct ieee80211com *ic\" "
"\"struct ieee80211_node *ni\" \"struct ieee80211_rssadapt *ra\" \"int "
"rssi\"> E<.Ft void> E<.Fn ieee80211_rssadapt_lower_rate \"struct "
"ieee80211com *ic\" \"struct ieee80211_node *ni\" \"struct ieee80211_rssadapt "
"*ra\" \"struct ieee80211_rssdesc *id\"> E<.Ft void> E<.Fn "
"ieee80211_rssadapt_raise_rate \"struct ieee80211com *ic\" \"struct "
"ieee80211_rssadapt *ra\" \"struct ieee80211_rssdesc *id\"> E<.Ft void> E<.Fn "
"ieee80211_rssadapt_updatestats \"struct ieee80211_rssadapt *ra\"> E<.Ft int> "
"E<.Fn ieee80211_rssadapt_choose \"struct ieee80211_rssadapt *ra\" \"struct "
"ieee80211_rateset *rs\" \"struct ieee80211_frame *wh\" \"u_int len\" \"int "
"fixed_rate\" \"const char *dvname\" \"int do_not_adapt\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:74
msgid ""
"The E<.Nm> module provides rapid adaptation of transmission data rate to "
"802.11 device drivers based on received-signal strength E<.Pq RSS>.  A "
"driver needs only to provide E<.Nm> with indications of RSS and "
"failure/success of transmissions for each 802.11 client or peer.  For each "
"transmit packet, E<.Nm> chooses the transmission data rate that offers the "
"best expected throughput, given the packet's length and destination."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:89
msgid ""
"E<.Nm> models an 802.11 channel very simply E<.Po> see also the E<.Sx BUGS> "
"section E<.Pc>.  It assumes that the packet-error rate E<.Pq PER> is "
"determined by the signal-to-noise ratio E<.Pq S/N> at the receiver, the "
"transmission data rate, and the packet length.  The S/N determines the "
"choice of data rate that yields the lowest PER for all packets of a certain "
"length."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rssadapt.9:91
#, no-wrap
msgid "Fn ieee80211_rssadapt_choose ra rs wh len fixed_rate dvname do_not_adapt"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:94
msgid "Choose the transmission data rate for a packet."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rssadapt.9:95 org_netbsd/src/share/man/man9/rssadapt.9:156 org_netbsd/src/share/man/man9/rssadapt.9:178 org_netbsd/src/share/man/man9/rssadapt.9:198
#, no-wrap
msgid "Fa ra"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:103
msgid ""
"Ordinarily, the E<.Nm> state object belonging to the node which is the "
"packet destination.  However, if the destination is a broadcast/multicast "
"address, then E<.Fa ra> belongs to the BSS node, E<.Va ic-\\*[Gt]ic_bss>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rssadapt.9:103
#, no-wrap
msgid "Fa rs"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:106
msgid ""
"A list of eligible data rates for the node; for example, the rates "
"negotiated when the node associated with the network."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:110
msgid ""
"The packet length in bytes, including the 802.11 header and frame check "
"sequence E<.Pq FCS>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rssadapt.9:110
#, no-wrap
msgid "Fa fixed_rate"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:122
msgid ""
"If the operator has set the data rate using, for example, E<.Ic \"ifconfig "
"wi0 media ds1\">, then E<.Fa fixed_rate> tells the index of that rate in "
"E<.Fa rs>.  E<.Nm> obeys a fixed data rate whenever the 802.11 standard "
"allows it: sometimes the standard requires multicast/broadcast packets to be "
"transmitted at a so-called E<.Dq basic rate>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rssadapt.9:122
#, no-wrap
msgid "Fa dvname"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:132
msgid ""
"The device driver uses E<.Fa dvname> to indicate the name of the interface "
"for the purpose of diagnostic and debug messages.  The driver sets E<.Fa "
"dvname> to E<.Dv NULL> when no messages are desired."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rssadapt.9:132
#, no-wrap
msgid "Fa do_not_adapt"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:140
msgid ""
"If E<.Fa do_not_adapt> is non-zero, then E<.Fn ieee80211_rssadapt_choose> "
"will choose the highest rate in E<.Fa rs> that suits the destination, "
"regardless of the RSS."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:146
msgid ""
"The return value of E<.Fn ieee80211_rssadapt_choose> is an index into E<.Fa "
"rs>, indicating its choice of transmit data rate."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rssadapt.9:146
#, no-wrap
msgid "Fn ieee80211_rssadapt_input ic ni ra rssi"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:151
msgid ""
"The RSS serves as a rough estimate of the S/N at each node.  A driver "
"provides RSS updates using E<.Fn ieee80211_rssadapt_input>, whose arguments "
"are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rssadapt.9:152 org_netbsd/src/share/man/man9/rssadapt.9:174
#, no-wrap
msgid "Fa ic"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:154
msgid "The wireless interface's 802.11 state object."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rssadapt.9:154 org_netbsd/src/share/man/man9/rssadapt.9:176
#, no-wrap
msgid "Fa ni"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:156
msgid "The 802.11 node whose RSS the driver is updating."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:160
msgid "The node's E<.Nm> state object."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rssadapt.9:160
#, no-wrap
msgid "Fa rssi"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:165
msgid ""
"The node's received signal strength indication.  The range of E<.Fa rssi> is "
"from 0 to 255."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rssadapt.9:166
#, no-wrap
msgid "Fn ieee80211_rssadapt_lower_rate ic ni ra id"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rssadapt.9:167
#, no-wrap
msgid "Fn ieee80211_rssadapt_raise_rate ic ra id"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:173
msgid ""
"Drivers call E<.Fn ieee80211_rssadapt_raise_rate> and E<.Fn "
"ieee80211_rssadapt_lower_rate> to indicate transmit successes and failures, "
"respectively."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:176
msgid "The 802.11 state object."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:178
msgid "The neighbor to whom the driver transmitted."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:182 org_netbsd/src/share/man/man9/rssadapt.9:202
msgid "The neighbor's E<.Nm> state object."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rssadapt.9:182 org_netbsd/src/share/man/man9/secmodel.9:96 org_netbsd/src/share/man/man9/secmodel.9:147
#, no-wrap
msgid "Fa id"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:184
msgid "DIsplays statistics on the transmission attempt."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rssadapt.9:185
#, no-wrap
msgid "Fn ieee80211_rssadapt_updatestats ra"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:197
msgid ""
"An 802.11 node is eligible for its RSS thresholds to decay every 1/10 to 10 "
"seconds.  It is eligible more often (every 1/10 second) at high packet "
"rates, and less often (every 10 seconds) at low packet rates.  A driver "
"assists E<.Nm> in tracking the exponential-average packet rate by calling "
"E<.Fn ieee80211_rssadapt_updatestats> every 1/10th second for each node's "
"E<.Vt ieee80211_rssadapt> object."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/rssadapt.9:204
#, no-wrap
msgid "ALGORITHM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:254
msgid ""
"E<.Nm> monitors the RSS from neighboring 802.11 nodes, recording the "
"exponential average RSS in each neighbor's E<.Vt ieee80211_rssadapt> "
"structure.  E<.Nm> uses transmit success/failure feedback from the device "
"driver to fill a table of RSS thresholds.  The table is indexed by packet "
"size, E<.Va L>, and a data rate, E<.Va R>, to find out the minimum "
"exponential-average RSS that a node must show before E<.Nm> will indicate "
"that a packet E<.Va L> bytes long can be transmitted R bits per second with "
"optimal expected throughput.  When the driver indicates a unicast packet is "
"transmitted unsuccessfully E<.Po> that is, the NIC received no ACK for the "
"packet E<.Pc>, E<.Nm> will move the corresponding RSS threshold toward the "
"exponential average RSSI at the time of transmission.  Thus several "
"consecutive transmit failures for the same E<.Ao> E<.Va L>, E<.Va R> E<.Ac> "
"tuple will ensure that the RSS threshold rises high enough that rate E<.Va "
"R> is abandoned for packets E<.Va L> bytes long.  When the driver indicates "
"a successful transmission, the RSS threshold corresponding to the same "
"packet length, but the next higher data rate, is lowered slightly.  The RSS "
"threshold is said to E<.Dq decay>.  This ensures that occasionally E<.Nm> "
"indicates the driver should try the next higher data rate, just in case "
"conditions at the receiver have changed E<.Po> for example, noise levels "
"have fallen E<.Pc> and a higher data rate can be supported at the same RSS "
"level."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:265
msgid ""
"The rate of decay is controlled.  In an interval of 1/10th second to 10 "
"seconds, only one RSS threshold per neighbor may decay.  The interval is "
"connected to the exponential-average rate that packets are being "
"transmitted.  At high packet rates, the interval is shortest.  It is longest "
"at low packet rates.  The rationale for this is that RSS thresholds should "
"not decay rapidly if there is no information from packet transmissions to "
"counteract their decay."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:269
msgid "An E<.Vt ieee80211_rssdesc> describes a transmission attempt."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:277
#, no-wrap
msgid ""
"struct ieee80211_rssdesc {\n"
"        u_int                    id_len;\n"
"        u_int                    id_rateidx;\n"
"        struct ieee80211_node   *id_node;\n"
"        u_int8_t                 id_rssi;\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:292
msgid ""
"E<.Fa id_len> is the length, in bytes, of the transmitted packet.  E<.Fa "
"id_node> points to the neighbor's E<.Vt ieee8021_node>, and E<.Fa id_rssi> "
"is the exponential-average RSS at the time the packet was transmitted.  "
"E<.Fa id_rateidx> is an index into the destination-neighbor's rate-set, "
"E<.Fa id_node-\\*[Gt]ni_rates>, indicating the transmit data rate for the "
"packet."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:305
msgid ""
"An E<.Vt ieee80211_rssadapt> contains the rate-adaptation state for a "
"neighboring 802.11 node.  Ordinarily a driver will E<.Dq subclass> E<.Vt "
"ieee80211_node>.  The E<.Vt ieee80211_rssadapt> structure will be a subclass "
"member.  In this way, every node's E<.Nm> condition is independently tracked "
"and stored in its node object."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:317
#, no-wrap
msgid ""
"struct ieee80211_rssadapt {\n"
"        u_int16_t               ra_avg_rssi;\n"
"        u_int32_t               ra_nfail;\n"
"        u_int32_t               ra_nok;\n"
"        u_int32_t               ra_pktrate;\n"
"        u_int16_t               ra_rate_thresh[IEEE80211_RSSADAPT_BKTS]\n"
"                                              [IEEE80211_RATE_SIZE];\n"
"        struct timeval          ra_last_raise;\n"
"        struct timeval          ra_raise_interval;\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:353
msgid ""
"E<.Fa ra_avg_rssi> is the exponential-average RSS, shifted left 8 bits.  "
"E<.Fa ra_nfail> tells the number of transmit failures in the current update "
"interval.  E<.Fa ra_nok> tells the number of transmit successes in the "
"current update interval.  E<.Fa ra_pktrate> tells the exponential average "
"number of transmit failure/success indications over past update intervals.  "
"This approximates the rate of packet-transmission.  E<.Fa ra_rate_thresh> "
"contains RSS thresholds that are indexed by E<.Aq \"packet length, data "
"rate\"> tuples.  When this node's exponential-average RSS exceeds E<.Fa "
"ra_rate_thresh[i][j]>, then packets at most 128 x 8^i bytes long are "
"eligible to be transmitted at the rate indexed by j.  E<.Fa ra_last_raise> "
"and E<.Fa ra_raise_interval> are used to control the rate that RSS "
"thresholds E<.Dq decay>.  E<.Fa ra_last_raise> indicates when E<.Fn "
"ieee80211_rssadapt_raise_rate> was last called.  E<.Fa ra_raise_interval> "
"tells the minimum period between consecutive calls to E<.Fn "
"ieee80211_rssadapt_raise_rate>.  If E<.Fn ieee80211_rssadapt_raise_rate> is "
"called more than once in any period, the second and subsequent calls are "
"ignored."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:358
msgid "The code for E<.Nm> is in the file E<.Pa sys/net80211/ieee80211_rssadapt.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:363
msgid ""
"E<.Xr wi 4> contains a reference implementation.  See E<.Pa "
"sys/dev/ic/wi.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:375
msgid ""
"E<.Xr wi 4> E<.Rs> E<.%A Javier del Prado Pavon> E<.%A Sunghyun Choi> E<.%T "
"\"Link Adaptation Strategy for IEEE 802.11 WLAN via Received Signal Strength "
"Measurement\"> E<.%J \"ICC'03\"> E<.%P pp. 1108-1113> E<.%C Anchorage, "
"Alaska> E<.%D May 2003> E<.Re>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:379
msgid "E<.Nm> first appeared in E<.Nx 3.0>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:386
msgid ""
"To cope with interference from microwave ovens, frequency-hopping radios, "
"and other sources of RF pulse-trains and bursts, E<.Nm> should adapt the "
"fragmentation threshold as well as the data rate."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:391
msgid ""
"For improved throughput, E<.Nm> should indicate to drivers when they should "
"use the 802.11b short-preamble."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rssadapt.9:394
msgid ""
"The constants in E<.Fn ieee80211_rssadapt_updatestats> should be "
"configurable."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/rt_timer.9:31
#, no-wrap
msgid "April 23, 1998"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/rt_timer.9:32
#, no-wrap
msgid "RT_TIMER 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rt_timer.9:41
msgid ""
"E<.Nm rt_timer>, E<.Nm rt_timer_add>, E<.Nm rt_timer_queue_create>, E<.Nm "
"rt_timer_queue_change>, E<.Nm rt_timer_queue_destroy>, E<.Nm "
"rt_timer_remove_all>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/rt_timer.9:41
#, no-wrap
msgid "route callout functions"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/rt_timer.9:43
#, no-wrap
msgid "net/route.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rt_timer.9:55
msgid ""
"E<.Ft \"struct rttimer_queue *\"> E<.Fn rt_timer_queue_create \"time_t "
"timeout\"> E<.Ft void> E<.Fn rt_timer_queue_change \"struct rttimer_queue "
"*q\" \"time_t timeout\"> E<.Ft void> E<.Fn rt_timer_queue_destroy \"struct "
"rttimer_queue *q\" \"int destroy\"> E<.Ft int> E<.Fn rt_timer_add \"struct "
"rtentry *rt\" \"void(*f)(struct rtentry *, struct rttimer *)\" \"struct "
"rttimer_queue *q\"> E<.Ft void> E<.Fn rt_timer_remove_all \"struct rtentry "
"*rt\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rt_timer.9:62
msgid ""
"The E<.Nm> functions provide a generic route callout functionality.  They "
"allow a function to be called for a route at any time.  This was originally "
"intended to be used to remove routes added by path MTU discovery code."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rt_timer.9:71
msgid ""
"For maximum efficiency, a separate queue should be defined for each timeout "
"period.  For example, one queue should be created for the 10 minute path MTU "
"discovery timeouts, another for 20 minute ARP timeouts after 20 minutes, and "
"so on.  This permits extremely fast queue manipulations so that the timeout "
"functions remain scalable, even in the face of thousands of route "
"manipulations per minute."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rt_timer.9:75
msgid ""
"It is possible to create only a single timeout queue for all possible "
"timeout values, but doing so is not scalable as queue manipulations become "
"quite expensive if the timeout deltas are not roughly constant."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rt_timer.9:79
msgid "The E<.Nm> interface provides the following functions:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rt_timer.9:80
#, no-wrap
msgid "Fn rt_timer_queue_create \"time_t timeout\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rt_timer.9:84
msgid ""
"This function creates a new timer queue with the specified timeout period "
"E<.Fa timeout>, expressed in seconds."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rt_timer.9:84
#, no-wrap
msgid "Fn rt_timer_queue_change \"rttimer_queue *q\" \"time_t timeout\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rt_timer.9:90
msgid ""
"This function modifies the timeout period for a timer queue.  Any value, "
"including 0, is valid.  The next time the timer queue's timeout expires "
"(based on the previous timeout value), all entries which are valid to "
"execute based on the new timeout will be executed, and the new timeout "
"period scheduled."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rt_timer.9:90
#, no-wrap
msgid "Fn rt_timer_queue_destroy \"rttimer_queue *q\" \"int destroy\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rt_timer.9:95
msgid ""
"This function destroys a timeout queue.  All entries are removed, and if the "
"E<.Fa destroy> argument is non-zero, the timeout action is performed for "
"each entry."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rt_timer.9:95
#, no-wrap
msgid ""
"Fn rt_timer_add \"struct rtentry *rt\" \"void(*f)(struct rtentry *, struct "
"rttimer *)\" \"struct rttimer_queue *q\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rt_timer.9:107
msgid ""
"This function adds an entry to a timeout queue.  The function E<.Fa f> will "
"be called after the timeout period for queue E<.Fa q> has elapsed.  If E<.Fa "
"f> is NULL the route will be deleted when the timeout expires."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rt_timer.9:107
#, no-wrap
msgid "Fn rt_timer_remove_all \"struct rtentry *rt\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rt_timer.9:113
msgid ""
"This function removes all references to the given route from the E<.Nm> "
"subsystem.  This is used when a route is deleted to ensure that no dangling "
"references remain."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rt_timer.9:117
msgid "E<.Xr netstat 1>, E<.Xr arp 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rt_timer.9:122
msgid "The E<.Nm> interface appeared in E<.Nx 1.4>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rt_timer.9:127
msgid ""
"This interface is roughly based on (but, alas, not compatible with) one "
"designed by David Borman of BSDI.  This implementation is by Kevin Lahey of "
"the Numerical Aerospace Simulation Facility, NASA Ames Research Center."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rt_timer.9:133
msgid ""
"The E<.Nm> interface is implemented in E<.Pa sys/net/route.h> and E<.Pa "
"sys/net/route.c>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/rwlock.9:30
#, no-wrap
msgid "November 22, 2009"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/rwlock.9:31
#, no-wrap
msgid "RWLOCK 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:45
msgid ""
"E<.Nm rw>, E<.Nm rw_init>, E<.Nm rw_destroy>, E<.Nm rw_enter>, E<.Nm "
"rw_exit>, E<.Nm rw_tryenter>, E<.Nm rw_tryupgrade>, E<.Nm rw_downgrade>, "
"E<.Nm rw_read_held>, E<.Nm rw_write_held>, E<.Nm rw_lock_held>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/rwlock.9:45
#, no-wrap
msgid "reader / writer lock primitives"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/rwlock.9:47
#, no-wrap
msgid "sys/rwlock.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:68
msgid ""
"E<.Ft void> E<.Fn rw_init \"krwlock_t *rw\"> E<.Ft void> E<.Fn rw_destroy "
"\"krwlock_t *rw\"> E<.Ft void> E<.Fn rw_enter \"krwlock_t *rw\" \"const "
"krw_t op\"> E<.Ft void> E<.Fn rw_exit \"krwlock_t *rw\"> E<.Ft int> E<.Fn "
"rw_tryenter \"krwlock_t *rw\" \"const krw_t op\"> E<.Ft int> E<.Fn "
"rw_tryupgrade \"krwlock_t *rw\"> E<.Ft void> E<.Fn rw_downgrade \"krwlock_t "
"*rw\"> E<.Ft int> E<.Fn rw_read_held \"krwlock_t *rw\"> E<.Ft int> E<.Fn "
"rw_write_held \"krwlock_t *rw\"> E<.Ft int> E<.Fn rw_lock_held \"krwlock_t "
"*rw\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:74
msgid ""
"Reader / writer locks (RW locks) are used in the kernel to synchronize "
"access to an object among LWPs (lightweight processes) and soft interrupt "
"handlers."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:77
msgid ""
"In addition to the capabilities provided by mutexes, RW locks distinguish "
"between read (shared) and write (exclusive) access."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:79
msgid "RW locks are in one of three distinct states at any given time:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rwlock.9:80
#, no-wrap
msgid "Dv Unlocked"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:82
msgid "The lock is not held."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rwlock.9:82
#, no-wrap
msgid "Dv Read locked"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:87
msgid ""
"The lock holders intend to read the protected object.  Multiple callers may "
"hold a RW lock with E<.Dq read intent> simultaneously."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rwlock.9:87
#, no-wrap
msgid "Dv Write locked"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:91
msgid ""
"The lock holder intends to update the protected object.  Only one caller may "
"hold a RW lock with E<.Dq write intent>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:98
msgid ""
"The E<.Vt krwlock_t> type provides storage for the RW lock object.  This "
"should be treated as an opaque object and not examined directly by "
"consumers."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:101
msgid ""
"Note that these interfaces must not be used from a hardware interrupt "
"handler."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/rwlock.9:101
#, no-wrap
msgid "OPTIONS AND MACROS"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rwlock.9:103
#, no-wrap
msgid "Cd \"options DIANOSTIC\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:108
msgid ""
"Kernels compiled with the E<.Dv DIAGNOSTIC> option perform basic sanity "
"checks on RW lock operations."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:114
msgid ""
"Kernels compiled with the E<.Dv LOCKDEBUG> option perform potentially CPU "
"intensive sanity checks on RW lock operations."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rwlock.9:117
#, no-wrap
msgid "Fn rw_init rw"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:122
msgid ""
"Initialize a lock for use.  No other operations can be performed on the lock "
"until it has been initialized."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rwlock.9:122
#, no-wrap
msgid "Fn rw_destroy rw"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:126
msgid ""
"Release resources used by a lock.  The lock may not be used after it has "
"been destroyed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rwlock.9:126
#, no-wrap
msgid "Fn rw_enter rw op"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:136
msgid ""
"If E<.Dv RW_READER> is specified as the argument to E<.Fa op>, acquire a "
"read lock.  If the lock is write held, the caller will block and not return "
"until the hold is acquired.  Callers must not recursively acquire read "
"locks."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:142
msgid ""
"If E<.Dv RW_WRITER> is specified, acquire a write lock.  If the lock is "
"already held, the caller will block and not return until the hold is "
"acquired."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:146
msgid ""
"RW locks and other types of locks must always be acquired in a consistent "
"order with respect to each other.  Otherwise, the potential for system "
"deadlock exists."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rwlock.9:146
#, no-wrap
msgid "Fn rw_exit rw"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:150
msgid "Release a lock.  The lock must have been previously acquired by the caller."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rwlock.9:150
#, no-wrap
msgid "Fn rw_tryenter rw op"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:155
msgid ""
"Try to acquire a lock, but do not block if the lock is already held.  If the "
"lock is acquired successfully, return non-zero.  Otherwise, return zero."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:162
msgid "Valid arguments to E<.Fa op> are E<.Dv RW_READER> or E<.Dv RW_WRITER>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rwlock.9:162
#, no-wrap
msgid "Fn rw_tryupgrade rw"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:167
msgid ""
"Try to upgrade a lock from one read hold to a write hold.  If the lock is "
"upgraded successfully, returns non-zero.  Otherwise, returns zero."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rwlock.9:167
#, no-wrap
msgid "Fn rw_downgrade rw"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:170
msgid "Downgrade a lock from a write hold to a read hold."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rwlock.9:170
#, no-wrap
msgid "Fn rw_write_held rw"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rwlock.9:171
#, no-wrap
msgid "Fn rw_read_held rw"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/rwlock.9:172
#, no-wrap
msgid "Fn rw_lock_held rw"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:177
msgid ""
"Test the lock's condition and return non-zero if the lock is held "
"(potentially by the current LWP) and matches the specified condition.  "
"Otherwise, return zero."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:180
msgid ""
"These functions must never be used to make locking decisions at run time: "
"they are provided only for diagnostic purposes."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/rwlock.9:181
#, no-wrap
msgid "PERFORMANCE CONSIDERATIONS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:187
msgid ""
"RW locks are subject to high cache contention on multiprocessor systems, and "
"scale poorly when the write:read ratio is not strongly in favour of "
"readers.  Ideally, RW locks should only be used in settings when the "
"following three conditions are met:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:191
msgid ""
"The data object(s) protected by the RW lock are read much more frequently "
"than written."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:194
msgid ""
"The read-side hold time for the RW lock is long (in the order of thousands "
"of processor clock cycles)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:197
msgid ""
"Strong synchronization semantics are required: there is no scope for "
"lockless, lazy or optimistic synchronization."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:202
msgid ""
"Generally speaking, it is better to organise code paths and/or data flows "
"such that fewer and weaker synchronization points are required to ensure "
"correct operation."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:205
msgid "The core of the RW lock implementation is in E<.Pa sys/kern/kern_rwlock.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:210
msgid ""
"The header file E<.Pa sys/sys/rwlock.h> describes the public interface, and "
"interfaces that machine-dependent code must provide to support RW locks."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:223
msgid ""
"E<.Xr lockstat 8>, E<.Xr condvar 9>, E<.Xr mb 9>, E<.Xr mutex 9> E<.Rs> "
"E<.%A Jim Mauro> E<.%A Richard McDougall> E<.%T Solaris Internals: Core "
"Kernel Architecture> E<.%I Prentice Hall> E<.%D 2001> E<.%O ISBN "
"0-13-022496-0> E<.Re>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/rwlock.9:225
msgid "The RW lock primitives first appeared in E<.Nx 5.0>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/scanc.9:28 org_netbsd/src/share/man/man9/skpc.9:28
#, no-wrap
msgid "November 1, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/scanc.9:29
#, no-wrap
msgid "SCANC 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scanc.9:34
msgid "E<.Nm scanc>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/scanc.9:34
#, no-wrap
msgid "use byte string as lookup table index"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/scanc.9:37 org_netbsd/src/share/man/man9/skpc.9:37
#, no-wrap
msgid "lib/libkern/libkern.h"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/scanc.9:43
msgid ""
"E<.Ft int> E<.Fn scanc \"size_t size\" \"const u_char *cp\" \"const u_char "
"table[]\" \"int mask\">"
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/scanc.9:56
msgid ""
"The E<.Fn scanc> function scans the byte string E<.Fa cp>, whose length is "
"E<.Fa size>.  A character in the string is used as an index in the 256-byte "
"E<.Fa table>.  If a bitwise-AND of the byte from the table and E<.Fa mask> "
"isn't zero or the string is exhausted, the scan stops."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/scanc.9:61
msgid "The E<.Fn scanc> function returns the number of characters skipped."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scanc.9:64
msgid "The E<.Fn scanc> function emulates a VAX instruction with the same name."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/sched_4bsd.9:30
#, no-wrap
msgid "July 14, 2007"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/sched_4bsd.9:31
#, no-wrap
msgid "SCHED_4BSD 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sched_4bsd.9:35
msgid "E<.Nm sched_4bsd>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/sched_4bsd.9:35
#, no-wrap
msgid "The 4.4BSD thread scheduler"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sched_4bsd.9:50
msgid ""
"E<.Ft void> E<.Fn resetpriority \"lwp_t *l\"> E<.Ft void> E<.Fn sched_tick "
"\"struct cpu_info *ci\"> E<.Ft void> E<.Fn sched_schedclock \"lwp_t *l\"> "
"E<.Ft void> E<.Fn sched_pstats_hook \"struct proc *p\" \"int minslp\"> E<.Ft "
"void> E<.Fn sched_setrunnable \"lwp_t *l\"> E<.Ft void> E<.Fn updatepri "
"\"lwp_t *l\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sched_4bsd.9:57
msgid ""
"The traditional E<.Bx 4.4> scheduler employs a E<.Dq multilevel feedback "
"queues> algorithm, favouring interactive, short-running threads to CPU-bound "
"ones."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sched_4bsd.9:62
msgid ""
"E<.Fn resetpriority> recomputes the priority of a thread running in user "
"mode.  If the resulting priority is higher than that of the current thread, "
"a reschedule is arranged."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sched_4bsd.9:67
msgid ""
"E<.Fn sched_tick> gets called from E<.Xr hardclock 9> every 100ms to force a "
"switch between equal priority threads."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sched_4bsd.9:71
msgid ""
"The priority of the current thread is adjusted through E<.Fn "
"sched_schedclock>.  The priority of a thread gets worse as it accumulates "
"CPU time."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sched_4bsd.9:76
msgid ""
"E<.Fn sched_pstats_hook> gets called from E<.Fn sched_pstats> every Hz ticks "
"in order to recompute the priorities of all threads."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sched_4bsd.9:81
msgid ""
"E<.Fn sched_setrunnable> checks if an LWP has slept for more than one "
"second.  If so, its priority is updated by E<.Fn updatepri>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sched_4bsd.9:86
msgid ""
"The E<.Bx 4.4> scheduler subsystem is implemented within the file E<.Pa "
"sys/kern/sched_4bsd.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sched_4bsd.9:100
msgid ""
"E<.Xr csf 9>, E<.Xr hardclock 9>, E<.Xr mi_switch 9>, E<.Xr sched_m2 9>, "
"E<.Xr userret 9> E<.Rs> E<.%A Marshall Kirk McKusick> E<.%A Keith Bostic> "
"E<.%A Michael J. Karels> E<.%A John S. Quarterman> E<.%B \"The Design and "
"Implementation of the 4.4BSD Operating System\"> E<.%I \"Addison Wesley\"> "
"E<.%D 1996> E<.Re>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/sched_m2.9:30
#, no-wrap
msgid "March 5, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/sched_m2.9:31
#, no-wrap
msgid "SCHED_M2 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sched_m2.9:35
msgid "E<.Nm sched_m2>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/sched_m2.9:35
#, no-wrap
msgid "The M2 thread scheduler"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sched_m2.9:41
msgid ""
"The M2 scheduler implements a scheduling algorithm similar to the scheduler "
"implementations of UNIX System V Release 4 and Solaris."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sched_m2.9:44
msgid "The M2 scheduler is implemented within the file E<.Pa sys/kern/sched_m2.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sched_m2.9:56
msgid ""
"E<.Xr csf 9>, E<.Xr hardclock 9>, E<.Xr mi_switch 9>, E<.Xr sched_4bsd 9>, "
"E<.Xr userret 9> E<.Rs> E<.%A Berny Goodheart> E<.%A James Cox> E<.%B \"The "
"Magic Garden Explained: The Internals of UNIX System V Release 4\"> E<.%I "
"\"Prentice Hall\"> E<.%D 1994> E<.Re>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/scsipi.9:28
#, no-wrap
msgid "SCSIPI 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:32
msgid "E<.Nm scsipi>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/scsipi.9:32
#, no-wrap
msgid "SCSI/ATAPI middle-layer interface"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/scsipi.9:34
#, no-wrap
msgid "dev/scsipi/atapiconf.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/scsipi.9:35
#, no-wrap
msgid "dev/scsipi/scsiconf.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:58
msgid ""
"E<.Ft void> E<.Fn scsipi_async_event \"struct scsipi_channel *chan\" "
"\"scsipi_async_event_t event\" \"void *arg\"> E<.Ft void> E<.Fn "
"scsipi_channel_freeze \"struct scsipi_channel *chan\" \"int count\"> E<.Ft "
"void> E<.Fn scsipi_channel_thaw \"struct scsipi_channel *chan\" \"int "
"count\"> E<.Ft void> E<.Fn scsipi_channel_timed_thaw \"void *arg\"> E<.Ft "
"void> E<.Fn scsipi_periph_freeze \"struct scsipi_periph *periph\" \"int "
"count\"> E<.Ft void> E<.Fn scsipi_periph_thaw \"struct scsipi_periph "
"*periph\" \"int count\"> E<.Ft void> E<.Fn scsipi_periph_timed_thaw \"void "
"*arg\"> E<.Ft void> E<.Fn scsipi_done \"struct scsipi_xfer *xs\"> E<.Ft "
"void> E<.Fn scsipi_printaddr \"struct scsipi_periph *periph\"> E<.Ft int> "
"E<.Fn scsipi_target_detach \"struct scsipi_channel *chan\" \"int target\" "
"\"int lun\" \"int flags\"> E<.Ft int> E<.Fn scsipi_thread_call_callback "
"\"struct scsipi_channel *chan\" \"void (*callback)(struct scsipi_channel *, "
"void *)\" \"void *arg\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:78
msgid ""
"The E<.Nm> system is the middle layer interface between SCSI/ATAPI host bus "
"adapters (HBA) and high-level SCSI/ATAPI drivers.  This document describes "
"the interfaces provided by the E<.Nm> layer towards the HBA layer.  An HBA "
"has to provide a pointer to a E<.Va struct scsipi_adapter> and one pointer "
"per channel to a E<.Va struct scsipi_channel>.  Once the SCSI or ATAPI bus "
"is attached, the E<.Nm> system will scan the bus and allocate a E<.Va struct "
"scsipi_periph> for each device found on the bus.  A high-level command "
"(command sent from the high-level SCSI/ATAPI layer to the low-level HBA "
"layer) is described by a E<.Va struct scsipi_xfer>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:89
msgid ""
"A request is sent to the HBA driver through the E<.Fn adapt_request> "
"callback.  The HBA driver signals completion (with or without errors) of the "
"request through E<.Fn scsipi_done>.  E<.Nm> knows the resource's limits of "
"the HBA (max number of concurrent requests per adapter of channel, and per "
"periph), and will make sure the HBA won't receive more requests than it can "
"handle."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:95
msgid ""
"The mid-layer can also handle E<.Dv QUEUE FULL> and E<.Dv CHECK CONDITION> "
"events."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/scsipi.9:95
#, no-wrap
msgid "INITIALISATION"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:99
msgid ""
"An HBA driver has to allocate and initialize to 0 a E<.Va struct "
"scsipi_adapter> and fill in the following members:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:100
#, no-wrap
msgid "Va struct device *adapt_dev"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:103
msgid "pointer to the HBA's E<.Va struct device>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:103
#, no-wrap
msgid "Va int adapt_nchannels"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:105
msgid "number of channels (or busses) of the adapter"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:105
#, no-wrap
msgid "Va int adapt_openings"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:109
msgid ""
"total number of commands the adapter can handle (may be replaced by E<.Va "
"chan_openings>, see below)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:109
#, no-wrap
msgid "Va int adapt_max_periph"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:111
msgid "number of commands the adapter can handle per device"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:115
msgid ""
"The following callbacks should be provided through the E<.Va struct "
"scsipi_adapter>:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:116
#, no-wrap
msgid ""
"void Fn (*adapt_request) \"struct scsipi_channel *\" scsipi_adapter_req_t "
"\"void *\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:118 org_netbsd/src/share/man/man9/scsipi.9:120
msgid "mandatory"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:118
#, no-wrap
msgid "void Fn (*adapt_minphys) \"struct buf *\""
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:120
#, no-wrap
msgid ""
"int Fn (*adapt_ioctl) \"struct scsipi_channel *\" u_long \"void *\" int "
"\"struct lwp *\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:122
msgid "optional"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:122
#, no-wrap
msgid "int Fn (*adapt_enable) \"struct device *\" int"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:126 org_netbsd/src/share/man/man9/scsipi.9:130 org_netbsd/src/share/man/man9/scsipi.9:134
msgid "optional, set to E<.Dv NULL> if not used"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:126
#, no-wrap
msgid ""
"int Fn (*adapt_getgeom) \"struct scsipi_periph *\" \"struct disk_parms *\" "
"u_long"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:130
#, no-wrap
msgid ""
"int Fn (*adapt_accesschk) \"struct scsipi_periph *\" \"struct "
"scsipi_inquiry_pattern *\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:139
msgid ""
"The HBA driver has to allocate and initialize to 0 one E<.Va struct "
"scsipi_channel> per channel and fill in the following members:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:140
#, no-wrap
msgid "Va struct scsipi_adapter *chan_adapter"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:143
msgid "Pointer to the HBA's E<.Fa struct scsipi_adapter>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:143
#, no-wrap
msgid "Va struct scsipi_bustype *chan_bustype"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:151
msgid ""
"should be initialized to either E<.Va bus_atapi> or E<.Va bus_scsi>, both "
"defined in the E<.Nm> code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:151
#, no-wrap
msgid "Va int chan_channel"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:153
msgid "channel number (starting at 0)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:153
#, no-wrap
msgid "Va int chan_flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:155
msgid "channel flags:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:156
#, no-wrap
msgid "Dv SCSIPI_CHAN_OPENINGS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:161
msgid ""
"Use per-channel max number of commands E<.Va chan_openings> instead of "
"per-adapter E<.Va adapt_openings>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:161
#, no-wrap
msgid "Dv SCSIPI_CHAN_CANGROW"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:169
msgid ""
"This channel can grow its E<.Va chan_openings> or E<.Va adapt_openings> on "
"request (via the E<.Fn adapt_request> callback)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:169
#, no-wrap
msgid "Dv SCSIPI_CHAN_NOSETTLE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:172
msgid ""
"Do not wait SCSI_DELAY seconds for devices to settle before probing (usually "
"used by adapters that provide an \\*qabstracted\\*q view of the bus)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:173
#, no-wrap
msgid "Va int chan_openings"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:178
msgid ""
"total number of commands the adapter can handle for this channel (used only "
"if the E<.Dv SCSIPI_CHAN_OPENINGS> flag is set)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:178
#, no-wrap
msgid "Va chan_max_periph"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:183
msgid ""
"number of commands per device the adapter can handle on this channel (used "
"only if the E<.Va SCSIPI_CHAN_OPENINGS> flag is set)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:183
#, no-wrap
msgid "Va int chan_ntargets"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:185
msgid "number of targets"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:185
#, no-wrap
msgid "Va int chan_nluns"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:187
msgid "number of LUNs per target"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:187
#, no-wrap
msgid "Va int chan_id"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:189
msgid "adapter's ID on this channel"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:189
#, no-wrap
msgid "Va int chan_defquirks"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:192
msgid "default device quirks.  Quirks are defined in"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/scsipi.9:192 org_netbsd/src/share/man/man9/scsipi.9:225
#, no-wrap
msgid "dev/scsipi/scsipiconf.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:197
msgid ""
"and are usually set in the middle layer based on the device's inquiry data.  "
"For some kinds of adapters it may be convenient to have a set of quirks "
"applied to all devices, regardless of the inquiry data."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:210
msgid ""
"The HBA driver attaches the SCSI or ATAPI bus (depending on the setting of "
"E<.Va chan_bustype>)  by passing a pointer to the E<.Va struct "
"scsipi_channel> to the E<.Xr autoconf 9> machinery.  The print function "
"shall be either E<.Fn scsiprint> or E<.Fn atapiprint>."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/scsipi.9:210
#, no-wrap
msgid "OTHER DATA STRUCTURES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:217
msgid ""
"When scanning the bus, the E<.Nm> system allocates a E<.Va struct "
"scsipi_periph> for each device probed.  The interesting fields are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:218
#, no-wrap
msgid "Va struct device *periph_dev"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:221
msgid "pointer to the device's E<.Va struct device>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:221
#, no-wrap
msgid "Va struct scsipi_channel *periph_channel"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:223
msgid "pointer to the channel the device is connected to"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:223
#, no-wrap
msgid "Va int periph_quirks"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:225
msgid "device quirks, defined in"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:226
#, no-wrap
msgid "Va int periph_target"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:228
msgid "target ID, or drive number on ATAPI"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:228
#, no-wrap
msgid "Va int periph_lun"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:230
msgid "LUN (currently not used on ATAPI)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:235
msgid ""
"A SCSI or ATAPI request is passed to the HBA through a E<.Va struct "
"scsipi_xfer>.  The HBA driver has access to the following data:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:236
#, no-wrap
msgid "Va struct callout xs_callout"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:238
msgid "callout for adapter use, usually for command timeout"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:238
#, no-wrap
msgid "Va int xs_control"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:240
msgid "control flags (only flags of interest for HBA drivers are described):"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:241
#, no-wrap
msgid "Dv XS_CTL_POLL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:244
msgid ""
"poll in the HBA driver for request completion (most likely because "
"interrupts are disabled)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:244
#, no-wrap
msgid "Dv XS_CTL_RESET"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:246
msgid "reset the device"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:246
#, no-wrap
msgid "Dv XS_CTL_DATA_UIO"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:250
msgid "xs_data points to a E<.Fa struct uio> buffer"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:250
#, no-wrap
msgid "Dv XS_CTL_DATA_IN"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:252
msgid "data is transferred from HBA to memory"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:252
#, no-wrap
msgid "Dv XS_CTL_DATA_OUT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:254
msgid "data is transferred from memory to HBA"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:254
#, no-wrap
msgid "Dv XS_CTL_DISCOVERY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:256
msgid "this xfer is part of a device discovery done by the middle layer"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:256
#, no-wrap
msgid "Dv XS_CTL_REQSENSE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:258
msgid "xfer is a request sense"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:260
#, no-wrap
msgid "Va int xs_status"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:262
msgid "status flags:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:263
#, no-wrap
msgid "Va XS_STS_DONE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:266
msgid "xfer is done (set by E<.Fn scsipi_done>)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:266
#, no-wrap
msgid "Va XS_STS_PRIVATE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:268
msgid "mask of flags reserved for HBA's use (0xf0000000)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:270
#, no-wrap
msgid "Va struct scsipi_periph *xs_periph"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:272
msgid "periph doing the xfer"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:272
#, no-wrap
msgid "Va int timeout"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:279
msgid ""
"command timeout, in milliseconds.  The HBA should start the timeout at the "
"time the command is accepted by the device.  If the timeout happens, the HBA "
"shall terminate the command through E<.Fn scsipi_done> with a XS_TIMEOUT "
"error"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:279
#, no-wrap
msgid "Va struct scsipi_generic *cmd"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:281
msgid "scsipi command to execute"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:281
#, no-wrap
msgid "Va int cmdlen"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:283
msgid "len (in bytes) of the cmd buffer"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:283
#, no-wrap
msgid "Va u_char *data"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:285
msgid "data buffer (this is either a DMA or uio address)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:285
#, no-wrap
msgid "Va int datalen"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:287
msgid "data length (in bytes, zero if uio)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:287
#, no-wrap
msgid "Va int resid"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:291
msgid "difference between E<.Fa datalen> and how much data was really transferred"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:291
#, no-wrap
msgid "Va scsipi_xfer_result_t error"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:296
msgid ""
"error value returned by the HBA driver to mid-layer.  See description of "
"E<.Fn scsipi_done> for valid values"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:296
#, no-wrap
msgid "Va union {struct scsipi_sense_data scsi_sense; uint32_t atapi_sense;} sense"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:303
msgid ""
"where to store sense info if E<.Fa error> is E<.Dv XS_SENSE> or E<.Dv "
"XS_SHORTSENSE>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:303
#, no-wrap
msgid "Va uint8_t status"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:311
msgid ""
"SCSI status; checked by middle layer when E<.Fa error is> E<.Dv XS_BUSY> "
"(the middle layer handles E<.Dv SCSI_CHECK> and E<.Dv SCSI_QUEUE_FULL>)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:311
#, no-wrap
msgid "Va uint8_t xs_tag_type"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:313
msgid "SCSI tag type, set to 0 if untagged command"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:313
#, no-wrap
msgid "Va uint8_t xs_tag_id"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:315
msgid "tag ID, used for tagged commands"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/scsipi.9:316
#, no-wrap
msgid "FUNCTIONS AND CALLBACKS"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:318
#, no-wrap
msgid ""
"Fn (*adapt_request) \"struct scsipi_channel *chan\" \"scsipi_adapter_req_t "
"req\" \"void *arg\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:322
msgid ""
"Used by the mid-layer to transmit a request to the adapter.  E<.Va req> can "
"be one of:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:323
#, no-wrap
msgid "Dv ADAPTER_REQ_RUN_XFER"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:331
msgid ""
"request the adapter to send a command to the device.  E<.Fa arg> is a "
"pointer to the E<.Va struct scsipi_xfer>.  Once the xfer is complete the HBA "
"driver shall call E<.Fn scsipi_done> with updated status and error "
"information."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:331
#, no-wrap
msgid "Dv ADAPTER_REQ_GROW_RESOURCES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:341
msgid ""
"ask the adapter to increase resources of the channel (grow E<.Va "
"adapt_openings> or E<.Va chan_openings>)  if possible.  Support of this "
"feature is optional.  This request is called from the kernel completion "
"thread.  E<.Fa arg> must be ignored."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:341
#, no-wrap
msgid "Dv ADAPTER_REQ_SET_XFER_MODE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:348
msgid ""
"set the xfer mode for a for I_T Nexus.  This will be called once all LUNs of "
"a target have been probed.  E<.Fa arg> points to a E<.Va struct "
"scsipi_xfer_mode> defined as follows:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:349
#, no-wrap
msgid "Va int xm_target"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:351
msgid "target for I_T Nexus"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:351
#, no-wrap
msgid "Va int xm_mode"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:353
msgid "bitmask of device capabilities"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:353
#, no-wrap
msgid "Va int xm_period"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:355
msgid "sync period"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:355
#, no-wrap
msgid "Va int xm_offset"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:357
msgid "sync offset"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:366
msgid ""
"E<.Va xm_period> and E<.Va xm_offset> shall be ignored for E<.Dv "
"ADAPTER_REQ_SET_XFER_MODE>.  E<.Va xm_mode> holds the following bits:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:367
#, no-wrap
msgid "Dv PERIPH_CAP_SYNC"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:369
msgid "ST synchronous transfers"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:369
#, no-wrap
msgid "Dv PERIPH_CAP_WIDE16"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:371
msgid "ST 16 bit wide transfers"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:371
#, no-wrap
msgid "Dv PERIPH_CAP_WIDE32"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:373
msgid "ST 32 bit wide transfers"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:373
#, no-wrap
msgid "Dv PERIPH_CAP_DT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:375
msgid "DT transfers"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:375
#, no-wrap
msgid "Dv PERIPH_CAP_TQING"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:377
msgid "tagged queuing"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:381
msgid ""
"Whenever the xfer mode changes, the driver should call E<.Fn "
"scsipi_async_event> to notify the mid-layer."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:385
msgid "E<.Fn adapt_request> may be called from interrupt context."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:385
#, no-wrap
msgid "Fn adapt_minphys"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:391
msgid ""
"pointer to the driver's minphys function.  If the driver can handle "
"transfers of size E<.Dv MAXPHYS>, this can point to E<.Fn minphys>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:391
#, no-wrap
msgid "Fn adapt_ioctl"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:396
msgid ""
"ioctl function for the channel.  The only ioctl supported at this level is "
"E<.Dv SCBUSIORESET> for which the HBA driver shall issue a SCSI reset on the "
"channel."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:396
#, no-wrap
msgid "int Fn adapt_enable \"struct device *dev\" \"int enable\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:405
msgid ""
"Disable the adapter if E<.Va enable> is zero, or enable it if non-zero.  "
"Returns 0 if operation is successful, or error from E<.Pa "
"\\*[Lt]sys/errno.h\\*[Gt]>.  This callback is optional, and is useful mostly "
"for hot-plug devices.  For example, this callback would power on or off the "
"relevant PCMCIA socket for a PCMCIA controller."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:405
#, no-wrap
msgid ""
"int Fn adapt_getgeom \"struct scsipi_periph *periph\" \"struct disk_parms "
"*params\" \"u_long sectors\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:410
msgid ""
"Optional callback, used by high-level drivers to get the fictitious geometry "
"used by the controller's firmware for the specified periph.  Returns 0 if "
"successful.  See Adaptec drivers for details."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:410
#, no-wrap
msgid ""
"int Fn adapt_accesschk \"struct scsipi_periph *periph\" \"struct "
"scsipi_inquiry_pattern *inqbuf\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:418
msgid ""
"Optional callback; if present the mid-layer uses it to check if it can "
"attach a driver to the specified periph.  If the callback returns a non-zero "
"value, the periph is ignored by the E<.Nm> code.  This callback is used by "
"adapters which want to drive some devices themselves, for example hardware "
"RAID controllers."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:418
#, no-wrap
msgid ""
"Fn scsipi_async_event \"struct scsipi_channel *chan\" \"scsipi_async_event_t "
"event\" \"void *arg\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:422
msgid ""
"Asynchronous event notification for the mid-layer.  E<.Fa event> can be one "
"of:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:423
#, no-wrap
msgid "Dv ASYNC_EVENT_MAX_OPENINGS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:428
msgid ""
"set max openings for a periph.  Argument is a E<.Va struct "
"scsipi_max_openings> with at least the following members:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:429
#, no-wrap
msgid "Va int mo_target"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:430
#, no-wrap
msgid "Va int mo_lun"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:431
#, no-wrap
msgid "Va int mo_openings"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:436
msgid ""
"Not all periphs may allow openings to increase; if not allowed the request "
"is silently ignored."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:436
#, no-wrap
msgid "Dv ASYNC_EVENT_XFER_MODE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:448
msgid ""
"update the xfer mode for an I_T nexus.  Argument is a E<.Va struct "
"scsipi_xfer_mode> properly filled in.  An E<.Dv ASYNC_EVENT_XFER_MODE> call "
"with E<.Dv PERIPH_CAP_TQING> set in E<.Va xm_mode> is mandatory to activate "
"tagged queuing."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:448
#, no-wrap
msgid "Dv ASYNC_EVENT_RESET"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:454
msgid ""
"channel has been reset.  No argument.  HBA drivers have to issue E<.Dv "
"ASYNC_EVENT_RESET events if they rely on the> mid-layer for SCSI CHECK "
"CONDITION handling."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:456
#, no-wrap
msgid "Fn scsipi_done \"struct scsipi_xfer *xs\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:461
msgid ""
"shall be called by the HBA when the xfer is complete, or when it needs to be "
"requeued by the mid-layer.  E<.Va error> in the scsipi_xfer shall be set to "
"one of the following:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:462
#, no-wrap
msgid "Dv XS_NOERROR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:464
msgid "xfer completed without error."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:464
#, no-wrap
msgid "Dv XS_SENSE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:466
msgid "Check the returned SCSI sense for the error."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:466
#, no-wrap
msgid "Dv XS_SHORTSENSE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:468
msgid "Check the ATAPI sense for the error."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:468
#, no-wrap
msgid "Dv XS_DRIVER_STUFFUP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:470
msgid "Driver failed to perform operation."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:470
#, no-wrap
msgid "Dv XS_RESOURCE_SHORTAGE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:473
msgid ""
"Adapter resource shortage.  The mid-layer will retry the command after some "
"delay."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:473
#, no-wrap
msgid "Dv XS_SELTIMEOUT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:475
msgid "The device timed out while trying to send the command"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:475
#, no-wrap
msgid "Dv XS_TIMEOUT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:477
msgid ""
"The command was accepted by the device, but it didn't complete in allowed "
"time."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:477
#, no-wrap
msgid "Dv XS_BUSY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:481
msgid "The mid-layer will check E<.Va status> for additional details:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:482
#, no-wrap
msgid "Dv SCSI_CHECK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:488
msgid ""
"SCSI check condition.  The mid-layer will freeze the periph queue and issue "
"a REQUEST SENSE command.  If the HBA supports tagged queuing, it shall "
"remove and requeue any command not yet accepted by the HBA (or at last make "
"sure no more commands will be sent to the device before the REQUEST SENSE is "
"complete)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:488
#, no-wrap
msgid "Dv SCSI_QUEUE_FULL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:490
msgid "The mid layer will adjust the periph's openings and requeue the command."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:490
#, no-wrap
msgid "Dv SCSI_BUSY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:492
msgid "The mid-layer will requeue the xfer after delay."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:493
#, no-wrap
msgid "Dv XS_RESET"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:495
msgid "xfer destroyed by a reset; the mid-layer will requeue it."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:495
#, no-wrap
msgid "Dv XS_REQUEUE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:497
msgid "Ask the mid-layer to requeue this command immediately."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:508
msgid ""
"The adapter should not reference an E<.Fa xfer> once E<.Fn scsipi_done "
"\"xfer\"> has been called, unless the E<.Fa xfer> had E<.Dv XS_CTL_POLL> "
"set."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:523
msgid ""
"E<.Fn scsipi_done> will call the E<.Fn adapt_request> callback again only if "
"called with E<.Fa xs-\\*[Gt]error> set to E<.Dv XS_NOERROR>, and E<.Fa xfer> "
"doesn't have E<.Dv XS_CTL_POLL> set.  All other error conditions are handled "
"by a kernel thread (once the HBA's interrupt handler has returned)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:523
#, no-wrap
msgid "Fn scsipi_printaddr \"struct scsipi_periph *periph\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:526
msgid ""
"print a kernel message with the periph's name, in the form "
"device(controller:channel:target:lun)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:526
#, no-wrap
msgid "Fn scsipi_channel_freeze \"struct scsipi_channel *chan\" \"int count\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:530
msgid ""
"Freeze the specified channel (requests are queued but not sent to HBA).  The "
"channel's freeze counter is increased by E<.Fa count>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:530
#, no-wrap
msgid "Fn scsipi_channel_thaw \"struct scsipi_channel *chan\" \"int count\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:539
msgid ""
"Decrement the channel's freeze counter by E<.Fa count> and process the queue "
"if the counter goes to 0.  In order to preserve command ordering, HBA "
"drivers should not call E<.Fn scsipi_channel_thaw> before calling E<.Fn "
"scsipi_done> for all commands in the HBA's queue which need to be requeued."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:539 org_netbsd/src/share/man/man9/scsipi.9:547
#, no-wrap
msgid "Fn scsipi_periph_timed_thaw \"void *arg\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:545
msgid ""
"Call E<.Fn scsipi_channel_thaw \"arg\" \"1\">.  Intended to be used as E<.Xr "
"callout 9> callback."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:545
#, no-wrap
msgid "Fn scsipi_periph_freeze \"struct scsipi_periph *periph\" \"int count\""
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:546
#, no-wrap
msgid "Fn scsipi_periph_thaw \"struct scsipi_periph *periph\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:549
msgid "Same as the channel counterparts, but only for one specific peripheral."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:549
#, no-wrap
msgid ""
"Fn scsipi_target_detach \"struct scsipi_channel *chan\" \"int target\" \"int "
"lun\" \"int flags\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:561
msgid ""
"detach the periph associated with this I_T_L nexus.  Both E<.Fa target> and "
"E<.Fa lun> may be wildcarded using the magic value -1.  E<.Fa flags> is "
"passed to E<.Fn config_detach \"\"> \\&.  Returns 0 if successful, or error "
"code if a device couldn't be removed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:561
#, no-wrap
msgid ""
"Fn scsipi_thread_call_callback \"struct scsipi_channel *chan\" \"void "
"(*callback)(struct scsipi_channel *, void *)\" \"void *arg\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:574
msgid ""
"E<.Fn callback> will be called with E<.Fa chan> and E<.Fa arg> as arguments, "
"from the channel completion thread.  The callback is run at splbio.  E<.Fn "
"scsipi_thread_call_callback> will freeze the channel by one, it's up to the "
"caller to thaw it when appropriate.  Returns 0 if the callback was properly "
"recorded, or EBUSY if the channel has already a callback pending."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:577
#, no-wrap
msgid "Pa sys/dev/scsiconf.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:579
msgid "header file for use by SCSI HBA drivers"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/scsipi.9:579
#, no-wrap
msgid "Pa sys/dev/atapiconf.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:581
msgid "header file for use by ATAPI HBA drivers"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:586
msgid ""
"Both header files include E<.Pa sys/dev/scsipiconf.h> which contains most "
"structure definitions, function prototypes and macros."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:591
msgid ""
"The best examples are existing HBA drivers.  Most of them sit in the E<.Pa "
"sys/dev/ic> directory."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:596
msgid "The E<.Nm> interface appeared in E<.Nx 1.6>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/scsipi.9:600
msgid ""
"The E<.Nm> interface was designed and implemented by Jason R. Thorpe.  "
"Manuel Bouyer converted most drivers to the new interface."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/secmodel.9:28 org_netbsd/src/share/man/man9/secmodel_bsd44.9:28 org_netbsd/src/share/man/man9/secmodel_suser.9:28 org_netbsd/src/share/man/man9/sysctl.9:30
#, no-wrap
msgid "December 4, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/secmodel.9:29
#, no-wrap
msgid "SECMODEL 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:33
msgid "E<.Nm secmodel>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/secmodel.9:33
#, no-wrap
msgid "security model development guidelines"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/secmodel.9:35 org_netbsd/src/share/man/man9/secmodel.9:490
#, no-wrap
msgid "secmodel/secmodel.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:47
msgid ""
"E<.Ft int> E<.Fn secmodel_register \"secmodel_t *sm\" \"const char *id\" "
"\"const char *name\" \"prop_dictionary_t behavior\" \"secmodel_eval_t "
"sm_eval\" \"secmodel_setinfo_t sm_setinfo\"> E<.Ft int> E<.Fn "
"secmodel_deregister \"secmodel_t sm\"> E<.Ft int> E<.Fn secmodel_eval "
"\"const char *id\" \"const char *what\" \"void *arg\" \"void *ret\"> E<.Ft "
"static int> E<.Fn secmodel_\\*[Lt]model\\*[Gt]_eval \"const char *what\" "
"\"void *arg\" \"void *ret\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:58
msgid ""
"E<.Nx> provides a complete abstraction of the underlying security model used "
"within the operating system through a set of E<.Xr kauth 9> scopes and "
"actions.  It allows maintaining the traditional security model (based on a "
"single E<.Em super-user> and above-super-user restrictions known as E<.Em "
"securelevel>)  while decoupling it easily from the system."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:66
msgid ""
"It is possible to modify the security model -- either slightly or using an "
"entirely different model -- by attaching/detaching E<.Xr kauth 9> "
"listeners.  This can be done via the E<.Nm> pluggable framework."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:75
msgid ""
"A E<.Nm> is typically implemented as a kernel E<.Xr module 9>, and can be "
"either built-in statically or loaded dynamically at run-time.  They base "
"their decisions on available information, either directly from kernel, from "
"a userspace daemon or even from a centralized network authorization server."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:79
msgid "The E<.Nm> framework offers the following data types:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel.9:80
#, no-wrap
msgid "Fa secmodel_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:83
msgid "An opaque type that describes a E<.Nm>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel.9:86
#, no-wrap
msgid "Fn secmodel_register sm id name behavior sm_eval sm_setinfo"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:91
msgid ""
"Register a security model to the E<.Nm> framework and stores its description "
"inside E<.Fa sm>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel.9:92
#, no-wrap
msgid "Fa sm"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:96
msgid "The E<.Nm> description."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:99
msgid "The unique identifier of the E<.Nm>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:102
msgid "The descriptive human-readable name of the E<.Nm>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel.9:102
#, no-wrap
msgid "Fa behavior"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:107
msgid ""
"(optional) a E<.Xr prop_dictionary 3> that declares the behavior of this "
"security model, like E<.Do copy credentials on fork . Dc>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel.9:107
#, no-wrap
msgid "Fa sm_eval"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:114
msgid ""
"(optional) the E<.Fn secmodel_\\*[Lt]model\\*[Gt]_eval> callback used by a "
"E<.Nm> to register an evaluation routine that can be queried later by "
"another security model."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel.9:114
#, no-wrap
msgid "Fa sm_setinfo"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:124
msgid ""
"(optional) the E<.Fn secmodel_\\*[Lt]model\\*[Gt]_setinfo> callback used by "
"a E<.Nm> to register a routine that permits other security models to alter "
"the E<.Nm> internals.  Currently not implemented."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel.9:125
#, no-wrap
msgid "Fn secmodel_deregister sm"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:130
msgid "Deregister the E<.Nm> described by E<.Fa sm>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel.9:130
#, no-wrap
msgid "Fn secmodel_eval id what arg ret"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:133
msgid ""
"Call the evaluation callback implemented by a security model.  The return "
"value can be either:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:136
msgid "zero (0), when the call succeeded."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:140
msgid "positive, when the error comes directly from the E<.Nm> framework."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:144
msgid ""
"negative, when the error comes from the evaluation callback implemented in "
"the targetted security model.  The value is then implementation-defined."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:150
msgid "The unique identifier of the targetted E<.Nm>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel.9:150
#, no-wrap
msgid "Fa what"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:153
msgid "The query that will be passed down to the targetted E<.Nm>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:156
msgid "The arguments passed to the evaluation routine of the targetted E<.Nm>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel.9:156
#, no-wrap
msgid "Fa ret"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:158
msgid "The answer of the evaluation routine."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:163
msgid ""
"If successful, functions return 0.  Otherwise, the following error values "
"are returned:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel.9:164
#, no-wrap
msgid "Bq Er EEXIST"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:168
msgid "The E<.Nm> is already registered."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel.9:168
#, no-wrap
msgid "Bq Er EFAULT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:170
msgid "An invalid address or reference was passed as parameter."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel.9:170 org_netbsd/src/share/man/man9/sysmon_taskq.9:87 org_netbsd/src/share/man/man9/vnodeops.9:1417
#, no-wrap
msgid "Bq Er EINVAL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:172
msgid "An invalid value was passed as parameter."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel.9:172 org_netbsd/src/share/man/man9/vnodeops.9:1427 org_netbsd/src/share/man/man9/vnsubr.9:259
#, no-wrap
msgid "Bq Er ENOENT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:176
msgid ""
"The targetted E<.Nm> does not exist, or it does not implement an evaluation "
"callback."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/secmodel.9:177
#, no-wrap
msgid "WRITING A SECURITY MODEL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:184
msgid ""
"Before writing a security model one should be familiar with the E<.Xr kauth "
"9> KPI, its limitations, requirements, and so on.  See E<.Xr kauth 9> for "
"details."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:190
msgid ""
"A security model is based on the kernel E<.Xr module 9> framework, and can "
"be built-in statically inside kernel or loaded dynamically at run-time.  It "
"is composed of (code-wise) the following components:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:203
msgid ""
"E<.Xr module 9> routines, especially a E<.Fn MODULE> declaration and a E<.Fn "
"secmodel_\\*[Lt]model\\*[Gt]_modcmd> function used to start E<.Po through Dv "
"MODULE_CMD_INIT Pc> and stop E<.Po through Dv MODULE_CMD_FINI Pc> the "
"E<.Nm>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:212
msgid ""
"Entry routines, named E<.Fn secmodel_\\*[Lt]model\\*[Gt]_init> and E<.Fn "
"secmodel_\\*[Lt]model\\*[Gt]_start>, used to initialize and start the "
"security model, and another function called E<.Fn "
"secmodel_\\*[Lt]model\\*[Gt]_stop>, to stop the security model in case the "
"module is to be unloaded."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:219
msgid ""
"A E<.Xr sysctl 9> setup routine for the model.  This should create an entry "
"for the model in the E<.Xr sysctl 7> namespace, under the "
"\"security.models.\\*[Lt]model\\*[Gt]\" hierarchy."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:225
msgid ""
"All \"knobs\" for the model should be located under the new node, as well as "
"a mandatory E<.Fa name> variable, indicating a descriptive human-readable "
"name for the model."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:231
msgid ""
"A E<.Xr sysctl 9> teardown routine used to destroy the E<.Xr sysctl 7> tree "
"associated with the model."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:236
msgid ""
"If the model uses any private data inside credentials, listening on the "
"credentials scope, E<.Dv KAUTH_SCOPE_CRED>, is required."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:239
msgid ""
"Optionally, internal data-structures used by the model.  These must all be "
"prefixed with \"secmodel_\\*[Lt]model\\*[Gt]_\"."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:242
msgid ""
"A set of listeners, attached to various scopes, used to enforce the policy "
"the model intends to implement."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:248
msgid ""
"Finally, a security model should register itself after being initialized "
"using E<.Fn secmodel_register>, and deregister itself before being stopped "
"using E<.Fn secmodel_deregister>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:257
msgid ""
"Below is sample code for a E<.Xr kauth 9> network scope listener for the "
"E<.Em jenna> security model.  It is used to allow users with a user-id below "
"1000 to bind to reserved ports (for example, 22/TCP):"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:263 org_netbsd/src/share/man/man9/secmodel.9:428
#, no-wrap
msgid ""
"int\n"
"secmodel_jenna_network_cb(kauth_cred_t cred, kauth_action_t action,\n"
"    void *cookie, void *arg0, void *arg1, void *arg2, void *arg3)\n"
"{\n"
"\tint result;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:266 org_netbsd/src/share/man/man9/secmodel.9:393 org_netbsd/src/share/man/man9/secmodel.9:431
#, no-wrap
msgid ""
"\t/* Default defer. */\n"
"\tresult = KAUTH_RESULT_DEFER;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:284
#, no-wrap
msgid ""
"\tswitch (action) {\n"
"\tcase KAUTH_NETWORK_BIND:\n"
"\t\t/*\n"
"\t\t * We only care about bind(2) requests to privileged\n"
"\t\t * ports.\n"
"\t\t */\n"
"\t\tif ((u_long)arg0 == KAUTH_REQ_NETWORK_BIND_PRIVPORT) {\n"
"\t\t\t/*\n"
"\t\t\t * If the user-id is below 1000, which may\n"
"\t\t\t * indicate a \"reserved\" user-id, allow the\n"
"\t\t\t * request.\n"
"\t\t\t */\n"
"\t\t\tif (kauth_cred_geteuid(cred) \\*[Lt] 1000)\n"
"\t\t\t\tresult = KAUTH_RESULT_ALLOW;\n"
"\t\t}\n"
"\t\tbreak;\n"
"\t}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:287 org_netbsd/src/share/man/man9/secmodel.9:418 org_netbsd/src/share/man/man9/secmodel.9:455
#, no-wrap
msgid ""
"\treturn (result);\n"
"}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:291
msgid ""
"There are two main issues, however, with that listener, that you should be "
"aware of when approaching to write your own security model:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:296
msgid ""
"E<.Xr kauth 9> uses restrictive decisions: if you attach this listener "
"on-top of an existing security model, even if it would allow the request, it "
"could still be denied."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:300
msgid ""
"If you attach this listener as the only listener for the network scope, "
"there are many other requests that will be deferred and, eventually, denied "
"-- which may not be desired."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:305
msgid ""
"That's why before implementing listeners, it should be clear whether they "
"implement an entirely new from scratch security model, or add on-top of an "
"existing one."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:307
msgid "There are several things you should remember when writing a security model:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:316
msgid ""
"Pay attention to the correctness of your E<.Nm> implementation of the "
"desired policy.  Certain rights can grant more privileges on the system than "
"others, like allowing calls to E<.Xr chroot 2> or mounting a file-system."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:318
msgid "All unhandled requests are denied by default."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:323
msgid ""
"Authorization requests can not be issued when the kernel is holding any "
"locks.  This is a requirement from kernel code to allow designing security "
"models where the request should be dispatched to userspace or a different "
"host."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:331
msgid ""
"Private listener data -- such as internal data-structures -- is entirely "
"under the responsibility of the developer.  Locking, synchronization, and "
"garbage collection are all things that E<.Xr kauth 9> does E<.Em not> take "
"care of for you!"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/secmodel.9:332
#, no-wrap
msgid "STACKING ON AN EXISTING SECURITY MODEL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:339
msgid ""
"One of the shortcomings of E<.Xr kauth 9> is that it does not provide any "
"stacking mechanism, similar to Linux Security Modules (LSM).  This, however, "
"is considered a feature in reducing dependency on other people's code."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:342
msgid ""
"To properly \"stack\" minor adjustments on-top of an existing security "
"model, one could use one of two approaches:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:346
msgid ""
"Register an internal scope for the security model to be used as a fall-back "
"when requests are deferred."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:353
msgid ""
"This requires the security model developer to add an internal scope for "
"every scope the model partly covers, and register the fall-back listeners to "
"it.  In the model's listener(s) for the scope, when a defer decision is "
"made, the request is passed to be authorized on the internal scope, "
"effectively using the fall-back security model."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:355
msgid "Here is example code that implements the above:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:357
#, no-wrap
msgid "#include \\*[Lt]secmodel/bsd44/bsd44.h\\*[Gt]\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:363
#, no-wrap
msgid ""
"/*\n"
" * Internal fall-back scope for the network scope.\n"
" */\n"
"#define\tJENNA_ISCOPE_NETWORK \"jenna.iscope.network\"\n"
"static kauth_scope_t secmodel_jenna_iscope_network;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:373
#, no-wrap
msgid ""
"/*\n"
" * Jenna's entry point. Register internal scope for the network scope\n"
" * which we partly cover for fall-back authorization.\n"
" */\n"
"void\n"
"secmodel_jenna_start(void)\n"
"{\n"
"\tsecmodel_jenna_iscope_network = kauth_register_scope(\n"
"\t    JENNA_ISCOPE_NETWORK, NULL, NULL);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:379
#, no-wrap
msgid ""
"\tkauth_listen_scope(JENNA_ISCOPE_NETWORK,\n"
"\t    secmodel_bsd44_suser_network_cb, NULL);\n"
"\tkauth_listen_scope(JENNA_ISCOPE_NETWORK,\n"
"\t    secmodel_securelevel_network_cb, NULL);\n"
"}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:390
#, no-wrap
msgid ""
"/*\n"
" * Jenna sits on top of another model, effectively filtering requests.\n"
" * If it has nothing to say, it discards the request. This is a good\n"
" * example for fine-tuning a security model for a special need.\n"
" */\n"
"int\n"
"secmodel_jenna_network_cb(kauth_cred_t cred, kauth_action_t action,\n"
"    void *cookie, void *arg0, void *arg1, void *arg2, void *arg3)\n"
"{\n"
"\tint result;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:406 org_netbsd/src/share/man/man9/secmodel.9:444
#, no-wrap
msgid ""
"\tswitch (action) {\n"
"\tcase KAUTH_NETWORK_BIND:\n"
"\t\t/*\n"
"\t\t * We only care about bind(2) requests to privileged\n"
"\t\t * ports.\n"
"\t\t */\n"
"\t\tif ((u_long)arg0 == KAUTH_REQ_NETWORK_BIND_PRIVPORT) {\n"
"\t\t\tif (kauth_cred_geteuid(cred) \\*[Lt] 1000)\n"
"\t\t\t\tresult = KAUTH_RESULT_ALLOW;\n"
"\t\t}\n"
"\t\tbreak;\n"
"\t}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:415
#, no-wrap
msgid ""
"\t/*\n"
"\t * If we have don't have a decision, fall-back to the bsd44\n"
"\t * security model.\n"
"\t */\n"
"\tif (result == KAUTH_RESULT_DEFER)\n"
"\t\tresult = kauth_authorize_action(\n"
"\t\t    secmodel_jenna_iscope_network, cred, action,\n"
"\t\t    arg0, arg1, arg2, arg3);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:422
msgid ""
"If the above is not desired, or cannot be used for any reason, there is "
"always the ability to manually call the fall-back routine:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:452
#, no-wrap
msgid ""
"\t/*\n"
"\t * If we have don't have a decision, fall-back to the bsd44\n"
"\t * security model's suser behavior.\n"
"\t */\n"
"\tif (result == KAUTH_RESULT_DEFER)\n"
"\t\tresult = secmodel_bsd44_suser_network_cb(cred, action,\n"
"\t\t    cookie, arg0, arg1, arg2, arg3);\n"
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/secmodel.9:457
#, no-wrap
msgid "AVAILABLE SECURITY MODELS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:461
msgid ""
"The following is a list of security models available in the default E<.Nx> "
"distribution."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel.9:462
#, no-wrap
msgid "Xr secmodel_suser 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:466
msgid "Implements the E<.Em super-user> (root) security policy."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel.9:466
#, no-wrap
msgid "Xr secmodel_securelevel 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:470
msgid "Implements the E<.Em securelevel> security model."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel.9:470
#, no-wrap
msgid "Xr secmodel_extensions 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:474
msgid ""
"Implements extensions to the traditional E<.Bx 4.4> security model, like "
"usermounts."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel.9:474
#, no-wrap
msgid "Xr secmodel_bsd44 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:479
msgid "Traditional E<.Nx> security model, derived from E<.Bx 4.4>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel.9:479
#, no-wrap
msgid "Xr secmodel_overlay 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:482
msgid "Sample overlay security model, sitting on-top of E<.Xr secmodel_bsd44 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:488
msgid "The core of the E<.Nm> implementation is in E<.Pa sys/secmodel/secmodel.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:499
msgid ""
"To make it easier on developers to write new security models from scratch, "
"E<.Nx> maintains an example E<.Nm> under E<.Pa share/examples/secmodel/>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:507
msgid ""
"E<.Xr kauth 9>, E<.Xr module 9>, E<.Xr secmodel_bsd44 9>, E<.Xr "
"secmodel_extensions 9>, E<.Xr secmodel_overlay 9>, E<.Xr "
"secmodel_securelevel 9>, E<.Xr secmodel_suser 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:514
msgid ""
"Kernel Authorization was introduced in E<.Nx 4.0> as the subsystem "
"responsible for authorization and credential management.  Before its "
"introduction, there were several ways for providing resource access control:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:518
msgid "Checking if the user in question is the super-user via E<.Fn suser>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:520
msgid "Comparing the user-id against hard-coded values, often zero."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:522
msgid "Checking the system securelevel."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:529
msgid ""
"The problem with the above is that the interface (\"can X do Y?\") was "
"tightly coupled with the implementation (\"is X Z?\").  E<.Xr kauth 9> "
"allows separating them, dispatching requests with highly detailed context "
"using a consistent and clear KPI."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:537
msgid ""
"The E<.Nm> framework was extended in E<.Nx 6.0> to implement E<.Nm> "
"registration and evaluation procedure calls."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel.9:538 org_netbsd/src/share/man/man9/secmodel_bsd44.9:55 org_netbsd/src/share/man/man9/secmodel_extensions.9:119 org_netbsd/src/share/man/man9/secmodel_overlay.9:52 org_netbsd/src/share/man/man9/secmodel_securelevel.9:281 org_netbsd/src/share/man/man9/secmodel_suser.9:92
msgid "E<.An Elad Efrat Aq elad@NetBSD.org>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/secmodel_bsd44.9:29
#, no-wrap
msgid "SECMODEL_BSD44 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_bsd44.9:33
msgid "E<.Nm secmodel_bsd44>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/secmodel_bsd44.9:33
#, no-wrap
msgid "traditional"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_bsd44.9:37
msgid "E<.Nx> security model (based on E<.Bx 4.4>)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_bsd44.9:48
msgid ""
"E<.Nm> is the default security model in E<.Nx>.  It is the traditional "
"security model based on E<.Bx 4.4> and is composed of three separate "
"security models: E<.Xr secmodel_extensions 9>, E<.Xr secmodel_securelevel 9> "
"and E<.Xr secmodel_suser 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_bsd44.9:54
msgid ""
"E<.Xr kauth 9>, E<.Xr secmodel 9>, E<.Xr secmodel_extensions 9>, E<.Xr "
"secmodel_securelevel 9>, E<.Xr secmodel_suser 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/secmodel_extensions.9:30
#, no-wrap
msgid "December 3, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/secmodel_extensions.9:31
#, no-wrap
msgid "SECMODEL_EXTENSIONS 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_extensions.9:35
msgid "E<.Nm secmodel_extensions>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/secmodel_extensions.9:35
#, no-wrap
msgid "Extensions security model"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_extensions.9:43
msgid ""
"E<.Nm> implements extensions to the traditional security model based on the "
"original E<.Bx 4.4>.  They can be used to grant additional privileges to "
"ordinary users, or enable specific security measures like curtain mode."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_extensions.9:45
msgid "The extensions are described below."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/secmodel_extensions.9:45
#, no-wrap
msgid "Curtain mode"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_extensions.9:49
msgid ""
"When enabled, all returned objects will be filtered according to the user-id "
"requesting information about them, preventing users from accessing objects "
"they do not own."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_extensions.9:57
msgid ""
"It affects the output of many commands, including E<.Xr fstat 1>, E<.Xr "
"netstat 1>, E<.Xr ps 1>, E<.Xr sockstat 1>, and E<.Xr w 1>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_extensions.9:64
msgid ""
"This extension is enabled by setting E<.Pa "
"security.models.extensions.curtain> or E<.Pa security.curtain> E<.Xr sysctl "
"7> to a non-zero value."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_extensions.9:69
msgid ""
"It can be enabled at any time, but cannot be disabled anymore when the E<.Em "
"securelevel> of the system is above 0."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/secmodel_extensions.9:69
#, no-wrap
msgid "Non-superuser mounts"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_extensions.9:83
msgid ""
"When enabled, it allows file-systems to be mounted by an ordinary user who "
"owns the point E<.Ar node> and has at least read access to the E<.Ar "
"special> device E<.Xr mount 8> arguments.  Note that the E<.Cm nosuid> and "
"E<.Cm nodev> flags must be given for non-superuser mounts."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_extensions.9:90
msgid ""
"This extension is enabled by setting E<.Pa "
"security.models.extensions.usermount> or E<.Pa vfs.generic.usermount> E<.Xr "
"sysctl 7> to a non-zero value."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_extensions.9:95 org_netbsd/src/share/man/man9/secmodel_extensions.9:109
msgid ""
"It can be disabled at any time, but cannot be enabled anymore when the E<.Em "
"securelevel> of the system is above 0."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/secmodel_extensions.9:95
#, no-wrap
msgid "Non-superuser control of CPU sets"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_extensions.9:99
msgid ""
"When enabled, an ordinary user is allowed to control the CPU E<.Xr affinity "
"3> of the processes and threads he owns."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_extensions.9:104
msgid ""
"This extension is enabled by setting E<.Pa "
"security.models.extensions.user_set_cpu_affinity> E<.Xr sysctl 7> to a "
"non-zero value."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_extensions.9:118
msgid ""
"E<.Xr affinity 3>, E<.Xr sched 3>, E<.Xr sysctl 7>, E<.Xr kauth 9>, E<.Xr "
"secmodel 9>, E<.Xr secmodel_bsd44 9>, E<.Xr secmodel_securelevel 9>, E<.Xr "
"secmodel_suser 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/secmodel_overlay.9:28
#, no-wrap
msgid "September 15, 2006"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/secmodel_overlay.9:29
#, no-wrap
msgid "SECMODEL_OVERLAY 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_overlay.9:33
msgid "E<.Nm secmodel_overlay>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/secmodel_overlay.9:33
#, no-wrap
msgid "sample overlay security model implementation"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/secmodel_overlay.9:35
#, no-wrap
msgid "secmodel/overlay/overlay.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_overlay.9:45
msgid ""
"E<.Nm> is a sample implementation for an overlay security model.  It can be "
"thought of as a E<.Dq filter> for the underlying model it overlays, by "
"default it is E<.Xr secmodel_bsd44 9>, where developers or administrators "
"can implement custom policies using least intrusive code changes."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_overlay.9:47
msgid "E<.Pa sys/secmodel/overlay/secmodel_overlay.c>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_overlay.9:51
msgid "E<.Xr kauth 9>, E<.Xr secmodel 9>, E<.Xr secmodel_bsd44 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:30
#, no-wrap
msgid "SECMODEL_SECURELEVEL 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:34
msgid "E<.Nm secmodel_securelevel>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:34
#, no-wrap
msgid "securelevel security model"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:43
msgid ""
"The securelevel mechanism is intended to allow protecting the persistence of "
"code and data on the system, or a subset thereof, from modification, even by "
"the E<.Em super-user> by providing convenient means of E<.Dq locking down> a "
"system to a degree suited to its environment."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:53
msgid ""
"The E<.Em super-user> can raise the E<.Em securelevel> using E<.Xr sysctl "
"8>, but only E<.Xr init 8> can lower it."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:55
msgid "Four security levels are provided."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:56
#, no-wrap
msgid "\\&-1 Em Permanently insecure mode"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:62
msgid "Do not raise the E<.Em securelevel> on boot"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:63
#, no-wrap
msgid "\\ 0 Em Insecure mode"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:69
msgid ""
"The init process (PID 1) may not be traced or accessed by E<.Xr ptrace 2> or "
"procfs."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:73
msgid ""
"Immutable and append-only file flags may be changed by E<.Xr chflags 1> or "
"by other means."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:75
msgid "All devices may be read or written subject to their permissions."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:79
msgid ""
"All E<.Xr gpio 4> pins can be set and device drivers can be attached to "
"them."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:83
msgid ""
"On architectures that support E<.Xr module 4>, kernel modules can be loaded "
"and unloaded."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:84
#, no-wrap
msgid "\\ 1 Em Secure mode"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:90
msgid "All effects of E<.Em securelevel> 0."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:98
msgid ""
"The E<.Xr kmem 4> memory files E<.Pa /dev/mem> and E<.Pa /dev/kmem> may not "
"be written to."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:100
msgid "Raw disk devices of mounted file systems are read-only."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:102
msgid "Immutable and append-only file flags may not be removed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:104
msgid "Kernel modules may not be loaded or unloaded."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:111
msgid ""
"Neither the E<.Va net.inet.ip.sourceroute> nor the E<.Va "
"vm.user_va0_disable> E<.Xr sysctl 8> variables may be changed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:115
msgid "Adding or removing E<.Xr sysctl 9> nodes is denied."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:117
msgid "The RTC offset may not be changed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:119
msgid "Set-id coredump settings may not be altered."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:123
msgid "Attaching the IP-based kernel debugger, E<.Xr ipkdb 4>, is not allowed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:127
msgid ""
"Device E<.Dq pass-thru> requests that may be used to perform raw disk and/or "
"memory access are denied."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:133
msgid "The E<.Em iopl> and E<.Em ioperm> calls are denied."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:135
msgid "Access to unmanaged memory is denied."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:139
msgid "Only GPIO pins that have been set at E<.Em securelevel> 0 can be accessed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:140
#, no-wrap
msgid "\\ 2 Em Highly secure mode"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:146
msgid "All effects of E<.Em securelevel> 1."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:148
msgid "Raw disk devices are always read-only whether mounted or not."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:151
msgid ""
"New disks may not be mounted, and existing mounts may only be downgraded "
"from read-write to read-only."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:153
msgid "The system clock may not be set backwards or close to overflow."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:155
msgid "Per-process coredump name may not be changed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:157
msgid "Packet filtering and NAT rules may not be altered."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:159
msgid "CPU ucode loading is denied on platforms that support it."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:178
msgid ""
"Highly secure mode may seem Draconian, but is intended as a last line of "
"defence should the E<.Em super-user> account be compromised.  Its effects "
"preclude circumvention of file flags by direct modification of a raw disk "
"device, or erasure of a file system by means of E<.Xr newfs 8>.  Further, it "
"can limit the potential damage of a compromised E<.Dq firewall> by "
"prohibiting the modification of packet filter rules.  Preventing the system "
"clock from being set backwards aids in post-mortem analysis and helps ensure "
"the integrity of logs.  Precision timekeeping is not affected because the "
"clock may still be slowed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:199
msgid ""
"Normally, the system runs in E<.Em securelevel> 0 while single-user and in "
"E<.Em securelevel> 1 while multi-user.  If a higher E<.Em securelevel> is "
"desired while running multi-user, it can be set using the E<.Sy securelevel> "
"keyword in the startup script E<.Pa /etc/rc.conf>, see E<.Xr rc.conf 5> for "
"details.  Lower securelevels require the kernel to be compiled with E<.Sy "
"options INSECURE>, causing it to always default to E<.Em securelevel> \\-1."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:216
msgid ""
"In order for this protection to be effective, the administrator must ensure "
"that no program that is run while the security level is 0 or lower, nor any "
"data or configuration file used by any such program, can be modified while "
"the security level is greater than 0.  This may be achieved through the "
"careful use of the E<.Dq immutable> file flag to define and protect a "
"Trusted Computing Base (TCB)  consisting of all such programs and data, or "
"by ensuring that all such programs and data are on filesystems that are "
"mounted read-only and running at security level 2 or higher.  E<.Em "
"Particular care must be taken to ensure, if relying upon> E<.Em security "
"level 1 and the use of file flags, that the integrity of the> E<.Em TCB "
"cannot be compromised through the use of modifications to the> E<.Em "
"disklabel or access to overlapping disk partitions, including the> E<.Em raw "
"partition>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:221
msgid ""
"Do not overlook the fact that shell scripts (or anything else fed to an "
"interpreter, through any mechanism) and the kernel itself are \"programs "
"that run while the security level is 0\" and must be considered part of the "
"TCB."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:225
msgid "The following E<.Xr sysctl 3> variables are exported:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:226
#, no-wrap
msgid "security.models.securelevel.securelevel"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:230
msgid ""
"The system security level.  This level may be raised by processes with "
"appropriate privilege.  It may only be lowered by process 1 (init)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:239
msgid ""
"E<.Nm> exposes a E<.Xr secmodel_eval 9> evaluation routine to test whether "
"the current E<.Em securelevel> is above a certain threshold level or not."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:243 org_netbsd/src/share/man/man9/secmodel_suser.9:55
msgid "The parameters to E<.Xr secmodel_eval 9> are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:244 org_netbsd/src/share/man/man9/secmodel_suser.9:56
#, no-wrap
msgid "id"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:248
msgid ""
"the unique identifier of E<.Nm>: E<.Qo Dv org.netbsd.secmodel.securelevel "
"Qc>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:248 org_netbsd/src/share/man/man9/secmodel_suser.9:60
#, no-wrap
msgid "what"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:251
msgid "a string, E<.Qo Dv is-securelevel-above Qc>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:251 org_netbsd/src/share/man/man9/secmodel_suser.9:63
#, no-wrap
msgid "arg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:255
msgid "a reference to an E<.Dv int> representing the threshold level."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:255 org_netbsd/src/share/man/man9/secmodel_suser.9:69
#, no-wrap
msgid "ret"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:266
msgid ""
"a boolean, set by E<.Nm> to E<.Dv true> when the E<.Em securelevel> is "
"strictly above the threshold level, E<.Dv false> otherwise."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:267 org_netbsd/src/share/man/man9/secmodel_suser.9:79
#, no-wrap
msgid "RETURN TYPES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:274 org_netbsd/src/share/man/man9/secmodel_suser.9:86
msgid ""
"If successful, the evaluation returns 0 with the E<.Fa ret> argument being "
"either E<.Dv true> or E<.Dv false>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:279 org_netbsd/src/share/man/man9/secmodel_suser.9:91
msgid ""
"E<.Xr kauth 9>, E<.Xr secmodel 9>, E<.Xr secmodel_bsd44 9>, E<.Xr "
"secmodel_eval 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:285
msgid ""
"Systems without E<.Xr sysctl 8> behave as though they have security level "
"\\-1."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_securelevel.9:291
msgid ""
"The security level 2 restrictions relating to TCB integrity protection "
"should be enforced at security level 1.  Restrictions dependent upon "
"security level but not relating to TCB integrity protection should be "
"selected by E<.Xr sysctl 8> settings available only at security level 0 or "
"lower."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/secmodel_suser.9:29
#, no-wrap
msgid "SECMODEL_SUSER 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_suser.9:33
msgid "E<.Nm secmodel_suser>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/secmodel_suser.9:33
#, no-wrap
msgid "super-user security model"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_suser.9:43
msgid ""
"E<.Nm> implements the traditional E<.Em super-user> (root) as the user with "
"effective user-id 0.  The E<.Em super-user> is the host administrator, "
"considered to have higher privileges than other users."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_suser.9:51
msgid ""
"E<.Nm> exposes a E<.Xr secmodel_eval 9> evaluation routine to test whether a "
"set of credentials can be assimilated to E<.Em super-user> credentials or "
"not."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_suser.9:60
msgid "the unique identifier of E<.Nm>: E<.Qo Dv org.netbsd.secmodel.suser Qc>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_suser.9:63
msgid "a string, E<.Qo Dv is-root Qc>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_suser.9:69
msgid "the E<.Xr kauth 9> credentials E<.Po Fa kauth_cred_t Pc> of the caller."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/secmodel_suser.9:78
msgid ""
"a boolean, set by E<.Nm> to E<.Dv true> when the credentials are equivalent "
"to E<.Em super-user>, E<.Dv false> otherwise."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/select.9:31
#, no-wrap
msgid "May 13, 2008"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/select.9:32
#, no-wrap
msgid "SELECT 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/select.9:39
msgid "E<.Nm seldestroy>, E<.Nm selinit>, E<.Nm selrecord>, E<.Nm selnotify>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/select.9:39
#, no-wrap
msgid "select and poll subsystem"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/select.9:42
#, no-wrap
msgid "sys/select.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/select.9:51
msgid ""
"E<.Ft void> E<.Fn seldestroy \"struct selinfo *sip\"> E<.Ft void> E<.Fn "
"selinit \"struct selinfo *sip\"> E<.Ft void> E<.Fn selrecord \"struct lwp "
"*selector\" \"struct selinfo *sip\"> E<.Ft void> E<.Fn selnotify \"struct "
"selinfo *sip\" \"int events\" \"long knhint\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/select.9:60
msgid ""
"E<.Fn selinit> and E<.Fn seldestroy> functions must be used to initialize "
"and destroy the E<.Va struct selinfo>.  The E<.Fn seldestroy> function may "
"block."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/select.9:75
msgid ""
"E<.Fn selrecord> and E<.Fn selnotify> are used by device drivers to "
"coordinate with the kernel implementation of E<.Xr select 2> and E<.Xr poll "
"2>.  Each object that can be polled contains a E<.Dv selinfo> record.  "
"Device drivers provide locking for the E<.Dv selinfo> record."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/select.9:91
msgid ""
"E<.Fn selrecord> records that the calling thread is interested in events "
"related to a given object.  E<.Fn selrecord> should only be called when the "
"poll routine determines that the object is not ready for I/O: there are no "
"events of interest pending.  The check for pending I/O and call to E<.Fn "
"selrecord> must be atomic.  Atomicity can be provided by holding the "
"object's lock across the test and call to E<.Fn selrecord>.  For non-MPSAFE "
"drivers, the global E<.Dv kernel_lock> is enough to provide atomicity."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/select.9:101
msgid ""
"E<.Fn selnotify> is called by the underlying object handling code in order "
"to notify any waiting threads that an event of interest has occurred.  The "
"same lock held across the poll method and call to E<.Fn selrecord> must be "
"held across the call to E<.Fn selnotify>.  The lock prevents an event of "
"interest being signalled while a thread is in the process of recording its "
"interest."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/select.9:106
msgid ""
"The E<.Fa events> indicates which event happen.  Zero may be used if "
"unknown."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/select.9:113
msgid ""
"E<.Fn selnotify> also calls E<.Fn KNOTE> passing E<.Va knhint> as an "
"argument."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/select.9:121
msgid ""
"The core of the select and poll subsystem implementation is in E<.Pa "
"sys/kern/sys_select.c>.  Data structures and function prototypes are located "
"in E<.Pa sys/sys/select.h>, E<.Pa sys/sys/poll.h> and E<.Pa "
"sys/sys/selinfo.h>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/select.9:124
msgid "E<.Xr poll 2>, E<.Xr select 2>, E<.Xr knote 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/setbit.9:30
#, no-wrap
msgid "March 1, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/setbit.9:31
#, no-wrap
msgid "SETBIT 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/setbit.9:35
msgid "E<.Nm setbit>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/setbit.9:35
#, no-wrap
msgid "macros related to bitmaps"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/setbit.9:46
msgid ""
"E<.Ft void> E<.Fn setbit \"array\" \"x\"> E<.Ft void> E<.Fn clrbit \"array\" "
"\"x\"> E<.Ft int> E<.Fn isset \"array\" \"x\"> E<.Ft int> E<.Fn isclr "
"\"array\" \"x\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/setbit.9:50
msgid "The E<.Nm> family of macros operate with bitmaps, also known as bit arrays."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/setbit.9:67
msgid ""
"In a nutshell, E<.Fn setbit> sets the bit E<.Fa x> in E<.Fa array>, E<.Fn "
"clrbit> clears it, E<.Fn isset> tests whether E<.Fa x> is set, and E<.Fn "
"isclr> returns 1 if E<.Fa x> is not set."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/setbit.9:70
msgid ""
"The following example declares a buffer of 10 chars, treating it as an array "
"of 80 bits:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/setbit.9:72
#, no-wrap
msgid "char buf[10];\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/setbit.9:76
#, no-wrap
msgid "setbit(buf, 12);\t/* set the fifth bit in the second byte */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/setbit.9:79
msgid "E<.Xr bitstring 3>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/setbit.9:82
msgid ""
"The number of valid bits in a given array is assumed to be multiple of E<.Dv "
"CHAR_BIT>, the number of bits for smallest object that is not a bit-field."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/setjmp.9:30
#, no-wrap
msgid "May 23, 2002"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/setjmp.9:31
#, no-wrap
msgid "SETJMP 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/setjmp.9:36
msgid "E<.Nm setjmp>, E<.Nm longjmp>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/setjmp.9:36
#, no-wrap
msgid "non-local jumps"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/setjmp.9:44
msgid ""
"E<.Ft int> E<.Fn setjmp \"label_t *label\"> E<.Ft void> E<.Fn longjmp "
"\"label_t *label\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/setjmp.9:59
msgid ""
"The E<.Fn setjmp> function saves its calling environment in E<.Fa label>.  "
"It returns zero on success.  The E<.Fn longjmp> function restores the "
"environment saved by the most recent invocation of E<.Fn setjmp>.  It "
"returns so that kernel execution continues as if the corresponding "
"invocation of the E<.Fn setjmp> had just returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/setjmp.9:65
msgid ""
"E<.Fn setjmp> and E<.Fn longjmp> are a machine-independent interface for "
"machine-dependent implementations."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/setjmp.9:68
msgid "These functions are primarily used by E<.Xr ddb 4>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/setjmp.9:69
msgid "E<.Xr ddb 4>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/shutdownhook_establish.9:36
#, no-wrap
msgid "SHUTDOWNHOOK_ESTABLISH 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/shutdownhook_establish.9:41
msgid "E<.Nm shutdownhook_establish>, E<.Nm shutdownhook_disestablish>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/shutdownhook_establish.9:41
#, no-wrap
msgid "add or remove a shutdown hook"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/shutdownhook_establish.9:47
msgid ""
"E<.Ft void *> E<.Fn shutdownhook_establish \"void (*fn)(void *)\" \"void "
"*arg\"> E<.Ft void> E<.Fn shutdownhook_disestablish \"void *cookie\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/shutdownhook_establish.9:64
msgid ""
"The E<.Fn shutdownhook_establish> function adds E<.Fa fn> to the list of "
"hooks invoked by E<.Xr doshutdownhooks 9> at shutdown.  When invoked, the "
"hook function E<.Fa fn> will be passed E<.Fa arg> as its only argument."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/shutdownhook_establish.9:75
msgid ""
"The E<.Fn shutdownhook_disestablish> function removes the hook described by "
"the opaque pointer E<.Fa cookie> from the list of hooks to be invoked at "
"shutdown.  If E<.Fa cookie> is invalid, the result of E<.Fn "
"shutdownhook_disestablish> is undefined."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/shutdownhook_establish.9:82
msgid ""
"Shutdown hooks should be used to perform one-time activities that must "
"happen immediately before the kernel exits.  Because of the environment in "
"which they are run, shutdown hooks cannot rely on many system services "
"(including file systems, and timeouts and other interrupt-driven services), "
"or even basic system integrity (because the system could be rebooting after "
"a crash)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/shutdownhook_establish.9:88
msgid ""
"If successful, E<.Fn shutdownhook_establish> returns an opaque pointer "
"describing the newly-established shutdown hook.  Otherwise, it returns NULL."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/shutdownhook_establish.9:93
msgid ""
"It may be appropriate to use a shutdown hook to disable a device that does "
"direct memory access, so that the device will not try to access memory while "
"the system is rebooting."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/shutdownhook_establish.9:97
msgid ""
"It may be appropriate to use a shutdown hook to inform watchdog timer "
"hardware that the operating system is no longer running."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/shutdownhook_establish.9:99
msgid "E<.Xr doshutdownhooks 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/shutdownhook_establish.9:100
msgid "The names are clumsy, at best."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/signal.9:30
#, no-wrap
msgid "April 29, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/signal.9:31
#, no-wrap
msgid "SIGNAL 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:57
msgid ""
"E<.Nm signal>, E<.Nm siginit>, E<.Nm sigactsinit>, E<.Nm sigactsunshare>, "
"E<.Nm sigactsfree>, E<.Nm execsigs>, E<.Nm sigaction1>, E<.Nm sigprocmask1>, "
"E<.Nm sigpending1>, E<.Nm sigsuspend1>, E<.Nm sigaltstack1>, E<.Nm "
"pgsignal>, E<.Nm kpgsignal>, E<.Nm psignal>, E<.Nm kpsignal>, E<.Nm "
"issignal>, E<.Nm postsig>, E<.Nm killproc>, E<.Nm sigexit>, E<.Nm "
"trapsignal>, E<.Nm sendsig>, E<.Nm sigcode>, E<.Nm sigtramp>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/signal.9:57
#, no-wrap
msgid "software signal facilities"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/signal.9:59
#, no-wrap
msgid "sys/signal.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:104
msgid ""
"E<.Ft void> E<.Fn siginit \"struct proc *p\"> E<.Ft void> E<.Fn sigactsinit "
"\"struct proc *pp\" \"int share\"> E<.Ft void> E<.Fn sigactsunshare \"struct "
"proc *p\"> E<.Ft void> E<.Fn sigactsfree \"struct proc *p\"> E<.Ft void> "
"E<.Fn execsigs \"struct proc *p\"> E<.Ft int> E<.Fn sigaction1 \"struct lwp "
"*l\" \"int signum\" \"const struct sigaction *nsa\" \"struct sigaction "
"*osa\" \"void *tramp\" \"int vers\"> E<.Ft int> E<.Fn sigprocmask1 \"struct "
"lwp *l\" \"int how\" \"const sigset_t *nss\" \"sigset_t *oss\"> E<.Ft void> "
"E<.Fn sigpending1 \"struct lwp *l\" \"sigset_t *ss\"> E<.Ft int> E<.Fn "
"sigsuspend1 \"struct lwp *l\" \"const sigset_t *ss\"> E<.Ft int> E<.Fn "
"sigaltstack1 \"struct lwp *l\" \"const struct sigaltstack *nss\" \"struct "
"sigaltstack *oss\"> E<.Ft void> E<.Fn pgsignal \"struct pgrp *pgrp\" \"int "
"signum\" \"int checkctty\"> E<.Ft void> E<.Fn kpgsignal \"struct pgrp "
"*pgrp\" \"ksiginfo_t *ks\" \"void *data\" \"int checkctty\"> E<.Ft void> "
"E<.Fn psignal \"struct proc *p\" \"int signum\"> E<.Ft void> E<.Fn kpsignal "
"\"struct proc *p\" \"ksiginfo_t *ks\" \"void *data\"> E<.Ft int> E<.Fn "
"issignal \"struct lwp *l\"> E<.Ft void> E<.Fn postsig \"int signum\"> E<.Ft "
"void> E<.Fn killproc \"struct proc *p\" \"const char *why\"> E<.Ft void> "
"E<.Fn sigexit \"struct lwp *l\" \"int signum\"> E<.Ft void> E<.Fn trapsignal "
"\"struct lwp *l\" \"const ksiginfo_t *ks\"> E<.Ft void> E<.Fn sendsig "
"\"const ksiginfo_t *ks\" \"const sigset_t *mask\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:107
msgid ""
"The system defines a set of signals that may be delivered to a process.  "
"These functions implement the kernel portion of the signal facility."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:111
msgid ""
"Signal numbers used throughout the kernel signal facilities should always be "
"within the range of E<.Bq 1- Ns NSIG>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:118
msgid ""
"Most of the kernel's signal infrastructure is implemented in "
"machine-independent code.  Machine-dependent code provides support for "
"invoking a process's signal handler, restoring context when the signal "
"handler returns, generating signals when hardware traps occur, triggering "
"the delivery of signals when a process is about to return from the kernel to "
"userspace."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:124
msgid ""
"The signal state for a process is contained in E<.Fa struct sigctx>.  This "
"includes the list of signals with delivery pending, information about the "
"signal handler stack, the signal mask, and the address of the signal "
"trampoline."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:128
msgid ""
"The registered signal handlers for a process are recorded in E<.Fa struct "
"sigacts>.  This structure may be shared by multiple processes."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:131
msgid "The kernel's signal facilities are implemented by the following functions:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/signal.9:132
#, no-wrap
msgid "Fn siginit p"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:140
msgid ""
"This function initializes the signal state of E<.Va proc0> to the system "
"default.  This signal state is then inherited by E<.Xr init 8> when it is "
"started by the kernel."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/signal.9:140
#, no-wrap
msgid "Fn sigactsinit pp share"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:158
msgid ""
"This function creates an initial E<.Fa struct sigacts> for the process E<.Fa "
"pp>.  If the E<.Fa share> argument is non-zero, then E<.Fa pp> shares the "
"E<.Fa struct sigacts> by holding a reference.  Otherwise, E<.Fa pp> receives "
"a new E<.Fa struct sigacts> which is copied from the parent."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/signal.9:158
#, no-wrap
msgid "Fn sigactsunshare p"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:165
msgid ""
"This function causes the process E<.Fa p> to no longer share its E<.Fa "
"struct sigacts> The current state of the signal actions is maintained in the "
"new copy."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/signal.9:165
#, no-wrap
msgid "Fn sigactsfree p"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:174
msgid ""
"This function decrements the reference count on the E<.Fa struct sigacts> of "
"process E<.Fa p>.  If the reference count reaches zero, the E<.Fa struct "
"sigacts> is freed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/signal.9:174
#, no-wrap
msgid "Fn execsigs p"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:179
msgid ""
"This function is used to reset the signal state of the process E<.Fa p> to "
"the system defaults when the process execs a new program image."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/signal.9:179
#, no-wrap
msgid "Fn sigaction1 l signum nsa osa tramp vers"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:203
msgid ""
"This function implements the E<.Xr sigaction 2> system call.  The E<.Fa "
"tramp> and E<.Fa vers> arguments provide support for userspace signal "
"trampolines.  Trampoline version 0 is reserved for the legacy "
"kernel-provided signal trampoline; E<.Fa tramp> must be E<.Dv NULL> in this "
"case.  Otherwise, E<.Fa vers> specifies the ABI of the trampoline specified "
"by E<.Fa tramp>.  The signal trampoline ABI is machine-dependent, and must "
"be coordinated with the E<.Fn sendsig> function."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/signal.9:203
#, no-wrap
msgid "Fn sigprocmask1 l how nss oss"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:208
msgid "This function implements the E<.Xr sigprocmask 2> system call."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/signal.9:208
#, no-wrap
msgid "Fn sigpending1 l ss"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:213
msgid "This function implements the E<.Xr sigpending 2> system call."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/signal.9:213
#, no-wrap
msgid "Fn sigsuspend1 l ss"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:218
msgid "This function implements the E<.Xr sigsuspend 2> system call."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/signal.9:218
#, no-wrap
msgid "Fn sigaltstack1 l nss oss"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:223
msgid "This function implements the E<.Xr sigaltstack 2> system call."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/signal.9:223
#, no-wrap
msgid "Fn pgsignal pgrp signum checkctty"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:228
msgid "This is a wrapper function for E<.Fn kpgsignal> which is described below."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/signal.9:228
#, no-wrap
msgid "Fn kpgsignal pgrp ks data checkctty"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:243
msgid ""
"Schedule the signal E<.Fa ks-\\*[Gt]ksi_signo> to be delivered to all "
"members of the process group E<.Fa pgrp>.  If E<.Fa checkctty> is non-zero, "
"the signal is only sent to processes which have a controlling terminal.  The "
"E<.Fa data> argument and the complete signal scheduling semantics are "
"described in the E<.Fn kpsignal> function below."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/signal.9:243
#, no-wrap
msgid "Fn trapsignal l ks"
msgstr ""

#
#.  XXX: Check for reality in 2010.
#
#.  This function is meant to be called by machine-dependent trap handling
#.  code, through the
#.  .Dv p-\*[Gt]p_emul-\*[Gt]e_trapsignal
#.  function pointer because some emulations define their own trapsignal
#.  functions that remap the signal information to what the emulation
#.  expects.
#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:257
msgid ""
"Sends the signal E<.Fa ks-\\*[Gt]ksi_signo> caused by a hardware trap to the "
"current process."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/signal.9:257
#, no-wrap
msgid "Fn psignal p signum"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:262
msgid "This is a wrapper function for E<.Fn kpsignal> which is described below."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/signal.9:262
#, no-wrap
msgid "Fn kpsignal p ks data"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:276
msgid ""
"Schedule the signal E<.Fa ks-\\*[Gt]ksi_signo> to be delivered to the "
"process E<.Fa p>.  The E<.Fa data> argument, if not E<.Dv NULL>, points to "
"the file descriptor data that caused the signal to be generated in the E<.Li "
"SIGIO> case."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:285
msgid ""
"With a few exceptions noted below, the target process signal disposition is "
"updated and is marked as runnable, so further handling of the signal is done "
"in the context of the target process after a context switch; see E<.Fn "
"issignal> below.  Note that E<.Fn kpsignal> does not by itself cause a "
"context switch to happen."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:287
msgid "The target process is not marked as runnable in the following cases:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:292
msgid ""
"The target process is sleeping uninterruptibly.  The signal will be noticed "
"when the process returns from the system call or trap."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:294
msgid "The target process is currently ignoring the signal."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:299
msgid ""
"If a stop signal is sent to a sleeping process that takes the default action "
"E<.Pq see Xr sigaction 2>, the process is stopped without awakening it."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:305
msgid ""
"SIGCONT restarts a stopped process E<.Pq or puts them back to sleep> "
"regardless of the signal action E<.Pq e.g., blocked or ignored>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:312
msgid ""
"If the target process is being traced, E<.Fn kpsignal> behaves as if the "
"target process were taking the default action for E<.Fa signum>.  This "
"allows the tracing process to be notified of the signal."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/signal.9:312
#, no-wrap
msgid "Fn issignal l"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:317
msgid ""
"This function determines which signal, if any, is to be posted to the "
"current process.  A signal is to be posted if:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:320
msgid "The signal has a handler provided by the program image."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:322
msgid "The signal should cause the process to dump core and/or terminate."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:324
msgid "The signal should interrupt the current system call."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:329
msgid ""
"Signals which cause the process to be stopped are handled within E<.Fn "
"issignal> directly."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:334
msgid ""
"E<.Fn issignal> should be called by machine-dependent code when returning to "
"userspace from a system call or other trap or interrupt by using the "
"following code:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:337
#, no-wrap
msgid ""
"while (signum = CURSIG(curproc))\n"
"\tpostsig(signum);\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/signal.9:339
#, no-wrap
msgid "Fn postsig signum"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:350
msgid ""
"The E<.Fn postsig> function is used to invoke the action for the signal "
"E<.Fa signum> in the current process.  If the default action of a signal is "
"to terminate the process, and the signal does not have a registered handler, "
"the process exits using E<.Fn sigexit>, dumping a core image if necessary."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/signal.9:350
#, no-wrap
msgid "Fn killproc p why"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:357
msgid ""
"This function sends a SIGKILL signal to the specified process.  The message "
"provided by E<.Fa why> is sent to the system log and is also displayed on "
"the process's controlling terminal."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/signal.9:357
#, no-wrap
msgid "Fn sigexit l signum"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:363
msgid ""
"This function forces the current process to exit with the signal E<.Fa "
"signum>, generating a core file if appropriate.  No checks are made for "
"masked or caught signals; the process always exits."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/signal.9:363
#, no-wrap
msgid "Fn sendsig ks mask"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:376
msgid ""
"This function is provided by machine-dependent code, and is used to invoke a "
"signal handler for the current process.  E<.Fn sendsig> must prepare the "
"registers and stack of the current process to invoke the signal handler "
"stored in the process's E<.Fa struct sigacts>.  This may include switching "
"to an alternate signal stack specified by the process.  The previous "
"register, stack, and signal state are stored in a E<.Fa ucontext_t>, which "
"is then copied out to the user's stack."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:379
msgid ""
"The registers and stack must be set up to invoke the signal handler as "
"follows:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:381
#, no-wrap
msgid "(*handler)(int signum, siginfo_t *info, void *ctx)\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:400
msgid ""
"where E<.Fa signum> is the signal number, E<.Fa info> contains additional "
"signal specific information when E<.Li SA_SIGINFO> is specified when setting "
"up the signal handler.  E<.Fa ctx> is the pointer to E<.Fa ucontext_t> on "
"the user's stack.  The registers and stack must also arrange for the signal "
"handler to return to the signal trampoline.  The trampoline is then used to "
"return to the code which was executing when the signal was delivered using "
"the E<.Xr setcontext 2> system call."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:411
msgid ""
"For performance reasons, it is recommended that E<.Fn sendsig> arrange for "
"the signal handler to be invoked directly on architectures where it is "
"convenient to do so.  In this case, the trampoline is used only for the "
"signal return path.  If it is not feasible to directly invoke the signal "
"handler, the trampoline is also used to invoke the handler, performing any "
"final set up that was not possible for E<.Fn sendsig> to perform."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:422
msgid ""
"E<.Fn sendsig> must invoke the signal trampoline with the correct ABI.  The "
"ABI of the signal trampoline is specified on a per-signal basis in the E<.Fn "
"sigacts> structure for the process.  Trampoline version 0 is reserved for "
"the legacy kernel-provided, on-stack signal trampoline.  All other "
"trampoline versions indicate a specific trampoline ABI.  This ABI is "
"coordinated with machine-dependent code in the system C library."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/signal.9:423
#, no-wrap
msgid "SIGNAL TRAMPOLINE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:430
msgid ""
"The signal trampoline is a special piece of code which provides support for "
"invoking the signal handlers for a process.  The trampoline is used to "
"return from the signal handler back to the code which was executing when the "
"signal was delivered, and is also used to invoke the handler itself on "
"architectures where it is not feasible to have the kernel invoke the handler "
"directly."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:446
msgid ""
"In traditional E<.Ux> systems, the signal trampoline, also referred to as "
"the E<.Dq sigcode>, is provided by the kernel and copied to the top of the "
"user's stack when a new process is created or a new program image is "
"exec'd.  Starting in E<.Nx 2.0>, the signal trampoline is provided by the "
"system C library.  This allows for more flexibility when the signal facility "
"is extended, makes dealing with signals easier in debuggers, such as E<.Xr "
"gdb 1>, and may also enhance system security by allowing the kernel to "
"disallow execution of code on the stack."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:450
msgid ""
"The signal trampoline is specified on a per-signal basis.  The correct "
"trampoline is selected automatically by the C library when a signal handler "
"is registered by a process."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:455
msgid ""
"Signal trampolines have a special naming convention which enables debuggers "
"to determine the characteristics of the signal handler and its arguments.  "
"Trampoline functions are named like so:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:457
#, no-wrap
msgid "__sigtramp_\\*[Lt]flavor\\*[Gt]_\\*[Lt]version\\*[Gt]\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:460
msgid "where:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/signal.9:461
#, no-wrap
msgid "Aq flavor"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:464
msgid "The flavor of the signal handler.  The following flavors are valid:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/signal.9:465
#, no-wrap
msgid "sigcontext"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:468
msgid ""
"Specifies a traditional BSD-style (deprecated) signal handler with the "
"following signature:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:472
#, no-wrap
msgid ""
"void (*handler)(int signum,\n"
"\tint code,\n"
"\tstruct sigcontext *scp);\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/signal.9:473
#, no-wrap
msgid "siginfo"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:475
msgid "Specifies a POSIX-style signal handler with the following signature:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:479
#, no-wrap
msgid ""
"void (*handler)(int signum,\n"
"\tsiginfo_t *si,\n"
"\tvoid *uc);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:483
msgid ""
"Note: sigcontext style signal handlers are deprecated, and retained only for "
"compatibility with older binaries."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/signal.9:484
#, no-wrap
msgid "Aq version"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:491
msgid ""
"Specifies the ABI version of the signal trampoline.  The trampoline ABI is "
"coordinated with the machine-dependent kernel E<.Fn sendsig> function.  The "
"trampoline version needs to be unique even across different trampoline "
"flavors, in order to simplify trampoline selection in the kernel."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:496
msgid ""
"The following is an example if a signal trampoline name which indicates that "
"the trampoline is used for traditional BSD-style signal handlers and "
"implements version 1 of the signal trampoline ABI:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:498
#, no-wrap
msgid "__sigtramp_sigcontext_1\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:501
msgid "The current signal trampoline is:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:503
#, no-wrap
msgid "__sigtramp_siginfo_2\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/signal.9:507
msgid "E<.Xr sigaction 2>, E<.Xr signal 7>, E<.Xr condvar 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/skpc.9:29
#, no-wrap
msgid "SKPC 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/skpc.9:34
msgid "E<.Nm skpc>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/skpc.9:34
#, no-wrap
msgid "skip a character in a byte string"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/skpc.9:43
msgid "E<.Ft int> E<.Fn skpc \"u_char mask\" \"size_t size\" \"u_char *cp\">"
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/skpc.9:54
msgid ""
"The E<.Fn skpc> function scans the byte string E<.Fa cp>, whose length is "
"E<.Fa size>, until it finds the first character which isn't equal to E<.Fa "
"mask> or the string is exhausted."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/skpc.9:59
msgid "The E<.Fn skpc> function returns the number of characters skipped."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/skpc.9:62
msgid "The E<.Fn skpc> function emulates a VAX instruction with the same name."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/sockopt.9:27
#, no-wrap
msgid "SOCKOPT 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sockopt.9:36
msgid ""
"E<.Nm sockopt_init>, E<.Nm sockopt_destroy>, E<.Nm sockopt_get>, E<.Nm "
"sockopt_getint> E<.Nm sockopt_set>, E<.Nm sockopt_setint>,"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/sockopt.9:36
#, no-wrap
msgid "socket options handling"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sockopt.9:51
msgid ""
"E<.Ft void> E<.Fn sockopt_init \"struct sockopt *sopt\" \"int level\" \"int "
"name\" \"size_t size\"> E<.Ft void> E<.Fn sockopt_destroy \"struct sockopt "
"*sopt\"> E<.Ft int> E<.Fn sockopt_get \"struct sockopt *sopt\" \"void "
"*value\" \"size_t size\"> E<.Ft int> E<.Fn sockopt_getint \"struct sockopt "
"*sopt\" \"int *value\"> E<.Ft int> E<.Fn sockopt_set \"struct sockopt "
"*sopt\" \"const void *value\" \"size_t size\"> E<.Ft int> E<.Fn "
"sockopt_setint \"struct sockopt *sopt\" \"int value\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sockopt.9:55
msgid ""
"The E<.Ft sockopt> structure is used to pass a socket option and associated "
"value:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sockopt.9:63
#, no-wrap
msgid ""
"struct sockopt {\n"
"\tint\t\tsopt_level;\t\t/* option level */\n"
"\tint\t\tsopt_name;\t\t/* option name */\n"
"\tsize_t\t\tsopt_size;\t\t/* data length */\n"
"\tvoid *\t\tsopt_data;\t\t/* data pointer */\n"
"\tuint8_t\t\tsopt_buf[sizeof(int)];\t/* internal storage */\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sockopt.9:68
msgid ""
"The internal storage is used for the common case of values up to integer "
"size so that memory allocation is not required and sopt_data will point to "
"this in that case."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sockopt.9:75
msgid ""
"Rather than provide accessor functions, the E<.Ft sockopt> structure is "
"public and the contents are expected to be internally consistent, but the "
"normal practice would be to use the appropriate methods for storage and "
"retrieval of values where a known datatype is expected, as the size will be "
"verified."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sockopt.9:80
msgid ""
"Note: a sockopt structure may only be used for a single level/name/size "
"combination.  If the structure is to be re-used, it must be destroyed and "
"re-initialized with the new values."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sockopt.9:86
msgid ""
"Kernels compiled with the E<.Dv DIAGNOSTIC> option will perform basic sanity "
"checks on socket options operations."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sockopt.9:89
#, no-wrap
msgid "Fn sockopt_init sopt level name size"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sockopt.9:101
msgid ""
"Initialise sockopt storage.  If E<.Ar size> is given, E<.Fn sockopt_init> "
"will arrange for sopt_data to point to a buffer of E<.Ar size> bytes for the "
"sockopt value.  Where memory needs to be allocated to satisfy this, E<.Fn "
"sockopt_init> may sleep."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sockopt.9:101
#, no-wrap
msgid "Fn sockopt_destroy sopt"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sockopt.9:103
msgid "Destroy sockopt storage, releasing any allocated memory."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sockopt.9:103
#, no-wrap
msgid "Fn sockopt_get sopt value size"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sockopt.9:108
msgid ""
"Copy out sockopt value.  Will return E<.Er EINVAL> if an incorrect data size "
"is given."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sockopt.9:108
#, no-wrap
msgid "Fn sockopt_getint sopt value"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sockopt.9:113
msgid ""
"Common case of get sockopt integer value.  Will return E<.Er EINVAL> if "
"sockopt does not contain an integer sized value."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sockopt.9:113
#, no-wrap
msgid "Fn sockopt_set sopt value size"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sockopt.9:126
msgid ""
"Copy in sockopt value.  The sockopt structure must contain a data field of "
"E<.Ar size> bytes or be previously unset, in which case a data buffer may be "
"allocated using E<.Xr kmem_alloc 9> with the E<.Dv KM_NOSLEEP> flag which "
"may cause E<.Fn sockopt_set> to return E<.Er ENOMEM>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sockopt.9:134
msgid ""
"Note: If you need to use E<.Fn sockopt_set> in a context where memory "
"allocation may be required and you do not wish to contemplate failure, the "
"sockopt structure can be initialised in a more suitable context using E<.Fn "
"sockopt_init> which will not fail."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sockopt.9:134
#, no-wrap
msgid "Fn sockopt_setint sopt value"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sockopt.9:138
msgid ""
"Common case of set sockopt integer value.  The sockpt structure must contain "
"an int sized data field or be previously unset, in which case the data "
"pointer will be set to the internal storage."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sockopt.9:144
msgid ""
"The function prototypes and sockopt structure are defined in the E<.Pa "
"sys/sys/socketvar.h> header file, and the socket options implementation is "
"in E<.Pa sys/kern/uipc_socket.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sockopt.9:147
msgid "E<.Xr errno 2>, E<.Xr kmem 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sockopt.9:152
msgid ""
"The socket options KPI was inspired by a similar KPI in E<.Fx> and first "
"appeared in E<.Nx 5.0>."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/softintr.9:63
#, no-wrap
msgid "SOFTINT 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/softintr.9:70
msgid ""
"E<.Nm softint>, E<.Nm softint_establish>, E<.Nm softint_disestablish>, E<.Nm "
"softint_schedule>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/softintr.9:70
#, no-wrap
msgid "machine-independent software interrupt framework"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/softintr.9:72 org_netbsd/src/share/man/man9/spl.9:46
#, no-wrap
msgid "sys/intr.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/softintr.9:79
msgid ""
"E<.Ft void *> E<.Fn softint_establish \"u_int flags\" \"void (*func)(void "
"*)\" \"void *arg\"> E<.Ft void> E<.Fn softint_disestablish \"void *cookie\"> "
"E<.Ft void> E<.Fn softint_schedule \"void *cookie\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/softintr.9:83
msgid ""
"The software interrupt framework is designed to provide a generic software "
"interrupt mechanism which can be used any time a low-priority callback is "
"needed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/softintr.9:87
msgid ""
"It allows dynamic registration of software interrupts for loadable drivers "
"and protocol stacks, prioritization and fair queueing of software "
"interrupts, and allows machine-dependent optimizations to reduce cost."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/softintr.9:94
msgid ""
"Four priority levels are provided.  In order of priority (lowest to highest) "
"the levels are: clock, bio, net, serial.  The names are symbolic and in "
"isolation do not have any direct connection with a particular kind of device "
"activity: they are only meant as a guide."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/softintr.9:102
msgid ""
"The four priority levels map directly to scheduler priority levels, and "
"where the architecture implements E<.Dq fast> software interrupts, they also "
"map onto interrupt priorities.  The interrupt priorities are intended to be "
"hidden from machine independent code, which should in general use "
"thread-safe mechanisms to synchronize with software interrupts (for example: "
"mutexes)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/softintr.9:112
msgid ""
"Software interrupts run with limited machine context.  In particular, they "
"do not possess any address space context.  They should not try to operate on "
"user space addresses, or to use virtual memory facilities other than those "
"noted as interrupt safe.  Unlike hardware interrupts, software interrupts do "
"have thread context.  They may block on synchronization objects, sleep, and "
"resume execution at a later time."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/softintr.9:120
msgid ""
"Since software interrupts are a limited resource and run with higher "
"priority than most other LWPs in the system, all block-and-resume activity "
"by a software interrupt must be kept short to allow further processing at "
"that level to continue.  By extension, code running with process context "
"must take care to ensure that any lock that may be taken from a software "
"interrupt can not be held for more than a short period of time."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/softintr.9:127
msgid ""
"The kernel does not allow software interrupts to use facilities or perform "
"actions that are likely to block for a significant amount of time.  This "
"means that it's not valid for a software interrupt to sleep on condition "
"variables or to wait for resources to become available (for example, "
"memory)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/softintr.9:130
#, no-wrap
msgid "Fn softint_establish flags func arg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/softintr.9:137
msgid ""
"Register a software interrupt.  The E<.Fa flags> value must contain one of "
"the following constants, specifing the priority level for the soft "
"interrupt:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/softintr.9:142
msgid ""
"E<.Dv SOFTINT_CLOCK>, E<.Dv SOFTINT_BIO>, E<.Dv SOFTINT_NET>, E<.Dv "
"SOFTINT_SERIAL>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/softintr.9:151
msgid ""
"If the constant E<.Dv SOFTINT_MPSAFE> is not logically ORed into E<.Fa "
"flags>, the global E<.Dv kernel_lock> will automatically be acquired before "
"the soft interrupt handler is called."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/softintr.9:159
msgid ""
"The constant E<.Fa func> specifies the function to call when the soft "
"interrupt is executed.  The argument E<.Fa arg> will be passed to this "
"function."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/softintr.9:170
msgid ""
"E<.Fn softint_establish> may block in order to allocate memory.  If "
"successful, it returns a E<.Pf non- Dv NULL> opaque value to be used as an "
"argument to E<.Fn softint_schedule> and/or E<.Fn softint_disestablish>.  If "
"for some reason it does not succeed, it returns E<.Dv NULL>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/softintr.9:170
#, no-wrap
msgid "Fn softint_disestablish cookie"
msgstr ""

#.  XXX What happens to pending scheduled calls?
#. type: Plain text
#: org_netbsd/src/share/man/man9/softintr.9:176
msgid ""
"Deallocate a software interrupt previously allocated by a call to E<.Fn "
"softint_establish>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/softintr.9:176
#, no-wrap
msgid "Fn softint_schedule cookie"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/softintr.9:185
msgid ""
"Schedule a software interrupt previously allocated by a call to E<.Fn "
"softint_establish> to be executed as soon as that software interrupt is "
"unblocked.  E<.Fn softint_schedule> can safely be called multiple times "
"before the callback routine is invoked."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/softintr.9:193
msgid ""
"Soft interrupt scheduling is CPU-local.  A request to dispatch a soft "
"interrupt will only be serviced on the same CPU where the request was made.  "
"The LWPs (light weight processes) dedicated to soft interrupt processing are "
"bound to their home CPUs, so if a soft interrupt handler sleeps and later "
"resumes, it will always resume on the same CPU."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/softintr.9:197
msgid ""
"On a system with multiple processors, multiple instances of the same soft "
"interrupt handler can be in flight simultaneously (at most one per-CPU)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/softintr.9:206
msgid ""
"E<.Xr callout 9>, E<.Xr condvar 9>, E<.Xr kthread 9>, E<.Xr mutex 9>, E<.Xr "
"rwlock 9>, E<.Xr spl 9>, E<.Xr workqueue 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/softintr.9:219
msgid ""
"The E<.Nx> machine-independent software interrupt framework was designed in "
"1997 and was implemented by one port in E<.Nx 1.3>.  However, it did not "
"gain wider implementation until E<.Nx 1.5>.  Between E<.Nx 4.0> and E<.Nx "
"5.0> the framework was re-implemented in a machine-independent way to "
"provide software interrupts with thread context."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/spl.9:31
#, no-wrap
msgid "SPL 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:44
msgid ""
"E<.Nm spl>, E<.Nm spl0>, E<.Nm splhigh>, E<.Nm splvm>, E<.Nm splsched>, "
"E<.Nm splsoftbio>, E<.Nm splsoftclock>, E<.Nm splsoftnet>, E<.Nm "
"splsoftserial>, E<.Nm splx>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/spl.9:44 org_netbsd/src/share/man/man9/man9.i386/splraise.9:33
#, no-wrap
msgid "modify system interrupt priority level"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:65
msgid ""
"E<.Ft void> E<.Fn spl0 void> E<.Ft int> E<.Fn splhigh void> E<.Ft int> E<.Fn "
"splsched void> E<.Ft int> E<.Fn splvm void> E<.Ft int> E<.Fn splsoftbio "
"void> E<.Ft int> E<.Fn splsoftclock void> E<.Ft int> E<.Fn splsoftserial "
"void> E<.Ft int> E<.Fn splsoftnet void> E<.Ft void> E<.Fn splx \"int s\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:69
msgid ""
"These functions raise and lower the interrupt priority level.  They are used "
"by kernel code to block interrupts in critical sections, in order to protect "
"data structures."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:79
msgid ""
"In a multi-CPU system, these functions change the interrupt priority level "
"on the local CPU only.  In general, device drivers should not make use of "
"these interfaces.  To ensure correct synchronization, device drivers should "
"use the E<.Xr condvar 9>, E<.Xr mutex 9>, and E<.Xr rwlock 9> interfaces."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:86
msgid ""
"Interrupt priorities are arranged in a strict hierarchy, although sometimes "
"levels may be equivalent (overlap).  The hierarchy means that raising the "
"IPL to any level will block interrupts at that level, and at all lower "
"levels.  The hierarchy is used to minimize data loss due to interrupts not "
"being serviced in a timely fashion."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:94
msgid ""
"The levels may be divided into two groups: hard and soft.  Hard interrupts "
"are generated by hardware devices.  Soft interrupts are a way of deferring "
"hardware interrupts to do more expensive processing at a lower interrupt "
"priority, and are explicitly scheduled by the higher-level interrupt "
"handler.  Software interrupts are further described by E<.Xr softint 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:103
msgid ""
"Note that hard interrupt handlers do not possess process (thread) context "
"and so it is not valid to use kernel facilities that may attempt to sleep "
"from a hardware interrupt.  For example, it is not possible to acquire a "
"reader/writer lock from a hardware interrupt.  Soft interrupt handlers "
"possess limited process context and so may sleep briefly in order to acquire "
"a reader/writer lock or adaptive mutex, but may not sleep for any other "
"reason."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:106
msgid ""
"In order of highest to lowest priority, the priority-raising functions along "
"with their counterpart symbolic tags are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/spl.9:107
#, no-wrap
msgid "Fn splhigh , IPL_HIGH"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:113
msgid ""
"Blocks all hard and soft interrupts, including the highest level I/O "
"interrupts, such as interrupts from serial interfaces and the statistics "
"clock (if any).  It is also used for code that cannot tolerate any "
"interrupts."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:123
msgid ""
"Code running at this level may not (in general) directly access machine "
"independent kernel services.  For example, it is illegal to call the kernel "
"E<.Fn printf> function or to try and allocate memory.  The methods of "
"synchronization available are: spin mutexes and scheduling a soft "
"interrupt.  Generally, all code run at this level must schedule additional "
"processing to run in a software interrupt."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:128
msgid ""
"Code with thread context running at this level must not use a kernel "
"interface that may cause the current LWP to sleep, such as the E<.Xr condvar "
"9> interfaces."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:132
msgid ""
"Interrupt handlers at this level cannot acquire the global kernel_lock and "
"so must be coded to ensure correct synchronization on multiprocessor "
"systems."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/spl.9:132
#, no-wrap
msgid "Fn splsched , IPL_SCHED"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:136
msgid ""
"Blocks all medium priority hardware interrupts, such as interrupts from "
"audio devices, and the clock interrupt."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:144
msgid ""
"Interrupt handlers running at this level endure the same restrictions as at "
"IPL_HIGH, but may access scheduler interfaces, and so may awaken LWPs (light "
"weight processes) using the E<.Xr condvar 9> interfaces, and may schedule "
"callouts using the E<.Xr callout 9> interfaces."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:149
msgid ""
"Code with thread context running at this level may sleep via the E<.Xr "
"condvar 9> interfaces, and may use other kernel facilities that could cause "
"the current LWP to sleep."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/spl.9:149
#, no-wrap
msgid "Fn splvm , IPL_VM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:155
msgid ""
"Blocks hard interrupts from E<.Dq low> priority hardware interrupts, such as "
"interrupts from network, block I/O and tty devices."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:162
msgid ""
"Code running at this level endures the same restrictions as at IPL_SCHED, "
"but may use the deprecated E<.Xr malloc 9> or endorsed E<.Xr pool_cache 9> "
"interfaces to allocate memory."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:171
msgid ""
"At the time of writing, the global E<.Dv kernel_lock> is automatically "
"acquired for interrupts at this level, in order to support device drivers "
"that do not provide their own multiprocessor synchronization.  A future "
"release of the system may allow the automatic acquisition of E<.Dv "
"kernel_lock> to be disabled for individual interrupt handlers."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/spl.9:171
#, no-wrap
msgid "Fn splsoftserial , IPL_SOFTSERIAL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:174
msgid "Blocks soft interrupts at the IPL_SOFTSERIAL symbolic level."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:178
msgid ""
"This is the first of the software levels.  Soft interrupts at this level and "
"lower may acquire reader/writer locks or adaptive mutexes."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/spl.9:178
#, no-wrap
msgid "Fn splsoftnet , IPL_SOFTNET"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:181
msgid "Blocks soft interrupts at the IPL_SOFTNET symbolic level."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/spl.9:181
#, no-wrap
msgid "Fn splsoftbio , IPL_SOFTBIO"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:184
msgid "Blocks soft interrupts at the IPL_SOFTBIO symbolic level."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/spl.9:184
#, no-wrap
msgid "Fn splsoftclock , IPL_SOFTCLOCK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:187
msgid "Blocks soft interrupts at the IPL_SOFTCLOCK symbolic level."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:191
msgid ""
"This is the priority at which callbacks generated by the E<.Xr callout 9> "
"facility runs."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:194
msgid "One function lowers the system priority level:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/spl.9:195
#, no-wrap
msgid "Fn spl0 , IPL_NONE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:201
msgid ""
"Unblocks all interrupts.  This should rarely be used directly; E<.Fn splx> "
"should be used instead."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:210
msgid ""
"The E<.Fn splx> function restores the system priority level to the one "
"encoded in E<.Fa s>, which must be a value previously returned by one of the "
"other E<.Nm> functions."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:216
msgid ""
"E<.Xr condvar 9>, E<.Xr i386/splraise 9>, E<.Xr kpreempt 9>, E<.Xr mutex 9>, "
"E<.Xr rwlock 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:235
msgid ""
"In E<.Bx 4.4>, E<.Fn splnet> was used to block network software interrupts.  "
"Most device drivers used E<.Fn splimp> to block hardware interrupts.  To "
"avoid unnecessarily blocking other interrupts, in E<.Nx 1.1> a new function "
"was added that blocks only network hardware interrupts.  For consistency "
"with other E<.Nm> functions, the old E<.Fn splnet> function was renamed to "
"E<.Fn splsoftnet>, and the new function was named E<.Fn splnet>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:246
msgid ""
"Originally, E<.Fn splsoftclock> lowered the system priority level.  During "
"the E<.Nx 1.5> development cycle, E<.Fn spllowersoftclock> was introduced "
"and the semantics of E<.Fn splsoftclock> were changed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:260
msgid ""
"The E<.Fn splimp> call was removed from the kernel between E<.Nx 1.5> and "
"E<.Nx 1.6>.  The function of E<.Fn splimp> was replaced by E<.Fn splvm> and "
"code which abused the semantics of E<.Fn splimp> was changed to not mix "
"interrupt priority levels."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/spl.9:266
msgid ""
"Between E<.Nx 4.0> and E<.Nx 5.0>, the hardware levels were reduced in "
"number and a strict hierarchy defined."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/splraiseipl.9:28
#, no-wrap
msgid "February 11, 2007"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/splraiseipl.9:29
#, no-wrap
msgid "SPLRAISEIPL 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/splraiseipl.9:34
msgid "E<.Nm splraiseipl>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/splraiseipl.9:34
#, no-wrap
msgid "raise the system priority level"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/splraiseipl.9:43
msgid "E<.Ft int> E<.Fn splraiseipl \"ipl_cookie_t icookie\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/splraiseipl.9:50
msgid ""
"E<.Fn splraiseipl> raises the system priority level to the level specified "
"by E<.Fa icookie>.  E<.Fa icookie> should be a value returned by E<.Fn "
"makeiplcookie>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/splraiseipl.9:58
msgid ""
"In general, device drivers should not make use of this interface.  To ensure "
"correct synchronization, device drivers should use the E<.Xr condvar 9>, "
"E<.Xr mutex 9>, and E<.Xr rwlock 9> interfaces."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/splraiseipl.9:63
msgid ""
"See the E<.Xr spl 9> manual page for a description of interrupt priority "
"levels."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/splraiseipl.9:68
msgid ""
"E<.Fn splraiseipl> returns saved priority level which can be used for E<.Fn "
"splx>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/splraiseipl.9:70
msgid "The following two lines are functional equivalents."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/splraiseipl.9:72
#, no-wrap
msgid "\ts = splraiseipl(makeiplcookie(IPL_VM));\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/splraiseipl.9:75
#, no-wrap
msgid "\ts = splvm();\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/splraiseipl.9:81
msgid ""
"Because E<.Fn makeiplcookie> can be slow and is not expected to be used in a "
"perfomance critical path, it's better to do it beforehand."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/splraiseipl.9:84
#, no-wrap
msgid ""
"\tinitialization_code(ipl_t ipl)\n"
"\t{\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/splraiseipl.9:87
#, no-wrap
msgid ""
"\t\tourcookie = makeiplcookie(ipl);\n"
"\t}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/splraiseipl.9:91
#, no-wrap
msgid ""
"\tperformance_critical_code()\n"
"\t{\n"
"\t\tint s;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/splraiseipl.9:96
#, no-wrap
msgid ""
"\t\ts = splraiseipl(ourcookie);\n"
"\t\tdo_something();\n"
"\t\tsplx(s);\n"
"\t}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/splraiseipl.9:103
msgid ""
"E<.Xr condvar 9>, E<.Xr makeiplcookie 9>, E<.Xr mutex 9>, E<.Xr rwlock 9>, "
"E<.Xr spl 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/store.9:36
#, no-wrap
msgid "STORE 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/store.9:46
msgid ""
"E<.Nm store>, E<.Nm subyte>, E<.Nm suibyte>, E<.Nm susword>, E<.Nm "
"suswintr>, E<.Nm suword>, E<.Nm suiword>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/store.9:46
#, no-wrap
msgid "store data to user-space"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/store.9:58
msgid ""
"E<.Ft int> E<.Fn subyte \"void *base\" \"int c\"> E<.Ft int> E<.Fn susword "
"\"void *base\" \"short c\"> E<.Ft int> E<.Fn suswintr \"void *base\" \"short "
"c\"> E<.Ft int> E<.Fn suword \"void *base\" \"long c\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/store.9:63
msgid ""
"The E<.Nm> functions are designed to copy small amounts of data to the "
"user-space of the currently running process."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/store.9:68
#, no-wrap
msgid "Fn subyte"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/store.9:71
msgid "Stores a byte of data to the user-space address E<.Fa base>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/store.9:71
#, no-wrap
msgid "Fn susword"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/store.9:74
msgid "Stores a short word of data to the user-space address E<.Fa base>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/store.9:74
#, no-wrap
msgid "Fn suswintr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/store.9:78
msgid ""
"Stores a short word of data to the user-space address E<.Fa base>.  This "
"function is safe to call during an interrupt context."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/store.9:78
#, no-wrap
msgid "Fn suword"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/store.9:81
msgid "Stores a word of data to the user-space address E<.Fa base>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/store.9:86
msgid "The E<.Nm> functions return 0 on success or -1 on failure."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/store.9:88
msgid "E<.Xr copy 9>, E<.Xr fetch 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/suspendsched.9:30
#, no-wrap
msgid "September 21, 2002"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/suspendsched.9:31
#, no-wrap
msgid "SUSPENDSCHED 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/suspendsched.9:35
msgid "E<.Nm suspendsched>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/suspendsched.9:35
#, no-wrap
msgid "suspend the scheduler"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/suspendsched.9:41
msgid "E<.Ft void> E<.Fn suspendsched \"void\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/suspendsched.9:46
msgid ""
"The E<.Fn suspendsched> function suspends the operation of the scheduler by "
"stopping all non-system processes which are on the run queue or the sleep "
"queue."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/suspendsched.9:49
msgid ""
"The E<.Fn suspendsched> function must not be called with the scheduler lock "
"held."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/sysctl.9:31
#, no-wrap
msgid "SYSCTL 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:35
msgid "E<.Nm sysctl>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/sysctl.9:35
#, no-wrap
msgid "system variable control interfaces"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:65
msgid ""
"Primary external interfaces: E<.Ft void> E<.Fn sysctl_init void> E<.Ft int> "
"E<.Fn sysctl_lock \"struct lwp *l\" \"void *oldp\" \"size_t savelen\"> E<.Ft "
"int> E<.Fn sysctl_dispatch \"const int *name\" \"u_int namelen\" \"void "
"*oldp\" \"size_t *oldlenp\" \"const void *newp\" \"size_t newlen\" \"const "
"int *oname\" \"struct lwp *l\" \"const struct sysctlnode *rnode\"> E<.Ft "
"void> E<.Fn sysctl_unlock \"struct lwp *l\"> E<.Ft int> E<.Fn sysctl_createv "
"\"struct sysctllog **log\" \"int cflags\" \"const struct sysctlnode "
"**rnode\" \"const struct sysctlnode **cnode\" \"int flags\" \"int type\" "
"\"const char *namep\" \"const char *desc\" \"sysctlfn func\" \"u_quad_t qv\" "
"\"void *newp\" \"size_t newlen\" ...> E<.Ft int> E<.Fn sysctl_destroyv "
"\"struct sysctlnode *rnode\" ...> E<.Ft void> E<.Fn sysctl_free \"struct "
"sysctlnode *rnode\"> E<.Ft void> E<.Fn sysctl_teardown \"struct sysctllog "
"**\"> E<.Ft int> E<.Fn old_sysctl \"int *name\" \"u_int namelen\" \"void "
"*oldp\" \"size_t *oldlenp\" \"void *newp\" \"size_t newlen\" \"struct lwp "
"*l\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:86
msgid ""
"Core internal functions: E<.Ft int> E<.Fn sysctl_locate \"struct lwp *l\" "
"\"const int *name\" \"u_int namelen\" \"const struct sysctlnode **rnode\" "
"\"int *nip\"> E<.Ft int> E<.Fn sysctl_lookup \"const int *name\" \"u_int "
"namelen\" \"void *oldp\" \"size_t *oldlenp\" \"const void *newp\" \"size_t "
"newlen\" \"const int *oname\" \"struct lwp *l\" \"const struct sysctlnode "
"*rnode\"> E<.Ft int> E<.Fn sysctl_create \"const int *name\" \"u_int "
"namelen\" \"void *oldp\" \"size_t *oldlenp\" \"const void *newp\" \"size_t "
"newlen\" \"const int *oname\" \"struct lwp *l\" \"const struct sysctlnode "
"*rnode\"> E<.Ft int> E<.Fn sysctl_destroy \"const int *name\" \"u_int "
"namelen\" \"void *oldp\" \"size_t *oldlenp\" \"const void *newp\" \"size_t "
"newlen\" \"const int *oname\" \"struct lwp *l\" \"const struct sysctlnode "
"*rnode\"> E<.Ft int> E<.Fn sysctl_query \"const int *name\" \"u_int "
"namelen\" \"void *oldp\" \"size_t *oldlenp\" \"const void *newp\" \"size_t "
"newlen\" \"const int *oname\" \"struct lwp *l\" \"const struct sysctlnode "
"*rnode\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:102
msgid ""
"Simple E<.Dq helper> functions: E<.Ft int> E<.Fn sysctl_needfunc \"const int "
"*name\" \"u_int namelen\" \"void *oldp\" \"size_t *oldlenp\" \"const void "
"*newp\" \"size_t newlen\" \"const int *oname\" \"struct lwp *l\" \"const "
"struct sysctlnode *rnode\"> E<.Ft int> E<.Fn sysctl_notavail \"const int "
"*name\" \"u_int namelen\" \"void *oldp\" \"size_t *oldlenp\" \"const void "
"*newp\" \"size_t newlen\" \"const int *oname\" \"struct lwp *l\" \"const "
"struct sysctlnode *rnode\"> E<.Ft int> E<.Fn sysctl_null \"const int *name\" "
"\"u_int namelen\" \"void *oldp\" \"size_t *oldlenp\" \"const void *newp\" "
"\"size_t newlen\" \"const int *oname\" \"struct lwp *l\" \"const struct "
"sysctlnode *rnode\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:107
msgid ""
"The SYSCTL subsystem instruments a number of kernel tunables and other data "
"structures via a simple MIB-like interface, primarily for consumption by "
"userland programs, but also for use internally by the kernel."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:132
msgid ""
"All operations on the SYSCTL tree must be protected by acquiring the main "
"SYSCTL lock.  The only functions that can be called when the lock is not "
"held are E<.Fn sysctl_lock>, E<.Fn sysctl_createv>, E<.Fn sysctl_destroyv>, "
"and E<.Fn old_sysctl>.  All other functions require the tree to be locked.  "
"This is to prevent other users of the tree from moving nodes around during "
"an add operation, or from destroying nodes or subtrees that are actively "
"being used.  The lock is acquired by calling E<.Fn sysctl_lock> with a "
"pointer to the process's lwp E<.Fa l> E<.Dv ( NULL> may be passed to all "
"functions as the lwp pointer if no lwp is appropriate, though any changes "
"made via E<.Fn sysctl_create>, E<.Fn sysctl_destroy>, E<.Fn sysctl_lookup>, "
"or by any helper function will be done with effective superuser privileges)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:142
msgid ""
"The E<.Fa oldp> and E<.Fa savelen> arguments are a pointer to and the size "
"of the memory region the caller will be using to collect data from SYSCTL.  "
"These may also be E<.Dv NULL> and 0, respectively."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:152
msgid ""
"The memory region will be locked via E<.Fn uvm_vslock> if it is a region in "
"userspace.  The address and size of the region are recorded so that when the "
"SYSCTL lock is to be released via E<.Fn sysctl_unlock>, only the lwp pointer "
"E<.Fa l> is required."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/sysctl.9:152
#, no-wrap
msgid "LOOKUPS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:163
msgid ""
"Once the lock has been acquired, it is typical to call E<.Fn "
"sysctl_dispatch> to handle the request.  E<.Fn sysctl_dispatch> will examine "
"the contents of E<.Fa name>, an array of integers at least E<.Fa namelen> "
"long, which is to be located in kernel space, in order to determine which "
"function to call to handle the specific request."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:167
msgid ""
"The following algorithm is used by E<.Fn sysctl_dispatch> to determine the "
"function to call:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:172
msgid "Scan the tree using E<.Fn sysctl_locate>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:176
msgid "If the node returned has a E<.Dq helper> function, call it."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:179
msgid ""
"If the requested node was found but has no function, call E<.Fn "
"sysctl_lookup>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:188
msgid ""
"If the node was not found and E<.Fa name> specifies one of E<.Fn "
"sysctl_query>, E<.Fn sysctl_create>, or E<.Fn sysctl_destroy>, call the "
"appropriate function."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:192
msgid ""
"If none of these options applies and no other error was yet recorded, return "
"E<.Er EOPNOTSUPP>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:241
msgid ""
"The E<.Fa oldp> and E<.Fa oldlenp> arguments to E<.Fn sysctl_dispatch>, as "
"with all the other core functions, describe an area into which the current "
"or requested value may be copied.  E<.Fa oldp> may or may not be a pointer "
"into userspace (as dictated by whether E<.Fa l> is E<.Dv NULL> or not).  "
"E<.Fa oldlenp> is a E<.No non- Ns Dv NULL> pointer to a size_t.  E<.Fa newp> "
"and E<.Fa newlen> describe an area where the new value for the request may "
"be found; E<.Fa newp> may also be a pointer into userspace.  The E<.Fa "
"oname> argument is a E<.No non- Ns Dv NULL> pointer to the base of the "
"request currently being processed.  By simple arithmetic on E<.Fa name>, "
"E<.Fa namelen>, and E<.Fa oname>, one can easily determine the entire "
"original request and E<.Fa namelen> values, if needed.  The E<.Fa rnode> "
"value, as passed to E<.Fn sysctl_dispatch> represents the root of the tree "
"into which the current request is to be dispatched.  If E<.Dv NULL>, the "
"main tree will be used."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:257
msgid ""
"The E<.Fn sysctl_locate> function scans a tree for the node most specific to "
"a request.  If the pointer referenced by E<.Fa rnode> is not E<.Dv NULL>, "
"the tree indicated is searched, otherwise the main tree will be used.  The "
"address of the most relevant node will be returned via E<.Fa rnode> and the "
"number of MIB entries consumed will be returned via E<.Fa nip>, if it is not "
"E<.Dv NULL>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:267
msgid ""
"The E<.Fn sysctl_lookup> function takes the same arguments as E<.Fn "
"sysctl_dispatch> with the caveat that the value for E<.Fa namelen> must be "
"zero in order to indicate that the node referenced by the E<.Fa rnode> "
"argument is the one to which the lookup is being applied."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/sysctl.9:267
#, no-wrap
msgid "CREATION AND DESTRUCTION OF NODES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:287
msgid ""
"New nodes are created and destroyed by the E<.Fn sysctl_create> and E<.Fn "
"sysctl_destroy> functions.  These functions take the same arguments as E<.Fn "
"sysctl_dispatch> with the additional requirement that the E<.Fa namelen> "
"argument must be 1 and the E<.Fa name> argument must point to an integer "
"valued either E<.Dv CTL_CREATE> or E<.Dv CTL_CREATESYM> when creating a new "
"node, or E<.Dv CTL_DESTROY> when destroying a node."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:301
msgid ""
"The E<.Fa newp> and E<.Fa newlen> arguments should point to a copy of the "
"node to be created or destroyed.  If the create or destroy operation was "
"successful, a copy of the node created or destroyed will be placed in the "
"space indicated by E<.Fa oldp> and E<.Fa oldlenp>.  If the create operation "
"fails because of a conflict with an existing node, a copy of that node will "
"be returned instead."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:311
msgid ""
"In order to facilitate the creation and destruction of nodes from a given "
"tree by kernel subsystems, the functions E<.Fn sysctl_createv> and E<.Fn "
"sysctl_destroyv> are provided.  These functions take care of the overhead of "
"filling in the contents of the create or destroy request, dealing with "
"locking, locating the appropriate parent node, etc."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:330
msgid ""
"The arguments to E<.Fn sysctl_createv> are used to construct the new node.  "
"If the E<.Fa log> argument is not E<.Dv NULL>, a E<.Em sysctllog> structure "
"will be allocated and the pointer referenced will be changed to address it.  "
"The same log may be used for any number of nodes, provided they are all "
"inserted into the same tree.  This allows for a series of nodes to be "
"created and later removed from the tree in a single transaction (via E<.Fn "
"sysctl_teardown>)  without the need for any record keeping on the caller's "
"part."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:353
msgid ""
"The E<.Fa cflags> argument is currently unused and must be zero.  The E<.Fa "
"rnode> argument must either be E<.Dv NULL> or a valid pointer to a reference "
"to the root of the tree into which the new node must be placed.  If it is "
"E<.Dv NULL>, the main tree will be used.  It is illegal for E<.Fa rnode> to "
"refer to a E<.Dv NULL> pointer.  If the E<.Fa cnode> argument is not E<.Dv "
"NULL>, on return it will be adjusted to point to the address of the new "
"node."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:364
msgid ""
"The E<.Fa flags> and E<.Fa type> arguments are combined into the E<.Fa "
"sysctl_flags> field, and the current value for E<.Dv SYSCTL_VERSION> is "
"added in.  The following types are defined:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysctl.9:365
#, no-wrap
msgid "Dv CTLTYPE_NODE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:367
msgid "A node intended to be a parent for other nodes."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysctl.9:367
#, no-wrap
msgid "Dv CTLTYPE_INT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:369
msgid "A signed integer."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysctl.9:369
#, no-wrap
msgid "Dv CTLTYPE_STRING"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:371
msgid "A NUL-terminated string."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysctl.9:371
#, no-wrap
msgid "Dv CTLTYPE_QUAD"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:373
msgid "An unsigned 64-bit integer."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysctl.9:373
#, no-wrap
msgid "Dv CTLTYPE_STRUCT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:375
msgid "A structure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysctl.9:375
#, no-wrap
msgid "Dv CTLTYPE_BOOL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:377
msgid "A boolean."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:391
msgid ""
"The E<.Fa namep> argument is copied into the E<.Fa sysctl_name> field and "
"must be less than E<.Dv SYSCTL_NAMELEN> characters in length.  The string "
"indicated by E<.Fa desc> will be copied if the E<.Dv CTLFLAG_OWNDESC> flag "
"is set, and will be used as the node's description."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:393
msgid "Two additional remarks:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:401
msgid ""
"The E<.Dv CTLFLAG_PERMANENT> flag can only be set from SYSCTL setup routines "
"(see E<.Sx SETUP FUNCTIONS>)  as called by E<.Fn sysctl_init>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:411
msgid ""
"If E<.Fn sysctl_destroyv> attempts to delete a node that does not own its "
"own description (and is not marked as permanent), but the deletion fails, "
"the description will be copied and E<.Fn sysctl_destroyv> will set the E<.Dv "
"CTLFLAG_OWNDESC> flag."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:447
msgid ""
"The E<.Fa func> argument is the name of a E<.Dq helper> function (see E<.Sx "
"HELPER FUNCTIONS AND MACROS>).  If the E<.Dv CTLFLAG_IMMEDIATE> flag is set, "
"the E<.Fa qv> argument will be interpreted as the initial value for the new "
"E<.Dq bool>, E<.Dq int> or E<.Dq quad> node.  This flag does not apply to "
"any other type of node.  The E<.Fa newp> and E<.Fa newlen> arguments "
"describe the data external to SYSCTL that is to be instrumented.  One of "
"E<.Fa func>, E<.Fa qv> and the E<.Dv CTLFLAG_IMMEDIATE> flag, or E<.Fa newp> "
"and E<.Fa newlen> must be given for nodes that instrument data, otherwise an "
"error is returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:465
msgid ""
"The remaining arguments are a list of integers specifying the path through "
"the MIB to the node being created.  The list must be terminated by the E<.Dv "
"CTL_EOL> value.  The penultimate value in the list may be E<.Dv CTL_CREATE> "
"if a dynamic MIB entry is to be made for this node.  E<.Fn sysctl_createv> "
"specifically does not support E<.Dv CTL_CREATESYM>, since setup routines are "
"expected to be able to use the in-kernel E<.Xr ksyms 4> interface to "
"discover the location of the data to be instrumented.  If the node to be "
"created matches a node that already exists, a return code of 0 is given, "
"indicating success."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:481
msgid ""
"When using E<.Fn sysctl_destroyv> to destroy a given node, the E<.Fa rnode> "
"argument, if not E<.Dv NULL>, is taken to be the root of the tree from which "
"the node is to be destroyed, otherwise the main tree is used.  The rest of "
"the arguments are a list of integers specifying the path through the MIB to "
"the node being destroyed.  If the node being destroyed does not exist, a "
"successful return code is given.  Nodes marked with the E<.Dv "
"CTLFLAG_PERMANENT> flag cannot be destroyed."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/sysctl.9:481
#, no-wrap
msgid "HELPER FUNCTIONS AND MACROS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:498
msgid ""
"Helper functions are invoked with the same common argument set as E<.Fn "
"sysctl_dispatch> except that the E<.Fa rnode> argument will never be E<.Dv "
"NULL>.  It will be set to point to the node that corresponds most closely to "
"the current request.  Helpers are forbidden from modifying the node they are "
"passed; they should instead copy the structure if changes are required in "
"order to effect access control or other checks.  The E<.Dq helper> prototype "
"and function that needs to ensure that a newly assigned value is within a "
"certain range (presuming external data) would look like the following:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:501
#, no-wrap
msgid "static int sysctl_helper(SYSCTLFN_PROTO);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:507
#, no-wrap
msgid ""
"static int\n"
"sysctl_helper(SYSCTLFN_ARGS)\n"
"{\n"
"\tstruct sysctlnode node;\n"
"\tint t, error;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:509
#, no-wrap
msgid "\tt = *(int *)rnode-\\*[Gt]sysctl_data;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:515
#, no-wrap
msgid ""
"\tnode = *rnode;\n"
"\tnode.sysctl_data = \\*[Am]t;\n"
"\terror = sysctl_lookup(SYSCTLFN_CALL(\\*[Am]node));\n"
"\tif (error || newp == NULL)\n"
"\t\treturn (error);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:518
#, no-wrap
msgid ""
"\tif (t \\*[Lt] 0 || t \\*[Gt] 20)\n"
"\t\treturn (EINVAL);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:522
#, no-wrap
msgid ""
"\t*(int *)rnode-\\*[Gt]sysctl_data = t;\n"
"\treturn (0);\n"
"}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:532
#, no-wrap
msgid ""
"The use of the\n"
"E<.Dv SYSCTLFN_PROTO>,\n"
"E<.Dv SYSCTLFN_ARGS, and>\n"
"E<.Dv SYSCTLFN_CALL>\n"
" macros ensure that all arguments are passed properly.\n"
"The single argument to the\n"
"E<.Dv SYSCTLFN_CALL>\n"
"macro is the pointer to the node being examined.\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:549
msgid ""
"Three basic helper functions are available for use.  E<.Fn sysctl_needfunc> "
"will emit a warning to the system console whenever it is invoked and "
"provides a simplistic read-only interface to the given node.  E<.Fn "
"sysctl_notavail> will forward E<.Dq queries> to E<.Fn sysctl_query> so that "
"subtrees can be discovered, but will return E<.Er EOPNOTSUPP> for any other "
"condition.  E<.Fn sysctl_null> specifically ignores any arguments given, "
"sets the value indicated by E<.Fa oldlenp> to zero, and returns success."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/sysctl.9:549
#, no-wrap
msgid "SETUP FUNCTIONS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:567
msgid ""
"Though nodes can be added to the SYSCTL tree at any time, in order to add "
"nodes during the kernel bootstrap phase, a proper E<.Dq setup> function must "
"be used.  Setup functions are declared using the E<.Dv SYSCTL_SETUP> macro, "
"which takes the name of the function and a short string description of the "
"function as arguments.  E<.Po> See the E<.Dv SYSCTL_DEBUG_SETUP> kernel "
"configuration in E<.Xr options 4>.  E<.Pc> The address of the function is "
"added to a list of functions that E<.Fn sysctl_init> traverses during "
"initialization."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:575
msgid ""
"Setup functions do not have to add nodes to the main tree, but can set up "
"their own trees for emulation or other purposes.  Emulations that require "
"use of a main tree but with some nodes changed to suit their own purposes "
"can arrange to overlay a sparse private tree onto their main tree by making "
"the E<.Fa e_sysctlovly> member of their struct emul definition point to the "
"overlaid tree."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:581
msgid ""
"Setup functions should take care to create all nodes from the root down to "
"the subtree they are creating, since the order in which setup functions are "
"called is arbitrary (the order in which setup functions are called is only "
"determined by the ordering of the object files as passed to the linker when "
"the kernel is built)."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/sysctl.9:581 org_netbsd/src/share/man/man9/uvm.9:344
#, no-wrap
msgid "MISCELLANEOUS FUNCTIONS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:586
msgid ""
"E<.Fn sysctl_init> is called early in the kernel bootstrap process.  It "
"initializes the SYSCTL lock, calls all the registered setup functions, and "
"marks the tree as permanent."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:597
msgid ""
"E<.Fn sysctl_free> will unconditionally delete any and all nodes below the "
"given node.  Its intended use is for the deletion of entire trees, not "
"subtrees.  If a subtree is to be removed, E<.Fn sysctl_destroy> or E<.Fn "
"sysctl_destroyv> should be used to ensure that nodes not owned by the "
"sub-system being deactivated are not mistakenly destroyed.  The SYSCTL lock "
"must be held when calling this function."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:603
msgid ""
"E<.Fn sysctl_teardown> unwinds a E<.Em sysctllog> and deletes the nodes in "
"the opposite order in which they were created."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:619
msgid ""
"E<.Fn old_sysctl> provides an interface similar to the old SYSCTL "
"implementation, with the exception that access checks on a per-node basis "
"are performed if the E<.Fa l> argument is E<.No non- Ns Dv NULL>.  If called "
"with a E<.Dv NULL> argument, the values for E<.Fa newp> and E<.Fa oldp> are "
"interpreted as kernel addresses, and access is performed as for the "
"superuser."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:622
msgid ""
"It is expected that nodes will be added to (or removed from) the tree during "
"the following stages of a machine's lifetime:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:626
msgid "initialization -- when the kernel is booting"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:628
msgid "autoconfiguration -- when devices are being probed at boot time"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:632
msgid ""
"E<.Dq plug and play> device attachment -- when a PC-Card, USB, or other "
"device is plugged in or attached"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:634
msgid "module initialization -- when a module is being loaded"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:639
msgid ""
"E<.Dq run-time> -- when a process creates a node via the E<.Xr sysctl 3> "
"interface"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:654
msgid ""
"Nodes marked with E<.Dv CTLFLAG_PERMANENT> can only be added to a tree "
"during the first or initialization phase, and can never be removed.  The "
"initialization phase terminates when the main tree's root is marked with the "
"E<.Dv CTLFLAG_PERMANENT> flag.  Once the main tree is marked in this manner, "
"no nodes can be added to any tree that is marked with E<.Dv "
"CTLFLAG_READONLY> at its root, and no nodes can be added at all if the main "
"tree's root is so marked."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:659
msgid ""
"Nodes added by device drivers, modules, and at device insertion time can be "
"added to (and removed from)  E<.Dq read-only> parent nodes."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:667
msgid ""
"Nodes created by processes can only be added to E<.Dq writable> parent "
"nodes.  See E<.Xr sysctl 3> for a description of the flags that are allowed "
"to be used by when creating nodes."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:669
msgid "E<.Xr sysctl 3>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:672
msgid "The dynamic SYSCTL implementation first appeared in E<.Nx 2.0>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysctl.9:675
msgid ""
"E<.An Andrew Brown> E<.Aq atatat@NetBSD.org> designed and implemented the "
"dynamic SYSCTL implementation."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:30
#, no-wrap
msgid "April 10, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:31
#, no-wrap
msgid "SYSMON_ENVSYS 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:35
msgid "E<.Nm sysmon_envsys>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:35
#, no-wrap
msgid "kernel part of the envsys 2 framework"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:37 org_netbsd/src/share/man/man9/sysmon_pswitch.9:37
#, no-wrap
msgid "dev/sysmon/sysmonvar.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:56
msgid ""
"E<.Ft struct sysmon_envsys *> E<.Fn sysmon_envsys_create \"void\"> E<.Ft "
"void> E<.Fn sysmon_envsys_destroy \"struct sysmon_envsys *\"> E<.Ft int> "
"E<.Fn sysmon_envsys_register \"struct sysmon_envsys *\"> E<.Ft void> E<.Fn "
"sysmon_envsys_unregister \"struct sysmon_envsys *\"> E<.Ft int> E<.Fn "
"sysmon_envsys_sensor_attach \"struct sysmon_envsys *\" \"envsys_data_t *\"> "
"E<.Ft int> E<.Fn sysmon_envsys_sensor_detach \"struct sysmon_envsys *\" "
"\"envsys_data_t *\"> E<.Ft void> E<.Fn sysmon_envsys_sensor_event \"struct "
"sysmon_envsys *\" \"envsys_data_t *\" \"int\"> E<.Ft void> E<.Fn "
"sysmon_envsys_foreach_sensor \"sysmon_envsys_callback_t\" \"void *\" "
"\"bool\"> E<.Ft int> E<.Fn sysmon_envsys_update_limits \"struct "
"sysmon_envsys *\" \"envsys_data_t *\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:67
msgid ""
"E<.Nm> is the kernel part of the E<.Xr envsys 4> framework.  With this "
"framework you are able to register and unregister a E<.Nm> device, attach or "
"detach sensors into a device, and enable or disable automatic monitoring for "
"some sensors without any user interactivity, among other things."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:67
#, no-wrap
msgid "HOW TO USE THE FRAMEWORK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:78
msgid ""
"To register a new driver to the E<.Nm> framework, a E<.Em sysmon_envsys> "
"object must be allocated and initialized; the E<.Fn sysmon_envsys_create> "
"function is used for this.  This returns a zero'ed pointer to a E<.Em "
"sysmon_envsys> structure."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:90
msgid ""
"Once the object has been initialized, actual sensors may be initialized and "
"attached (see the E<.Sx SENSOR DETAILS> section for more information).  This "
"is accomplished by the E<.Fn sysmon_envsys_sensor_attach> function, which "
"will attach the E<.Em envsys_data_t> (a sensor) specified as second argument "
"into the E<.Em sysmon_envsys> object specified in the first argument."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:97
msgid ""
"Finally, after all sensors have been attached, the device needs to set some "
"required (and optional) members of the E<.Em sysmon_envsys> structure before "
"calling the E<.Fn sysmon_envsys_register> function to register the device."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:104
msgid ""
"In case of errors during the initialization, the E<.Fn "
"sysmon_envsys_destroy> function should be used.  This detachs all previously "
"attached sensors and deallocates the E<.Em sysmon_envsys> object."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:115
msgid ""
"Some sensors can be monitored, and when the sensor value changes an event "
"can be delivered to the E<.Xr powerd 8> daemon.  Sensor monitoring can be "
"performed by the E<.Nm> framework on a polled basis.  Alternatively, the "
"sensor's device driver can call the E<.Fn sysmon_envsys_sensor_event> "
"function to deliver the event without waiting for the device to be polled."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:123
msgid ""
"The E<.Fn sysmon_envsys_foreach_sensor> function can be used by other parts "
"of the kernel to iterate over all registered sensors.  This capability is "
"used by the E<.Xr i386/apm 4> driver to summarize the state of all battery "
"sensors."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:130
msgid ""
"Drivers can also call the E<.Fn sysmon_envsys_update_limits> function when "
"it is necessary to reinitialize a sensor's threshhold values.  This is used "
"by the E<.Xr acpibat 4> driver when a new battery is inserted."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:135
msgid ""
"The E<.Em sysmon_envsys> structure is defined as follows (only the public "
"members are shown):"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:148
#, no-wrap
msgid ""
"struct sysmon_envsys {\n"
"\tconst char \t*sme_name;\n"
"\tint\t\tsme_flags;\n"
"\tint\t\tsme_class;\n"
"\tuint64_t\tsme_events_timeout;\n"
"\tvoid \t\t*sme_cookie;\n"
"\tvoid (*sme_refresh)(struct sysmon_envsys *, envsys_data_t *);\n"
"\tvoid (*sme_set_limits)(struct sysmon_envsys *, envsys_data_t *,\n"
"\t\t\t       sysmon_envsys_lim_t *, uint32_t *);\n"
"\tvoid (*sme_get_limits)(struct sysmon_envsys *, envsys_data_t *,\n"
"\t\t\t       sysmon_envsys_lim_t *, uint32_t *);\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:151
msgid "The members have the following meaning:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:153
#, no-wrap
msgid "Fa sme_class"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:158
msgid ""
"This specifies the class of the sysmon envsys device.  See the E<.Sy DEVICE "
"CLASSES> section for more information (OPTIONAL)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:158
#, no-wrap
msgid "Fa sme_name"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:160
msgid "The name that will be used in the driver (REQUIRED)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:160
#, no-wrap
msgid "Fa sme_flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:170
msgid ""
"Additional flags for the E<.Nm> device.  Currently supporting E<.Ar "
"SME_DISABLE_REFRESH>.  If enabled, the E<.Ar sme_refresh> function callback "
"won't be used to refresh sensor data and the driver will use its own method "
"(OPTIONAL)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:170
#, no-wrap
msgid "Fa sme_events_timeout"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:173
msgid ""
"This is used to specify the default timeout value (in seconds) that will be "
"used to check for critical events if any monitoring flag was set (OPTIONAL)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:178
msgid ""
"If the driver wants to refresh sensors data via the E<.Nm> framework, the "
"following members may be specified:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:180
#, no-wrap
msgid "Fa sme_cookie"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:189
msgid ""
"Typically a pointer to the device struct (also called E<.Dq softc>).  This "
"may be used in the E<.Sy sme_refresh>, E<.Sy sme_get_limits>, or E<.Sy "
"sme_set_limits> function callbacks."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:189
#, no-wrap
msgid "Fa sme_refresh"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:202
msgid ""
"Pointer to a function that will be used to refresh sensor data in the "
"device.  This can be used to set the state and other properties of the "
"sensor depending on the data returned by the driver.  E<.Em NOTE>: E<.Em You "
"don't have to refresh all sensors, only the sensor specified by the> E<.Sy "
"edata-\\*[Gt]sensor> E<.Em index>.  If this member is not specified, the "
"device driver will be totally responsible for all updates of this sensor; "
"the E<.Nm> framework will not be able to update the sensor value."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:202
#, no-wrap
msgid "Fa sme_get_limits"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:213
msgid ""
"Pointer to a function that will be used to obtain from the driver the "
"initial limits (or thresholds) used when monitoring a sensor's value.  (See "
"the E<.Sx SENSOR DETAILS> section for more information.)  If this member is "
"not specified, the E<.Dv ENVSYS_FMONLIMITS> flag will be ignored, and limit "
"monitoring will not occur until appropriate limits are enabled from userland "
"via E<.Xr envstat 8>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:213
#, no-wrap
msgid "Fa sme_set_limits"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:220
msgid ""
"Pointer to a function that alerts the device driver whenever monitoring "
"limits (or thresholds) are updated by the user.  Setting this function "
"allows the device driver to reprogram hardware limits (if provided by the "
"device) when the user-specificied limits are updated, and gives the driver "
"direct control over setting the sensor's state based on hardware status."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:229
msgid ""
"The E<.Fa sme_set_limits> callback can be invoked with the third argument (a "
"pointer to the new limits) set to a E<.Dv NULL> pointer.  Device drivers "
"must recognize this as a request to restore the sensor limits to their "
"original, boot-time values."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:236
msgid ""
"If the E<.Fa sme_set_limits> member is not specified, the device driver is "
"not informed of changes to the sensor's limit values, and the E<.Nm> "
"framework performs all limit checks in software."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:241
msgid ""
"Note that it's not necessary to refresh the sensors data before the driver "
"is registered, only do it if you need the data in your driver to check for a "
"specific condition."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:248
msgid ""
"The timeout value for the monitoring events on a device may be changed via "
"the E<.Dv ENVSYS_SETDICTIONARY> E<.Xr ioctl 2> or the E<.Xr envstat 8> "
"command."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:261
msgid ""
"To unregister a driver previously registered with the E<.Nm> framework, the "
"E<.Fn sysmon_envsys_unregister> function must be used.  If there were "
"monitoring events registered for the driver, they all will be destroyed "
"before the device is unregistered and its sensors are detached.  Finally the "
"E<.Em sysmon_envsys> object will be freed, so there's no need to call E<.Fn "
"sysmon_envsys_destroy>."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:261
#, no-wrap
msgid "DEVICE CLASSES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:269
msgid ""
"The E<.Fa sme_class> member of the E<.Fa sysmon_envsys> structure is an "
"optional flag that specifies the class of the sysmon envsys device.  "
"Currently there are two classes:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:271
#, no-wrap
msgid "SME_CLASS_ACADAPTER"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:281
msgid ""
"This class is for devices that want to act as an E<.Em AC adapter>.  The "
"device writer must ensure that at least there is a sensor with E<.Em units> "
"of E<.Dv ENVSYS_INDICATOR>.  This will be used to report its current state "
"(on/off)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:281
#, no-wrap
msgid "SME_CLASS_BATTERY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:290
msgid ""
"This class is for devices that want to act as a E<.Em Battery>.  The device "
"writer must ensure that at least there are two sensors with units of E<.Dv "
"ENVSYS_BATTERY_CAPACITY> and E<.Dv ENVSYS_BATTERY_CHARGE>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:307
msgid ""
"These two sensors are used to ensure that the battery device can send a "
"E<.Em low-power> event to the E<.Xr powerd 8> daemon (if running) when all "
"battery devices are in a critical state.  (The critical state occurs when a "
"battery is not currently charging and its charge state is low or critical.)  "
"When the E<.Em low-power> condition is met, an event is sent to the E<.Xr "
"powerd 8> daemon (if running), which will shutdown the system gracefully by "
"executing the E<.Fa /etc/powerd/scripts/sensor_battery> script."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:315
msgid ""
"If E<.Xr powerd 8> is not running, the system will be powered off via the "
"E<.Xr cpu_reboot 9> call with the E<.Dv RB_POWERDOWN> flag."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:325
msgid ""
"E<.Em NOTE>: If a E<.Dv SME_CLASS_ACADAPTER> or E<.Dv SME_CLASS_BATTERY> "
"class device doesn't have the sensors required, the E<.Em low-power> event "
"will never be sent, and the graceful shutdown won't be possible."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:325
#, no-wrap
msgid "SENSOR DETAILS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:329
msgid ""
"Each sensor uses a E<.Sy envsys_data_t> structure, it's defined as follows "
"(only the public members are shown);"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:344
#, no-wrap
msgid ""
"typedef struct envsys_data {\n"
"\tuint32_t\tunits;\n"
"\tuint32_t\tstate;\n"
"\tuint32_t\tflags;\n"
"\tuint32_t\trpms;\n"
"\tint32_t\t\trfact;\n"
"\tint32_t\t\tvalue_cur;\n"
"\tint32_t\t\tvalue_max;\n"
"\tint32_t\t\tvalue_min;\n"
"\tint32_t\t\tvalue_avg;\n"
"\tsysmon_envsys_lim_t limits;\n"
"\tint\t\tupropset;\n"
"\tchar\t\tdesc[ENVSYS_DESCLEN];\n"
"} envsys_data_t;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:349
msgid ""
"The members for the E<.Sy envsys_data_t> structure have the following "
"meaning:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:351
#, no-wrap
msgid "Fa units"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:353
msgid "Used to set the units type."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:353
#, no-wrap
msgid "Fa state"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:355
msgid "Used to set the current state."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:367
msgid ""
"Used to set additional flags.  Among other uses, if one or more of the E<.Dv "
"ENVSYS_FMONxxx> flags are set, automatic sensor monitoring will be enabled.  "
"Periodically, the sensor's value will be checked and if certain conditions "
"are met, an event will be sent to the E<.Xr powerd 8> daemon.  E<.Em NOTE> "
"E<.Em that limits (or thresholds) can be set at any time to enable> E<.Em "
"monitoring that the sensor's value remains within those limits>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:367
#, no-wrap
msgid "Fa rpms"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:371
msgid "Used to set the nominal RPM value for E<.Sy fan> sensors."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:371
#, no-wrap
msgid "Fa rfact"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:375
msgid "Used to set the rfact value for E<.Sy voltage> sensors."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:375
#, no-wrap
msgid "Fa value_cur"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:377
msgid "Used to set the current value."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:377
#, no-wrap
msgid "Fa value_max"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:379
msgid "Used to set the maximum value."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:379
#, no-wrap
msgid "Fa value_min"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:381
msgid "Used to set the minimum value."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:381
#, no-wrap
msgid "Fa value_avg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:383
msgid "Used to set the average value."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:383
#, no-wrap
msgid "Fa limits"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:385
msgid "Structure used to contain the sensor's alarm thresholds."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:385
#, no-wrap
msgid "Fa upropset"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:387
msgid "Used to keep track of which sensor properties are set."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:387 org_netbsd/src/share/man/man9/vcons.9:80
#, no-wrap
msgid "Fa desc"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:392
msgid ""
"Used to set the description string.  E<.Em NOTE> E<.Em that the description "
"string must be unique in a device, and sensors with> E<.Em duplicate or "
"empty description will simply be ignored>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:395
msgid "Users of this framework must take care about the following points:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:401
msgid ""
"The E<.Ar desc> member needs to have a valid description, unique in a device "
"and non empty to be valid."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:406
msgid "The E<.Ar units> type must be valid.  The following units are defined:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:408
#, no-wrap
msgid "Dv ENVSYS_STEMP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:410
msgid "For temperature sensors."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:410
#, no-wrap
msgid "Dv ENVSYS_SFANRPM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:412
msgid "For fan sensors."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:412
#, no-wrap
msgid "Dv ENVSYS_SVOLTS_AC"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:414
msgid "For AC Voltage."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:414
#, no-wrap
msgid "Dv ENVSYS_SVOLTS_DC"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:416
msgid "For DC Voltage."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:416
#, no-wrap
msgid "Dv ENVSYS_SOHMS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:418
msgid "For Ohms."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:418
#, no-wrap
msgid "Dv ENVSYS_SWATTS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:420
msgid "For Watts."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:420
#, no-wrap
msgid "Dv ENVSYS_SAMPS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:422
msgid "For Ampere."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:422
#, no-wrap
msgid "Dv ENVSYS_SWATTHOUR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:424
msgid "For Watts hour."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:424
#, no-wrap
msgid "Dv ENVSYS_SAMPHOUR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:426
msgid "For Ampere hour."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:426
#, no-wrap
msgid "Dv ENVSYS_INDICATOR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:428
msgid "For sensors that only want a boolean type."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:428
#, no-wrap
msgid "Dv ENVSYS_INTEGER"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:430
msgid "For sensors that only want an integer type."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:430
#, no-wrap
msgid "Dv ENVSYS_DRIVE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:432
msgid "For drive sensors."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:432
#, no-wrap
msgid "Dv ENVSYS_BATTERY_CAPACITY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:443
msgid ""
"For Battery device classes.  This sensor unit uses the E<.Dv "
"ENVSYS_BATTERY_CAPACITY_*> values in E<.Ar value_cur> to report its current "
"capacity to userland.  Mandatory if E<.Fa sme_class> is set to E<.Dv "
"SME_CLASS_BATTERY>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:443
#, no-wrap
msgid "Dv ENVSYS_BATTERY_CHARGE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:455
msgid ""
"For Battery device classes.  This sensor is equivalent to the Indicator "
"type, it's a boolean.  Use it to specify in what state is the Battery state: "
"E<.Sy true> if the battery is currently charging or E<.Sy false> otherwise.  "
"Mandatory if E<.Fa sme_class> is set to E<.Dv SME_CLASS_BATTERY>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:462
msgid ""
"When initializing or refreshing the sensor, the E<.Ar state> member should "
"be set to a known state (otherwise it will be in unknown state).  Possible "
"values:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:464
#, no-wrap
msgid "Dv ENVSYS_SVALID"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:466
msgid "Sets the sensor to a valid state."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:466
#, no-wrap
msgid "Dv ENVSYS_SINVALID"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:468
msgid "Sets the sensor to an invalid state."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:468
#, no-wrap
msgid "Dv ENVSYS_SCRITICAL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:470
msgid "Sets the sensor to a critical state."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:470
#, no-wrap
msgid "Dv ENVSYS_SCRITUNDER"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:472
msgid "Sets the sensor to a critical under state."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:472
#, no-wrap
msgid "Dv ENVSYS_SCRITOVER"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:474
msgid "Sets the sensor to a critical over state."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:474
#, no-wrap
msgid "Dv ENVSYS_SWARNUNDER"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:476
msgid "Sets the sensor to a warning under state."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:476
#, no-wrap
msgid "Dv ENVSYS_SWARNOVER"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:478
msgid "Sets the sensor to a warning over state."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:484
msgid "The E<.Ar flags> member accepts one or more of the following flags:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:486
#, no-wrap
msgid "Dv ENVSYS_FCHANGERFACT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:494
msgid ""
"Marks the sensor with ability to change the E<.Ar rfact> value on the fly "
"(in voltage sensors).  The E<.Ar rfact> member must be used in the correct "
"place of the code that retrieves and converts the value of the sensor."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:494
#, no-wrap
msgid "Dv ENVSYS_FPERCENT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:501
msgid ""
"This uses the E<.Ar value_cur> and E<.Ar value_max> members to make a "
"percentage.  Both values must be enabled and have data."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:501
#, no-wrap
msgid "Dv ENVSYS_FVALID_MAX"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:505
msgid "Marks the E<.Ar value_max> value as valid."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:505
#, no-wrap
msgid "Dv ENVSYS_FVALID_MIN"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:509
msgid "Marks the E<.Ar value_min> value as valid."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:509
#, no-wrap
msgid "Dv ENVSYS_FVALID_AVG"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:513
msgid "Marks the E<.Ar value_avg> value as valid."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:513
#, no-wrap
msgid "Dv ENVSYS_FMONCRITICAL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:515
msgid "Enables and registers a new event to monitor a critical state."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:515
#, no-wrap
msgid "Dv ENVSYS_FMONLIMITS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:518
msgid ""
"Enables and registers a new event to monitor a sensor's value crossing "
"limits or thresholds."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:518
#, no-wrap
msgid "Dv ENVSYS_FMONSTCHANGED"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:527
msgid ""
"Enables and registers a new event to monitor battery capacity or drive state "
"sensors.  The flag is not effective if the E<.Ar units> member is not E<.Dv "
"ENVSYS_DRIVE> or E<.Dv ENVSYS_BATTERY_CAPACITY>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:527
#, no-wrap
msgid "Dv ENVSYS_FMONNOTSUPP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:533
msgid ""
"Disallows setting of limits (or thresholds) via the E<.Dv "
"ENVSYS_SETDICTIONARY> E<.Xr ioctl 2>.  This flag only disables setting the "
"limits from userland.  It has no effect on monitoring flags set by the "
"driver."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:541
msgid ""
"E<.Em If the driver has to use any of the> E<.Ar value_max>, E<.Ar "
"value_min>, E<.Em or> E<.Ar value_avg> E<.Em members, they should be marked "
"as valid with the appropriate flag>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:550
msgid ""
"If E<.Ar units> is set to E<.Dv ENVSYS_DRIVE>, the E<.Ar value_cur> member "
"must be set to one of the following predefined states:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:552
#, no-wrap
msgid "Dv ENVSYS_DRIVE_EMPTY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:554
msgid "Drive state is unknown."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:554
#, no-wrap
msgid "Dv ENVSYS_DRIVE_READY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:556
msgid "Drive is ready."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:556
#, no-wrap
msgid "Dv ENVSYS_DRIVE_POWERUP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:558
msgid "Drive is powering up."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:558
#, no-wrap
msgid "Dv ENVSYS_DRIVE_ONLINE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:560
msgid "Drive is online."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:560
#, no-wrap
msgid "Dv ENVSYS_DRIVE_OFFLINE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:562
msgid "Drive is offline."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:562
#, no-wrap
msgid "Dv ENVSYS_DRIVE_IDLE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:564
msgid "Drive is idle."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:564
#, no-wrap
msgid "Dv ENVSYS_DRIVE_ACTIVE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:566
msgid "Drive is active."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:566
#, no-wrap
msgid "Dv ENVSYS_DRIVE_BUILD"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:568
msgid "Drive is building."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:568
#, no-wrap
msgid "Dv ENVSYS_DRIVE_REBUILD"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:570
msgid "Drive is rebuilding."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:570
#, no-wrap
msgid "Dv ENVSYS_DRIVE_POWERDOWN"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:572
msgid "Drive is powering down."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:572
#, no-wrap
msgid "Dv ENVSYS_DRIVE_FAIL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:574
msgid "Drive has failed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:574
#, no-wrap
msgid "Dv ENVSYS_DRIVE_PFAIL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:576
msgid "Drive has been degraded."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:576
#, no-wrap
msgid "Dv ENVSYS_DRIVE_MIGRATING"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:578
msgid "Drive is migrating."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:578
#, no-wrap
msgid "Dv ENVSYS_DRIVE_CHECK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:580
msgid "Drive is checking its state."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:590
msgid ""
"If E<.Ar units> is set to E<.Dv ENVSYS_BATTERY_CAPACITY>, the E<.Ar "
"value_cur> member must be set to one of the following predefined capacity "
"states:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:592
#, no-wrap
msgid "Dv ENVSYS_BATTERY_CAPACITY_NORMAL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:594
msgid "Battery charge is normal."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:594
#, no-wrap
msgid "Dv ENVSYS_BATTERY_CAPACITY_CRITICAL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:596
msgid "Battery charge is critical."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:596
#, no-wrap
msgid "Dv ENVSYS_BATTERY_CAPACITY_LOW"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:598
msgid "Battery charge is low."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:598
#, no-wrap
msgid "Dv ENVSYS_BATTERY_CAPACITY_WARNING"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:600
msgid "Battery charge is on or below the warning capacity."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:617
msgid ""
"The E<.Xr envsys 4> framework expects to have the values converted to a unit "
"that can be converted to another one easily.  That means the user should "
"convert the value returned by the driver to the appropriate unit.  For "
"example voltage sensors to E<.Sy mV>, temperature sensors to E<.Sy uK>, "
"Watts to E<.Sy mW>, Ampere to E<.Sy mA>, etc."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:625
msgid ""
"The following types shouldn't need any conversion: E<.Dv "
"ENVSYS_BATTERY_CAPACITY>, E<.Dv ENVSYS_BATTERY_CHARGE>, E<.Dv "
"ENVSYS_INDICATOR>, E<.Dv ENVSYS_INTEGER>, and E<.Dv ENVSYS_DRIVE>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:629
msgid ""
"E<.Em PLEASE NOTE THAT YOU MUST AVOID USING FLOATING POINT OPERATIONS> E<.Em "
"IN KERNEL WHEN CONVERTING THE DATA RETURNED BY THE DRIVER TO THE> E<.Em "
"APPROPRIATE UNIT, IT'S NOT ALLOWED>."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:631
#, no-wrap
msgid "HOW TO ENABLE AUTOMATIC MONITORING IN SENSORS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:637
msgid ""
"The following example illustrates how to enable automatic monitoring in a "
"virtual driver for a E<.Em critical> state in the first sensor E<.Fa ( "
"sc_sensor[0]>):"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:645
#, no-wrap
msgid ""
"int\n"
"mydriver_initialize_sensors(struct mysoftc *sc)\n"
"{\n"
"\t...\n"
"\t/* sensor is initialized with a valid state */\n"
"\tsc-\\*[Gt]sc_sensor[0].state = ENVSYS_SVALID;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:651
#, no-wrap
msgid ""
"\t/*\n"
"\t * the monitor member must be true to enable\n"
"\t * automatic monitoring.\n"
"\t */\n"
"\tsc-\\*[Gt]sc_sensor[0].monitor = true;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:656
#, no-wrap
msgid ""
"\t/* and now we specify the type of the monitoring event */\n"
"\tsc-\\*[Gt]sc_sensor[0].flags |= ENVSYS_FMONCRITICAL;\n"
"\t...\n"
"}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:661
#, no-wrap
msgid ""
"int\n"
"mydriver_refresh(struct sysmon_envsys *sme, envsys_data_t *edata)\n"
"{\n"
"\tstruct mysoftc *sc = sme-\\*[Gt]sme_cookie;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:664
#, no-wrap
msgid ""
"\t/* we get current data from the driver */\n"
"\tedata-\\*[Gt]value_cur = sc-\\*[Gt]sc_getdata();\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:682
#, no-wrap
msgid ""
"\t/*\n"
"\t * if value is too high, mark the sensor in\n"
"\t * critical state.\n"
"\t */\n"
"\tif (edata-\\*[Gt]value_cur \\*[Gt] MYDRIVER_SENSOR0_HIWAT) {\n"
"\t\tedata-\\*[Gt]state = ENVSYS_SCRITICAL;\n"
"\t\t/* a critical event will be sent now automatically */\n"
"\t} else {\n"
"\t\t/*\n"
"\t\t * if value is within the limits, and we came from\n"
"\t\t * a critical state make sure to change sensor's state\n"
"\t\t * to valid.\n"
"\t\t */\n"
"\t\tedata-\\*[Gt]state = ENVSYS_SVALID;\n"
"\t}\n"
"\t...\n"
"}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:687
msgid "The E<.Sy envsys 2> framework is implemented within the files:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:689
msgid "E<.Pa sys/dev/sysmon/sysmon_envsys.c>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:691
msgid "E<.Pa sys/dev/sysmon/sysmon_envsys_events.c>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:693
msgid "E<.Pa sys/dev/sysmon/sysmon_envsys_tables.c>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:695
msgid "E<.Pa sys/dev/sysmon/sysmon_envsys_util.c>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:698
msgid "E<.Xr envsys 4>, E<.Xr envstat 8>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:707
msgid ""
"The first E<.Em envsys> framework first appeared in E<.Nx 1.5>.  The E<.Em "
"envsys 2> framework first appeared in E<.Nx 5.0>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:715
msgid ""
"The (current)  E<.Em envsys 2> framework was implemented by E<.An Juan "
"Romero Pardines>.  Additional input on the design was provided by many "
"E<.Nx> developers around the world."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_envsys.9:719
msgid ""
"The first E<.Em envsys> framework was implemented by Jason R. Thorpe, Tim "
"Rightnour, and Bill Squier."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:31
#, no-wrap
msgid "SYSMON_PSWITCH 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:35
msgid "E<.Nm sysmon_pswitch>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:35
#, no-wrap
msgid "framework for power switches"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:44
msgid ""
"E<.Ft int> E<.Fn sysmon_pswitch_register \"struct sysmon_pswitch *smpsw\"> "
"E<.Ft void> E<.Fn sysmon_pswitch_unregister \"struct sysmon_pswitch "
"*smpsw\"> E<.Ft void> E<.Fn sysmon_pswitch_event \"struct sysmon_pswitch "
"*smpsw\" \"int event\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:55
msgid ""
"The machine-independent E<.Nm> provides a framework for power management.  "
"The interface has been largely superceded by the E<.Xr pmf 9> framework, but "
"E<.Nm> is still used to manage power switches as well as related mechanical "
"adapters and buttons.  These are encapsulated in the following structure:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:59
#, no-wrap
msgid ""
"struct sysmon_pswitch {\n"
"\tconst char *smpsw_name;\t\t/* power switch name */\n"
"\tint smpsw_type;\t\t\t/* power switch type */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:62
#, no-wrap
msgid ""
"\tLIST_ENTRY(sysmon_pswitch) smpsw_list;\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:70
msgid ""
"Unsurprisingly, E<.Fa smpsw_name> specifies the name of the power switch and "
"E<.Fa smpsw_type> defines the type of it.  The following types are defined:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:72
#, no-wrap
msgid "PSWITCH_TYPE_POWER"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:73
#, no-wrap
msgid "PSWITCH_TYPE_SLEEP"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:74
#, no-wrap
msgid "PSWITCH_TYPE_LID"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:75
#, no-wrap
msgid "PSWITCH_TYPE_RESET"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:76
#, no-wrap
msgid "PSWITCH_TYPE_ACADAPTER"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:77
#, no-wrap
msgid "PSWITCH_TYPE_HOTKEY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:84
msgid ""
"If the type is E<.Dv PSWITCH_TYPE_HOTKEY>, there are few predefined names "
"that can be used for E<.Fa smpsw_name>:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:86
#, no-wrap
msgid "PSWITCH_HK_DISPLAY_CYCLE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:88
msgid "E<.Em display-cycle>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:88
#, no-wrap
msgid "PSWITCH_HK_LOCK_SCREEN"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:90
msgid "E<.Em lock-screen>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:90
#, no-wrap
msgid "PSWITCH_HK_BATTERY_INFO"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:92
msgid "E<.Em battery-info>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:92
#, no-wrap
msgid "PSWITCH_HK_EJECT_BUTTON"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:94
msgid "E<.Em eject-button>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:94
#, no-wrap
msgid "PSWITCH_HK_ZOOM_BUTTON"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:96
msgid "E<.Em zoom-button>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:96
#, no-wrap
msgid "PSWITCH_HK_VENDOR_BUTTON"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:98
msgid "E<.Em vendor-button>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:105
msgid ""
"Once a power switch event has been proceeded, E<.Nm> will inform the user "
"space E<.Xr powerd 8>, which will possibly execute a script matching the "
"type of the power switch."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:113
msgid ""
"After the E<.Em sysmon_pswitch> structure has been initialized, a new power "
"switch device can be registered by using E<.Fn sysmon_pswitch_register>.  "
"The device can be detached from the framework by E<.Fn "
"sysmon_pswitch_unregister>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:119
msgid ""
"The E<.Fn sysmon_pswitch_event> is used to signal a new power switch event.  "
"There are two possibilities for the value of E<.Fa event>:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:120
#, no-wrap
msgid "PSWITCH_EVENT_PRESSED"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:122
msgid ""
"A button has been pressed, the lid has been closed, the AC adapter is off, "
"etc."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:122
#, no-wrap
msgid "PSWITCH_EVENT_RELEASED"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:124
msgid "A button has been released, the lid is open, the AC adapter is on, etc."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:132
msgid ""
"The corresponding events in E<.Xr powerd 8> are E<.Em pressed> and E<.Em "
"released>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:137
msgid "E<.Xr powerd 8>, E<.Xr pmf 9>, E<.Xr sysmon_envsys 9>, E<.Xr sysmon_taskq 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_pswitch.9:138 org_netbsd/src/share/man/man9/sysmon_taskq.9:97
msgid "E<.An Jason R. Thorpe Aq thorpej@NetBSD.org>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/sysmon_taskq.9:31
#, no-wrap
msgid "SYSMON_TASKQ 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_taskq.9:35
msgid "E<.Nm sysmon_taskq>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/sysmon_taskq.9:35
#, no-wrap
msgid "general purpose system monitoring task queue"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/sysmon_taskq.9:37
#, no-wrap
msgid "dev/sysmon/sysmon_taskq.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_taskq.9:46
msgid ""
"E<.Ft void> E<.Fn sysmon_task_queue_preinit \"void\"> E<.Ft void> E<.Fn "
"sysmon_task_queue_init \"void\"> E<.Ft void> E<.Fn sysmon_task_queue_fini "
"\"void\"> E<.Ft int> E<.Fn sysmon_task_queue_sched \"u_int pri\" \"void "
"(*func)(void *)\" \"void *arg\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_taskq.9:52
msgid ""
"The machine-independent E<.Nm> provides a simple general purpose task "
"queue.  It can be used to run callbacks that require thread context, but do "
"not warrant the use of a more fine-grained solution."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_taskq.9:56
msgid ""
"Although the intended usage is related to the context of system monitoring "
"and power management, also other comparable functions are suitable for "
"E<.Nm>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_taskq.9:67
msgid ""
"The necessary internal data structures are initialized during system startup "
"by E<.Fn sysmon_task_queue_preinit>.  Before actual usage, a "
"machine-dependent procedure should finish the initialization by calling "
"E<.Fn sysmon_task_queue_init>.  This will create a kernel thread that can be "
"later halted by E<.Fn sysmon_task_queue_fini>.  All scheduled tasks are "
"executed before the queue is halted."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_taskq.9:81
msgid ""
"The E<.Fn sysmon_task_queue_sched> enqueues E<.Fa func> to be executed at "
"the priority E<.Fa pri>.  If E<.Fa pri> is 0, the scheduled function will be "
"placed as the last element in the queue.  The single argument passed to "
"E<.Fa func> is specified by E<.Fa arg>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_taskq.9:86
msgid ""
"Upon successful completion, E<.Fn sysmon_task_queue_sched> returns 0.  "
"Otherwise, the following error values are returned:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_taskq.9:89
msgid "An invalid parameter was specified."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/sysmon_taskq.9:89
#, no-wrap
msgid "Bq Er ENOMEM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_taskq.9:91
msgid "There was not enough memory."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/sysmon_taskq.9:96
msgid "E<.Xr queue 3>, E<.Xr kthread 9>, E<.Xr workqueue 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/tc.9:31
#, no-wrap
msgid "TC 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tc.9:44
msgid ""
"E<.Nm TC>, E<.Nm tc_intr_establish>, E<.Nm tc_intr_disestablish>, E<.Nm "
"tc_intr_evcnt>.  E<.Nm tc_mb>, E<.Nm tc_wmb>, E<.Nm tc_syncbus>, E<.Nm "
"tc_badaddr>, E<.Nm TC_DENSE_TO_SPARSE>, E<.Nm TC_PHYS_TO_UNCACHED>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/tc.9:44
#, no-wrap
msgid "TURBOchannel bus"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/tc.9:48
#, no-wrap
msgid "dev/tc/tcdevs.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tc.9:68
msgid ""
"E<.Ft void> E<.Fn tc_intr_establish \"struct device *dev\" \"void *cookie\" "
"\"int level\" \"int (*handler)(void *)\" \"void *arg\"> E<.Ft void> E<.Fn "
"tc_intr_disestablish \"struct device *dev\" \"void *cookie\"> E<.Ft const "
"struct evcnt *> E<.Fn tc_intr_evcnt \"struct device *dev\" \"void *cookie\"> "
"E<.Ft void> E<.Fn tc_mb \"\"> E<.Ft void> E<.Fn tc_wmb \"\"> E<.Ft void> "
"E<.Fn tc_syncbus \"\"> E<.Ft int> E<.Fn tc_badaddr \"tc_addr_t tcaddr\"> "
"E<.Ft tc_addr_t> E<.Fn TC_DENSE_TO_SPARSE \"tc_addr_t addr\"> E<.Ft "
"tc_addr_t> E<.Fn TC_PHYS_TO_UNCACHED \"tc_addr_t addr\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tc.9:76
msgid ""
"The E<.Nm> device provides support for the DEC TURBOchannel bus found on all "
"DEC TURBOchannel machines with MIPS (DECstation 5000 series, excluding the "
"5000/200) and Alpha (3000-series) systems.  TURBOchannel is a 32-bit wide "
"synchronous DMA-capable bus, running at 25 MHz on higher-end machines and at "
"12.5 MHz on lower-end machines."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tc.9:79
msgid ""
"Drivers for devices attached to the TURBOchannel bus will make use of the "
"following data types:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/tc.9:80
#, no-wrap
msgid "Fa struct tc_attach_args"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tc.9:83
msgid ""
"A structure use to inform the driver of TURBOchannel bus properties.  It "
"contains the following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tc.9:92
#, no-wrap
msgid ""
"\tbus_space_tag_t\tta_memt;\n"
"\tbus_dma_tag_t\tta_dmat;\n"
"\tchar\t\tta_modname[TC_ROM_LLEN+1];\n"
"\tu_int\t\tta_slot;\n"
"\ttc_offset_t\tta_offset;\n"
"\ttc_addr_t\tta_addr;\n"
"\tvoid\t\t*ta_cookie;\n"
"\tu_int\t\tta_busspeed;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tc.9:103
msgid ""
"The E<.Em ta_busspeed> member specifies the TURBOchannel bus speed and is "
"useful for time-related functions.  Values values are E<.Em "
"TC_SPEED_12_5_MHZ> for the 12.5 MHz bus and E<.Em TC_SPEED_25_MHZ> for the "
"50 MHz bus."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/tc.9:106
#, no-wrap
msgid "Fn tc_intr_establish dev cookie level handler arg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tc.9:122
msgid ""
"Establish an interrupt handler with device E<.Fa dev> for the interrupt "
"described completely by E<.Fa cookie>, the value passed to the driver in the "
"E<.Em ta_cookie> member of the E<.Em tc_attach_args> structure.  The "
"priority of the interrupt is specified by E<.Fa level>.  When the interrupt "
"occurs the function E<.Fa handler> is called with argument E<.Fa arg>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/tc.9:122
#, no-wrap
msgid "Fn tc_intr_disestablish dev cookie"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tc.9:127
msgid ""
"Dis-establish the interrupt handler with device E<.Fa dev> for the interrupt "
"described completely E<.Fa cookie>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/tc.9:127
#, no-wrap
msgid "Fn tc_intr_evcnt dev cookie"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/tc.9:132
#, no-wrap
msgid "Fn tc_mb \"\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tc.9:136
msgid ""
"A read/write memory barrier.  Any CPU-to-memory reads/writes before the "
"barrier must complete before any CPU-to-memory reads/writes after it."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/tc.9:136
#, no-wrap
msgid "Fn tc_wmb \"\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tc.9:140
msgid ""
"A write memory barrier.  Any CPU-to-memory writes before the barrier must "
"complete before any CPU-to-memory writes after it."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/tc.9:140
#, no-wrap
msgid "Fn tc_syncbus \"\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tc.9:143
msgid ""
"Synchronise writes on the TURBOchannel bus by ensuring CPU writes are "
"propagated across the TURBOchannel bus."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/tc.9:143
#, no-wrap
msgid "Fn tc_badaddr tcaddr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tc.9:147
msgid "Returns non-zero if the given address E<.Fa tcaddr> is invalid."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/tc.9:147
#, no-wrap
msgid "Fn TC_DENSE_TO_SPARSE addr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tc.9:152
msgid ""
"Convert the given physical address E<.Fa addr> in TURBOchannel dense space "
"to the corresponding address in TURBOchannel sparse space."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/tc.9:152
#, no-wrap
msgid "Fn TC_PHYS_TO_UNCACHED addr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tc.9:157
msgid ""
"Convert the given system memory physical address E<.Fa addr> to the physical "
"address of the corresponding region that is not cached."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tc.9:167
msgid ""
"The TURBOchannel bus is a direct-connection bus.  During autoconfiguration, "
"the parent specifies the name of the found TURBOchannel module into the "
"E<.Fa ta_modname> member of the E<.Em tc_attach_args> structure.  Drivers "
"should match on this name."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tc.9:172
msgid ""
"The TURBOchannel bus supports 32-bit, bidirectional DMA transfers.  Support "
"is provided by the standard E<.Xr bus_dma 9> interface."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tc.9:177
msgid ""
"The TURBOchannel subsystem itself is implemented within the file E<.Pa "
"sys/dev/tc/tc_subr.c>.  Machine-dependent portions can be found in E<.Pa "
"sys/arch/\\*[Lt]arch\\*[Gt]/tc/tcbus.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tc.9:182
msgid ""
"E<.Xr tc 4>, E<.Xr autoconf 9>, E<.Xr bus_dma 9>, E<.Xr bus_space 9>, E<.Xr "
"driver 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/tcp_congctl.9:30
#, no-wrap
msgid "October 15, 2006"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/tcp_congctl.9:31
#, no-wrap
msgid "TCP_CONGCTL 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tcp_congctl.9:35
msgid "E<.Nm tcp_congctl>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/tcp_congctl.9:35
#, no-wrap
msgid "TCP congestion control API"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/tcp_congctl.9:37
#, no-wrap
msgid "netinet/tcp_congctl.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tcp_congctl.9:45
msgid ""
"E<.Ft int> E<.Fn tcp_congctl_register \"const char *\" \"struct tcp_congctl "
"*\"> E<.Ft int> E<.Fn tcp_congctl_unregister \"const char *\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tcp_congctl.9:51
msgid ""
"The E<.Nm tcp_congctrl> API is used to add or remove TCP congestion control "
"algorithms on-the-fly and to modularize them.  It includes basically two "
"functions:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/tcp_congctl.9:52
#, no-wrap
msgid "Fn tcp_congctl_register \"const char *\" \"struct tcp_congctl *\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tcp_congctl.9:57
msgid ""
"Registers a new congestion control algorithm.  The E<.Fa struct tcp_congctl> "
"argument must contain a list of callbacks like the following:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tcp_congctl.9:68
#, no-wrap
msgid ""
"struct tcp_congctl {\n"
"\tint  (*fast_retransmit)(struct tcpcb *,\n"
"\t    struct tcphdr *);\n"
"\tvoid (*slow_retransmit)(struct tcpcb *);\n"
"\tvoid (*fast_retransmit_newack)(struct tcpcb *,\n"
"\t    struct tcphdr *);\n"
"\tvoid (*newack)(struct tcpcb *,\n"
"\t    struct tcphdr *);\n"
"\tvoid (*cong_exp)(struct tcpcb *);\n"
"};\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/tcp_congctl.9:69
#, no-wrap
msgid "Fn tcp_congctl_unregister \"const char *\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tcp_congctl.9:71
msgid "If found, unregister the selected TCP congestion control algorithm."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tcp_congctl.9:89
msgid ""
"E<.Fn tcp_congctl_register> and E<.Fn tcp_congctl_unregister> both return "
"E<.Dv 0> when there is no error.  If the name is already registered, E<.Fn "
"tcp_congctl_register> will return E<.Er EEXIST>.  E<.Fn "
"tcp_congctl_unregister> can return E<.Er ENOENT> if there is no congestion "
"control algorithm by that name and can return E<.Er EBUSY> if the matched "
"algorithm is being used by userspace applications."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tcp_congctl.9:94
msgid ""
"Implementation is in E<.Pa sys/netinet/tcp_congctl.c> and the interface is "
"in E<.Pa sys/netinet/tcp_congctl.h>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tcp_congctl.9:95
msgid "E<.Xr tcp 4>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/time_second.9:35
#, no-wrap
msgid "March 13, 2008"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/time_second.9:36
#, no-wrap
msgid "TIME_SECOND 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/time_second.9:42
msgid "E<.Nm time_second>, E<.Nm time_uptime>, E<.Nm boottime>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/time_second.9:42
#, no-wrap
msgid "system time variables"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/time_second.9:47
msgid "E<.Vt extern time_t time_second;> E<.Vt extern time_t time_uptime;>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/time_second.9:49
msgid "E<.Vt extern struct timeval boottime;>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/time_second.9:62
msgid ""
"The E<.Va time_second> variable is the system's E<.Dq wall time> clock.  It "
"is set at boot by E<.Xr inittodr 9>, and is updated periodically via E<.Xr "
"timecounter 9> framework, and also updated by the E<.Xr settimeofday 2> "
"system call."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/time_second.9:69
msgid ""
"The E<.Va time_uptime> variable is a monotonically increasing system clock.  "
"It is set at boot, and is updated periodically.  (It is not updated by E<.Xr "
"settimeofday 2>.)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/time_second.9:77
msgid ""
"The E<.Va boottime> variable holds the system boot time.  It is set at "
"system boot, and is updated when the system time is adjusted with E<.Xr "
"settimeofday 2>.  The variable may be read and written without special "
"precautions."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/time_second.9:81
msgid ""
"All of these variables contain times expressed in seconds and microseconds "
"since midnight (0 hour), January 1, 1970."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/time_second.9:92
msgid ""
"The E<.Xr bintime 9>, E<.Xr getbintime 9>, E<.Xr microtime 9>, E<.Xr "
"getmicrotime 9>, E<.Xr nanotime 9>, and E<.Xr getnanotime 9> functions can "
"be used to get the current time more accurately and in an atomic manner."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/time_second.9:103
msgid ""
"Similarly, the E<.Xr binuptime 9>, E<.Xr getbinuptime 9>, E<.Xr microuptime "
"9>, E<.Xr getmicrouptime 9>, E<.Xr nanouptime 9>, and E<.Xr getnanouptime 9> "
"functions can be used to get the time elapsed since boot more accurately and "
"in an atomic manner."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/time_second.9:108
msgid ""
"E<.Xr clock_settime 2>, E<.Xr ntp_adjtime 2>, E<.Xr timeval 3>, E<.Xr "
"hardclock 9>, E<.Xr hz 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/timecounter.9:41
#, no-wrap
msgid "TIMECOUNTER 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:46
msgid "E<.Nm timecounter>, E<.Nm tc_init>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/timecounter.9:46
#, no-wrap
msgid "machine-independent binary timescale"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/timecounter.9:48
#, no-wrap
msgid "sys/timetc.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:51
msgid "E<.Ft void> E<.Fn tc_init \"struct timecounter *tc\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:55
msgid ""
"The timecounter interface is a machine-independent implementation of a "
"binary timescale using whatever hardware support is at hand for tracking "
"time."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:57
msgid "A timecounter is a binary counter which has two properties:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:60
msgid "it runs at a fixed, known frequency; and"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:66
msgid ""
"it has sufficient bits to not roll over in less than approximately max(2 "
"msec, E<.Pf 2/ Em HZ> seconds) (the value 2 here is really 1 + delta, for "
"some indeterminate value of delta)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:72
msgid ""
"The interface between the hardware which implements a timecounter and the "
"machine-independent code which uses this to keep track of time is a E<.Va "
"timecounter> structure:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:83
#, no-wrap
msgid ""
"struct timecounter {\n"
"\ttimecounter_get_t\t*tc_get_timecount;\n"
"\ttimecounter_pps_t\t*tc_poll_pps;\n"
"\tu_int \t\t\ttc_counter_mask;\n"
"\tu_int64_t\t\ttc_frequency;\n"
"\tconst char\t\t*tc_name;\n"
"\tint\t\t\ttc_quality;\n"
"\tvoid\t\t\t*tc_priv;\n"
"\tstruct timecounter\t*tc_next;\n"
"}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:88
msgid "The fields of the E<.Va timecounter> structure are described below."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/timecounter.9:89
#, no-wrap
msgid "Fn \"u_int (*tc_get_timecount)\" \"struct timecounter *\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:93
msgid ""
"This function reads the counter.  It is not required to mask any "
"unimplemented bits out, as long as they are constant."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/timecounter.9:93
#, no-wrap
msgid "Fn \"void (*tc_poll_pps)\" \"struct timecounter *\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:100
msgid ""
"This function is optional and can be set to E<.Dv NULL>.  It will be called "
"whenever the timecounter is rewound, and is intended to check for PPS "
"events.  Normal hardware does not need it but timecounters which latch PPS "
"in hardware do."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/timecounter.9:100
#, no-wrap
msgid "Va tc_counter_mask"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:102
msgid "This mask should mask off any unimplemented bits."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/timecounter.9:102
#, no-wrap
msgid "Va tc_frequency"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:104
msgid "Frequency of the counter in Hz."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/timecounter.9:104
#, no-wrap
msgid "Va tc_name"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:107
msgid "Name of the timecounter.  Can be any NUL-terminated string."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/timecounter.9:107
#, no-wrap
msgid "Va tc_quality"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:112
msgid ""
"Used to determine if this timecounter is better than another timecounter \\- "
"higher means better.  Negative means E<.Dq only use at explicit request>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/timecounter.9:112
#, no-wrap
msgid "Va tc_priv"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:114
msgid "Pointer to the timecounter's private parts."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/timecounter.9:114
#, no-wrap
msgid "Va tc_next"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:116
msgid "For internal use."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:126
msgid ""
"To register a new timecounter, the hardware device driver should fill a "
"E<.Va timecounter> structure with appropriate values and call the E<.Fn "
"tc_init> function, giving a pointer to the structure as a E<.Fa tc> "
"parameter."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/timecounter.9:126
#, no-wrap
msgid "TIMESTAMP FORMAT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:131
msgid ""
"The timestamp format used in the machine independent timecounter "
"implementation is a E<.Va bintime> structure:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:136
#, no-wrap
msgid ""
"struct bintime {\n"
"\ttime_t\tsec;\n"
"\tuint64_t frac;\n"
"}\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:149
msgid ""
"The E<.Va sec> field records the number of seconds as well as the E<.Va "
"tv_sec> field in the traditional E<.Ux> E<.Va timeval> and E<.Va timespec> "
"structures, described in E<.Xr timeval 3>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:161
msgid ""
"The E<.Va frac> field records fractional seconds represented in a fully 64 "
"bit integer, i.e. it goes all the way from E<.Li 0> through E<.Li "
"0xFFFFFFFFFFFFFFFF> per each second.  The effective resolution of the E<.Va "
"frac> value depends on a frequency of the machine dependent timecounter "
"source."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:167
msgid ""
"The E<.Va bintime> format is a binary number, not a pseudo-decimal number, "
"so it can be used as a simple binary counter without expensive 64 bit "
"arithmetics."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:173
msgid ""
"The timecounter framework is implemented in the file E<.Pa "
"sys/kern/kern_tc.c>.  The E<.Va bintime> structure and related functions are "
"defined in the file"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/timecounter.9:173
#, no-wrap
msgid "sys/time.h ."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:190
msgid ""
"E<.Xr clock_settime 2>, E<.Xr ntp_adjtime 2>, E<.Xr settimeofday 2>, E<.Xr "
"bintime 9>, E<.Xr bintime_add 9>, E<.Xr binuptime 9>, E<.Xr hz 9>, E<.Xr "
"time_second 9> E<.Rs> E<.%A Poul-Henning Kamp> E<.%T \"Timecounters: "
"Efficient and precise timekeeping in SMP kernels\"> E<.%J \"Proceedings of "
"EuroBSDCon 2002, Amsterdam\"> E<.%D 15-17 November, 2002> E<.%U "
"http://phk.freebsd.dk/pubs/timecounter.pdf> E<.Re>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/timecounter.9:195
msgid ""
"The timecounter interface first appeared in E<.Fx>, and was ported to E<.Nx "
"4.0> by Frank Kardel and Simon Burge."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/todr.9:31
#, no-wrap
msgid "TODR 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/todr.9:39
msgid ""
"E<.Nm todr_attach>, E<.Nm todr_gettime>, E<.Nm todr_settime>, E<.Nm "
"clock_ymdhms_to_secs>, E<.Nm clock_secs_to_ymdhms>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/todr.9:39
#, no-wrap
msgid "time-of-day clock support"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/todr.9:41
#, no-wrap
msgid "dev/clock_subr.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/todr.9:52
msgid ""
"E<.Ft void> E<.Fn todr_attach \"todr_chip_handle_t\"> E<.Ft int> E<.Fn "
"todr_gettime \"todr_chip_handle_t\" \"struct timeval *\"> E<.Ft int> E<.Fn "
"todr_settime \"todr_chip_handle_t\" \"struct timeval *\"> E<.Ft void> E<.Fn "
"clock_secs_to_ymdhms \"int\" \"struct clock_ymdhms *\"> E<.Ft time_t> E<.Fn "
"clock_ymdhms_to_secs \"struct clock_ymdhms *\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/todr.9:70
msgid ""
"The E<.Fn todr_*> functions provide an interface to read, set and control "
"E<.Ql time-of-day> devices.  A driver for a E<.Ql time-of-day> device "
"registers its E<.Fa todr_chip_handle_t> with machine-dependent code using "
"the E<.Fn todr_attach> function.  Alternatively, a machine-dependent "
"front-end to a E<.Ql time-of-day> device driver may obtain the E<.Fa "
"todr_chip_handle_t> directly."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/todr.9:83
msgid ""
"The E<.Fn todr_gettime> retrieves the current data and time from the TODR "
"device and returns it in the E<.Fa struct timeval> storage provided by the "
"caller.  E<.Fn todr_settime> sets the date and time in the TODR device "
"represented by E<.Fa todr_chip_handle_t> according to the E<.Fa struct "
"timeval> argument."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/todr.9:93
msgid ""
"The utilities E<.Fn clock_secs_to_ymdhms> and E<.Fn clock_ymdhms_to_secs> "
"are provided to convert a time value in seconds to and from a structure "
"representing the date and time as a E<.Aq "
"year,month,day,weekday,hour,minute,seconds> tuple.  This structure is "
"defined as follows:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/todr.9:103
#, no-wrap
msgid ""
"struct clock_ymdhms {\n"
"\tu_short dt_year;\t/* Year */\n"
"\tu_char dt_mon;\t\t/* Month (1-12) */\n"
"\tu_char dt_day;\t\t/* Day (1-31) */\n"
"\tu_char dt_wday;\t\t/* Day of week (0-6) */\n"
"\tu_char dt_hour;\t\t/* Hour (0-23) */\n"
"\tu_char dt_min;\t\t/* Minute (0-59) */\n"
"\tu_char dt_sec;\t\t/* Second (0-59) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/todr.9:106
msgid "Note: leap years are recognised by these conversion routines."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/todr.9:111
msgid ""
"The E<.Fn todr_*> functions return 0 if the requested operation was "
"successful; otherwise an error code from"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/todr.9:116
msgid ""
"shall be returned.  However, behaviour is undefined if an invalid E<.Fa "
"todr_chip_handle_t> is passed to any of these functions."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/todr.9:125
msgid ""
"The E<.Fn clock_ymdhms_to_secs> function returns \\-1 if the time in seconds "
"would be less that zero or too large to fit in a E<.Fa time_t>.  The E<.Fn "
"clock_secs_to_ymdhms> function never fails."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/todr.9:130
msgid ""
"E<.Xr intersil7170 4>, E<.Xr mk48txx 4>, E<.Xr inittodr 9>, E<.Xr resettodr "
"9>, E<.Xr time_second 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/tvtohz.9:30
#, no-wrap
msgid "TVTOHZ 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tvtohz.9:34
msgid "E<.Nm tvtohz>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/tvtohz.9:34
#, no-wrap
msgid "convert time interval to tick count"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tvtohz.9:39
msgid "E<.Ft int> E<.Fn tvtohz \"struct timeval *tv\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tvtohz.9:46
msgid ""
"The E<.Fn tvtohz> function accepts a single argument E<.Fa tv> which "
"specifies the time interval over which to calculate the number of system "
"ticks that would elapse."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tvtohz.9:49
msgid ""
"Returns the integral number of system ticks expected to elapse in the given "
"interval, including the current tick."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tvtohz.9:55
msgid ""
"E<.Xr timeval 3>, E<.Xr callout 9>, E<.Xr microtime 9>, E<.Xr microuptime "
"9>, E<.Xr mstohz 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/tvtohz.9:65
msgid ""
"The E<.Nm> function first appeared in E<.Fx 3.0> and was ported to E<.Nx "
"4.0> as a part of E<.Xr timecounter 9> framework."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/ubc.9:28
#, no-wrap
msgid "UBC 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ubc.9:32
msgid "E<.Nm ubc>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/ubc.9:32
#, no-wrap
msgid "unified buffer cache"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/ubc.9:34 org_netbsd/src/share/man/man9/uvm.9:35 org_netbsd/src/share/man/man9/uvm_km.9:35 org_netbsd/src/share/man/man9/uvm_map.9:36
#, no-wrap
msgid "uvm/uvm.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ubc.9:45
msgid ""
"E<.Ft void *> E<.Fn ubc_alloc \"struct uvm_object *uobj\" \"voff_t offset\" "
"\"vsize_t *lenp\" \"int advice\" \"int flags\"> E<.Ft void> E<.Fn "
"ubc_release \"void *va\" \"int flags\"> E<.Ft int> E<.Fn ubc_uiomove "
"\"struct uvm_object *uobj\" \"struct uio *uio\" \"vsize_t todo\" \"int "
"advice\" \"int flags\"> E<.Ft void> E<.Fn ubc_purge \"struct uvm_object "
"*uobj\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ubc.9:58
msgid ""
"E<.Fn ubc_alloc> creates a kernel mapping of E<.Fa uobj> starting at offset "
"E<.Fa offset>.  The desired length of the mapping is pointed to by E<.Fa "
"lenp>, but the actual mapping may be smaller than this.  E<.Fa lenp> is "
"updated to contain the actual length mapped.  E<.Fa advice> is the access "
"pattern hint, which must be one of"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ubc.9:60 org_netbsd/src/share/man/man9/uvm_map.9:180
#, no-wrap
msgid "UVM_ADV_NORMAL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ubc.9:62
msgid "No hint"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ubc.9:62 org_netbsd/src/share/man/man9/uvm_map.9:182
#, no-wrap
msgid "UVM_ADV_RANDOM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ubc.9:64
msgid "Random access hint"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ubc.9:64 org_netbsd/src/share/man/man9/uvm_map.9:184
#, no-wrap
msgid "UVM_ADV_SEQUENTIAL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ubc.9:66
msgid "Sequential access hint (from lower offset to higher offset)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ubc.9:71
msgid "The possible E<.Fa flags> are"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ubc.9:73
#, no-wrap
msgid "UBC_READ"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ubc.9:75
msgid "Mapping will be accessed for read."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ubc.9:75
#, no-wrap
msgid "UBC_WRITE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ubc.9:77
msgid "Mapping will be accessed for write."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ubc.9:77
#, no-wrap
msgid "UBC_FAULTBUSY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ubc.9:80
msgid ""
"Fault in window's pages already during mapping operation.  Makes sense only "
"for write."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ubc.9:89
msgid ""
"Once the mapping is created, it must be accessed only by methods that can "
"handle faults, such as E<.Fn uiomove> or E<.Fn kcopy>.  Page faults on the "
"mapping will result in the object's pager method being called to resolve the "
"fault."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ubc.9:97
msgid ""
"E<.Fn ubc_release> frees the mapping at E<.Fa va> for reuse.  The mapping "
"may be cached to speed future accesses to the same region of the object.  "
"The flags can be any of"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ubc.9:99
#, no-wrap
msgid "UBC_UNMAP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ubc.9:101
msgid "Do not cache mapping."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ubc.9:119
msgid ""
"E<.Fn ubc_uiomove> allocates an UBC memory window, performs I/O on it and "
"unmaps the window.  The E<.Fa advice> parameter takes the same values as the "
"respective parameter in E<.Fn ubc_alloc> and the E<.Fa flags> parameter "
"takes the same arguments as E<.Fn ubc_alloc> and E<.Fn ubc_release>.  "
"Additionally, the flag E<.Dv UBC_PARTIALOK> can be provided to indicate that "
"it is acceptable to return if an error occurs mid-transfer."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ubc.9:124
msgid ""
"E<.Fn ubc_purge> disassociates all UBC structures from an empty UVM object, "
"specified by E<.Fa uobj>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ubc.9:129
msgid ""
"The E<.Nm> subsystem is implemented within the file E<.Pa "
"sys/uvm/uvm_bio.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ubc.9:144
msgid ""
"E<.Xr pmap 9>, E<.Xr uiomove 9>, E<.Xr uvm 9>, E<.Xr vnode 9>, E<.Xr "
"vnodeops 9> E<.Rs> E<.%A Chuck Silvers> E<.%T \"UBC: An Efficient Unified "
"I/O and Memory Caching Subsystem for NetBSD\"> E<.%I USENIX Association> "
"E<.%B Proceedings of the FREENIX Track: 2000 USENIX Annual Technical "
"Conference> E<.%P 285-290> E<.%D June 18-23, 2000> E<.%U "
"http://www.usenix.org/event/usenix2000/freenix/full_papers/silvers/silvers.pdf> "
"E<.Re>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ubc.9:147
msgid "UBC first appeared in E<.Nx 1.6>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ubc.9:151
msgid ""
"Chuck Silvers E<.Aq chuq@chuq.com> designed and implemented the UBC part of "
"UVM, which uses UVM pages to cache vnode data rather than the traditional "
"buffer cache buffers."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/ucas.9:28 org_netbsd/src/share/man/man9/workqueue.9:28 org_netbsd/src/share/man/man9/xcall.9:30
#, no-wrap
msgid "October 24, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/ucas.9:29
#, no-wrap
msgid "UCAS 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucas.9:34
msgid "E<.Nm ucas>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/ucas.9:34
#, no-wrap
msgid "atomic memory operations on user-space address"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/ucas.9:47
msgid ""
"E<.Ft int> E<.Fn ucas_ptr \"volatile void *uptr\" \"void *old\" \"void "
"*new\" \"void *retp\"> E<.Ft int> E<.Fn ucas_int \"volatile int *uptr\" "
"\"int old\" \"int new\" \"int *retp\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucas.9:50
msgid ""
"These functions provide compare-and-swap (CAS) functionality on user-space "
"address."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucas.9:54
msgid ""
"Except that they can be safely used for the kernel to access user-space "
"address, they are semantically equivalents of E<.Xr atomic_cas 3>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ucas.9:56
#, no-wrap
msgid "Fa uptr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucas.9:59
msgid "The pointer to the variable.  This should be a user-space pointer."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ucas.9:59
#, no-wrap
msgid "Fa old"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucas.9:61
msgid "The value to compare with the variable."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ucas.9:61
#, no-wrap
msgid "Fa new"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucas.9:63
msgid "The value to store to the variable."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ucas.9:63
#, no-wrap
msgid "Fa retp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucas.9:65
msgid "The pointer to the memory to store the old value of the variable."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/ucas.9:77
msgid ""
"On success, these functions return 0.  In that case, the caller can consult "
"the value returned via E<.Fa retp> to check the result of the CAS "
"operation.  Otherwise, these functions return an appropriate E<.Xr errno 9> "
"error code, typically E<.Dv EFAULT>."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/ucas.9:81
msgid "E<.Xr atomic_cas 3>, E<.Xr intro 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucas.9:88
msgid ""
"Conceptually, the E<.Fa retp> argument of E<.Fn ucas_ptr> would be of E<.Dv "
"void **>.  The current prototype is a compromise for usability."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/ucom.9:31
#, no-wrap
msgid "UCOM 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:35
msgid "E<.Nm ucom>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/ucom.9:35
#, no-wrap
msgid "interface for USB tty like devices"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:51
msgid ""
"The E<.Nm> driver is a (relatively) easy way to make a USB device look like "
"a E<.Xr tty 4>.  It basically takes two bulk pipes, input and output, and "
"makes a tty out of them.  This is useful for a number of device types, e.g., "
"serial ports (see E<.Xr uftdi 4>), modems (see E<.Xr umodem 4>), and devices "
"that traditionally look like a tty (see E<.Xr uvisor 4>)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:58
msgid ""
"Communication between the real driver and the E<.Nm> driver is via the "
"attachment arguments (when attached) and via the E<.Va ucom_methods> struct"
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/ucom.9:58
#, no-wrap
msgid "ATTACHMENT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:73
#, no-wrap
msgid ""
"struct ucom_attach_args {\n"
"\tint portno;\n"
"\tint bulkin;\n"
"\tint bulkout;\n"
"\tu_int ibufsize;\n"
"\tu_int ibufsizepad;\n"
"\tu_int obufsize;\n"
"\tu_int obufsizepad;\n"
"\tusbd_device_handle device;\n"
"\tusbd_interface_handle iface;\n"
"\tstruct ucom_methods *methods;\n"
"\tvoid *arg;\n"
"};\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ucom.9:76
#, no-wrap
msgid "Dv int portno"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:83
msgid ""
"identifies the port if the devices should have more than one E<.Nm> "
"attached.  Use the value E<.Dv UCOM_UNK_PORTNO> if there is only one port."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ucom.9:83
#, no-wrap
msgid "Dv int bulkin"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:85
msgid "the number of the bulk input pipe."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ucom.9:85
#, no-wrap
msgid "Dv int bulkout"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:87
msgid "the number of the bulk output pipe."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ucom.9:87
#, no-wrap
msgid "Dv u_int ibufsize"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:89
msgid "the size of the read requests on the bulk in pipe."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ucom.9:89 org_netbsd/src/share/man/man9/ucom.9:95
#, no-wrap
msgid "Dv u_int ibufsizepad"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:93
msgid "the size of the input buffer.  This is usually the same as E<.Dv ibufsize>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ucom.9:93
#, no-wrap
msgid "Dv u_int obufsize"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:95
msgid "the size of the write requests on the bulk out pipe."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:99
msgid "the size of the output buffer.  This is usually the same as E<.Dv obufsize>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ucom.9:99
#, no-wrap
msgid "Dv usbd_device_handle device"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:101
msgid "a handle to the device."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ucom.9:101
#, no-wrap
msgid "usbd_interface_handle iface"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:103
msgid "a handle to the interface that should be used."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ucom.9:103
#, no-wrap
msgid "struct ucom_methods *methods"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:107
msgid ""
"a pointer to the methods that the E<.Nm> driver should use for further "
"communication with the driver."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ucom.9:107
#, no-wrap
msgid "void *arg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:109
msgid "the value that should be passed as first argument to each method."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/ucom.9:110
#, no-wrap
msgid "METHODS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:122
msgid ""
"The E<.Dv ucom_methods> struct contains a number of function pointers used "
"by the E<.Nm> driver at various stages.  If the device is not interested in "
"being called at a particular point it should just use a E<.Dv NULL> pointer "
"and the E<.Nm> driver will use a sensible default."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:140
#, no-wrap
msgid ""
"struct ucom_methods {\n"
"\tvoid (*ucom_get_status)(void *sc, int portno,\n"
"\t\t\t\tu_char *lsr, u_char *msr);\n"
"\tvoid (*ucom_set)(void *sc, int portno, int reg, int onoff);\n"
"#define UCOM_SET_DTR 1\n"
"#define UCOM_SET_RTS 2\n"
"#define UCOM_SET_BREAK 3\n"
"\tint (*ucom_param)(void *sc, int portno, struct termios *);\n"
"\tint (*ucom_ioctl)(void *sc, int portno, u_long cmd,\n"
"\t\t\t  void *data, int flag, struct lwp *l);\n"
"\tint (*ucom_open)(void *sc, int portno);\n"
"\tvoid (*ucom_close)(void *sc, int portno);\n"
"\tvoid (*ucom_read)(void *sc, int portno, u_char **ptr,\n"
"\t\t\t  uint32_t *count);\n"
"\tvoid (*ucom_write)(void *sc, int portno, u_char *to,\n"
"\t\t\t   u_char *from, uint32_t *count);\n"
"};\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ucom.9:143
#, no-wrap
msgid ""
"Fn \"void (*ucom_get_status)\" \"void *sc, int portno, u_char *lsr, u_char "
"*msr\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:151
msgid ""
"get the status of port E<.Fa portno>.  The status consists of the line "
"status, E<.Fa lsr>, and the modem status E<.Fa msr>.  The contents of these "
"two bytes is exactly as for a 16550 UART."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ucom.9:151
#, no-wrap
msgid "Fn \"void (*ucom_set)\" \"void *sc, int portno, int reg, int onoff\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:153
msgid "Set (or unset) a particular feature of a port."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ucom.9:153
#, no-wrap
msgid "Fn \"int (*ucom_param)\" \"void *sc, int portno, struct termios *t\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:158
msgid ""
"Set the speed, number of data bit, stop bits, and parity of a port according "
"to the E<.Xr termios 4> struct."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ucom.9:158
#, no-wrap
msgid ""
"Fn \"int (*ucom_ioctl)\" \"void *sc, int portno, u_long cmd, void *data, int "
"flag, struct lwp *l\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:162
msgid "implements any non-standard E<.Xr ioctl 2> that a device needs."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ucom.9:162
#, no-wrap
msgid "Fn \"int (*ucom_open)\" \"void *sc, int portno\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:166
msgid "called just before the E<.Nm> driver opens the bulk pipes for the port."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ucom.9:166
#, no-wrap
msgid "Fn \"void (*ucom_close)\" \"void *sc, int portno\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:170
msgid "called just after the E<.Nm> driver closes the bulk pipes for the port."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ucom.9:170
#, no-wrap
msgid ""
"Fn \"void (*ucom_read)\" \"void *sc, int portno, u_char **ptr, uint32_t "
"*count\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:177
msgid ""
"if the data delivered on the bulk pipe is not just the raw input characters "
"this routine needs to adjust E<.Fa ptr> and E<.Fa count> so that they tell "
"where to find the given number of raw characters."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ucom.9:177
#, no-wrap
msgid ""
"Fn \"void (*ucom_write)\" \"void *sc, int portno, u_char *dst, u_char *src, "
"uint32_t *count\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:199
msgid ""
"if the data written to the bulk pipe is not just the raw characters then "
"this routine needs to copy E<.Fa count> raw characters from E<.Fa src> into "
"the buffer at E<.Fa dst> and do the appropriate padding.  The E<.Fa count> "
"should be updated to the new size.  The buffer at E<.Fa src> is at most "
"E<.Va ibufsize> bytes and the buffer at E<.Fa dst> is E<.Va ibufsizepad> "
"bytes."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:202
msgid "Apart from these methods there is a function"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/ucom.9:203
#, no-wrap
msgid "Fn \"void ucom_status_change\" \"struct ucom_softc *\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:207
msgid "which should be called by the driver whenever it notices a status change."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:213
msgid "E<.Xr tty 4>, E<.Xr uftdi 4>, E<.Xr umodem 4>, E<.Xr usb 4>, E<.Xr uvisor 4>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/ucom.9:217
msgid "This E<.Nm> interface first appeared in E<.Nx 1.5>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/uiomove.9:27
#, no-wrap
msgid "April 26, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/uiomove.9:28
#, no-wrap
msgid "UIOMOVE 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uiomove.9:32
msgid "E<.Nm uiomove>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/uiomove.9:32
#, no-wrap
msgid "move data described by a struct uio"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uiomove.9:37
msgid "E<.Ft int> E<.Fn uiomove \"void *buf\" \"size_t n\" \"struct uio *uio\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uiomove.9:48
msgid ""
"The E<.Fn uiomove> function copies up to E<.Fa n> bytes between the "
"kernel-space address pointed to by E<.Fa buf> and the addresses described by "
"E<.Fa uio>, which may be in user-space or kernel-space."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uiomove.9:54
msgid "The E<.Fa uio> argument is a pointer to a E<.Va struct uio> as defined by"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/uiomove.9:54
#, no-wrap
msgid "sys/uio.h :"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uiomove.9:64
#, no-wrap
msgid ""
"struct uio {\n"
"\tstruct\tiovec *uio_iov;\n"
"\tint\tuio_iovcnt;\n"
"\toff_t\tuio_offset;\n"
"\tsize_t\tuio_resid;\n"
"\tenum\tuio_rw uio_rw;\n"
"\tstruct\tvmspace *uio_vmspace;\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uiomove.9:70
msgid ""
"A E<.Va struct uio> typically describes data in motion.  Several of the "
"fields described below reflect that expectation."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uiomove.9:72
#, no-wrap
msgid "Va uio_iov"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uiomove.9:79
msgid ""
"Pointer to array of E<.Tn I/O> vectors to be processed.  The E<.Va struct "
"iovec> is defined to be:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uiomove.9:84
#, no-wrap
msgid ""
"struct iovec {\n"
"\tvoid\t*iov_base;\n"
"\tsize_t\t iov_len;\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uiomove.9:90
msgid ""
"The members in the E<.Va struct iovec> should only be initialized.  These "
"are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uiomove.9:91
#, no-wrap
msgid "Va iov_base"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uiomove.9:93
msgid "The address for a range of memory to or from which data is transferred."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uiomove.9:93
#, no-wrap
msgid "Va iov_len"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uiomove.9:97
msgid ""
"The number of bytes of data to be transferred to or from the range of memory "
"starting at E<.Va iov_base>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uiomove.9:98
#, no-wrap
msgid "Va uio_iovcnt"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uiomove.9:104
msgid "The number of E<.Tn I/O> vectors in the E<.Va uio_iov> array."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uiomove.9:104
#, no-wrap
msgid "Va uio_offset"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uiomove.9:106
msgid "An offset into the corresponding object."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uiomove.9:106
#, no-wrap
msgid "Va uio_resid"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uiomove.9:109
msgid ""
"The amount of space described by the structure; notionally, the amount of "
"data remaining to be transferred."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uiomove.9:109
#, no-wrap
msgid "Va uio_rw"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uiomove.9:112
msgid ""
"A flag indicating whether data should be read into the space (UIO_READ) or "
"written from the space (UIO_WRITE)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uiomove.9:112
#, no-wrap
msgid "Va uio_vmspace"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uiomove.9:114
msgid "A pointer to the address space which is being transferred to or from."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uiomove.9:125
msgid ""
"The value of E<.Va uio-\\*[Gt]uio_rw> controls whether E<.Fn uiomove> copies "
"data from E<.Fa buf> to E<.Fa uio> or vice versa."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uiomove.9:131
msgid "The lesser of E<.Fa n> or E<.Va uio-\\*[Gt]uio_resid> bytes are copied."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uiomove.9:144
msgid ""
"E<.Fn uiomove> changes fields of the structure pointed to by E<.Fa uio>, "
"such that E<.Va uio-\\*[Gt]uio_resid> is decremented by the amount of data "
"moved, E<.Va uio-\\*[Gt]uio_offset> is incremented by the same amount, and "
"the array of iovecs is adjusted to point that much farther into the region "
"described.  This allows multiple calls to E<.Fn uiomove> to easily be used "
"to fill or drain the region of data."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uiomove.9:151
msgid ""
"Upon successful completion, E<.Fn uiomove> returns 0.  If a bad address is "
"encountered, E<.Er EFAULT> is returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uiomove.9:154
msgid "E<.Xr copy 9>, E<.Xr fetch 9>, E<.Xr store 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/usbdi.9:30
#, no-wrap
msgid "December 3, 1999"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/usbdi.9:31
#, no-wrap
msgid "USBDI 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:35
msgid "E<.Nm usbdi>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/usbdi.9:35
#, no-wrap
msgid "USB device drivers interface"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/usbdi.9:37
#, no-wrap
msgid "dev/usb/usb.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/usbdi.9:38
#, no-wrap
msgid "dev/usb/usbdi.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:55
msgid ""
"Device driver access to the USB bus centers around transfers.  A transfer "
"describes a communication with a USB device.  A transfer is an abstract "
"concept that can result in several physical packets being transferred to or "
"from a device.  A transfer is described by a E<.Va usbd_xfer_handle>.  It is "
"allocated by E<.Va usbd_alloc_xfer> and the data describing the transfer is "
"filled by E<.Va usbd_setup_default_xfer> for control pipe transfers, by "
"E<.Va usbd_setup_xfer> for bulk and interrupt transfers, and by E<.Va "
"usbd_setup_isoc_xfer> for isochronous transfers."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:58
msgid "describe E<.Va usbd_do_request>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:60
msgid "describe pipes"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:63
msgid "describe usbd_status"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/usbdi.9:63
#, no-wrap
msgid "Functions offered by usbdi"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:65
#, no-wrap
msgid "Dv usbd_status usbd_open_pipe(usbd_interface_handle iface, uint8_t address,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:68
#, no-wrap
msgid ""
"    uint8_t flags,\n"
"    usbd_pipe_handle *pipe)\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:68
#, no-wrap
msgid "Dv usbd_status usbd_close_pipe(usbd_pipe_handle pipe)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:69
#, no-wrap
msgid "Dv usbd_status usbd_transfer(usbd_xfer_handle req)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:70
#, no-wrap
msgid "Dv usbd_xfer_handle usbd_alloc_xfer(usbd_device_handle)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:71
#, no-wrap
msgid "Dv usbd_status usbd_free_xfer(usbd_xfer_handle xfer)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:72
#, no-wrap
msgid "Dv void usbd_setup_xfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:76
#, no-wrap
msgid ""
"     usbd_private_handle priv, void *buffer,\n"
"     uint32_t length, uint16_t flags, uint32_t timeout,\n"
"     usbd_callback)\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:76
#, no-wrap
msgid "Dv void usbd_setup_default_xfer(usbd_xfer_handle xfer,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:81
#, no-wrap
msgid ""
"     usbd_device_handle dev,\n"
"     usbd_private_handle priv, uint32_t timeout,\n"
"     usb_device_request_t *req,  void *buffer,\n"
"     uint32_t length, uint16_t flags, usbd_callback)\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:81
#, no-wrap
msgid "Dv void usbd_setup_isoc_xfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:84
#, no-wrap
msgid ""
"     usbd_private_handle priv, uint16_t *frlengths,\n"
"     uint32_t nframes, uint16_t flags, usbd_callback)\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:84
#, no-wrap
msgid ""
"Dv void usbd_get_xfer_status(usbd_xfer_handle xfer, usbd_private_handle "
"*priv,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:86
#, no-wrap
msgid "     void **buffer, uint32_t *count, usbd_status *status)\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:86
#, no-wrap
msgid ""
"Dv usb_endpoint_descriptor_t "
"*usbd_interface2endpoint_descriptor(usbd_interface_handle iface, uint8_t "
"address)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:87
#, no-wrap
msgid "Dv usbd_status usbd_abort_pipe(usbd_pipe_handle pipe)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:88
#, no-wrap
msgid "Dv usbd_status usbd_clear_endpoint_stall(usbd_pipe_handle pipe)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:89
#, no-wrap
msgid "Dv usbd_status usbd_clear_endpoint_stall_async(usbd_pipe_handle pipe)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:90
#, no-wrap
msgid ""
"Dv usbd_status usbd_endpoint_count(usbd_interface_handle dev, uint8_t "
"*count)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:91
#, no-wrap
msgid "Dv usbd_status usbd_interface_count(usbd_device_handle dev, uint8_t *count)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:92
#, no-wrap
msgid ""
"Dv usbd_status usbd_interface2device_handle(usbd_interface_handle iface, "
"usbd_device_handle *dev)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:93
#, no-wrap
msgid ""
"Dv usbd_status usbd_device2interface_handle(usbd_device_handle dev, uint8_t "
"ifaceno, usbd_interface_handle *iface)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:95
#, no-wrap
msgid "Dv usbd_device_handle usbd_pipe2device_handle(usbd_pipe_handle)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:96
#, no-wrap
msgid "Dv void *usbd_alloc_buffer(usbd_xfer_handle req, uint32_t size)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:97
#, no-wrap
msgid "Dv void usbd_free_buffer(usbd_xfer_handle req)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:98
#, no-wrap
msgid "Dv void *usbd_get_buffer(usbd_xfer_handle xfer)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:99
#, no-wrap
msgid "Dv usbd_status usbd_sync_transfer(usbd_xfer_handle req)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:100
#, no-wrap
msgid ""
"Dv usbd_status usbd_open_pipe_intr(usbd_interface_handle iface, uint8_t "
"address,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:104
#, no-wrap
msgid ""
"     uint8_t flags, usbd_pipe_handle *pipe,\n"
"     usbd_private_handle priv, void *buffer,\n"
"     uint32_t length, usbd_callback)\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:104
#, no-wrap
msgid ""
"Dv usbd_status usbd_do_request(usbd_device_handle pipe, usb_device_request_t "
"*req, void *data)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:105
#, no-wrap
msgid ""
"Dv usbd_status usbd_do_request_async(usbd_device_handle pipe, "
"usb_device_request_t *req, void *data)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:106
#, no-wrap
msgid ""
"Dv usbd_status usbd_do_request_flags(usbd_device_handle pipe, "
"usb_device_request_t *req,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:108
#, no-wrap
msgid "     void *data, uint16_t flags, int *)\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:108
#, no-wrap
msgid ""
"Dv usb_interface_descriptor_t "
"*usbd_get_interface_descriptor(usbd_interface_handle iface)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:109
#, no-wrap
msgid ""
"Dv usb_config_descriptor_t *usbd_get_config_descriptor(usbd_device_handle "
"dev)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:110
#, no-wrap
msgid ""
"Dv usb_device_descriptor_t *usbd_get_device_descriptor(usbd_device_handle "
"dev)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:111
#, no-wrap
msgid "Dv usbd_status usbd_set_interface(usbd_interface_handle, int)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:112
#, no-wrap
msgid "Dv int usbd_get_no_alts(usb_config_descriptor_t *, int)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:113
#, no-wrap
msgid ""
"Dv \"usbd_status\tusbd_get_interface(usbd_interface_handle\" iface, uint8_t "
"*aiface)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:114
#, no-wrap
msgid ""
"Dv void usbd_fill_deviceinfo (usbd_device_handle dev, struct usb_device_info "
"*di)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:115
#, no-wrap
msgid "Dv int usbd_get_interface_altindex(usbd_interface_handle iface)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:116
#, no-wrap
msgid ""
"Dv usb_interface_descriptor_t *usbd_find_idesc(usb_config_descriptor_t *cd, "
"int iindex, int ano)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:117
#, no-wrap
msgid ""
"Dv usb_endpoint_descriptor_t *usbd_find_edesc(usb_config_descriptor_t *cd, "
"int ifaceidx, int altidx,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:119
#, no-wrap
msgid "     int endptidx)\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:119
#, no-wrap
msgid "Dv const char *usbd_errstr(usbd_status err)"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/usbdi.9:121
#, no-wrap
msgid "Utilities from usbdi_util.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:127
msgid ""
"Based on the routines in E<.Dv \"usbdi.h\"> a number of utility functions "
"have been defined that are accessible through E<.Dv \"usbdi_util.h\">"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:128
#, no-wrap
msgid "Dv \"usbd_status\tusbd_get_desc(usbd_device_handle\" dev, int type,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:130
msgid "  int index, int len, void *desc)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:130
#, no-wrap
msgid "Dv \"usbd_status\tusbd_get_config_desc(usbd_device_handle,\" int,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:132
msgid "  usb_config_descriptor_t *)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:132
#, no-wrap
msgid "Dv \"usbd_status\tusbd_get_config_desc_full(usbd_device_handle,\" int,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:134
msgid "  void *, int)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:134
#, no-wrap
msgid "Dv \"usbd_status\tusbd_get_device_desc(usbd_device_handle\" dev,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:136
msgid "  usb_device_descriptor_t *d)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:136
#, no-wrap
msgid "Dv \"usbd_status\tusbd_set_address(usbd_device_handle\" dev, int addr)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:137
#, no-wrap
msgid "Dv \"usbd_status\tusbd_get_port_status(usbd_device_handle,\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:139
msgid "  int, usb_port_status_t *)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:139
#, no-wrap
msgid "Dv \"usbd_status\tusbd_set_hub_feature(usbd_device_handle\" dev, int)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:140
#, no-wrap
msgid "Dv \"usbd_status\tusbd_clear_hub_feature(usbd_device_handle,\" int)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:141
#, no-wrap
msgid "Dv \"usbd_status\tusbd_set_port_feature(usbd_device_handle\" dev, int, int)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:142
#, no-wrap
msgid "Dv \"usbd_status\tusbd_clear_port_feature(usbd_device_handle,\" int, int)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:143
#, no-wrap
msgid "Dv \"usbd_status\tusbd_get_device_status(usbd_device_handle,usb_status_t*)\""
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:144
#, no-wrap
msgid "Dv \"usbd_status\tusbd_get_hub_status(usbd_device_handle\" dev,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:146
msgid "  usb_hub_status_t *st)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:146
#, no-wrap
msgid "Dv \"usbd_status\tusbd_set_protocol(usbd_interface_handle\" dev, int report)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:147
#, no-wrap
msgid "Dv \"usbd_status\tusbd_get_report_descriptor\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:149
msgid "(usbd_device_handle dev, int ifcno, int repid, int size, void *d)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:149
#, no-wrap
msgid "Dv struct usb_hid_descriptor *usbd_get_hid_descriptor"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:151
msgid "(usbd_interface_handle ifc)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:151
#, no-wrap
msgid "Dv \"usbd_status\tusbd_set_report\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:153 org_netbsd/src/share/man/man9/usbdi.9:155 org_netbsd/src/share/man/man9/usbdi.9:157
msgid "(usbd_interface_handle iface,int type,int id,void *data,int len)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:153
#, no-wrap
msgid "Dv \"usbd_status\tusbd_set_report_async\""
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:155
#, no-wrap
msgid "Dv \"usbd_status\tusbd_get_report\""
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:157
#, no-wrap
msgid "Dv \"usbd_status\tusbd_set_idle\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:159
msgid "(usbd_interface_handle iface, int duration, int id)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:159
#, no-wrap
msgid "Dv \"usbd_status\tusbd_alloc_report_desc\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:161
msgid "(usbd_interface_handle ifc, void **descp, int *sizep, int mem)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:161
#, no-wrap
msgid "Dv \"usbd_status\tusbd_get_config\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:163
msgid "(usbd_device_handle dev, uint8_t *conf)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:163
#, no-wrap
msgid "Dv \"usbd_status\tusbd_get_string_desc\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:166
msgid ""
"(usbd_device_handle dev, int sindex, int langid, usb_string_descriptor_t "
"*sdesc)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:166
#, no-wrap
msgid "Dv \"void\t\tusbd_delay_ms(usbd_device_handle,\" u_int)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:167
#, no-wrap
msgid "Dv usbd_status usbd_set_config_no"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:169
msgid "(usbd_device_handle dev, int no, int msg)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:169
#, no-wrap
msgid "Dv usbd_status usbd_set_config_index"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:171
msgid "(usbd_device_handle dev, int index, int msg)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:171
#, no-wrap
msgid "Dv usbd_status usbd_bulk_transfer"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:174
msgid ""
"(usbd_xfer_handle xfer, usbd_pipe_handle pipe, uint16_t flags, uint32_t "
"timeout, void *buf, uint32_t *size, char *lbl)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:174
#, no-wrap
msgid "Dv void usb_detach_wait(device_ptr_t)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/usbdi.9:175
#, no-wrap
msgid "Dv void usb_detach_wakeup(device_ptr_t)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:179
msgid "E<.Xr usb 4>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:189
msgid ""
"This E<.Nm> interface first appeared in E<.Nx 1.4>.  The interface is based "
"on an early definition from the OpenUSBDI group within the USB "
"organisation.  Right after this definition the OpenUSBDI development got "
"closed for open source developers, so this interface has not followed the "
"further changes.  The OpenUSBDI specification is now available again, but "
"looks different."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/usbdi.9:191
msgid ""
"This man page is under development, so its biggest shortcoming is "
"incompleteness."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/userret.9:31
#, no-wrap
msgid "USERRET 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/userret.9:35
msgid "E<.Nm userret>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/userret.9:35
#, no-wrap
msgid "return path to user-mode execution"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/userret.9:41
msgid "E<.Ft void> E<.Fn userret \"struct lwp *l\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/userret.9:53
msgid ""
"The E<.Fn userret> function is executed after processing a trap E<.Pq e.g., "
"a system call or interrupt> before returning to user-mode execution.  The "
"implementation is machine dependent and is never invoked from "
"machine-independent code.  The function prototype for each architecture may "
"be different to the prototype above, however the functionally provided by "
"the E<.Fn userret> function on each architecture is essentially the same."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/userret.9:57
msgid "Specifically, the E<.Fn userret> function performs the following procedure:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/userret.9:65
msgid ""
"Detect a change in the signal disposition of the current process and invoke "
"E<.Xr postsig 9> to post the signal to the process.  This may occur when the "
"outcome of the trap or syscall posted a signal to the process E<.Pq e.g., "
"invalid instruction trap>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/userret.9:74
msgid ""
"Check the E<.Va want_resched> flag to see if the scheduler requires the "
"current process to be preempted by invoking E<.Xr preempt 9> E<.Pq see Xr "
"cpu_need_resched 9>.  This may occur if the clock interrupt causes the "
"scheduler to determine that the current process has completed its time "
"slice."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/userret.9:76
msgid "Update the scheduler state."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/userret.9:81
msgid ""
"E<.Xr cpu_need_resched 9>, E<.Xr postsig 9>, E<.Xr preempt 9>, E<.Xr "
"scheduler 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/uvm.9:28
#, no-wrap
msgid "UVM 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:32
msgid "E<.Nm uvm>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/uvm.9:32
#, no-wrap
msgid "virtual memory system external interface"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:42
msgid ""
"The UVM virtual memory system manages access to the computer's memory "
"resources.  User processes and the kernel access these resources through "
"UVM's external interface.  UVM's external interface includes functions that:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:46
msgid "initialize UVM sub-systems"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:48
msgid "manage virtual address spaces"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:50
msgid "resolve page faults"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:52
msgid "memory map files and devices"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:54
msgid "perform uio-based I/O to virtual memory"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:56
msgid "allocate and free kernel virtual memory"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:58
msgid "allocate and free physical memory"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:68
msgid ""
"In addition to exporting these services, UVM has two kernel-level processes: "
"pagedaemon and swapper.  The pagedaemon process sleeps until physical memory "
"becomes scarce.  When that happens, pagedaemon is awoken.  It scans physical "
"memory, paging out and freeing memory that has not been recently used.  The "
"swapper process swaps in runnable processes that are currently swapped out, "
"if there is room."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:70
msgid "There are also several miscellaneous functions."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/uvm.9:70
#, no-wrap
msgid "INITIALIZATION"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm.9:72 org_netbsd/src/share/man/man9/uvm.9:74 org_netbsd/src/share/man/man9/uvm.9:76 org_netbsd/src/share/man/man9/uvm.9:78 org_netbsd/src/share/man/man9/uvm.9:146 org_netbsd/src/share/man/man9/uvm.9:148 org_netbsd/src/share/man/man9/uvm.9:152 org_netbsd/src/share/man/man9/uvm.9:154 org_netbsd/src/share/man/man9/uvm.9:271 org_netbsd/src/share/man/man9/uvm.9:273 org_netbsd/src/share/man/man9/uvm.9:289 org_netbsd/src/share/man/man9/uvm.9:348 org_netbsd/src/share/man/man9/uvm.9:350 org_netbsd/src/share/man/man9/uvm.9:354 org_netbsd/src/share/man/man9/uvm.9:358 org_netbsd/src/share/man/man9/uvm.9:360 org_netbsd/src/share/man/man9/uvm.9:362 org_netbsd/src/share/man/man9/uvm.9:366 org_netbsd/src/share/man/man9/uvm.9:368
#, no-wrap
msgid "Ft void"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:74
msgid "E<.Fn uvm_init \"void\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:76
msgid "E<.Fn uvm_init_limits \"struct lwp *l\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:78
msgid "E<.Fn uvm_setpagesize \"void\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:80
msgid "E<.Fn uvm_swap_init \"void\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:89
msgid ""
"E<.Fn uvm_init> sets up the UVM system at system boot time, after the "
"console has been setup.  It initializes global state, the page, map, kernel "
"virtual memory state, machine-dependent physical map, kernel memory "
"allocator, pager and anonymous memory sub-systems, and then enables paging "
"of kernel objects."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:94
msgid ""
"E<.Fn uvm_init_limits> initializes process limits for the named process.  "
"This is for use by the system startup for process zero, before any other "
"processes are created."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:102
msgid ""
"E<.Fn uvm_setpagesize> initializes the uvmexp members pagesize (if not "
"already done by machine-dependent code), pageshift and pagemask.  It should "
"be called by machine-dependent code early in the E<.Fn pmap_init> call (see "
"E<.Xr pmap 9>)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:105
msgid "E<.Fn uvm_swap_init> initializes the swap sub-system."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/uvm.9:105
#, no-wrap
msgid "VIRTUAL ADDRESS SPACE MANAGEMENT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:108
msgid "See E<.Xr uvm_map 9>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/uvm.9:108
#, no-wrap
msgid "PAGE FAULT HANDLING"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:112
msgid ""
"E<.Fn uvm_fault \"struct vm_map *orig_map\" \"vaddr_t vaddr\" \"vm_prot_t "
"access_type\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:125
msgid ""
"E<.Fn uvm_fault> is the main entry point for faults.  It takes E<.Fa "
"orig_map> as the map the fault originated in, a E<.Fa vaddr> offset into the "
"map the fault occurred, and E<.Fa access_type> describing the type of access "
"requested.  E<.Fn uvm_fault> returns a standard UVM return value."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/uvm.9:125
#, no-wrap
msgid "MEMORY MAPPING FILES AND DEVICES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:128
msgid "See E<.Xr ubc 9>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/uvm.9:128
#, no-wrap
msgid "VIRTUAL MEMORY I/O"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:132
msgid "E<.Fn uvm_io \"struct vm_map *map\" \"struct uio *uio\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:139
msgid ""
"E<.Fn uvm_io> performs the I/O described in E<.Fa uio> on the memory "
"described in E<.Fa map>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/uvm.9:139
#, no-wrap
msgid "ALLOCATION OF KERNEL MEMORY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:142
msgid "See E<.Xr uvm_km 9>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/uvm.9:142
#, no-wrap
msgid "ALLOCATION OF PHYSICAL MEMORY"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm.9:144
#, no-wrap
msgid "Ft struct vm_page *"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:146
msgid ""
"E<.Fn uvm_pagealloc \"struct uvm_object *uobj\" \"voff_t off\" \"struct "
"vm_anon *anon\" \"int flags\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:148
msgid ""
"E<.Fn uvm_pagerealloc \"struct vm_page *pg\" \"struct uvm_object *newobj\" "
"\"voff_t newoff\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:150
msgid "E<.Fn uvm_pagefree \"struct vm_page *pg\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:152
msgid ""
"E<.Fn uvm_pglistalloc \"psize_t size\" \"paddr_t low\" \"paddr_t high\" "
"\"paddr_t alignment\" \"paddr_t boundary\" \"struct pglist *rlist\" \"int "
"nsegs\" \"int waitok\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:154
msgid "E<.Fn uvm_pglistfree \"struct pglist *list\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:156
msgid ""
"E<.Fn uvm_page_physload \"paddr_t start\" \"paddr_t end\" \"paddr_t "
"avail_start\" \"paddr_t avail_end\" \"int free_list\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:176
msgid ""
"E<.Fn uvm_pagealloc> allocates a page of memory at virtual address E<.Fa "
"off> in either the object E<.Fa uobj> or the anonymous memory E<.Fa anon>, "
"which must be locked by the caller.  Only one of E<.Fa uobj> and E<.Fa anon> "
"can be non E<.Dv NULL>.  Returns E<.Dv NULL> when no page can be found.  The "
"flags can be any of"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:179
#, no-wrap
msgid ""
"#define UVM_PGA_USERESERVE      0x0001  /* ok to use reserve pages */\n"
"#define UVM_PGA_ZERO            0x0002  /* returned page must be zero'd */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:191
msgid ""
"E<.Dv UVM_PGA_USERESERVE> means to allocate a page even if that will result "
"in the number of free pages being lower than E<.Dv "
"uvmexp.reserve_pagedaemon> (if the current thread is the pagedaemon) or "
"E<.Dv uvmexp.reserve_kernel> (if the current thread is not the pagedaemon).  "
"E<.Dv UVM_PGA_ZERO> causes the returned page to be filled with zeroes, "
"either by allocating it from a pool of pre-zeroed pages or by zeroing it "
"in-line as necessary."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:199
msgid ""
"E<.Fn uvm_pagerealloc> reallocates page E<.Fa pg> to a new object E<.Fa "
"newobj>, at a new offset E<.Fa newoff>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:210
msgid ""
"E<.Fn uvm_pagefree> frees the physical page E<.Fa pg>.  If the content of "
"the page is known to be zero-filled, caller should set E<.Dv PG_ZERO> in "
"pg-\\*[Gt]flags so that the page allocator will use the page to serve future "
"E<.Dv UVM_PGA_ZERO> requests efficiently."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:241
msgid ""
"E<.Fn uvm_pglistalloc> allocates a list of pages for size E<.Fa size> byte "
"under various constraints.  E<.Fa low> and E<.Fa high> describe the lowest "
"and highest addresses acceptable for the list.  If E<.Fa alignment> is "
"non-zero, it describes the required alignment of the list, in power-of-two "
"notation.  If E<.Fa boundary> is non-zero, no segment of the list may cross "
"this power-of-two boundary, relative to zero.  E<.Fa nsegs> is the maximum "
"number of physically contiguous segments.  If E<.Fa waitok> is non-zero, the "
"function may sleep until enough memory is available.  (It also may give up "
"in some situations, so a non-zero E<.Fa waitok> does not imply that E<.Fn "
"uvm_pglistalloc> cannot return an error.)  The allocated memory is returned "
"in the E<.Fa rlist> list; the caller has to provide storage only, the list "
"is initialized by E<.Fn uvm_pglistalloc>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:252
msgid ""
"E<.Fn uvm_pglistfree> frees the list of pages pointed to by E<.Fa list>.  If "
"the content of the page is known to be zero-filled, caller should set E<.Dv "
"PG_ZERO> in pg-\\*[Gt]flags so that the page allocator will use the page to "
"serve future E<.Dv UVM_PGA_ZERO> requests efficiently."
msgstr ""

#.  XXX expand on "system boot time"!
#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:269
msgid ""
"E<.Fn uvm_page_physload> loads physical memory segments into VM space on the "
"specified E<.Fa free_list>.  It must be called at system boot time to set up "
"physical memory management pages.  The arguments describe the E<.Fa start> "
"and E<.Fa end> of the physical addresses of the segment, and the available "
"start and end addresses of pages not already in use.  If a system has memory "
"banks of different speeds the slower memory should be given a higher E<.Fa "
"free_list> value."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/uvm.9:269
#, no-wrap
msgid "PROCESSES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:273
msgid "E<.Fn uvm_pageout \"void\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:275
msgid "E<.Fn uvm_scheduler \"void\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:279
msgid "E<.Fn uvm_pageout> is the main loop for the page daemon."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:285
msgid ""
"E<.Fn uvm_scheduler> is the process zero main loop, which is to be called "
"after the system has finished starting other processes.  It handles the "
"swapping in of runnable, swapped out processes in priority order."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/uvm.9:285
#, no-wrap
msgid "PAGE LOAN"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:289
msgid ""
"E<.Fn uvm_loan \"struct vm_map *map\" \"vaddr_t start\" \"vsize_t len\" "
"\"void *v\" \"int flags\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:291
msgid "E<.Fn uvm_unloan \"void *v\" \"int npages\" \"int flags\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:305
msgid ""
"E<.Fn uvm_loan> loans pages in a map out to anons or to the kernel.  E<.Fa "
"map> should be unlocked, E<.Fa start> and E<.Fa len> should be multiples of "
"E<.Dv PAGE_SIZE>.  Argument E<.Fa flags> should be one of"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:308 org_netbsd/src/share/man/man9/uvm.9:340
#, no-wrap
msgid ""
"#define UVM_LOAN_TOANON       0x01    /* loan to anons */\n"
"#define UVM_LOAN_TOPAGE       0x02    /* loan to kernel */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:324
msgid ""
"E<.Fa v> should be pointer to array of pointers to E<.Li struct anon> or "
"E<.Li struct vm_page>, as appropriate.  The caller has to allocate memory "
"for the array and ensure it's big enough to hold E<.Fa len / PAGE_SIZE> "
"pointers.  Returns 0 for success, or appropriate error number otherwise.  "
"Note that wired pages can't be loaned out and E<.Fn uvm_loan> will fail in "
"that case."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:337
msgid ""
"E<.Fn uvm_unloan> kills loans on pages or anons.  The E<.Fa v> must point to "
"the array of pointers initialized by previous call to E<.Fn uvm_loan>.  "
"E<.Fa npages> should match number of pages allocated for loan, this also "
"matches number of items in the array.  Argument E<.Fa flags> should be one "
"of"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:344
msgid "and should match what was used for previous call to E<.Fn uvm_loan>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm.9:346
#, no-wrap
msgid "Ft struct uvm_object *"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:348
msgid "E<.Fn uao_create \"vsize_t size\" \"int flags\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:350
msgid "E<.Fn uao_detach \"struct uvm_object *uobj\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:352
msgid "E<.Fn uao_reference \"struct uvm_object *uobj\">;"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm.9:352
#, no-wrap
msgid "Ft bool"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:354
msgid "E<.Fn uvm_chgkprot \"void *addr\" \"size_t len\" \"int rw\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:356
msgid "E<.Fn uvm_kernacc \"void *addr\" \"size_t len\" \"int rw\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:358
msgid ""
"E<.Fn uvm_vslock \"struct vmspace *vs\" \"void *addr\" \"size_t len\" "
"\"vm_prot_t prot\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:360
msgid "E<.Fn uvm_vsunlock \"struct vmspace *vs\" \"void *addr\" \"size_t len\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:362
msgid "E<.Fn uvm_meter \"void\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:364
msgid ""
"E<.Fn uvm_proc_fork \"struct proc *p1\" \"struct proc *p2\" \"bool "
"shared\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:366
msgid "E<.Fn uvm_grow \"struct proc *p\" \"vaddr_t sp\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:368
msgid ""
"E<.Fn uvn_findpages \"struct uvm_object *uobj\" \"voff_t offset\" \"int "
"*npagesp\" \"struct vm_page **pps\" \"int flags\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:370
msgid "E<.Fn uvm_vnp_setsize \"struct vnode *vp\" \"voff_t newsize\">;"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:383
msgid ""
"The E<.Fn uao_create>, E<.Fn uao_detach>, and E<.Fn uao_reference> functions "
"operate on anonymous memory objects, such as those used to support System V "
"shared memory.  E<.Fn uao_create> returns an object of size E<.Fa size> with "
"flags:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:386
#, no-wrap
msgid ""
"#define UAO_FLAG_KERNOBJ        0x1     /* create kernel object */\n"
"#define UAO_FLAG_KERNSWAP       0x2     /* enable kernel swap */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:394
msgid ""
"which can only be used once each at system boot time.  E<.Fn uao_reference> "
"creates an additional reference to the named anonymous memory object.  E<.Fn "
"uao_detach> removes a reference from the named anonymous memory object, "
"destroying it if removing the last reference."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:405
msgid ""
"E<.Fn uvm_chgkprot> changes the protection of kernel memory from E<.Fa addr> "
"to E<.Fa addr + len> to the value of E<.Fa rw>.  This is primarily useful "
"for debuggers, for setting breakpoints.  This function is only available "
"with options E<.Dv KGDB>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:414
msgid ""
"E<.Fn uvm_kernacc> checks the access at address E<.Fa addr> to E<.Fa addr + "
"len> for E<.Fa rw> access in the kernel address space."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:425
msgid ""
"E<.Fn uvm_vslock> and E<.Fn uvm_vsunlock> control the wiring and unwiring of "
"pages for process E<.Fa p> from E<.Fa addr> to E<.Fa addr + len>.  These "
"functions are normally used to wire memory for I/O."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:428
msgid "E<.Fn uvm_meter> calculates the load average."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:441
msgid ""
"E<.Fn uvm_proc_fork> forks a virtual address space for process' (old)  E<.Fa "
"p1> and (new)  E<.Fa p2>.  If the E<.Fa shared> argument is non zero, p1 "
"shares its address space with p2, otherwise a new address space is created.  "
"This function currently has no return value, and thus cannot fail.  In the "
"future, this function will be changed to allow it to fail in low memory "
"conditions."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:447
msgid ""
"E<.Fn uvm_grow> increases the stack segment of process E<.Fa p> to include "
"E<.Fa sp>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:463
msgid ""
"E<.Fn uvn_findpages> looks up or creates pages in E<.Fa uobj> at offset "
"E<.Fa offset>, marks them busy and returns them in the E<.Fa pps> array.  "
"Currently E<.Fa uobj> must be a vnode object.  The number of pages requested "
"is pointed to by E<.Fa npagesp>, and this value is updated with the actual "
"number of pages returned.  The flags can be"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:469
#, no-wrap
msgid ""
"#define UFP_ALL         0x00    /* return all pages requested */\n"
"#define UFP_NOWAIT      0x01    /* don't sleep */\n"
"#define UFP_NOALLOC     0x02    /* don't allocate new pages */\n"
"#define UFP_NOCACHE     0x04    /* don't return pages which already exist "
"*/\n"
"#define UFP_NORDONLY    0x08    /* don't return PG_READONLY pages */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:481
msgid ""
"E<.Dv UFP_ALL> is a pseudo-flag meaning all requested pages should be "
"returned.  E<.Dv UFP_NOWAIT> means that we must not sleep.  E<.Dv "
"UFP_NOALLOC> causes any pages which do not already exist to be skipped.  "
"E<.Dv UFP_NOCACHE> causes any pages which do already exist to be skipped.  "
"E<.Dv UFP_NORDONLY> causes any pages which are marked PG_READONLY to be "
"skipped."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:489
msgid ""
"E<.Fn uvm_vnp_setsize> sets the size of vnode E<.Fa vp> to E<.Fa newsize>.  "
"Caller must hold a reference to the vnode.  If the vnode shrinks, pages no "
"longer used are discarded."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/uvm.9:489
#, no-wrap
msgid "SYSCTL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:511
msgid ""
"UVM provides support for the E<.Dv CTL_VM> domain of the E<.Xr sysctl 3> "
"hierarchy.  It handles the E<.Dv VM_LOADAVG>, E<.Dv VM_METER>, E<.Dv "
"VM_UVMEXP>, and E<.Dv VM_UVMEXP2> nodes, which return the current load "
"averages, calculates current VM totals, returns the uvmexp structure, and a "
"kernel version independent view of the uvmexp structure, respectively.  It "
"also exports a number of tunables that control how much VM space is allowed "
"to be consumed by various tasks.  The load averages are typically accessed "
"from userland using the E<.Xr getloadavg 3> function.  The uvmexp structure "
"has all global state of the UVM system, and has the following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:516
#, no-wrap
msgid ""
"/* vm_page constants */\n"
"int pagesize;   /* size of a page (PAGE_SIZE): must be power of 2 */\n"
"int pagemask;   /* page mask */\n"
"int pageshift;  /* page shift */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:524
#, no-wrap
msgid ""
"/* vm_page counters */\n"
"int npages;     /* number of pages we manage */\n"
"int free;       /* number of free pages */\n"
"int paging;     /* number of pages in the process of being paged out */\n"
"int wired;      /* number of wired pages */\n"
"int reserve_pagedaemon; /* number of pages reserved for pagedaemon */\n"
"int reserve_kernel; /* number of pages reserved for kernel */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:530
#, no-wrap
msgid ""
"/* pageout params */\n"
"int freemin;    /* min number of free pages */\n"
"int freetarg;   /* target number of free pages */\n"
"int inactarg;   /* target number of inactive pages */\n"
"int wiredmax;   /* max number of wired pages */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:538
#, no-wrap
msgid ""
"/* swap */\n"
"int nswapdev;   /* number of configured swap devices in system */\n"
"int swpages;    /* number of PAGE_SIZE'ed swap pages */\n"
"int swpginuse;  /* number of swap pages in use */\n"
"int nswget;     /* number of times fault calls uvm_swap_get() */\n"
"int nanon;      /* number total of anon's in system */\n"
"int nfreeanon;  /* number of free anon's */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:553
#, no-wrap
msgid ""
"/* stat counters */\n"
"int faults;             /* page fault count */\n"
"int traps;              /* trap count */\n"
"int intrs;              /* interrupt count */\n"
"int swtch;              /* context switch count */\n"
"int softs;              /* software interrupt count */\n"
"int syscalls;           /* system calls */\n"
"int pageins;            /* pagein operation count */\n"
"                        /* pageouts are in pdpageouts below */\n"
"int pgswapin;           /* pages swapped in */\n"
"int pgswapout;          /* pages swapped out */\n"
"int forks;              /* forks */\n"
"int forks_ppwait;       /* forks where parent waits */\n"
"int forks_sharevm;      /* forks where vmspace is shared */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:573
#, no-wrap
msgid ""
"/* fault subcounters */\n"
"int fltnoram;   /* number of times fault was out of ram */\n"
"int fltnoanon;  /* number of times fault was out of anons */\n"
"int fltpgwait;  /* number of times fault had to wait on a page */\n"
"int fltpgrele;  /* number of times fault found a released page */\n"
"int fltrelck;   /* number of times fault relock called */\n"
"int fltrelckok; /* number of times fault relock is a success */\n"
"int fltanget;   /* number of times fault gets anon page */\n"
"int fltanretry; /* number of times fault retrys an anon get */\n"
"int fltamcopy;  /* number of times fault clears \"needs copy\" */\n"
"int fltnamap;   /* number of times fault maps a neighbor anon page */\n"
"int fltnomap;   /* number of times fault maps a neighbor obj page */\n"
"int fltlget;    /* number of times fault does a locked pgo_get */\n"
"int fltget;     /* number of times fault does an unlocked get */\n"
"int flt_anon;   /* number of times fault anon (case 1a) */\n"
"int flt_acow;   /* number of times fault anon cow (case 1b) */\n"
"int flt_obj;    /* number of times fault is on object page (2a) */\n"
"int flt_prcopy; /* number of times fault promotes with copy (2b) */\n"
"int flt_przero; /* number of times fault promotes with zerofill (2b) */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:586
#, no-wrap
msgid ""
"/* daemon counters */\n"
"int pdwoke;     /* number of times daemon woke up */\n"
"int pdrevs;     /* number of times daemon rev'd clock hand */\n"
"int pdfreed;    /* number of pages daemon freed since boot */\n"
"int pdscans;    /* number of pages daemon scanned since boot */\n"
"int pdanscan;   /* number of anonymous pages scanned by daemon */\n"
"int pdobscan;   /* number of object pages scanned by daemon */\n"
"int pdreact;    /* number of pages daemon reactivated since boot */\n"
"int pdbusy;     /* number of times daemon found a busy page */\n"
"int pdpageouts; /* number of times daemon started a pageout */\n"
"int pdpending;  /* number of times daemon got a pending pageout */\n"
"int pddeact;    /* number of pages daemon deactivates */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:591
msgid ""
"E<.Fn uvm_chgkprot> is only available if the kernel has been compiled with "
"options E<.Dv KGDB>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:596
msgid ""
"All structure and types whose names begin with E<.Dq vm_> will be renamed to "
"E<.Dq uvm_>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:618
msgid ""
"E<.Xr swapctl 2>, E<.Xr getloadavg 3>, E<.Xr kvm 3>, E<.Xr sysctl 3>, E<.Xr "
"ddb 4>, E<.Xr options 4>, E<.Xr memoryallocators 9>, E<.Xr pmap 9>, E<.Xr "
"ubc 9>, E<.Xr uvm_km 9>, E<.Xr uvm_map 9> E<.Rs> E<.%A Charles D. Cranor> "
"E<.%A Gurudatta M. Parulkar> E<.%T \"The UVM Virtual Memory System\"> E<.%I "
"USENIX Association> E<.%B Proceedings of the USENIX Annual Technical "
"Conference> E<.%P 117-130> E<.%D June 6-11, 1999> E<.%U "
"http://www.usenix.org/event/usenix99/full_papers/cranor/cranor.pdf> E<.Re>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:638
msgid ""
"UVM is a new VM system developed at Washington University in St. Louis "
"(Missouri).  UVM's roots lie partly in the Mach-based E<.Bx 4.4> VM system, "
"the E<.Fx> VM system, and the SunOS 4 VM system.  UVM's basic structure is "
"based on the E<.Bx 4.4> VM system.  UVM's new anonymous memory system is "
"based on the anonymous memory system found in the SunOS 4 VM (as described "
"in papers published by Sun Microsystems, Inc.).  UVM also includes a number "
"of features new to E<.Bx> including page loanout, map entry passing, "
"simplified copy-on-write, and clustered anonymous memory pageout.  UVM is "
"also further documented in an August 1998 dissertation by Charles D. Cranor."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:641
msgid "UVM appeared in E<.Nx 1.4>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:645
msgid "Charles D. Cranor E<.Aq chuck@ccrc.wustl.edu> designed and implemented UVM."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:652
msgid ""
"Matthew Green E<.Aq mrg@eterna.com.au> wrote the swap-space management code "
"and handled the logistical issues involved with merging UVM into the E<.Nx> "
"source tree."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm.9:656
msgid ""
"Chuck Silvers E<.Aq chuq@chuq.com> implemented the aobj pager, thus allowing "
"UVM to support System V shared memory and process swapping."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/uvm_km.9:27 org_netbsd/src/share/man/man9/uvm_map.9:27
#, no-wrap
msgid "June 3, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/uvm_km.9:28
#, no-wrap
msgid "UVM_KM 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_km.9:32
msgid "E<.Nm uvm_km>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/uvm_km.9:32
#, no-wrap
msgid "raw kernel memory or address space allocator"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_km.9:43
msgid ""
"E<.Ft vaddr_t> E<.Fn uvm_km_alloc \"struct vm_map *map\" \"vsize_t size\" "
"\"vsize_t align\" \"uvm_flag_t flags\"> E<.Ft void> E<.Fn uvm_km_free "
"\"struct vm_map *map\" \"vaddr_t addr\" \"vsize_t size\" \"uvm_flag_t "
"flags\"> E<.Ft struct vm_map *> E<.Fn uvm_km_suballoc \"struct vm_map *map\" "
"\"vaddr_t *min\" \"vaddr_t *max\" \"vsize_t size\" \"int flags\" \"bool "
"fixed\" \"struct vm_map_kernel *submap\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_km.9:51
msgid ""
"The UVM facility for allocation of kernel memory or address space in pages.  "
"Both wired and pageable memory can be allocated by this facility, as well as "
"kernel address space.  Note that this is a raw allocator.  For general "
"purpose memory allocation, E<.Xr kmem 9> interface should be used."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_km.9:65
msgid ""
"E<.Fn uvm_km_alloc> allocates E<.Fa size> bytes of kernel memory in map "
"E<.Fa map>.  The first address of the allocated memory range will be aligned "
"according to the E<.Fa align> argument E<.Pq specify 0 if no alignment is "
"necessary>.  The alignment must be a multiple of page size.  The E<.Fa "
"flags> is a bitwise inclusive OR of the allocation type and operation flags."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_km.9:67
msgid "The allocation type should be one of:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_km.9:68
#, no-wrap
msgid "UVM_KMF_WIRED"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_km.9:70
msgid "Wired memory."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_km.9:70
#, no-wrap
msgid "UVM_KMF_PAGEABLE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_km.9:72
msgid "Demand-paged zero-filled memory."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_km.9:72
#, no-wrap
msgid "UVM_KMF_VAONLY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_km.9:78
msgid ""
"Virtual address only.  No physical pages are mapped in the allocated "
"region.  If necessary, it is the caller's responsibility to enter page "
"mappings.  It is also the caller's responsibility to clean up the mappings "
"before freeing the address range."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_km.9:81
msgid "The following operation flags are available:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_km.9:82
#, no-wrap
msgid "UVM_KMF_CANFAIL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_km.9:88
msgid ""
"Can fail even if E<.Dv UVM_KMF_NOWAIT> is not specified and E<.Dv "
"UVM_KMF_WAITVA> is specified."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_km.9:88
#, no-wrap
msgid "UVM_KMF_ZERO"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_km.9:93
msgid ""
"Request zero-filled memory.  Only supported for E<.Dv UVM_KMF_WIRED>.  "
"Should not be used with other types."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_km.9:93
#, no-wrap
msgid "UVM_KMF_TRYLOCK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_km.9:95
msgid "Fail if cannot lock the map without sleeping."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_km.9:95
#, no-wrap
msgid "UVM_KMF_NOWAIT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_km.9:97
msgid "Fail immediately if no memory is available."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_km.9:97
#, no-wrap
msgid "UVM_KMF_WAITVA"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_km.9:99
msgid "Sleep to wait for the virtual address resources if needed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_km.9:110
msgid ""
"If neither E<.Dv UVM_KMF_NOWAIT> nor E<.Dv UVM_KMF_CANFAIL> are specified "
"and E<.Dv UVM_KMF_WAITVA> is specified, E<.Fn uvm_km_alloc> will never fail, "
"but rather sleep indefinitely until the allocation succeeds."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_km.9:117
msgid ""
"Pageability of the pages allocated with E<.Dv UVM_KMF_PAGEABLE> can be "
"changed by E<.Fn uvm_map_pageable>.  In that case, the entire range must be "
"changed atomically.  Changing a part of the range is not supported."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_km.9:138
msgid ""
"E<.Fn uvm_km_free> frees the memory range allocated by E<.Fn uvm_km_alloc>.  "
"E<.Fa addr> must be an address returned by E<.Fn uvm_km_alloc>.  E<.Fa map> "
"and E<.Fa size> must be the same as the ones used for the corresponding "
"E<.Fn uvm_km_alloc>.  E<.Fa flags> must be the allocation type used for the "
"corresponding E<.Fn uvm_km_alloc>.  Note that E<.Fn uvm_km_free> is the only "
"way to free memory ranges allocated by E<.Fn uvm_km_alloc>.  E<.Fn "
"uvm_unmap> must not be used."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_km.9:165
msgid ""
"E<.Fn uvm_km_suballoc> allocates submap from E<.Fa map>, creating a new map "
"if E<.Fa submap> is E<.Dv NULL>.  The addresses of the submap can be "
"specified explicitly by setting the E<.Fa fixed> argument to true, which "
"causes the E<.Fa min> argument to specify the beginning of the address in "
"the submap.  If E<.Fa fixed> is false, any address of size E<.Fa size> will "
"be allocated from E<.Fa map> and the start and end addresses returned in "
"E<.Fa min> and E<.Fa max>.  The E<.Fa flags> are used to initialize the "
"created submap.  The following flags can be set:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_km.9:166
#, no-wrap
msgid "VM_MAP_PAGEABLE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_km.9:168
msgid "Entries in the map may be paged out."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_km.9:168
#, no-wrap
msgid "VM_MAP_INTRSAFE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_km.9:170
msgid "Map should be interrupt-safe."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_km.9:170
#, no-wrap
msgid "VM_MAP_TOPDOWN"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_km.9:172
msgid "A top-down mapping should be arranged."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_km.9:180
msgid ""
"E<.Xr kmem 9>, E<.Xr pmap 9>, E<.Xr pool_cache 9>, E<.Xr uvm 9>, E<.Xr "
"uvm_map 9>, E<.Xr vmem 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_km.9:184 org_netbsd/src/share/man/man9/uvm_map.9:361
msgid "UVM and E<.Nm> first appeared in E<.Nx 1.4>."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/uvm_map.9:28
#, no-wrap
msgid "UVM_MAP 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:32
msgid "E<.Nm uvm_map>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:34
msgid "virtual address space management interface"
msgstr ""

#.  .Ft void
#.  .Fn uvmspace_unshare "struct lwp *l"
#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:73
msgid ""
"E<.Ft int> E<.Fn uvm_map \"struct vm_map *map\" \"vaddr_t *startp\" "
"\"vsize_t size\" \"struct uvm_object *uobj\" \"voff_t uoffset\" \"vsize_t "
"align\" \"uvm_flag_t flags\"> E<.Ft void> E<.Fn uvm_unmap \"struct vm_map "
"*map\" \"vaddr_t start\" \"vaddr_t end\"> E<.Ft int> E<.Fn uvm_map_pageable "
"\"struct vm_map *map\" \"vaddr_t start\" \"vaddr_t end\" \"bool "
"new_pageable\" \"int lockflags\"> E<.Ft bool> E<.Fn uvm_map_checkprot "
"\"struct vm_map *map\" \"vaddr_t start\" \"vaddr_t end\" \"vm_prot_t "
"protection\"> E<.Ft int> E<.Fn uvm_map_protect \"struct vm_map *map\" "
"\"vaddr_t start\" \"vaddr_t end\" \"vm_prot_t new_prot\" \"bool set_max\"> "
"E<.Ft int> E<.Fn uvm_deallocate \"struct vm_map *map\" \"vaddr_t start\" "
"\"vsize_t size\"> E<.Ft struct vmspace *> E<.Fn uvmspace_alloc \"vaddr_t "
"min\" \"vaddr_t max\"> E<.Ft void> E<.Fn uvmspace_exec \"struct lwp *l\" "
"\"vaddr_t start\" \"vaddr_t end\"> E<.Ft struct vmspace *> E<.Fn "
"uvmspace_fork \"struct vmspace *vm\"> E<.Ft void> E<.Fn uvmspace_free "
"\"struct vmspace *vm\"> E<.Ft void> E<.Fn uvmspace_share \"struct proc *p1\" "
"\"struct proc *p2\"> E<.Ft vaddr_t> E<.Fn uvm_uarea_alloc \"void\"> E<.Ft "
"void> E<.Fn uvm_uarea_free \"vaddr_t uaddr\"> E<.Ft vaddr_t> E<.Fn "
"uvm_uarea_system_alloc \"void\"> E<.Ft void> E<.Fn uvm_uarea_system_free "
"\"vaddr_t uaddr\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:75
msgid "The UVM facility for virtual address space management."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:121
msgid ""
"E<.Fn uvm_map> establishes a valid mapping in map E<.Fa map>, which must be "
"unlocked.  The new mapping has size E<.Fa size>, which must be a multiple of "
"E<.Dv PAGE_SIZE>.  The E<.Fa uobj> and E<.Fa uoffset> arguments can have "
"four meanings.  When E<.Fa uobj> is E<.Dv NULL> and E<.Fa uoffset> is E<.Dv "
"UVM_UNKNOWN_OFFSET>, E<.Fn uvm_map> does not use the machine-dependent E<.Dv "
"PMAP_PREFER> function.  If E<.Fa uoffset> is any other value, it is used as "
"the hint to E<.Dv PMAP_PREFER>.  When E<.Fa uobj> is not E<.Dv NULL> and "
"E<.Fa uoffset> is E<.Dv UVM_UNKNOWN_OFFSET>, E<.Fn uvm_map> finds the offset "
"based upon the virtual address, passed as E<.Fa startp>.  If E<.Fa uoffset> "
"is any other value, then a regular mapping is performed at this offset.  The "
"start address of the map will be returned in E<.Fa startp>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:129
msgid ""
"E<.Fa align> specifies alignment of mapping unless E<.Dv UVM_FLAG_FIXED> is "
"specified in E<.Fa flags>.  E<.Fa align> must be a power of 2."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:142
msgid ""
"E<.Fa flags> passed to E<.Fn uvm_map> are typically created using the E<.Fn "
"UVM_MAPFLAG \"vm_prot_t prot\" \"vm_prot_t maxprot\" \"vm_inherit_t inh\" "
"\"int advice\" \"int flags\"> macro, which uses the following values.  The "
"E<.Fa prot> and E<.Fa maxprot> can take are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_map.9:143
#, no-wrap
msgid "UVM_PROT_NONE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:145
msgid "No protection bits."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_map.9:145
#, no-wrap
msgid "UVM_PROT_R"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:147
msgid "Read."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_map.9:147
#, no-wrap
msgid "UVM_PROT_W"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:149
msgid "Write."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_map.9:149
#, no-wrap
msgid "UVM_PROT_X"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:151
msgid "Exec."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_map.9:151
#, no-wrap
msgid "UVM_PROT_MASK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:153
msgid "Mask to extraction the protection bits."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:161
msgid ""
"Additionally, the following constants for ORed values are available: E<.Dv "
"UVM_PROT_RW>, E<.Dv UVM_PROT_RX>, E<.Dv UVM_PROT_WX> and E<.Dv "
"UVM_PROT_RWX>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:165
msgid "The values that E<.Fa inh> can take are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_map.9:166
#, no-wrap
msgid "UVM_INH_SHARE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:168
msgid "Share the map."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_map.9:168
#, no-wrap
msgid "UVM_INH_COPY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:170
msgid "Copy the map."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_map.9:170
#, no-wrap
msgid "UVM_INH_NONE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:172
msgid "No inheritance."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_map.9:172
#, no-wrap
msgid "UVM_INH_MASK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:174
msgid "Mark to extract inherit flags."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:179
msgid "The values that E<.Fa advice> can take are:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:182
msgid "\"Normal\" use."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:184
msgid "\"Random\" access likelyhood."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:186
msgid "\"Sequential\" access likelyhood."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_map.9:186
#, no-wrap
msgid "UVM_ADV_MASK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:188
msgid "Mask to extract the advice flags."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:193
msgid "The values that E<.Fa flags> can take are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_map.9:194
#, no-wrap
msgid "UVM_FLAG_FIXED"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:198
msgid ""
"Attempt to map on the address specified by E<.Fa startp>.  Otherwise, it is "
"used just as a hint."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_map.9:198
#, no-wrap
msgid "UVM_FLAG_OVERLAY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:200
msgid "Establish overlay."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_map.9:200
#, no-wrap
msgid "UVM_FLAG_NOMERGE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:202
msgid "Do not merge map entries, if such merge is possible."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_map.9:202
#, no-wrap
msgid "UVM_FLAG_COPYONW"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:204
msgid "Use copy-on-write i.e. do not fault in the pages immediately."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_map.9:204
#, no-wrap
msgid "UVM_FLAG_AMAPPAD"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:206
msgid "User for BSS: alocate larger amap, if extending is likely."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_map.9:206
#, no-wrap
msgid "UVM_FLAG_TRYLOCK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:208
msgid "Fail if cannot acquire the lock immediately."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_map.9:208
#, no-wrap
msgid "UVM_FLAG_NOWAIT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:211
msgid "Not allowed to sleep.  Fail, in such case."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_map.9:211
#, no-wrap
msgid "UVM_FLAG_QUANTUM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:213
msgid "Indicates that map entry cannot be split once mapped."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_map.9:213
#, no-wrap
msgid "UVM_FLAG_WAITVA"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:215
msgid "Sleep until VA space is available, if it is not."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/uvm_map.9:215
#, no-wrap
msgid "UVM_FLAG_VAONLY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:219
msgid "Unmap only VA space.  Used by E<.Fn uvm_unmap>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:238
msgid ""
"The E<.Dv UVM_MAPFLAG> macro arguments can be combined with an or operator.  "
"There are several special purpose macros for checking protection "
"combinations, e.g., the E<.Dv UVM_PROT_WX>.  There are also some additional "
"macros to extract bits from the flags.  The E<.Dv UVM_PROTECTION>, E<.Dv "
"UVM_INHERIT>, E<.Dv UVM_MAXPROTECTION> and E<.Dv UVM_ADVICE> macros return "
"the protection, inheritance, maximum protection and advice, respectively.  "
"E<.Fn uvm_map> returns zero on success or error number otherwise."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:248
msgid ""
"E<.Fn uvm_unmap> removes a valid mapping, from E<.Fa start> to E<.Fa end>, "
"in map E<.Fa map>, which must be unlocked."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:260
msgid ""
"E<.Fn uvm_map_pageable> changes the pageability of the pages in the range "
"from E<.Fa start> to E<.Fa end> in map E<.Fa map> to E<.Fa new_pageable>.  "
"E<.Fn uvm_map_pageable> returns zero on success or error number otherwise."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:274
msgid ""
"E<.Fn uvm_map_checkprot> checks the protection of the range from E<.Fa "
"start> to E<.Fa end> in map E<.Fa map> against E<.Fa protection>.  This "
"returns either E<.Dv true> or E<.Dv false>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:290
msgid ""
"E<.Fn uvm_map_protect> changes the protection E<.Fa start> to E<.Fa end> in "
"map E<.Fa map> to E<.Fa new_prot>, also setting the maximum protection to "
"the region to E<.Fa new_prot> if E<.Fa set_max> is true.  This function "
"returns a standard UVM return value."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:298
msgid ""
"E<.Fn uvm_deallocate> deallocates kernel memory in map E<.Fa map> from "
"address E<.Fa start> to E<.Fa start + size>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:304
msgid ""
"E<.Fn uvmspace_alloc> allocates and returns a new address space, with ranges "
"from E<.Fa min> to E<.Fa max>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:315
msgid ""
"E<.Fn uvmspace_exec> either reuses the address space of thread E<.Fa l> (its "
"process) if there are no other references to it, or creates a new one with "
"E<.Fn uvmspace_alloc>.  The range of valid addresses in the address space is "
"reset to E<.Fa start> through E<.Fa end>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:321
msgid ""
"E<.Fn uvmspace_fork> creates and returns a new address space based upon the "
"E<.Fa vm> address space, typically used when allocating an address space for "
"a child process."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:326
msgid ""
"E<.Fn uvmspace_free> lowers the reference count on the address space E<.Fa "
"vm>, freeing the data structures if there are no other references."
msgstr ""

#.  .Pp
#.  .Fn uvmspace_unshare
#.  ensures that thread
#.  .Fa l
#.  has its own, unshared address space, by creating a new one if
#.  necessary by calling
#.  .Fn uvmspace_fork .
#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:339
msgid ""
"E<.Fn uvmspace_share> causes process E<.Pa p2> to share the address space of "
"E<.Fa p1>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:343
msgid ""
"E<.Fn uvm_uarea_alloc> allocates memory for a u-area (i.e. kernel stack, "
"PCB, etc) and returns the address."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:347
msgid "E<.Fn uvm_uarea_free> frees a u-area allocated with E<.Fn uvm_uarea_alloc>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:352
msgid ""
"E<.Fn uvm_uarea_system_alloc> and E<.Fn uvm_uarea_system_free> are optimised "
"routines, which are used for kernel threads."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/uvm_map.9:357
msgid "E<.Xr pmap 9>, E<.Xr uvm 9>, E<.Xr uvm_km 9>, E<.Xr vmem 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/vattr.9:30
#, no-wrap
msgid "January 8, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/vattr.9:31
#, no-wrap
msgid "VATTR 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vattr.9:36
msgid "E<.Nm vattr>, E<.Nm vattr_null>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/vattr.9:36
#, no-wrap
msgid "vnode attributes"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vattr.9:42
msgid "E<.Ft void> E<.Fn vattr_null \"struct vattr *vap\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vattr.9:45
msgid ""
"Vnode attributes describe attributes of a file or directory including file "
"permissions, owner, group, size, access time and modification time."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vattr.9:47
msgid "A vnode attribute has the following structure:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vattr.9:71
#, no-wrap
msgid ""
"struct vattr {\n"
"        enum vtype      va_type;        /* vnode type (for create) */\n"
"        mode_t          va_mode;        /* files access mode and type */\n"
"        nlink_t         va_nlink;       /* number of references to file */\n"
"        uid_t           va_uid;         /* owner user id */\n"
"        gid_t           va_gid;         /* owner group id */\n"
"        dev_t           va_fsid;        /* file system id (dev for now) */\n"
"        ino_t           va_fileid;      /* file id */\n"
"        u_quad_t        va_size;        /* file size in bytes */\n"
"        long            va_blocksize;   /* blocksize preferred for i/o */\n"
"        struct timespec va_atime;       /* time of last access */\n"
"        struct timespec va_mtime;       /* time of last modification */\n"
"        struct timespec va_ctime;       /* time file changed */\n"
"        struct timespec va_birthtime;   /* time file created */\n"
"        u_long          va_gen;         /* generation number of file */\n"
"        u_long          va_flags;       /* flags defined for file */\n"
"        dev_t           va_rdev;        /* device the special file "
"represents */\n"
"        u_quad_t        va_bytes;       /* bytes of disk space held by file "
"*/\n"
"        u_quad_t        va_filerev;     /* file modification number */\n"
"        u_int           va_vaflags;     /* operations flags, see below */\n"
"        long            va_spare;       /* remain quad aligned */\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vattr.9:78
msgid ""
"A field value of VNOVAL represents a field whose value is unavailable or "
"which is not to be changed.  Valid flag values for E<.Em va_flags> are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vattr.9:80
#, no-wrap
msgid "VA_UTIMES_NULL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vattr.9:82
msgid "utimes argument was NULL"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vattr.9:82
#, no-wrap
msgid "VA_EXCLUSIVE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vattr.9:84
msgid "exclusive create request"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vattr.9:92
msgid ""
"Vnode attributes for a file are set by the vnode operation E<.Xr VOP_SETATTR "
"9>.  Vnode attributes for a file are retrieved by the vnode operation E<.Xr "
"VOP_GETATTR 9>.  For more information on vnode operations see E<.Xr vnodeops "
"9>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vattr.9:94
#, no-wrap
msgid "Fn vattr_null vap"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vattr.9:98
msgid "Set vnode attributes in E<.Fa vap> to VNOVAL."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vattr.9:103
msgid "E<.Fn vattr_null> is implemented in E<.Pa sys/kern/vfs_subr.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vattr.9:107
msgid "E<.Xr intro 9>, E<.Xr vfs 9>, E<.Xr vnode 9>, E<.Xr vnodeops 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/vcons.9:27
#, no-wrap
msgid "February 12, 2006"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/vcons.9:28
#, no-wrap
msgid "VCONS 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:32
msgid "E<.Nm vcons>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/vcons.9:32
#, no-wrap
msgid "generic virtual console framework"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/vcons.9:34
#, no-wrap
msgid "wscons/wsdisplay_vconsvar.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:43
msgid ""
"E<.Ft int> E<.Fn vcons_init \"struct vcons_data *vd\" \"void *cookie\" "
"\"struct wsscreen_descr *desc\" \"struct wsdisplay_accessops *accops\"> "
"E<.Ft int> E<.Fn vcons_init_screen \"struct vcons_data *vd\" \"struct "
"vcons_screen *scr\" \"int exists\" \"long *defattr\"> E<.Ft void> E<.Fn "
"vcons_redraw_screen \"struct vcons_screen *scr\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:46
msgid ""
"These functions are used to setup and control the generic virtual console "
"framework."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:53
msgid ""
"The E<.Fn vcons_init> function initializes the framework, it needs to be "
"called for each driver that's going to use E<.Nm>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:56
msgid "E<.Fn vcons_init_screen> adds a virtual screen to a display."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:61
msgid ""
"E<.Fn vcons_redraw_screen> redraws a screen.  A driver should call it when "
"returning to terminal emulation mode, for instance when X exits."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:66
msgid ""
"E<.Vt struct vcons_data> contains all information needed to manage virtual "
"consoles on a display, usually it will be a member of the driver's softc."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:69
msgid "E<.Vt struct vcons_screen> describes a virtual screen."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/vcons.9:69
#, no-wrap
msgid "USAGE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:74
msgid ""
"To use vcons with a driver it needs to be initialized by calling E<.Fn "
"vcons_init>, usually in the driver's attach function."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vcons.9:75
#, no-wrap
msgid "Fa vd"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:78
msgid "should be a pointer to the driver's E<.Vt struct vcons_data>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vcons.9:78 org_netbsd/src/share/man/man9/vcons.9:135
#, no-wrap
msgid "Fa cookie"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:80
msgid "should be a pointer to the driver's softc."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:84
msgid ""
"should point to a E<.Vt struct wsscreen_descr> describing the default screen "
"type for this display."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vcons.9:84
#, no-wrap
msgid "Fa accops"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:94
msgid ""
"points to the driver's E<.Vt struct wsdisplay_accessops> so E<.Fn "
"vcons_init> can fill it in with its own implementations of E<.Fn "
"alloc_screen>, E<.Fn free_screen>, and E<.Fn show_screen>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:104
msgid ""
"A driver should however provide its own E<.Fn ioctl> and E<.Fn mmap> "
"implementations.  Both will receive a pointer to the driver's E<.Vt struct "
"vcons_data> as first parameter."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:122
msgid ""
"After initialization the driver needs to provide a callback function that "
"will be called whenever a screen is added.  Its purpose is to set up the "
"E<.Vt struct rasops_info> describing the screen.  After that the drawing "
"methods in E<.Vt struct rasops_info> will be replaced with wrappers which "
"call the original drawing functions (which may or may not be provided by the "
"driver) only when the respective screen is visible.  To add a virtual screen "
"the driver one should call E<.Fn vcons_init_screen> which will call the "
"callback function described above, allocate storage for characters and "
"attributes based on whatever the callback set up in E<.Vt struct "
"rasops_info>, and add the screen to a list kept in E<.Vt struct vcons_data>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:124
msgid "The callback needs to have this form:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:128
msgid ""
"E<.Ft void> E<.Fn init_screen \"void *cookie\" \"struct vcons_screen *scr\" "
"\"int existing\" \"long *defattr\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:134
msgid ""
"and should be stored in the E<.Va init_screen> member found in E<.Vt struct "
"vcons_data>.  The arguments are:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:138
msgid "is the cookie passed to E<.Fn vcons_init>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vcons.9:138
#, no-wrap
msgid "Fa scr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:146
msgid ""
"points to the E<.Vt struct vcons_screen> being added, its E<.Va scr_ri> "
"member, a E<.Vt struct rasops_info>, needs to be filled in."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vcons.9:146
#, no-wrap
msgid "Fa existing"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:148
msgid "is non-zero if the screen already exists and is only added to the list."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vcons.9:148
#, no-wrap
msgid "Fa defattr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:156
msgid ""
"points to the screen's default text attribute.  It's filled in by E<.Fn "
"vcons_init_screen> by calling the E<.Fn alloc_attr> method found in E<.Vt "
"struct rasops_info>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:168
msgid ""
"When attaching a E<.Xr wsdisplay 9> the E<.Va accesscookie> member of the "
"E<.Vt struct wsemuldisplaydev_attach_args> passed to E<.Fn config_found> "
"needs to be a pointer to the driver's E<.Vt struct vcons_data>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:172
msgid ""
"The following members of E<.Vt struct vcons_screen> may be of interest to "
"drivers:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vcons.9:173
#, no-wrap
msgid "Va scr_ri"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:177
msgid ""
"contains the E<.Vt struct rasops_info> describing the screen's geometry, "
"access methods and so on."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vcons.9:177
#, no-wrap
msgid "Va scr_cookie"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:181
msgid ""
"the value passed as cookie to E<.Fn vcons_init>.  Usually the driver's "
"softc."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vcons.9:181
#, no-wrap
msgid "Va scr_vd"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:184
msgid "the driver's E<.Vt struct vcons_data>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vcons.9:184
#, no-wrap
msgid "Va scr_flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:186
msgid "can be zero or any combination of:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vcons.9:187
#, no-wrap
msgid "Dv VCONS_NO_REDRAW"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:191
msgid "don't call E<.Fn vcons_redraw_screen> when this screen becomes visible."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vcons.9:191
#, no-wrap
msgid "Dv VCONS_SCREEN_IS_STATIC"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:199
msgid ""
"don't E<.Xr free 9> this screen's E<.Vt struct vcons_screen> in E<.Fn "
"free_screen> - useful if the screen has been statically allocated."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vcons.9:200
#, no-wrap
msgid "Va scr_status"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:204
msgid ""
"currently contains only one flag, E<.Dv VCONS_IS_VISIBLE>, which is set when "
"the screen is visible."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vcons.9:207
msgid "E<.Xr wscons 4>, E<.Xr wsdisplay 4>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/veriexec.9:30
#, no-wrap
msgid "March 18, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/veriexec.9:31
#, no-wrap
msgid "VERIEXEC 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:35
msgid "E<.Nm veriexec>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/veriexec.9:35
#, no-wrap
msgid "in-kernel file integrity subsystem KPI"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/veriexec.9:37
#, no-wrap
msgid "sys/verified_exec.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:74
msgid ""
"E<.Ft void> E<.Fn veriexec_init \"void\"> E<.Ft bool> E<.Fn veriexec_lookup "
"\"struct vnode *vp\"> E<.Ft int> E<.Fn veriexec_verify \"struct lwp *l\" "
"\"struct vnode *vp\" \"const u_char *name\" \"int flag\" \"bool *found\"> "
"E<.Ft void> E<.Fn veriexec_purge \"struct vnode *vp\"> E<.Ft int> E<.Fn "
"veriexec_fpops_add \"const char *fp_type\" \"size_t hash_len\" \"size_t "
"ctx_size\" \"veriexec_fpop_init_t init\" \"veriexec_fpop_update_t update\" "
"\"veriexec_fpop_final_t final\"> E<.Ft int> E<.Fn veriexec_file_add \"struct "
"lwp *l\" \"prop_dictionary_t dict\"> E<.Ft int> E<.Fn veriexec_file_delete "
"\"struct lwp *l\" \"struct vnode *vp\"> E<.Ft int> E<.Fn "
"veriexec_table_delete \"struct lwp *l\" \"struct mount *mp\"> E<.Ft int> "
"E<.Fn veriexec_flush \"struct lwp *l\"> E<.Ft int> E<.Fn veriexec_openchk "
"\"struct lwp *l\" \"struct vnode *vp\" \"const char *path\" \"int fmode\"> "
"E<.Ft int> E<.Fn veriexec_renamechk \"struct lwp *l\" \"struct vnode "
"*fromvp\" \"const char *fromname\" \"struct vnode *tovp\" \"const char "
"*toname\"> E<.Ft int> E<.Fn veriexec_removechk \"struct lwp *l\" \"struct "
"vnode *vp\" \"const char *name\"> E<.Ft int> E<.Fn veriexec_unmountchk "
"\"struct mount *mp\"> E<.Ft int> E<.Fn veriexec_convert \"struct vnode *vp\" "
"\"prop_dictionary_t rdict\"> E<.Ft int> E<.Fn veriexec_dump \"struct lwp "
"*l\" \"prop_array_t rarray\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:88
msgid ""
"E<.Nm> is the E<.Tn KPI> for E<.Em Veriexec>, the E<.Nx> in-kernel file "
"integrity subsystem.  It is responsible for managing the supported hashing "
"algorithms, fingerprint calculation and comparison, file monitoring tables, "
"and relevant hooks to enforce the E<.Em Veriexec> policy."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/veriexec.9:89
#, no-wrap
msgid "Core Routines"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:91
#, no-wrap
msgid "Fn veriexec_init void"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:96
msgid ""
"Initialize the E<.Em Veriexec> subsystem.  Called only once during system "
"startup."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:96
#, no-wrap
msgid "Fn veriexec_lookup vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:106
msgid ""
"Check if E<.Ar vp> is monitored by E<.Em Veriexec>.  Returns E<.Dv true> if "
"it is, or E<.Dv false> otherwise."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:106
#, no-wrap
msgid "Fn veriexec_verify l vp name flag found"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:114
msgid ""
"Verifies the digital fingerprint of E<.Ar vp>.  E<.Ar name> is the filename, "
"and E<.Ar flag> is the access flag.  The access flag can be one of:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:115
#, no-wrap
msgid "Dv VERIEXEC_DIRECT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:118
msgid "The file was executed directly via E<.Xr execve 2>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:118
#, no-wrap
msgid "Dv VERIEXEC_INDIRECT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:121
msgid ""
"The file was executed indirectly, either as an interpreter for a script or "
"mapped to an executable memory region."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:121
#, no-wrap
msgid "Dv VERIEXEC_FILE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:123
msgid "The file was opened for reading/writing."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:127
msgid "E<.Ar l> is the LWP for the request context."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:134
msgid ""
"An optional argument, E<.Ar found>, is a pointer to a boolean indicating "
"whether an entry for the file was found in the E<.Em Veriexec> tables."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:134
#, no-wrap
msgid "Fn veriexec_purge vp"
msgstr ""

#.  veriexec_page_verify() intentionally not documented.
#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:140
msgid ""
"Purge the file entry for E<.Ar vp>.  This invalidates the fingerprint so it "
"will be evaluated next time the file is accessed."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/veriexec.9:141
#, no-wrap
msgid "Fingerprint Related Routines"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:143
#, no-wrap
msgid "Fn veriexec_fpops_add fp_type hash_len ctx_size init update final"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:159
msgid ""
"Add support for fingerprinting algorithm E<.Ar fp_type> with binary hash "
"length E<.Ar hash_len> and calculation context size E<.Ar ctx_size> to E<.Em "
"Veriexec>.  E<.Ar init>, E<.Ar update>, and E<.Ar final> are the routines "
"used to initialize, update, and finalize a calculation context."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/veriexec.9:160
#, no-wrap
msgid "Table Management Routines"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:162
#, no-wrap
msgid "Fn veriexec_file_add l dict"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:167
msgid "Add a E<.Em Veriexec> entry for the file described by E<.Ar dict>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:170
msgid "E<.Ar dict> is expected to have the following:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:171 org_netbsd/src/share/man/man9/veriexec.9:257
#, no-wrap
msgid "Sy \"Name\tType\tPurpose\""
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:172
#, no-wrap
msgid "file\tstring\tfilename"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:173 org_netbsd/src/share/man/man9/veriexec.9:258
#, no-wrap
msgid "\"entry-type\tuint8\tentry\" type flags ( see Xr veriexec 4 )"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:174 org_netbsd/src/share/man/man9/veriexec.9:260
#, no-wrap
msgid "\"fp-type\tstring\tfingerprint\" hashing algorithm"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:175 org_netbsd/src/share/man/man9/veriexec.9:261
#, no-wrap
msgid "\"fp\tdata\tthe\" fingerprint"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:177
#, no-wrap
msgid "Fn veriexec_file_delete l vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:182
msgid "Remove E<.Em Veriexec> entry for E<.Ar vp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:182
#, no-wrap
msgid "Fn veriexec_table_delete l mp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:187
msgid "Remove E<.Em Veriexec> table for mount-point E<.Ar mp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:187
#, no-wrap
msgid "Fn veriexec_flush l"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:191
msgid "Delete all E<.Em Veriexec> tables."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/veriexec.9:192
#, no-wrap
msgid "Hook Handlers"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:194
#, no-wrap
msgid "Fn veriexec_openchk l vp path fmode"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:196
msgid "Called when a file is opened."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:209
msgid ""
"E<.Ar l> is the LWP opening the file, E<.Ar vp> is a vnode for the file "
"being opened as returned from E<.Xr namei 9>.  If E<.Dv NULL>, the file is "
"being created.  E<.Ar path> is the pathname for the file (not necessarily a "
"full path), and E<.Ar fmode> are the mode bits with which the file was "
"opened."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:209
#, no-wrap
msgid "Fn veriexec_renamechk l fromvp fromname tovp toname"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:211
msgid "Called when a file is renamed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:222
msgid ""
"E<.Ar fromvp> and E<.Ar fromname> are the vnode and filename of the file "
"being renamed.  E<.Ar tovp> and E<.Ar toname> are the vnode and filename of "
"the target file.  E<.Ar l> is the LWP renaming the file."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:226
msgid ""
"Depending on the strict level, E<.Nm> will either track changes "
"appropriately or prevent the rename."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:226
#, no-wrap
msgid "Fn veriexec_removechk l vp name"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:228
msgid "Called when a file is removed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:235
msgid ""
"E<.Ar vp> is the vnode of the file being removed, and E<.Ar name> is the "
"filename.  E<.Ar l> is the LWP removing the file,"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:239
msgid ""
"Depending on the strict level, E<.Nm> will either clean-up after the file or "
"prevent its removal."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:239
#, no-wrap
msgid "Fn veriexec_unmountchk mp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:243
msgid "Checks if the current strict level allows E<.Ar mp> to be unmounted."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:246
#, no-wrap
msgid "Fn veriexec_convert vp rdict"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:256
msgid ""
"Convert E<.Em Veriexec> entry for E<.Ar vp> to human-readable E<.Xr proplib "
"3> dictionary, E<.Ar rdict>, with the following elements:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:259
#, no-wrap
msgid "\"status\tuint8\tentry\" status ( see below )"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:267
msgid "The E<.Dq status> can be one of the following:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:268
#, no-wrap
msgid "Sy \"Status\tMeaning\""
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:269
#, no-wrap
msgid "\"FINGERPRINT_NOTEVAL\tnot\" evaluated"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:270
#, no-wrap
msgid "\"FINGERPRINT_VALID\tfingerprint\" match"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:271
#, no-wrap
msgid "\"FINGERPRINT_MISMATCH\tfingerprint\" mismatch"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:278
msgid "If no entry was found, E<.Er ENOENT> is returned.  Otherwise, zero."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:278
#, no-wrap
msgid "Fn veriexec_dump l rarray"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:284
msgid ""
"Fill E<.Ar rarray> with entries for all files monitored by E<.Em Veriexec> "
"that have a filename associated with them."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:292
msgid ""
"Each element in E<.Ar rarray> is a dictionary with the same elements as "
"filled by E<.Fn veriexec_convert>, with an additional field, E<.Dq file>, "
"containing the filename."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:295
#, no-wrap
msgid "Sy \"Path\tPurpose\""
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:296
#, no-wrap
msgid "\"src/sys/dev/verified_exec.c\tdriver\" for userland communication"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:297
#, no-wrap
msgid "\"src/sys/sys/verified_exec.h\tshared\" (userland/kernel) header file"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:298
#, no-wrap
msgid "\"src/sys/kern/kern_verifiedexec.c\tsubsystem\" code"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:299
#, no-wrap
msgid "\"src/sys/kern/vfs_syscalls.c\trename,\" remove, and unmount policies"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/veriexec.9:300
#, no-wrap
msgid "\"src/sys/kern/vfs_vnops.c\tregular\" file access policy"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:311
msgid ""
"E<.Xr proplib 3>, E<.Xr sysctl 3>, E<.Xr veriexec 4>, E<.Xr security 7>, "
"E<.Xr sysctl 8>, E<.Xr veriexecctl 8>, E<.Xr veriexecgen 8>, E<.Xr fileassoc "
"9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:314
msgid "E<.An Brett Lymn Aq blymn@NetBSD.org> E<.An Elad Efrat Aq elad@NetBSD.org>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:318
msgid ""
"There are two known issues with E<.Em Veriexec> that should be considered "
"when using it."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/veriexec.9:318
#, no-wrap
msgid "Remote File-systems"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:328
msgid ""
"There is an issue providing protection for files residing on mounts from "
"remote hosts.  Because access to the file-system does not necessarily go "
"through E<.Nm>, there is no way to track on-disk changes.  While it is "
"possible to minimize the effect by evaluating the file's fingerprint on each "
"access without caching the result, a problem arises when a file is "
"overwritten after its fingerprint has been evaluated and it is running on "
"the local host."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:333
msgid ""
"An attacker could potentially overwrite the file contents in the remote host "
"at that point, and force a flush on the local host, resulting in paging in "
"of the files from the disk, introducing malicious code into a supposedly "
"safe address space."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:336
msgid ""
"There is a fix for this issue, however due to dependencies on other work "
"that is still in progress it has not been committed yet."
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/veriexec.9:336
#, no-wrap
msgid "Layered File-systems"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:344
msgid ""
"Due to VFS limitations, E<.Nm> cannot track the same on-disk file across "
"multiple layers of overlay file-systems.  Therefore, you cannot expect "
"changes to files on overlay mounts will be detected simply because the "
"underlying mount is monitored by E<.Nm>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/veriexec.9:346
msgid ""
"A workaround for this issue is listing all files, under all mounts, you want "
"monitored in the signature file."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/vfs.9:30
#, no-wrap
msgid "September 22, 2001"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/vfs.9:31
#, no-wrap
msgid "VFS 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfs.9:35
msgid "E<.Nm vfs>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/vfs.9:35
#, no-wrap
msgid "kernel interface to file systems"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfs.9:43
msgid ""
"The virtual file system, E<.Nm>, is the kernel interface to file systems.  "
"The interface specifies the calls for the kernel to access file systems.  It "
"also specifies the core functionality that a file system must provide to the "
"kernel."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfs.9:52
msgid ""
"The focus of E<.Nm> activity is the E<.Em vnode> and is discussed in E<.Xr "
"vnode 9>.  File system operations such as mounting and syncing are discussed "
"in E<.Xr vfsops 9>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfs.9:56
msgid "E<.Xr intro 9>, E<.Xr vfsops 9>, E<.Xr vnode 9>, E<.Xr vnodeops 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/vfs_hooks.9:30
#, no-wrap
msgid "September 23, 2005"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/vfs_hooks.9:31
#, no-wrap
msgid "VFS_HOOKS 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfs_hooks.9:36
msgid "E<.Nm vfs_hooks>, E<.Nm vfs_hooks_unmount>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/vfs_hooks.9:36
#, no-wrap
msgid "VFS hooks interface"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfs_hooks.9:42
msgid "E<.Ft void> E<.Fn vfs_hooks_unmount \"struct mount *mp\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfs_hooks.9:49
msgid ""
"The VFS hooks interface provides a way for different kernel subsystems to "
"attach custom functions to specific VFS operations.  This enforces code "
"separation by keeping the VFS's core sources uncluttered and makes all "
"subsystem functionality reside in a single place.  As an example, this "
"interface is used by the NFS server code to automatically handle the exports "
"list for each mount point."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfs_hooks.9:53
msgid "Hooks are described by a E<.Ft struct vfs_hooks> object, as seen below:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfs_hooks.9:57
#, no-wrap
msgid ""
"struct vfs_hooks {\n"
"\tint\t(*vh_unmount)(struct mount *);\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfs_hooks.9:62
msgid ""
"For simplicity, each field is named after the VFS operation it refers to.  "
"The purpose of each member function, alongside some important notes, is "
"shown below:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfs_hooks.9:63
#, no-wrap
msgid "Fn vh_unmount mp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfs_hooks.9:65
msgid "This hook is executed during the unmount process of a file system."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfs_hooks.9:70
msgid ""
"For more information about the purpose of each operation, see E<.Xr vfsops "
"9>.  Note that any of these fields may be a null pointer."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfs_hooks.9:78
msgid ""
"After the definition of a E<.Ft struct vfs_hooks> object, the kernel has to "
"add it to the E<.Va vfs_hooks> link set using the E<.Fn VFS_HOOKS_ATTACH "
"\"struct vfs_hooks *\"> macro."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfs_hooks.9:84
msgid ""
"Please note that this interface is incomplete on purpose to keep it in its "
"smallest possible size (i.e., do not provide a hook that is not used).  If "
"you feel the need to hook a routine to a VFS operation that is not yet "
"supported by this interface, just add it to the files described in E<.Sx "
"CODE REFERENCES>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfs_hooks.9:87
msgid ""
"The following functions are provided to the VFS code to run the hooked "
"functions:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfs_hooks.9:88
#, no-wrap
msgid "Fn vfs_hooks_unmount mp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfs_hooks.9:92
msgid ""
"Runs all hooks for the VFS unmount operation.  Given that these operations "
"shall not fail, it returns E<.Ft void>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfs_hooks.9:98
msgid ""
"The VFS hooks interface is implemented within the files E<.Pa "
"sys/kern/vfs_hooks.c> and E<.Pa sys/sys/mount.h>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfs_hooks.9:102
msgid "E<.Xr intro 9>, E<.Xr vfs 9>, E<.Xr vfsops 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfs_hooks.9:104
msgid "The VFS hooks interface appeared in E<.Nx 4.0>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/vfsops.9:30
#, no-wrap
msgid "April 22, 2009"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/vfsops.9:31
#, no-wrap
msgid "VFSOPS 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:47
msgid ""
"E<.Nm vfsops>, E<.Nm VFS_MOUNT>, E<.Nm VFS_START>, E<.Nm VFS_UNMOUNT>, E<.Nm "
"VFS_ROOT>, E<.Nm VFS_QUOTACTL>, E<.Nm VFS_STATVFS>, E<.Nm VFS_SYNC>, E<.Nm "
"VFS_VGET>, E<.Nm VFS_FHTOVP>, E<.Nm VFS_VPTOFH>, E<.Nm VFS_SNAPSHOT>, E<.Nm "
"VFS_SUSPENDCTL>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/vfsops.9:47
#, no-wrap
msgid "kernel file system interface"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:78
msgid ""
"E<.Ft int> E<.Fo VFS_MOUNT> E<.Fa \"struct mount *mp\" \"const char *path\" "
"\"void *data\" \"size_t *dlen\"> E<.Fc> E<.Ft int> E<.Fn VFS_START \"struct "
"mount *mp\" \"int flags\"> E<.Ft int> E<.Fn VFS_UNMOUNT \"struct mount *mp\" "
"\"int mntflags\"> E<.Ft int> E<.Fn VFS_ROOT \"struct mount *mp\" \"struct "
"vnode **vpp\"> E<.Ft int> E<.Fn VFS_QUOTACTL \"struct mount *mp\" \"struct "
"quotactl_args *args\"> E<.Ft int> E<.Fn VFS_STATVFS \"struct mount *mp\" "
"\"struct statvfs *sbp\"> E<.Ft int> E<.Fn VFS_SYNC \"struct mount *mp\" "
"\"int waitfor\" \"kauth_cred_t cred\"> E<.Ft int> E<.Fn VFS_VGET \"struct "
"mount *mp\" \"ino_t ino\" \"struct vnode **vpp\"> E<.Ft int> E<.Fn "
"VFS_FHTOVP \"struct mount *mp\" \"struct fid *fhp\" \"struct vnode **vpp\"> "
"E<.Ft int> E<.Fn VFS_VPTOFH \"struct vnode *vp\" \"struct fid *fhp\" "
"\"size_t *fh_size\"> E<.Ft int> E<.Fn VFS_SNAPSHOT \"struct mount *mp\" "
"\"struct vnode *vp\" \"struct timespec *ts\"> E<.Ft int> E<.Fn "
"VFS_SUSPENDCTL \"struct mount *mp\" \"int cmd\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:84
msgid ""
"In a similar fashion to the E<.Xr vnode 9> interface, all operations that "
"are done on a file system are conducted through a single interface that "
"allows the system to carry out operations on a file system without knowing "
"its construction or type."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:99
msgid ""
"All supported file systems in the kernel have an entry in the E<.Va "
"vfs_list_initial> table.  This table is generated by E<.Xr config 1> and is "
"a E<.Dv NULL Ns No -terminated> list of E<.Vt vfsops> structures.  The "
"vfsops structure describes the operations that can be done to a specific "
"file system type.  The following table lists the elements of the vfsops "
"vector, the corresponding invocation macro, and a description of the "
"element."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:101
#, no-wrap
msgid "Sy Vector element Ta Sy Macro Ta Sy Description"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:103
#, no-wrap
msgid "int (*vfs_mount)() Ta Dv VFS_MOUNT Ta Mount a file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:107
#, no-wrap
msgid "int (*vfs_start)() Ta Dv VFS_START Ta Make operational"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:111
#, no-wrap
msgid "int (*vfs_unmount)() Ta Dv VFS_UNMOUNT Ta Unmount a file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:115
#, no-wrap
msgid "int (*vfs_root)() Ta Dv VFS_ROOT Ta Get the file system root vnode"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:119
#, no-wrap
msgid "int (*vfs_quotactl)() Ta Dv VFS_QUOTACTL Ta Query/modify space quotas"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:123
#, no-wrap
msgid "int (*vfs_statvfs)() Ta Dv VFS_STATVFS Ta Get file system statistics"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:127
#, no-wrap
msgid "int (*vfs_sync)() Ta Dv VFS_SYNC Ta Flush file system buffers"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:131
#, no-wrap
msgid "int (*vfs_vget)() Ta Dv VFS_VGET Ta Get vnode from file id"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:135
#, no-wrap
msgid "int (*vfs_fhtovp)() Ta Dv VFS_FHTOVP Ta NFS file handle to vnode lookup"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:139
#, no-wrap
msgid "int (*vfs_vptofh)() Ta Dv VFS_VPTOFH Ta Vnode to NFS file handle lookup"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:143
#, no-wrap
msgid "void (*vfs_init)() Ta \\- Ta Initialize file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:147
#, no-wrap
msgid "void (*vfs_reinit)() Ta \\- Ta Reinitialize file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:151
#, no-wrap
msgid "void (*vfs_done)() Ta \\- Ta Cleanup unmounted file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:155
#, no-wrap
msgid "int (*vfs_mountroot)() Ta \\- Ta Mount the root file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:159
#, no-wrap
msgid "int (*vfs_snapshot)() Ta Dv VFS_SNAPSHOT Ta Take a snapshot"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:163
#, no-wrap
msgid "int (*vfs_suspendctl)() Ta Dv VFS_SUSPENDCTL Ta Suspend or resume"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:186
msgid ""
"Some additional non-function members of the vfsops structure are the file "
"system name E<.Fa vfs_name> and a reference count E<.Fa vfs_refcount>.  It "
"is not mandatory for a file system type to support a particular operation, "
"but it must assign each member function pointer to a suitable function to do "
"the minimum required of it.  In most cases, such functions either do nothing "
"or return an error value to the effect that it is not supported.  E<.Fa "
"vfs_reinit>, E<.Fa vfs_mountroot>, E<.Fa vfs_fhtovp>, and E<.Fa vfs_vptofh> "
"may be E<.Dv NULL>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:199
msgid ""
"At system boot, each file system with an entry in E<.Va vfs_list_initial> is "
"established and initialized.  Each initialized file system is recorded by "
"the kernel in the list E<.Va vfs_list> and the file system specific "
"initialization function E<.Fa vfs_init> in its vfsops vector is invoked.  "
"When the file system is no longer needed E<.Fa vfs_done> is invoked to run "
"file system specific cleanups and the file system is removed from the kernel "
"list."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:208
msgid ""
"At system boot, the root file system is mounted by invoking the file system "
"type specific E<.Fa vfs_mountroot> function in the vfsops vector.  All file "
"systems that can be mounted as a root file system must define this "
"function.  It is responsible for initializing to list of mount structures "
"for all future mounted file systems."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:213
msgid ""
"Kernel state which affects a specific file system type can be queried and "
"modified using the E<.Xr sysctl 8> interface."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:215
#, no-wrap
msgid "Fn VFS_MOUNT mp path data dlen"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:225
msgid ""
"Mount a file system specified by the mount structure E<.Fa mp> on the mount "
"point described by E<.Fa path>.  The argument E<.Fa data> contains file "
"system type specific data, while the argument E<.Fa dlen> points to a "
"location specifying the length of the data."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:247
msgid ""
"E<.Fn VFS_MOUNT> initializes the mount structure for the mounted file "
"system.  This structure records mount-specific information for the file "
"system and records the list of vnodes associated with the file system.  This "
"function is invoked both to mount new file systems and to change the "
"attributes of an existing file system.  If the flag E<.Dv MNT_UPDATE> is set "
"in E<.Va mp-\\*[Gt]mnt_flag>, the file system should update its state.  This "
"can be used, for instance, to convert a read-only file system to "
"read-write.  The current attributes for a mounted file system can be fetched "
"by specifying E<.Dv MNT_GETARGS>.  If neither E<.Dv MNT_UPDATE> or E<.Dv "
"MNT_GETARGS> are specified, a new file system will attempted to be mounted."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:247
#, no-wrap
msgid "Fn VFS_START mp flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:258
msgid ""
"Make the file system specified by the mount structure E<.Fa mp> "
"operational.  The argument E<.Fa flags> is a set of flags for controlling "
"the operation of E<.Fn VFS_START>.  This function is invoked after E<.Fn "
"VFS_MOUNT> and before the first access to the file system."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:258
#, no-wrap
msgid "Fn VFS_UNMOUNT mp mntflags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:271
msgid ""
"Unmount a file system specified by the mount structure E<.Fa mp>.  E<.Fn "
"VFS_UNMOUNT> performs any file system type specific operations required "
"before the file system is unmounted, such are flushing buffers.  If E<.Dv "
"MNT_FORCE> is specified in the flags E<.Fa mntflags> then open files are "
"forcibly closed.  The function also deallocates space associated with data "
"structure that were allocated for the file system when it was mounted."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:271
#, no-wrap
msgid "Fn VFS_ROOT mp vpp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:283
msgid ""
"Get the root vnode of the file system specified by the mount structure E<.Fa "
"mp>.  The vnode is returned in the address given by E<.Fa vpp>.  This "
"function is used by the pathname translation algorithms when a vnode that "
"has been covered by a mounted file system is encountered.  While resolving "
"the pathname, the pathname translation algorithm will have to go through the "
"directory tree in the file system associated with that mount point and "
"therefore requires the root vnode of the file system."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:283
#, no-wrap
msgid "Fn VFS_QUOTACTL mp args"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:297
msgid ""
"Query/modify user space quotas for the file system specified by the mount "
"structure E<.Fa mp>.  The argument structure provides the operation ID and "
"arguments to perform.  This is the same interface as documented in E<.Xr "
"__quotactl 2> except that the file system argument has been resolved.  All "
"E<.Xr copyin 2> and E<.Xr copyout 2> processing is handled by code above the "
"file system."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:297
#, no-wrap
msgid "Fn VFS_STATVFS mp sbp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:309
msgid ""
"Get file system statistics for the file system specified by the mount "
"structure E<.Fa mp>.  A statvfs structure filled with the statistics is "
"returned in E<.Fa sbp>.  E<.Fn VFS_STATVFS> is the file system type specific "
"implementation of the E<.Xr statvfs 2> and E<.Xr fstatvfs 2> system calls."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:309
#, no-wrap
msgid "Fn VFS_SYNC mp waitfor cred"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:322
msgid ""
"Flush file system I/O buffers for the file system specified by the mount "
"structure E<.Fa mp>.  The E<.Fa waitfor> argument indicates whether a "
"partial flush or complete flush should be performed.  The argument E<.Fa "
"cred> specifies the calling credentials.  E<.Fn VFS_SYNC> does not provide "
"any return value since the operation can never fail."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:322
#, no-wrap
msgid "Fn VFS_VGET mp ino vpp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:335
msgid ""
"Get vnode for a file system type specific file id E<.Fa ino> for the file "
"system specified by the mount structure E<.Fa mp>.  The vnode is returned in "
"the address specified E<.Fa vpp>.  The function is optional for file systems "
"which have a unique id number for every file in the file system.  It is used "
"internally by the UFS file system and also by the NFSv3 server to implement "
"the READDIRPLUS NFS call.  If the file system does not support this "
"function, it should return E<.Er EOPNOTSUPP>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:335
#, no-wrap
msgid "Fn VFS_FHTOVP mp fhp vpp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:342
msgid ""
"Get the vnode for the file handle E<.Fa fhp> in the file system specified by "
"the mount structure E<.Fa mp>.  The locked vnode is returned in E<.Fa vpp>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:348
msgid ""
"When exporting, the call to E<.Fn VFS_FHTOVP> should follow a call to E<.Fn "
"netexport_check>, which checks if the file is accessible to the client."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:352 org_netbsd/src/share/man/man9/vfsops.9:386
msgid ""
"If file handles are not supported by the file system, this function must "
"return E<.Er EOPNOTSUPP>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:352
#, no-wrap
msgid "Fn VFS_VPTOFH vp fhp fh_size"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:362
msgid ""
"Get a file handle for the vnode specified by E<.Fa vp>.  The file handle is "
"returned in E<.Fa fhp>.  The contents of the file handle are defined by the "
"file system and are not examined by any other subsystems.  It should contain "
"enough information to uniquely identify a file within the file system as "
"well as noticing when a file has been removed and the file system resources "
"have been recycled for a new file."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:382
msgid ""
"The parameter E<.Fa fh_size> points to the container size for the file "
"handle.  This parameter should be updated to the size of the finished file "
"handle.  Note that it is legal to call this function with E<.Fa fhp> set to "
"E<.Dv NULL> in case E<.Fa fh_size> is zero.  In case E<.Fa fh_size> "
"indicates a storage space too small, the storage space required for the file "
"handle corresponding to E<.Fa vp> should be filled in and E<.Er E2BIG> "
"should be returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:386
#, no-wrap
msgid "Fn VFS_SNAPSHOT mp vp ts"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:398
msgid ""
"Take a snapshot of the file system specified by the mount structure E<.Fa "
"mp> and make it accessible through the locked vnode E<.Fa vp>.  If E<.Fa ts> "
"is not E<.Dv NULL> it will receive the time this snapshot was taken.  If the "
"file system does not support this function, it should return E<.Er "
"EOPNOTSUPP>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfsops.9:398
#, no-wrap
msgid "Fn VFS_SUSPENDCTL mp cmd"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:408
msgid ""
"Suspend or resume all operations on this file system.  E<.Fa cmd> is either "
"E<.Dv SUSPEND_SUSPEND> to suspend or E<.Dv SUSPEND_RESUME> to resume "
"operations.  If the file system does not support this function, it should "
"return E<.Er EOPNOTSUPP>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:414
msgid ""
"The vfs operations are implemented within the files E<.Pa "
"sys/kern/vfs_subr.c> and E<.Pa sys/kern/vfs_init.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:421
msgid ""
"E<.Xr intro 9>, E<.Xr namei 9>, E<.Xr vfs 9>, E<.Xr vfssubr 9>, E<.Xr vnode "
"9>, E<.Xr vnodeops 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfsops.9:424
msgid ""
"The vfs operations vector, its functions and the corresponding macros "
"appeared in E<.Bx 4.3>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/vfssubr.9:30
#, no-wrap
msgid "May 9, 2009"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/vfssubr.9:31
#, no-wrap
msgid "VFSSUBR 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfssubr.9:55
msgid ""
"E<.Nm vfssubr>, E<.Nm vfs_getnewfsid>, E<.Nm vfs_getvfs>, E<.Nm vfs_export>, "
"E<.Nm vfs_showexport>, E<.Nm vfs_export_lookup>, E<.Nm vfs_setpublicfs>, "
"E<.Nm vfs_mountedon>, E<.Nm vfs_mountroot>, E<.Nm vfs_unmountall>, E<.Nm "
"vfs_busy>, E<.Nm vfs_unbusy>, E<.Nm vfs_mountalloc>, E<.Nm "
"vfs_rootmountalloc>, E<.Nm vfs_shutdown>, E<.Nm vfs_attach>, E<.Nm "
"vfs_detach>, E<.Nm vfs_reinit>, E<.Nm vfs_getopsbyname>, E<.Nm vfs_suspend>, "
"E<.Nm vfs_resume>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/vfssubr.9:55
#, no-wrap
msgid "high-level interface to kernel file system interface"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfssubr.9:99
msgid ""
"E<.Ft void> E<.Fn vfs_getnewfsid \"struct mount *mp\"> E<.Ft struct mount *> "
"E<.Fn vfs_getvfs \"fsid_t *fsid\"> E<.Ft int> E<.Fn vfs_export_lookup "
"\"struct mount *mp\" \"struct netexport *nep\" \"struct export_args *argp\"> "
"E<.Ft int> E<.Fn vfs_setpublicfs \"struct mount *mp\" \"struct netexport "
"*nep\" \"struct export_args *argp\"> E<.Ft int> E<.Fn vfs_mountedon \"struct "
"vnode *vp\"> E<.Ft int> E<.Fn vfs_mountroot \"void\"> E<.Ft void> E<.Fn "
"vfs_unmountall \"struct lwp *l\"> E<.Ft int> E<.Fn vfs_busy \"struct mount "
"*mp\" \"int flags\" \"struct simplelock *interlkp\"> E<.Ft void> E<.Fn "
"vfs_unbusy \"struct mount *mp\"> E<.Ft struct mount *> E<.Fn vfs_mountalloc "
"\"struct vfsops *vfs\" \"struct vnode *vp\"> E<.Ft int> E<.Fn "
"vfs_rootmountalloc \"char *fstypename\" \"char *devname\" \"struct mount "
"**mpp\"> E<.Ft void> E<.Fn vfs_shutdown \"void\"> E<.Ft int> E<.Fn "
"vfs_attach \"struct vfsops *vfs\"> E<.Ft int> E<.Fn vfs_detach \"struct "
"vfsops *vfs\"> E<.Ft void> E<.Fn vfs_reinit \"void\"> E<.Ft struct vfsops *> "
"E<.Fn vfs_getopsbyname \"const char *name\"> E<.Ft int> E<.Fn vfs_suspend "
"\"struct mount *mp\" \"int nowait\"> E<.Ft void> E<.Fn vfs_resume \"struct "
"mount *mp\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfssubr.9:102
msgid ""
"The high-level functions described in this page are the interface to the "
"kernel file system interface (VFS)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfssubr.9:104
#, no-wrap
msgid "Fn vfs_getnewfsid mp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfssubr.9:110
msgid ""
"Get a new unique file system id type for the file system specified by the "
"mount structure E<.Fa mp>.  The file system id type is stored in E<.Em "
"mp-\\*[Gt]mnt_stat.f_fsidx>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfssubr.9:110
#, no-wrap
msgid "Fn vfs_getvfs fsid"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfssubr.9:113
msgid "Lookup a mount point with the file system identifier E<.Fa fsid>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfssubr.9:113
#, no-wrap
msgid "Fn vfs_export_lookup mp nep argp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfssubr.9:122
msgid ""
"Check client permission on the exportable file system specified by the mount "
"structure E<.Fa mp>.  The argument E<.Fa nam> is the address of the "
"networked client.  This function is used by file system type specific "
"functions to verify that the client can access the file system."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfssubr.9:122
#, no-wrap
msgid "Fn vfs_setpublicfs mp nep argp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfssubr.9:125
msgid ""
"Set the publicly exported file system specified by the mount structure E<.Fa "
"mp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfssubr.9:125
#, no-wrap
msgid "Fn vfs_mountedon vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfssubr.9:129
msgid ""
"Check to see if a file system is mounted on a block device specified by the "
"vnode E<.Fa vp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfssubr.9:129
#, no-wrap
msgid "Fn vfs_mountroot void"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfssubr.9:131
msgid "Mount the root file system."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfssubr.9:131
#, no-wrap
msgid "Fn vfs_unmountall l"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfssubr.9:133
msgid "Unmount all file systems."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfssubr.9:133
#, no-wrap
msgid "Fn vfs_busy mp flags interlkp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfssubr.9:141
msgid ""
"Mark the mount point specified by E<.Fa mp> as busy.  This function is used "
"to synchronize access and to delay unmounting.  The interlock specified by "
"argument E<.Fa interlkp> is not released on failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfssubr.9:141
#, no-wrap
msgid "Fn vfs_unbusy mp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfssubr.9:144
msgid "Free the busy file system specified by the mount structure E<.Fa mp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfssubr.9:144
#, no-wrap
msgid "Fn vfs_mountalloc vfsops vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfssubr.9:156
msgid ""
"Allocate and initialise a mount structure, setting E<.Em mnt_vnodecovered> "
"to E<.Fa vp> and E<.Em mnt_op> to E<.Fa vfsops>.  On success, mark the mount "
"structure as busy and return its address.  Otherwise, return E<.Dv NULL>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfssubr.9:156
#, no-wrap
msgid "Fn vfs_rootmountalloc fstypename devname mpp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfssubr.9:166
msgid ""
"Lookup a file system type specified by the name E<.Fa fstypename> and if "
"found allocate and initialise a mount structure for it.  The allocated mount "
"structure is returned in the address specified by E<.Fa mpp>.  The device "
"the root file system was mounted from is specified by the argument E<.Fa "
"devname> and is recorded in the new mount structure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfssubr.9:166
#, no-wrap
msgid "Fn vfs_shutdown"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfssubr.9:170
msgid ""
"Sync and unmount all file systems before shutting down.  Invoked by E<.Xr "
"cpu_reboot 9>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfssubr.9:170
#, no-wrap
msgid "Fn vfs_attach vfs"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfssubr.9:174
msgid "Establish file system E<.Fa vfs> and initialise it."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfssubr.9:174
#, no-wrap
msgid "Fn vfs_detach vfs"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfssubr.9:178
msgid "Remove file system E<.Fa vfs> from the kernel."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfssubr.9:178
#, no-wrap
msgid "Fn vfs_reinit void"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfssubr.9:182
msgid ""
"Reinitialises all file systems within the kernel through file "
"system-specific vfs operation (see E<.Xr vfsops 9>)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfssubr.9:182
#, no-wrap
msgid "Fn vfs_getopsbyname name"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfssubr.9:190
msgid ""
"Given a file system name specified by E<.Fa name>, look up the vfs "
"operations for that file system (see E<.Xr vfsops 9>), or return E<.Dv NULL> "
"if file system isn't present in the kernel."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfssubr.9:190
#, no-wrap
msgid "Fn vfs_suspend mp nowait"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfssubr.9:202
msgid ""
"Request a mounted file system to suspend all operations.  All new operations "
"to the file system are stopped.  After all operations in progress have "
"completed, the file system is synced to disk and the function returns.  If a "
"file system suspension is currently in progress and E<.Fa nowait> is set "
"E<.Er EWOULDBLOCK> is returned.  If the operation is successful, zero is "
"returned, otherwise an appropriate error code is returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vfssubr.9:202
#, no-wrap
msgid "Fn vfs_resume mp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfssubr.9:204
msgid "Request a mounted file system to resume operations."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfssubr.9:210
msgid ""
"The vfs interface functions are implemented within the files E<.Pa "
"sys/kern/vfs_subr.c> and E<.Pa sys/kern/vfs_init.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vfssubr.9:216
msgid ""
"E<.Xr intro 9>, E<.Xr namei 9>, E<.Xr vfs 9>, E<.Xr vfsops 9>, E<.Xr vnode "
"9>, E<.Xr vnodeops 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/video.9:28
#, no-wrap
msgid "July 24, 2008"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/video.9:29
#, no-wrap
msgid "VIDEO 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:33
msgid "E<.Nm video>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/video.9:33
#, no-wrap
msgid "interface between low and high level video drivers"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/video.9:35
#, no-wrap
msgid "dev/video_if.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:40
msgid ""
"E<.Ft device_t> E<.Fn video_attach_mi \"const struct video_hw_if *hw_if\" "
"\"device_t hw_dev\"> E<.Ft void> E<.Fn video_submit_payload \"device_t "
"vl_dev\" \"const struct video_payload *payload\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:47
msgid ""
"The video device driver is divided into a high level, machine independent "
"layer, and a low level hardware dependent layer.  The interface between "
"these is the E<.Fa video_hw_if> structure function pointers called by the "
"video layer, and video layer functions called by the hardware driver."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:57
msgid ""
"The high level video driver attaches to the low level driver when the latter "
"calls E<.Fa video_attach_mi>.  The E<.Fa video_hw_if> struct is as shown "
"below.  E<.Fa dev> is the device struct for the hardware device.  Return "
"value is the video layer device."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:61
#, no-wrap
msgid ""
"struct video_hw_if {\n"
"\tint\t(*open)(void *, int); /* open hardware */\n"
"\tvoid\t(*close)(void *);     /* close hardware */\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:63
#, no-wrap
msgid "\tconst char *\t(*get_devname)(void *);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:68
#, no-wrap
msgid ""
"\tint\t(*enum_format)(void *, uint32_t, struct video_format *);\n"
"\tint\t(*get_format)(void *, struct video_format *);\n"
"\tint\t(*set_format)(void *, struct video_format *);\n"
"\tint\t(*try_format)(void *, struct video_format *);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:71
#, no-wrap
msgid ""
"\tint\t(*start_transfer)(void *);\n"
"\tint\t(*stop_transfer)(void *);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:79
#, no-wrap
msgid ""
"\tint\t(*control_iter_init)(void *, struct video_control_iter *);\n"
"\tint\t(*control_iter_next)(void *, struct video_control_iter *);\n"
"\tint\t(*get_control_desc_group)(void *,\n"
"\t\t\t\t\t  struct video_control_desc_group *);\n"
"\tint\t(*get_control_group)(void *, struct video_control_group *);\n"
"\tint\t(*set_control_group)(void *, const struct video_control_group *);\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:88
msgid ""
"The upper layer of the video driver allocates buffers for video samples.  "
"The hardware driver submits data to the video layer with E<.Fa "
"video_submit_payload>.  E<.Fa vl_dev> is the video layer device returned by "
"E<.Fa video_attach_mi>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:95
#, no-wrap
msgid ""
"struct video_payload {\n"
"\tconst uint8_t\t*data;\n"
"\tsize_t\t\tsize;\n"
"\tint\t\tframeno;\n"
"\tbool\t\tend_of_frame;\n"
"};\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/video.9:97
#, no-wrap
msgid "Fa data"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:101
msgid ""
"Pointer to the video data for this payload.  This may only be a portion of "
"the data in one video sample or frame."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:103
msgid "Size in bytes of the video data in this payload"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/video.9:103
#, no-wrap
msgid "Fa frameno"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:107
msgid ""
"Frame number to which this payload belongs.  The hardware driver must toggle "
"the frame number between 0 and 1 so the video layer can detect sample or "
"frame boundaries."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/video.9:107
#, no-wrap
msgid "Fa end_of_frame"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:113
msgid ""
"Optional end of frame marker.  If the hardware layer sets this, the video "
"layer can immediately pass the completed sample or frame to userspace rather "
"than waiting for the next payload to toggle E<.Fa frameno>."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/video.9:114
#, no-wrap
msgid "HARDWARE-LAYER FUNCTIONS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:121
msgid ""
"The fields of E<.Va video_hw_if> are described in some more detail below.  "
"Some fields are optional and can be set to E<.Dv NULL> if not needed."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:130
msgid ""
"optional, is called when the video device is opened.  It should initialize "
"the hardware for I/O.  Every successful call to E<.Va open> is matched by a "
"call to E<.Va close>.  Return 0 on success, otherwise an error code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/video.9:132
#, no-wrap
msgid "Dv const char * get_devname(void *hdl)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:135
msgid ""
"mandatory, returns a NUL-terminated string naming the device, e.g. a vendor "
"and product model name."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/video.9:135
#, no-wrap
msgid "Dv int enum_format(void *hdl, uint32_t index, struct video_format *format);"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:144
msgid ""
"mandatory, called with an E<.Va index> from 0 to E<.Va max_index \\- 1>.  "
"Fills E<.Va format> with the format description at that index.  Returns 0 on "
"success, otherwise an error code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/video.9:144
#, no-wrap
msgid "Dv int get_format(void *hdl, struct video_format *format)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:151
msgid ""
"mandatory, fills E<.Va format> with the current video format.  There should "
"be a default format so this function works before and streaming has begun.  "
"Returns 0 on success, otherwise an error code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/video.9:151
#, no-wrap
msgid "Dv int set_format(void *hdl, struct video_format *format)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:158
msgid ""
"mandatory, sets the format of the video stream based on E<.Va format>.  "
"Fills E<.Va format> with the actual format used which may not be the same as "
"requested.  Returns 0 on success, otherwise an error code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/video.9:158
#, no-wrap
msgid "Dv int try_format(void *hdl, struct video_format *format)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:164
msgid ""
"optional, like E<.Va set_format> but does not actually change the stream "
"format, just checks what is available.  Returns 0 on success, otherwise an "
"error code."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/video.9:164
#, no-wrap
msgid "Dv int start_transfer(void *hdl)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:169
msgid ""
"mandatory, starts the capture of video frames.  Incoming video data must be "
"submitted to the video layer with repeated calls to E<.Fn "
"video_submit_payload>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/video.9:169
#, no-wrap
msgid "Dv int stop_transfer(void *hdl)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/video.9:170
#, no-wrap
msgid "Dv int control_iter_init(void *hdl, struct video_control_iter *)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:172 org_netbsd/src/share/man/man9/video.9:174
msgid "Does nothing at this time."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/video.9:172
#, no-wrap
msgid "Dv int control_iter_next(void *hdl, struct video_control_iter *)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/video.9:174
#, no-wrap
msgid "Dv int get_control_group(void *hdl, struct video_control_group *)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/video.9:175
#, no-wrap
msgid "Dv int set_control_group(void *hdl, struct video_control_group *)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:179
msgid "E<.Xr video 4>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:181
msgid "E<.An Patrick Mahoney Aq pat@polycrystal.org>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/video.9:187
msgid ""
"Incomplete.  Only supports a single video capture stream.  Does not support "
"output streams.  Format handling may change in the future.  Control handling "
"may change.  Current design requires copying all incoming video data."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/vme.9:30
#, no-wrap
msgid "June 12, 2001"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/vme.9:31
#, no-wrap
msgid "VME 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:49
msgid ""
"E<.Nm VME>, E<.Nm vme_probe>, E<.Nm vme_space_map>, E<.Nm vme_space_unmap>, "
"E<.Nm vme_intr_map>, E<.Nm vme_intr_establish>, E<.Nm "
"vme_intr_disestablish>, E<.Nm vme_intr_evcnt>, E<.Nm vme_dmamap_create>, "
"E<.Nm vme_dmamap_destroy>, E<.Nm vme_dmamem_alloc>, E<.Nm vme_dmamem_free>, "
"E<.Nm vme_space_alloc>, E<.Nm vme_space_free>, E<.Nm vme_space_get>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/vme.9:49
#, no-wrap
msgid "Versa Module Euroboard bus"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/vme.9:52
#, no-wrap
msgid "dev/vme/vmereg.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/vme.9:53
#, no-wrap
msgid "dev/vme/vmevar.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:100
msgid ""
"E<.Ft int> E<.Fn vme_probe \"void *vc\" \"vme_addr_t vmeaddr\" \"vme_size_t "
"len\" \"vme_am_t am\" \"vme_datasize_t datasize\" \"int (*callback)()\" "
"\"void *arg\"> E<.Ft int> E<.Fo vme_space_map> E<.Fa \"void *vc\" "
"\"vme_addr_t vmeaddr\" \"vme_size_t len\" \"vme_am_t am\" \"vme_datasize_t "
"datasize\" \"vme_swap_t swap\" \"bus_space_tag_t *tag\" \"bus_space_handle_t "
"*handle\" \"vme_mapresc_t *resc\"> E<.Fc> E<.Ft void> E<.Fn vme_space_unmap "
"\"void *vc\" \"vme_mapresc_t resc\"> E<.Ft int> E<.Fn vme_intr_map \"void "
"*vc\" \"int level\" \"int vector\" \"vme_intr_handle_t *handlep\"> E<.Ft "
"void *> E<.Fn vme_intr_establish \"void *vc\" \"vme_intr_handle_t handle\" "
"\"int prio\" \"int (*func)(void *)\" \"void *arg\"> E<.Ft void> E<.Fn "
"vme_intr_disestablish \"void *vc\" \"void *cookie\"> E<.Ft const struct "
"evcnt *> E<.Fn vme_intr_evcnt \"void *vc\" \"vme_intr_handle_t handle\"> "
"E<.Ft int> E<.Fo vme_dmamap_create> E<.Fa \"void *vc\" \"vme_size_t size\" "
"\"vme_am_t am\" \"vme_datasize_t datasize\"> E<.Fa \"vme_swap_t swap\" \"int "
"nsegs\" \"vme_size_t segsz\" \"vme_addr_t bound\"> E<.Fa \"int flags\" "
"\"bus_dmamap_t *map\"> E<.Fc> E<.Ft void> E<.Fn vme_dmamap_destroy \"void "
"*vc\" \"bus_dmamap_t map\"> E<.Ft int> E<.Fo vme_dmamem_alloc> E<.Fa \"void "
"*vc\" \"vme_size_t size\" \"vme_am_t am\" \"vme_datasize_t datasize\" "
"\"vme_swap_t swap\" \"bus_dma_segment_t *segs\" \"int nsegs\" \"int *rsegs\" "
"\"int flags\"> E<.Fc> E<.Ft void> E<.Fn vme_dmamem_free \"void *vc\" "
"\"bus_dma_segment_t *segs\" \"int nsegs\"> E<.Ft int> E<.Fn vme_space_alloc "
"\"struct vmebus_softc *tag\" \"vme_addr_t addr\" \"vme_size_t size\" "
"\"vme_am_t ams\"> E<.Ft void> E<.Fn vme_space_free \"void *vc\" \"vme_addr_t "
"addr\" \"vme_size_t size\" \"vme_am_t ams\"> E<.Ft int> E<.Fn vme_space_get "
"\"void *vc\" \"vme_size_t size\" \"vme_am_t ams\" \"u_long align\" "
"\"vme_addr_t *addr\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:108
msgid ""
"The E<.Nm> bus provides support for VME devices.  The VME bus is a "
"high-performance backplane bus for use in computer systems.  It is based on "
"the VMEbus specification initially released by the VMEbus International "
"Trade Association (VITA) in August of 1982.  It has since undergone IEC and "
"IEEE standardisation."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:116
msgid ""
"The VME bus supports 8, 16, and 32-bit transfers over non-multiplexed 32-bit "
"data and address paths.  The latest revisions allow 64-bit, multiplexed "
"transfers.  It supports asynchronous, fully handshaken transfers at speeds "
"up to 80 MB/sec.  It has a master-slave architecture, encouraging "
"multiprocessing and supports up to seven interrupt levels."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vme.9:121
#, no-wrap
msgid "Fa vme_chipset_tag_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:123
msgid "An opaque type identifying the bus controller."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vme.9:123
#, no-wrap
msgid "Fa vme_addr_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:125
msgid "Addresses on the bus."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vme.9:125
#, no-wrap
msgid "Fa vme_am_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:130
msgid ""
"Address modifiers.  Valid values are VME_AM_A32, VME_AM_A16, VME_AM_A24, "
"VME_AM_USERDEF (user/vendor definable), VME_AM_MBO, VME_AM_SUPER, "
"VME_AM_USER, VME_AM_DATA, VME_AM_PRG, VME_AM_BLT32 and VME_AM_BLT64."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vme.9:130
#, no-wrap
msgid "Fa vme_datasize_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:133
msgid ""
"The datasize of the address space.  Valid values are VME_D8, VME_D16, and "
"VME_D32."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vme.9:133
#, no-wrap
msgid "Fa vme_mapresc_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:135
msgid "Generic placeholder for any resources needed for a mapping."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vme.9:135
#, no-wrap
msgid "Fa vme_intr_handle_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:137
msgid "An opaque type describing an interrupt mapping."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vme.9:137
#, no-wrap
msgid "Fa vme_swap_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:140
msgid ""
"Hardware swap capabilities for controlling data endianness.  Valid values "
"have not been specified yet."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vme.9:140
#, no-wrap
msgid "Fa struct vme_range"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:143
msgid ""
"A structure used to describe an address range on the VME bus.  It contains "
"the following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:147
#, no-wrap
msgid ""
"\tvme_addr_t offset;\n"
"\tvme_size_t size;\n"
"\tvme_am_t am;\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vme.9:148
#, no-wrap
msgid "Fa struct vme_attach_args"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:159
#, no-wrap
msgid ""
"\tvme_chipset_tag_t va_vct;\n"
"\tbus_dma_tag_t va_bdt;\n"
"\tint ivector;\n"
"\tint ilevel;\n"
"\tint numcfranges;\n"
"\tstruct vme_range r[VME_MAXCFRANGES];\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vme.9:163
#, no-wrap
msgid "Fn vme_probe vc vmeaddr len am datasize callback arg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:185
msgid ""
"Probes the VME space managed by controller E<.Fa vc> at address E<.Fa "
"vmeaddr>, length E<.Fa len>, with address modifiers E<.Fa am> and datasize "
"E<.Fa datasize> for a device.  If a VME device is found, the function E<.Fa "
"callback()> (if it is not NULL) is called to perform device-specific "
"identification.  E<.Fa callback()> is called with the argument E<.Fa arg>, "
"and the bus-space tag and bus-space handle for accessing the VME space "
"mapping and should return a nonzero positive integer for a positive device "
"match."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vme.9:185
#, no-wrap
msgid "Fn vme_space_map vc vmeaddr len am datasize swap tag handle resc"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:208
msgid ""
"Maps the VME space managed by controller E<.Fa vc> at address E<.Fa "
"vmeaddr>, length E<.Fa len>, with address modifiers E<.Fa am>, datasize "
"E<.Fa datasize> and endianness E<.Fa swap> for a device.  If the mapping is "
"successful E<.Fa tag> contains the bus-space tag and E<.Fa handle> contains "
"the bus-space handle for accessing the VME space mapping.  E<.Fa resc> "
"contains the resources for the mappings.  E<.Fn vme_space_map> returns 0 on "
"success, and nonzero on error."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vme.9:208
#, no-wrap
msgid "Fn vme_space_unmap vc resc"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:213
msgid ""
"Unmaps the VME space mapping managed by controller E<.Fa vc> and resources "
"E<.Fa resc>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vme.9:213
#, no-wrap
msgid "Fn vme_intr_map vc level vector handlep"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:225
msgid ""
"Sets E<.Fa handlep> to a machine-dependent value which identifies a "
"particular interrupt source at level E<.Fa level> and vector E<.Fa vector> "
"on the controller E<.Fa vc>.  E<.Fn vme_intr_map> returns zero on success, "
"and nonzero on failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vme.9:225
#, no-wrap
msgid "Fn vme_intr_establish vc handle prio func arg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:238
msgid ""
"Establishes the interrupt handler E<.Fa handlep>.  When the device "
"interrupts, E<.Fa func()> will be called with a single argument E<.Fa arg> "
"and will run at the interrupt priority level E<.Fa prio>.  The return value "
"of E<.Fn vme_intr_establish> may be saved and passed to E<.Fn "
"vme_intr_disestablish>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vme.9:238
#, no-wrap
msgid "Fn vme_intr_disestablish vc cookie"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:244
msgid ""
"Disables the interrupt handler when the driver is no longer interested in "
"interrupts from the device.  E<.Fa cookie> is the value returned by E<.Fn "
"vme_intr_establish>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vme.9:244
#, no-wrap
msgid "Fn vme_intr_evcnt vc handle"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:247
msgid ""
"Increment the interrupt event counter for the interrupt specified by E<.Fa "
"handle>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vme.9:247
#, no-wrap
msgid "Fn vme_dmamap_create vc size am datasize swap nsegs segsz bound flags map"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:258
msgid ""
"Allocates a DMA handle and initializes it according to the parameters "
"provided.  The VME-specific parameters describe the address-space modifiers "
"E<.Fa am>, datasize E<.Fa datasize>, and endianness E<.Fa swap>.  The "
"remaining parameters are described in E<.Xr bus_dma 9>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vme.9:258
#, no-wrap
msgid "Fn vme_dmamap_destroy vc map"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:262
msgid ""
"Frees all resources associated with a given DMA handle.  The parameters are "
"described in E<.Xr bus_dma 9>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vme.9:262
#, no-wrap
msgid "Fn vme_dmamem_alloc vc size am datasize swap segs nsegs rsegs flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:278
msgid ""
"Allocates memory that is E<.Do> DMA safe E<.Dc for the VME bus managed by> "
"controller E<.Fa vc>.  The VME-specific parameters describe the "
"address-space modifiers E<.Fa am>, datasize E<.Fa datasize>, and endianness "
"E<.Fa swap>.  The remaining parameters are described in E<.Xr bus_dma 9>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vme.9:278
#, no-wrap
msgid "Fn vme_dmamem_free vc segs nsegs"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:283
msgid ""
"Frees memory previously allocated by E<.Fn vme_dmamem_alloc> for the VME "
"space managed by controller E<.Fa vc>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vme.9:283
#, no-wrap
msgid "Fn vme_space_alloc tag addr size ams"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:294
msgid ""
"Allocate VME space for the bus-space E<.Fa tag> at address E<.Fa addr> of "
"size E<.Fa size> and address-space modifiers E<.Fa ams>.  E<.Fn "
"vme_space_alloc> returns EINVAL on invalid inputs."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vme.9:294
#, no-wrap
msgid "Fn vme_space_free vc addr size ams"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:303
msgid ""
"Deallocate VME space for the bus-space E<.Fa tag> at address E<.Fa addr> of "
"size E<.Fa size> and address-space modifiers E<.Fa ams>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vme.9:303
#, no-wrap
msgid "Fn vme_space_get vc size ams align addr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:305
msgid "Returns EINVAL on invalid inputs."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:319
msgid ""
"The VME bus is an indirect-connection bus.  During autoconfiguration each "
"driver is required to probe the bus for the presence of a device.  A VME "
"driver will receive a pointer to a E<.Fa struct vme_attach_args> hinting at "
"\"locations\" (address ranges) on the VME bus where the device may be "
"located.  The driver should check the number of address ranges, allocate the "
"address space of these ranges using E<.Fn vme_space_alloc>, and probe the "
"address space for the device using E<.Fn vme_probe>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:329
msgid ""
"During driver attach the driver should also map the address ranges using "
"E<.Fn vme_space_map>.  The interrupt locators in E<.Fa struct "
"vme_attach_args> are used by E<.Fn vme_intr_map> and E<.Fn "
"vme_intr_establish>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:331
msgid "Extensive DMA facilities are provided."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:336
msgid ""
"The E<.Nm> subsystem itself is implemented within the file E<.Pa "
"sys/dev/vme/vme.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:342
msgid ""
"E<.Xr vme 4>, E<.Xr autoconf 9>, E<.Xr bus_dma 9>, E<.Xr bus_space 9>, E<.Xr "
"driver 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:345
msgid "The machine-independent VME subsystem appeared in E<.Nx 1.5>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vme.9:346
msgid "This page is incomplete."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/vmem.9:28
#, no-wrap
msgid "September 2, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/vmem.9:29
#, no-wrap
msgid "VMEM 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:34
msgid "E<.Nm vmem>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/vmem.9:34
#, no-wrap
msgid "virtual memory allocator"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/vmem.9:37
#, no-wrap
msgid "sys/vmem.h"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:68
msgid ""
"E<.Ft vmem_t *> E<.Fn vmem_create \"const char *name\" \"vmem_addr_t base\" "
"\"vmem_size_t size\" \"vmem_size_t quantum\" \"int (*allocfn)(void *, "
"vmem_size_t, vmem_size_t *, vm_flag_t, vmem_addr_t *)\" \"void "
"(*freefn)(void *, vmem_addr_t, vmem_size_t)\" \"void *arg\" \"vmem_size_t "
"qcache_max\" \"vm_flag_t flags\" \"int ipl\"> E<.Ft int> E<.Fn vmem_add "
"\"vmem_t *vm\" \"vmem_addr_t addr\" \"vmem_size_t size\" \"vm_flag_t flags\" "
"\"vmem_addr_t *addrp\"> E<.Ft int> E<.Fn vmem_xalloc \"vmem_t *vm\" "
"\"vmem_size_t size\" \"vmem_size_t align\" \"vmem_size_t phase\" "
"\"vmem_size_t nocross\" \"vmem_addr_t minaddr\" \"vmem_addr_t maxaddr\" "
"\"vm_flag_t flags\" \"vmem_addr_t *addrp\"> E<.Ft void> E<.Fn vmem_xfree "
"\"vmem_t *vm\" \"vmem_addr_t addr\" \"vmem_size_t size\"> E<.Ft int> E<.Fn "
"vmem_alloc \"vmem_t *vm\" \"vmem_size_t size\" \"vm_flag_t flags\" "
"\"vmem_addr_t *addrp\"> E<.Ft void> E<.Fn vmem_free \"vmem_t *vm\" "
"\"vmem_addr_t addr\" \"vmem_size_t size\"> E<.Ft void> E<.Fn vmem_destroy "
"\"vmem_t *vm\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:74
msgid ""
"The E<.Nm> is a general purpose resource allocator.  Despite its name, it "
"can be used for arbitrary resources other than virtual memory."
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:78
msgid "E<.Fn vmem_create> creates a new vmem arena."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:82
msgid "The string to describe the vmem."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vmem.9:82
#, no-wrap
msgid "Fa base"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:87
msgid ""
"The start address of the initial span.  Pass E<.Dv 0> if no initial span is "
"required."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:92
msgid "The size of the initial span.  Pass E<.Dv 0> if no initial span is required."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vmem.9:92
#, no-wrap
msgid "Fa quantum"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:94
msgid "The smallest unit of allocation."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vmem.9:94
#, no-wrap
msgid "Fa allocfn"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:130
msgid ""
"The callback function used to import spans from the backend arena.  Set both "
"E<.Fa allocfn> and E<.Fa freefn> to E<.Dv NULL> to disable automatic "
"imports.  E<.Nm> calls E<.Fo \"(*allocfn)\"> E<.Fa arg> E<.Fa size> E<.Fa "
"\"\\*[Am]actualsize\"> E<.Fa flags> E<.Fa \"\\*[Am]addrp\"> E<.Fc> to import "
"a span of size at least E<.Fa size>.  E<.Fa allocfn> should accept the same "
"E<.Fa flags> as E<.Fn vmem_alloc>.  E<.Fa allocfn> must return E<.Dv ENOMEM> "
"to indicate failure, or 0 on success.  If E<.Fa allocfn> succeeds, it must "
"write the actual size of the allocation to E<.Fa actualsize> and the "
"starting address of the imported span to E<.Fa addrp>.  The actual size will "
"always be greater than or equal to the requested size."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vmem.9:130
#, no-wrap
msgid "Fa freefn"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:150
msgid ""
"The callback function used to free spans to the backend arena.  E<.Fa "
"freefn> may be E<.Dv NULL> even if E<.Fa allocfn> is not E<.Dv NULL>.  "
"E<.Nm> calls E<.Fn \"(*freefn)\" arg addr size> to return to E<.Fa arg> a "
"span of size E<.Fa size>, starting at E<.Fa addr>, that was previously "
"allocated by E<.Fa allocfn>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:162
msgid ""
"The backend arena.  E<.Fa arg> may be E<.Dv NULL>.  E<.Nm> passes E<.Fa arg> "
"as the first argument of E<.Fa allocfn> and E<.Fa freefn>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vmem.9:162
#, no-wrap
msgid "Fa qcache_max"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:165
msgid ""
"The largest size of allocations which can be served by quantum cache.  It is "
"merely a hint and can be ignored."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:167
msgid "Either of:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vmem.9:168 org_netbsd/src/share/man/man9/vmem.9:195 org_netbsd/src/share/man/man9/vmem.9:258 org_netbsd/src/share/man/man9/vmem.9:321
#, no-wrap
msgid "Dv VM_SLEEP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:170 org_netbsd/src/share/man/man9/vmem.9:197 org_netbsd/src/share/man/man9/vmem.9:260 org_netbsd/src/share/man/man9/vmem.9:323
msgid "Can sleep until enough resources are available."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vmem.9:170 org_netbsd/src/share/man/man9/vmem.9:197 org_netbsd/src/share/man/man9/vmem.9:260 org_netbsd/src/share/man/man9/vmem.9:323
#, no-wrap
msgid "Dv VM_NOSLEEP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:175
msgid ""
"Don't sleep.  Immediately return E<.Dv NULL> if there are not enough "
"resources available."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:178
msgid "Interrupt level to be blocked for allocating from vmem."
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:194
msgid ""
"E<.Fn vmem_add> adds a span of size E<.Fa size> starting at E<.Fa addr> to "
"the arena.  Returns 0 on success, E<.Dv ENOMEM> on failure.  E<.Fa flags> "
"should be one of:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:202 org_netbsd/src/share/man/man9/vmem.9:265 org_netbsd/src/share/man/man9/vmem.9:328
msgid ""
"Don't sleep.  Immediately return E<.Dv ENOMEM> if there are not enough "
"resources available."
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:207
msgid "E<.Fn vmem_xalloc> allocates a resource from the arena."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vmem.9:209 org_netbsd/src/share/man/man9/vmem.9:282 org_netbsd/src/share/man/man9/vmem.9:304 org_netbsd/src/share/man/man9/vmem.9:345 org_netbsd/src/share/man/man9/vmem.9:367
#, no-wrap
msgid "Fa vm"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:211 org_netbsd/src/share/man/man9/vmem.9:306
msgid "The arena which we allocate from."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:213 org_netbsd/src/share/man/man9/vmem.9:308
msgid "Specify the size of the allocation."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:221
msgid ""
"If zero, don't care about the alignment of the allocation.  Otherwise, "
"request a resource segment starting at offset E<.Fa phase> from an E<.Fa "
"align> aligned boundary."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vmem.9:221
#, no-wrap
msgid "Fa phase"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:233
msgid ""
"See the above description of E<.Fa align>.  If E<.Fa align> is zero, E<.Fa "
"phase> should be zero.  Otherwise, E<.Fa phase> should be smaller than E<.Fa "
"align>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vmem.9:233
#, no-wrap
msgid "Fa nocross"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:237
msgid "Request a resource which doesn't cross E<.Fa nocross> aligned boundary."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vmem.9:237
#, no-wrap
msgid "Fa minaddr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:241
msgid ""
"Specify the minimum address which can be allocated, or E<.Dv VMEM_ADDR_MIN> "
"if the caller does not care."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vmem.9:241
#, no-wrap
msgid "Fa maxaddr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:245
msgid ""
"Specify the maximum address which can be allocated, or E<.Dv VMEM_ADDR_MAX> "
"if the caller does not care."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:247 org_netbsd/src/share/man/man9/vmem.9:310
msgid "A bitwise OR of an allocation strategy and a sleep flag."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:249 org_netbsd/src/share/man/man9/vmem.9:312
msgid "The allocation strategy is one of:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vmem.9:250 org_netbsd/src/share/man/man9/vmem.9:313
#, no-wrap
msgid "Dv VM_BESTFIT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:252 org_netbsd/src/share/man/man9/vmem.9:315
msgid "Prefer space efficiency."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vmem.9:252 org_netbsd/src/share/man/man9/vmem.9:315
#, no-wrap
msgid "Dv VM_INSTANTFIT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:254 org_netbsd/src/share/man/man9/vmem.9:317
msgid "Prefer performance."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:257 org_netbsd/src/share/man/man9/vmem.9:320
msgid "The sleep flag should be one of:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vmem.9:266 org_netbsd/src/share/man/man9/vmem.9:329
#, no-wrap
msgid "Fa addrp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:273
msgid ""
"On success, if E<.Fa addrp> is not E<.Dv NULL>, E<.Fn vmem_xalloc> "
"overwrites it with the start address of the allocated span."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:280
msgid ""
"E<.Fn vmem_xfree> frees resource allocated by E<.Fn vmem_xalloc> to the "
"arena."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:284 org_netbsd/src/share/man/man9/vmem.9:347
msgid "The arena which we free to."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vmem.9:284 org_netbsd/src/share/man/man9/vmem.9:347
#, no-wrap
msgid "Fa addr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:291
msgid ""
"The resource being freed.  It must be the one returned by E<.Fn "
"vmem_xalloc>.  Notably, it must not be the one from E<.Fn vmem_alloc>.  "
"Otherwise, the behaviour is undefined."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:297
msgid ""
"The size of the resource being freed.  It must be the same as the E<.Fa "
"size> argument used for E<.Fn vmem_xalloc>."
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:302
msgid "E<.Fn vmem_alloc> allocates a resource from the arena."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:336
msgid ""
"On success, if E<.Fa addrp> is not E<.Dv NULL>, E<.Fn vmem_alloc> overwrites "
"it with the start address of the allocated span."
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:343
msgid "E<.Fn vmem_free> frees resource allocated by E<.Fn vmem_alloc> to the arena."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:354
msgid ""
"The resource being freed.  It must be the one returned by E<.Fn "
"vmem_alloc>.  Notably, it must not be the one from E<.Fn vmem_xalloc>.  "
"Otherwise, the behaviour is undefined."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:360
msgid ""
"The size of the resource being freed.  It must be the same as the E<.Fa "
"size> argument used for E<.Fn vmem_alloc>."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:365
msgid "E<.Fn vmem_destroy> destroys a vmem arena."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:370
msgid ""
"The vmem arena being destroyed.  The caller should ensure that no one will "
"use it anymore."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:377
msgid ""
"E<.Fn vmem_create> return a pointer to the newly allocated vmem_t.  "
"Otherwise, it returns E<.Dv NULL>."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:387
msgid ""
"On success, E<.Fn vmem_xalloc> and E<.Fn vmem_alloc> return 0.  Otherwise, "
"E<.Dv ENOMEM> is returned."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:393
msgid ""
"The E<.Nm> subsystem is implemented within the file E<.Pa "
"sys/kern/subr_vmem.c>."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:406
msgid ""
"E<.Xr intro 9>, E<.Xr kmem 9>, E<.Xr memoryallocators 9>, E<.Xr uvm 9> "
"E<.Rs> E<.%A Jeff Bonwick> E<.%A Jonathan Adams> E<.%T \"Magazines and Vmem: "
"Extending the Slab Allocator to Many CPUs and Arbitrary Resources\"> E<.%J "
"\"2001 USENIX Annual Technical Conference\"> E<.%D 2001> E<.Re>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:411
msgid "This implementation of E<.Nm> was written by E<.An YAMAMOTO Takashi>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vmem.9:420
msgid ""
"E<.Nm> relies on E<.Xr malloc 9>, E<.Xr pool 9>, and E<.Xr RUN_ONCE 9>, so "
"it cannot be used as early during system bootstrap as E<.Xr extent 9>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/vnfileops.9:30
#, no-wrap
msgid "April 9, 2008"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/vnfileops.9:31
#, no-wrap
msgid "VNFILEOPS 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnfileops.9:42
msgid ""
"E<.Nm vnfileops>, E<.Nm vn_closefile>, E<.Nm vn_fcntl>, E<.Nm vn_ioctl>, "
"E<.Nm vn_read>, E<.Nm vn_poll>, E<.Nm vn_statfile>, E<.Nm vn_write>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/vnfileops.9:42
#, no-wrap
msgid "vnode file descriptor operations"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnfileops.9:61
msgid ""
"E<.Ft int> E<.Fn vn_closefile \"file_t *fp\"> E<.Ft int> E<.Fn vn_fcntl "
"\"file_t *fp\" \"u_int com\" \"void *data\"> E<.Ft int> E<.Fn vn_ioctl "
"\"file_t *fp\" \"u_long com\" \"void *data\"> E<.Ft int> E<.Fn vn_read "
"\"file_t *fp\" \"off_t *offset\" \"struct uio *uio\" \"kauth_cred_t cred\" "
"\"int flags\"> E<.Ft int> E<.Fn vn_poll \"file_t *fp\" \"int events\"> E<.Ft "
"int> E<.Fn vn_statfile \"file_t *fp\" \"struct stat *sb\"> E<.Ft int> E<.Fn "
"vn_write \"file_t *fp\" \"off_t *offset\" \"struct uio *uio\" \"kauth_cred_t "
"cred\" \"int flags\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnfileops.9:68
msgid ""
"The functions described in this page are the vnode-specific file descriptor "
"operations.  They should only be accessed through the opaque function "
"pointers in the file entries (see E<.Xr file 9>).  They are described here "
"only for completeness."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnfileops.9:70
#, no-wrap
msgid "Fn vn_closefile fp l"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnfileops.9:81
msgid ""
"Common code for a file table vnode close operation.  The file is described "
"by E<.Fa fp> and E<.Fa l> is the calling lwp.  E<.Fn vn_closefile> simply "
"calls E<.Xr vn_close 9> with the appropriate arguments."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnfileops.9:81
#, no-wrap
msgid "Fn vn_fcntl fp com data l"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnfileops.9:100
msgid ""
"Common code for a file table vnode E<.Xr fcntl 2> operation.  The file is "
"specified by E<.Fa fp>.  The argument E<.Fa l> is the calling lwp.  E<.Fn "
"vn_fcntl> simply locks the vnode and invokes the vnode operation E<.Xr "
"VOP_FCNTL 9> with the command E<.Fa com> and buffer E<.Fa data>.  The vnode "
"is unlocked on return.  If the operation is successful zero is returned, "
"otherwise an appropriate error is returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnfileops.9:100
#, no-wrap
msgid "Fn vn_ioctl fp com data l"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnfileops.9:117
msgid ""
"Common code for a file table vnode ioctl operation.  The file is specified "
"by E<.Fa fp>.  The argument E<.Fa l> is the calling lwp E<.Fn vn_ioctl> "
"simply locks the vnode and invokes the vnode operation E<.Xr VOP_IOCTL 9> "
"with the command E<.Fa com> and buffer E<.Fa data>.  The vnode is unlocked "
"on return.  If the operation is successful zero is returned, otherwise an "
"appropriate error is returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnfileops.9:117
#, no-wrap
msgid "Fn vn_read fp offset uio cred flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnfileops.9:135
msgid ""
"Common code for a file table vnode read.  The argument E<.Fa fp> is the file "
"structure, The argument E<.Fa offset> is the offset into the file.  The "
"argument E<.Fa uio> is the uio structure describing the memory to read "
"into.  The caller's credentials are specified in E<.Fa cred>.  The E<.Fa "
"flags> argument can define FOF_UPDATE_OFFSET to update the read position in "
"the file.  If the operation is successful zero is returned, otherwise an "
"appropriate error is returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnfileops.9:135
#, no-wrap
msgid "Fn vn_poll fp events l"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnfileops.9:145
msgid ""
"Common code for a file table vnode poll operation.  E<.Fn vn_poll> simply "
"calls E<.Xr VOP_POLL 9> with the events E<.Fa events> and the calling lwp "
"E<.Fa l>.  The function returns a bitmask of available events."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnfileops.9:145
#, no-wrap
msgid "Fn vn_statfile fp sb l"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnfileops.9:161
msgid ""
"Common code for a stat operation.  The file descriptor is specified by the "
"argument E<.Fa fp> and E<.Fa sb> is the buffer to return the stat "
"information.  The argument E<.Fa l> is the calling lwp.  E<.Fn vn_statfile> "
"basically calls the vnode operation E<.Xr VOP_GETATTR 9> and transfer the "
"contents of a vattr structure into a struct stat.  If the operation is "
"successful zero is returned, otherwise an appropriate error code is "
"returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnfileops.9:161
#, no-wrap
msgid "Fn vn_write fp offset uio cred flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnfileops.9:179
msgid ""
"Common code for a file table vnode write.  The argument E<.Fa fp> is the "
"file structure, The argument E<.Fa offset> is the offset into the file.  The "
"argument E<.Fa uio> is the uio structure describing the memory to read "
"from.  The caller's credentials are specified in E<.Fa cred>.  The E<.Fa "
"flags> argument can define FOF_UPDATE_OFFSET to update the read position in "
"the file.  If the operation is successful zero is returned, otherwise an "
"appropriate error is returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnfileops.9:183
msgid ""
"The high-level convenience functions are implemented within the file E<.Pa "
"sys/kern/vfs_vnops.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnfileops.9:188
msgid ""
"E<.Xr file 9>, E<.Xr intro 9>, E<.Xr vnode 9>, E<.Xr vnodeops 9>, E<.Xr "
"vnsubr 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/vnode.9:30
#, no-wrap
msgid "February 8, 2012"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/vnode.9:31
#, no-wrap
msgid "VNODE 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:58
msgid ""
"E<.Nm vnode>, E<.Nm vref>, E<.Nm vrele>, E<.Nm vrele_async>, E<.Nm vget>, "
"E<.Nm vput>, E<.Nm vhold>, E<.Nm holdrele>, E<.Nm getnewvnode>, E<.Nm "
"ungetnewvnode>, E<.Nm vrecycle>, E<.Nm vgone>, E<.Nm vgonel>, E<.Nm vflush>, "
"E<.Nm vaccess>, E<.Nm bdevvp>, E<.Nm cdevvp>, E<.Nm vfinddev>, E<.Nm "
"vdevgone>, E<.Nm vwakeup>, E<.Nm vflushbuf>, E<.Nm vinvalbuf>, E<.Nm "
"vtruncbuf>, E<.Nm vprint>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/vnode.9:58
#, no-wrap
msgid "kernel representation of a file or directory"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:109
msgid ""
"E<.Ft void> E<.Fn vref \"struct vnode *vp\"> E<.Ft void> E<.Fn vrele "
"\"struct vnode *vp\"> E<.Ft void> E<.Fn vrele_async \"struct vnode *vp\"> "
"E<.Ft int> E<.Fn vget \"struct vnode *vp\" \"int lockflag\"> E<.Ft void> "
"E<.Fn vput \"struct vnode *vp\"> E<.Ft void> E<.Fn vhold \"struct vnode "
"*vp\"> E<.Ft void> E<.Fn holdrele \"struct vnode *vp\"> E<.Ft int> E<.Fn "
"getnewvnode \"enum vtagtype tag\" \"struct mount *mp\" \"int (**vops)(void "
"*)\" \"kmutex_t *slock\" \"struct vnode **vpp\"> E<.Ft void> E<.Fn "
"ungetnewvnode \"struct vnode *vp\"> E<.Ft int> E<.Fn vrecycle \"struct vnode "
"*vp\" \"struct simplelock *inter_lkp\" \"struct lwp *l\"> E<.Ft void> E<.Fn "
"vgone \"struct vnode *vp\"> E<.Ft void> E<.Fn vgonel \"struct vnode *vp\" "
"\"struct lwp *l\"> E<.Ft int> E<.Fn vflush \"struct mount *mp\" \"struct "
"vnode *skipvp\" \"int flags\"> E<.Ft int> E<.Fn vaccess \"enum vtype type\" "
"\"mode_t file_mode\" \"uid_t uid\" \"gid_t gid\" \"mode_t acc_mode\" "
"\"kauth_cred_t cred\"> E<.Ft int> E<.Fn bdevvp \"dev_t dev\" \"struct vnode "
"**vpp\"> E<.Ft int> E<.Fn cdevvp \"dev_t dev\" \"struct vnode **vpp\"> E<.Ft "
"int> E<.Fn vfinddev \"dev_t dev\" \"enum vtype\" \"struct vnode **vpp\"> "
"E<.Ft void> E<.Fn vdevgone \"int maj\" \"int minl\" \"int minh\" \"enum "
"vtype type\"> E<.Ft void> E<.Fn vwakeup \"struct buf *bp\"> E<.Ft int> E<.Fn "
"vflushbuf \"struct vnode *vp\" \"int sync\"> E<.Ft int> E<.Fn vinvalbuf "
"\"struct vnode *vp\" \"int flags\" \"kauth_cred_t cred\" \"struct lwp *l\" "
"\"int slpflag\" \"int slptimeo\"> E<.Ft int> E<.Fn vtruncbuf \"struct vnode "
"*vp\" \"daddr_t lbn\" \"int slpflag\" \"int slptimeo\"> E<.Ft void> E<.Fn "
"vprint \"const char *label\" \"struct vnode *vp\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:118
msgid ""
"The vnode is the focus of all file activity in E<.Nx>.  There is a unique "
"vnode allocated for each active file, directory, mounted-on file, fifo, "
"domain socket, symbolic link and device.  The kernel has no concept of a "
"file's underlying structure and so it relies on the information stored in "
"the vnode to describe the file.  Thus, the vnode associated with a file "
"holds all the administration information pertaining to it."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:130
msgid ""
"When a process requests an operation on a file, the E<.Xr vfs 9> interface "
"passes control to a file system type dependent function to carry out the "
"operation.  If the file system type dependent function finds that a vnode "
"representing the file is not in main memory, it dynamically allocates a new "
"vnode from the system main memory pool.  Once allocated, the vnode is "
"attached to the data structure pointer associated with the cause of the "
"vnode allocation and it remains resident in the main memory until the system "
"decides that it is no longer needed and can be recycled."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:132
msgid "The vnode has the following structure:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:168
#, no-wrap
msgid ""
"struct vnode {\n"
"\tstruct uvm_object v_uobj;\t\t/* the VM object */\n"
"\tkcondvar_t\tv_cv;\t\t\t/* synchronization */\n"
"\tvoff_t\t\tv_size;\t\t\t/* size of file */\n"
"\tvoff_t\t\tv_writesize;\t\t/* new size after write */\n"
"\tint\t\tv_iflag;\t\t/* VI_* flags */\n"
"\tint\t\tv_vflag;\t\t/* VV_* flags */\n"
"\tint\t\tv_uflag;\t\t/* VU_* flags */\n"
"\tint\t\tv_numoutput;\t\t/* # of pending writes */\n"
"\tint\t\tv_writecount;\t\t/* ref count of writers */\n"
"\tint\t\tv_holdcnt;\t\t/* page & buffer refs */\n"
"\tint\t\tv_synclist_slot;\t/* synclist slot index */\n"
"\tstruct mount\t*v_mount;\t\t/* ptr to vfs we are in */\n"
"\tint\t\t(**v_op)(void *);\t/* vnode operations vector */\n"
"\tTAILQ_ENTRY(vnode) v_freelist;\t\t/* vnode freelist */\n"
"\tstruct vnodelst\t*v_freelisthd;\t\t/* which freelist? */\n"
"\tTAILQ_ENTRY(vnode) v_mntvnodes;\t\t/* vnodes for mount point */\n"
"\tstruct buflists\tv_cleanblkhd;\t\t/* clean blocklist head */\n"
"\tstruct buflists\tv_dirtyblkhd;\t\t/* dirty blocklist head */\n"
"\tTAILQ_ENTRY(vnode) v_synclist;\t\t/* vnodes with dirty bufs */\n"
"\tLIST_HEAD(, namecache) v_dnclist;\t/* namecaches (children) */\n"
"\tLIST_HEAD(, namecache) v_nclist;\t/* namecaches (parent) */\n"
"\tunion {\n"
"\t\tstruct mount\t*vu_mountedhere;/* ptr to vfs (VDIR) */\n"
"\t\tstruct socket\t*vu_socket;\t/* unix ipc (VSOCK) */\n"
"\t\tstruct specnode\t*vu_specnode;\t/* device (VCHR, VBLK) */\n"
"\t\tstruct fifoinfo\t*vu_fifoinfo;\t/* fifo (VFIFO) */\n"
"\t\tstruct uvm_ractx *vu_ractx;\t/* read-ahead ctx (VREG) */\n"
"\t} v_un;\n"
"\tenum vtype\tv_type;\t\t\t/* vnode type */\n"
"\tenum vtagtype\tv_tag;\t\t\t/* type of underlying data */\n"
"\tstruct vnlock\tv_lock;\t\t\t/* lock for this vnode */\n"
"\tvoid \t\t*v_data;\t\t/* private data for fs */\n"
"\tstruct klist\tv_klist;\t\t/* notes attached to vnode */\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:173
msgid ""
"Most members of the vnode structure should be treated as opaque and only "
"manipulated using the proper functions.  There are some rather common "
"exceptions detailed throughout this page."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:184
msgid ""
"Files and file systems are inextricably linked with the virtual memory "
"system and E<.Em v_uobj> contains the data maintained by the virtual memory "
"system.  For compatibility with code written before the integration of E<.Xr "
"uvm 9> into E<.Nx>, C-preprocessor directives are used to alias the members "
"of E<.Em v_uobj>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:188
msgid "Vnode flags are recorded by E<.Em v_flag>.  Valid flags are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:190
#, no-wrap
msgid "VROOT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:192
msgid "This vnode is the root of its file system."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:192
#, no-wrap
msgid "VTEXT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:194
msgid "This vnode is a pure text prototype."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:194
#, no-wrap
msgid "VSYSTEM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:197
msgid ""
"This vnode is being used by the kernel; only used to skip quota files in "
"E<.Fn vflush>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:197
#, no-wrap
msgid "VISTTY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:199
msgid "This vnode represents a tty; used when reading dead vnodes."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:199
#, no-wrap
msgid "VEXECMAP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:201
msgid "This vnode has executable mappings."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:201
#, no-wrap
msgid "VWRITEMAP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:203
msgid "This vnode might have PROT_WRITE user mappings."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:203
#, no-wrap
msgid "VWRITEMAPDIRTY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:205
msgid "This vnode might have dirty pages due to VWRITEMAP"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:205
#, no-wrap
msgid "VLOCKSWORK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:207
msgid "This vnode's file system supports locking."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:207
#, no-wrap
msgid "VXLOCK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:209
msgid "This vnode is currently locked to change underlying type."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:209
#, no-wrap
msgid "VXWANT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:211
msgid "A process is waiting for this vnode."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:211
#, no-wrap
msgid "VBWAIT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:213
msgid "Waiting for output associated with this vnode to complete."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:213
#, no-wrap
msgid "VALIASED"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:215
msgid "This vnode has an alias."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:215
#, no-wrap
msgid "VDIROP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:218
msgid ""
"This vnode is involved in a directory operation.  This flag is used "
"exclusively by LFS."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:218
#, no-wrap
msgid "VLAYER"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:220
msgid "This vnode is on a layered file system."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:220
#, no-wrap
msgid "VONWORKLST"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:222
msgid "This vnode is on syncer work-list."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:222
#, no-wrap
msgid "VFREEING"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:224
msgid "This vnode is being freed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:224
#, no-wrap
msgid "VMAPPED"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:226
msgid "This vnode might have user mappings."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:241
msgid ""
"The VXLOCK flag is used to prevent multiple processes from entering the "
"vnode reclamation code.  It is also used as a flag to indicate that "
"reclamation is in progress.  The VXWANT flag is set by threads that wish to "
"be awakened when reclamation is finished.  Before E<.Em v_flag> can be "
"modified, the E<.Em v_interlock> simplelock must be acquired.  See E<.Xr "
"lock 9> for details on the kernel locking API."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:287
msgid ""
"Each vnode has three reference counts: E<.Em v_usecount>, E<.Em "
"v_writecount> and E<.Em v_holdcnt>.  The first is the number of active "
"references within the kernel to the vnode.  This count is maintained by "
"E<.Fn vref>, E<.Fn vrele>, E<.Fn vrele_async>, and E<.Fn vput>.  The second "
"is the number of active references within the kernel to the vnode performing "
"write access to the file.  It is maintained by the E<.Xr open 2> and E<.Xr "
"close 2> system calls.  The third is the number of references within the "
"kernel requiring the vnode to remain active and not be recycled.  This count "
"is maintained by E<.Fn vhold> and E<.Fn holdrele>.  When both the E<.Em "
"v_usecount> and E<.Em v_holdcnt> reach zero, the vnode is recycled to the "
"freelist and may be reused for another file.  The transition to and from the "
"freelist is handled by E<.Fn getnewvnode>, E<.Fn ungetnewvnode> and E<.Fn "
"vrecycle>.  Access to E<.Em v_usecount>, E<.Em v_writecount> and E<.Em "
"v_holdcnt> is also protected by the E<.Em v_interlock> simplelock."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:298
msgid ""
"The number of pending synchronous and asynchronous writes on the vnode are "
"recorded in E<.Em v_numoutput>.  It is used by E<.Xr fsync 2> to wait for "
"all writes to complete before returning to the user.  Its value must only be "
"modified at splbio (see E<.Xr spl 9>).  It does not track the number of "
"dirty buffers attached to the vnode."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:307
msgid ""
"E<.Em v_dnclist> and E<.Em v_nclist> are used by E<.Xr namecache 9> to "
"maintain the list of associated entries so that E<.Xr cache_purge 9> can "
"purge them."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:313
msgid ""
"The link to the file system which owns the vnode is recorded by E<.Em "
"v_mount>.  See E<.Xr vfsops 9> for further information of file system mount "
"status."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:326
msgid ""
"The E<.Em v_op> pointer points to its vnode operations vector.  This vector "
"describes what operations can be done to the file associated with the "
"vnode.  The system maintains one vnode operations vector for each file "
"system type configured into the kernel.  The vnode operations vector "
"contains a pointer to a function for each operation supported by the file "
"system.  See E<.Xr vnodeops 9> for a description of vnode operations."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:339
msgid ""
"When not in use, vnodes are kept on the freelist through E<.Em v_freelist>.  "
"The vnodes still reference valid files but may be reused to refer to a new "
"file at any time.  When a valid vnode which is on the freelist is used "
"again, the user must call E<.Fn vget> to increment the reference count and "
"retrieve it from the freelist.  When a user wants a new vnode for another "
"file, E<.Fn getnewvnode> is invoked to remove a vnode from the freelist and "
"initialize it for the new file."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:345
msgid ""
"The type of object the vnode represents is recorded by E<.Em v_type>.  It is "
"used by generic code to perform checks to ensure operations are performed on "
"valid file system objects.  Valid types are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:347
#, no-wrap
msgid "VNON"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:349
msgid "The vnode has no type."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:349
#, no-wrap
msgid "VREG"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:351
msgid "The vnode represents a regular file."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:351
#, no-wrap
msgid "VDIR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:353
msgid "The vnode represents a directory."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:353
#, no-wrap
msgid "VBLK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:355
msgid "The vnode represents a block special device."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:355
#, no-wrap
msgid "VCHR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:357
msgid "The vnode represents a character special device."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:357
#, no-wrap
msgid "VLNK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:359
msgid "The vnode represents a symbolic link."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:359
#, no-wrap
msgid "VSOCK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:361
msgid "The vnode represents a socket."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:361
#, no-wrap
msgid "VFIFO"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:363
msgid "The vnode represents a pipe."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:363
#, no-wrap
msgid "VBAD"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:365
msgid "The vnode represents a bad file (not currently used)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:378
msgid ""
"Vnode tag types are used by external programs only (e.g., E<.Xr pstat 8>), "
"and should never be inspected by the kernel.  Its use is deprecated since "
"new E<.Em v_tag> values cannot be defined for loadable file systems.  The "
"E<.Em v_tag> member is read-only.  Valid tag types are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:380
#, no-wrap
msgid "VT_NON"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:382
msgid "non file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:382
#, no-wrap
msgid "VT_UFS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:384
msgid "universal file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:384
#, no-wrap
msgid "VT_NFS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:386
msgid "network file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:386
#, no-wrap
msgid "VT_MFS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:388
msgid "memory file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:388
#, no-wrap
msgid "VT_MSDOSFS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:390
msgid "FAT file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:390
#, no-wrap
msgid "VT_LFS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:392
msgid "log-structured file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:392
#, no-wrap
msgid "VT_LOFS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:394
msgid "loopback file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:394
#, no-wrap
msgid "VT_FDESC"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:396
msgid "file descriptor file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:396
#, no-wrap
msgid "VT_NULL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:398
msgid "null file system layer"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:398
#, no-wrap
msgid "VT_UMAP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:400
msgid "uid/gid remapping file system layer"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:400
#, no-wrap
msgid "VT_KERNFS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:402
msgid "kernel interface file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:402
#, no-wrap
msgid "VT_PROCFS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:404
msgid "process interface file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:404
#, no-wrap
msgid "VT_AFS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:406
msgid "AFS file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:406
#, no-wrap
msgid "VT_ISOFS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:408
msgid "ISO 9660 file system(s)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:408
#, no-wrap
msgid "VT_UNION"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:410
msgid "union file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:410
#, no-wrap
msgid "VT_ADOSFS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:412
msgid "Amiga file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:412
#, no-wrap
msgid "VT_EXT2FS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:414
msgid "Linux's ext2 file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:414
#, no-wrap
msgid "VT_CODA"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:416
msgid "Coda file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:416
#, no-wrap
msgid "VT_FILECORE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:418
msgid "filecore file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:418
#, no-wrap
msgid "VT_NTFS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:420
msgid "Microsoft NT's file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:420
#, no-wrap
msgid "VT_VFS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:422
msgid "virtual file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:422
#, no-wrap
msgid "VT_OVERLAY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:424
msgid "overlay file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:424
#, no-wrap
msgid "VT_SMBFS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:426
msgid "SMB file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:426
#, no-wrap
msgid "VT_PTYFS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:428
msgid "pseudo-terminal device file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:428
#, no-wrap
msgid "VT_TMPFS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:430
msgid "efficient memory file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:430
#, no-wrap
msgid "VT_UDF"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:432
msgid "universal disk format file system"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:432
#, no-wrap
msgid "VT_SYSVBFS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:434
msgid "systemV boot file system"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:448
msgid ""
"All vnode locking operations use E<.Em v_lock>.  This lock is acquired by "
"calling E<.Xr vn_lock 9> and released by calling E<.Xr VOP_UNLOCK 9>.  The "
"reason for this asymmetry is that E<.Xr vn_lock 9> is a wrapper for E<.Xr "
"VOP_LOCK 9> with extra checks, while the unlocking step usually does not "
"need additional checks and thus has no wrapper."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:472
msgid ""
"The vnode locking operation is complicated because it is used for many "
"purposes.  Sometimes it is used to bundle a series of vnode operations (see "
"E<.Xr vnodeops 9>)  into an atomic group.  Many file systems rely on it to "
"prevent race conditions in updating file system type specific data "
"structures rather than using their own private locks.  The vnode lock can "
"operate as a multiple-reader (shared-access lock)  or single-writer lock "
"(exclusive access lock), however many current file system implementations "
"were written assuming only single-writer locking.  Multiple-reader locking "
"functions equivalently only in the presence of big-lock SMP locking or a "
"uni-processor machine.  The lock may be held while sleeping.  While the "
"E<.Em v_lock> is acquired, the holder is guaranteed that the vnode will not "
"be reclaimed or invalidated.  Most file system functions require that you "
"hold the vnode lock on entry.  See E<.Xr lock 9> for details on the kernel "
"locking API."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:476
msgid ""
"Each file system underlying a vnode allocates its own private area and hangs "
"it from E<.Em v_data>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:492
msgid ""
"Most functions discussed in this page that operate on vnodes cannot be "
"called from interrupt context.  The members E<.Em v_numoutput>, E<.Em "
"v_holdcnt>, E<.Em v_dirtyblkhd>, E<.Em v_cleanblkhd>, E<.Em v_freelist>, and "
"E<.Em v_synclist> are modified in interrupt context and must be protected by "
"E<.Xr splbio 9> unless it is certain that there is no chance an interrupt "
"handler will modify them.  The vnode lock must not be acquired within "
"interrupt context."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:494
#, no-wrap
msgid "Fn vref vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:502
msgid ""
"Increment E<.Em v_usecount> of the vnode E<.Em vp>.  Any kernel thread "
"system which uses a vnode (e.g., during the operation of some algorithm or "
"to store in a data structure) should call E<.Fn vref>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:502
#, no-wrap
msgid "Fn vrele vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:520
msgid ""
"Decrement E<.Em v_usecount> of unlocked vnode E<.Em vp>.  Any code in the "
"system which is using a vnode should call E<.Fn vrele> when it is finished "
"with the vnode.  If E<.Em v_usecount> of the vnode reaches zero and E<.Em "
"v_holdcnt> is greater than zero, the vnode is placed on the holdlist.  If "
"both E<.Em v_usecount> and E<.Em v_holdcnt> are zero, the vnode is placed on "
"the freelist."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:520
#, no-wrap
msgid "Fn vrele_async vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:523
msgid ""
"Will asychronously release the vnode in different context than the caller, "
"sometime after the call."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:523
#, no-wrap
msgid "Fn vget vp lockflags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:542
msgid ""
"Reclaim vnode E<.Fa vp> from the freelist, increment its reference count and "
"lock it.  The argument E<.Fa lockflags> specifies the E<.Xr rwlock 9> flags "
"used to lock the vnode.  If the VXLOCK is set in E<.Fa vp Ns 's> E<.Em "
"v_flag>, vnode E<.Fa vp> is being recycled in E<.Fn vgone> and the calling "
"thread sleeps until the transition is complete.  When it is awakened, an "
"error is returned to indicate that the vnode is no longer usable (possibly "
"having been recycled to a new file system type)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:542
#, no-wrap
msgid "Fn vput vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:553
msgid ""
"Unlock vnode E<.Fa vp> and decrement its E<.Em v_usecount>.  Depending on "
"the reference counts, move the vnode to the holdlist or the freelist.  This "
"operation is functionally equivalent to calling E<.Xr VOP_UNLOCK 9> followed "
"by E<.Fn vrele>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:553
#, no-wrap
msgid "Fn vhold vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:562
msgid ""
"Mark the vnode E<.Fa vp> as active by incrementing E<.Em "
"vp-\\*[Gt]v_holdcnt> and moving the vnode from the freelist to the "
"holdlist.  Once on the holdlist, the vnode will not be recycled until it is "
"released with E<.Fn holdrele>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:562
#, no-wrap
msgid "Fn holdrele vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:568
msgid ""
"Mark the vnode E<.Fa vp> as inactive by decrementing E<.Em "
"vp-\\*[Gt]v_holdcnt> and moving the vnode from the holdlist to the freelist."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:568
#, no-wrap
msgid "Fn getnewvnode tag mp vops slock vpp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:581
msgid ""
"Retrieve the next vnode from the freelist.  E<.Fn getnewvnode> must choose "
"whether to allocate a new vnode or recycle an existing one.  The criterion "
"for allocating a new one is that the total number of vnodes is less than the "
"number desired or there are no vnodes on either free list.  Generally only "
"vnodes that have no buffers associated with them are recycled and the next "
"vnode from the freelist is retrieved.  If the freelist is empty, vnodes on "
"the holdlist are considered.  The new vnode is returned in the address "
"specified by E<.Fa vpp>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:588
msgid ""
"The argument E<.Fa mp> is the mount point for the file system requested the "
"new vnode.  Before retrieving the new vnode, the file system is checked if "
"it is busy (such as currently unmounting).  An error is returned if the file "
"system is unmounted."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:610
msgid ""
"The argument E<.Fa tag> is the vnode tag assigned to E<.Fa "
"*vpp-\\*[Gt]v_tag>.  The argument E<.Fa vops> is the vnode operations vector "
"of the file system requesting the new vnode.  If a vnode is successfully "
"retrieved zero is returned, otherwise an appropriate error code is "
"returned.  If E<.Fa slock> is not E<.Dv NULL>, it specifies the lock to "
"share for E<.Em v_interlock>.  The reference will be held on the lock and "
"sharing noted.  Reference will be released and lock unshared when the vnode "
"gets recycled.  If E<.Dv NULL> (regular case), vnode will use its own "
"interlock."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:610
#, no-wrap
msgid "Fn ungetnewvnode vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:620
msgid ""
"Undo the operation of E<.Fn getnewvnode>.  The argument E<.Fa vp> is the "
"vnode to return to the freelist.  This function is needed for E<.Xr VFS_VGET "
"9> which may need to push back a vnode in case of a locking race condition."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:620
#, no-wrap
msgid "Fn vrecycle vp inter_lkp l"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:626
msgid ""
"Recycle the unused vnode E<.Fa vp> to the front of the freelist.  E<.Fn "
"vrecycle> is a null operation if the reference count is greater than zero."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:626
#, no-wrap
msgid "Fn vgone vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:630
msgid ""
"Eliminate all activity associated with the unlocked vnode E<.Fa vp> in "
"preparation for recycling."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:630
#, no-wrap
msgid "Fn vgonel vp p"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:634
msgid ""
"Eliminate all activity associated with the locked vnode E<.Fa vp> in "
"preparation for recycling."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:634
#, no-wrap
msgid "Fn vflush mp skipvp flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:654
msgid ""
"Remove any vnodes in the vnode table belonging to mount point E<.Fa mp>.  If "
"E<.Fa skipvp> is not E<.Dv NULL> it is exempt from being flushed.  The "
"argument E<.Fa flags> is a set of flags modifying the operation of E<.Fn "
"vflush>.  If FORCECLOSE is not specified, there should not be any active "
"vnodes and the error E<.Er EBUSY> is returned if any are found (this is a "
"user error, not a system error).  If FORCECLOSE is specified, active vnodes "
"that are found are detached.  If WRITECLOSE is set, only flush out regular "
"file vnodes open for writing.  SKIPSYSTEM causes any vnodes marked V_SYSTEM "
"to be skipped."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:654
#, no-wrap
msgid "Fn vaccess type file_mode uid gid acc_mode cred"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:660
msgid ""
"Do access checking by comparing the file's permissions to the caller's "
"desired access type E<.Fa acc_mode> and credentials E<.Fa cred>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:660
#, no-wrap
msgid "Fn bdevvp dev vpp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:665
msgid ""
"Create a vnode for a block device.  E<.Fn bdevvp> is used for root file "
"systems, swap areas and for memory file system special devices."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:665
#, no-wrap
msgid "Fn cdevvp dev vpp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:669
msgid ""
"Create a vnode for a character device.  E<.Fn cdevvp> is used for the "
"console and kernfs special devices."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:669
#, no-wrap
msgid "Fn vfinddev dev vtype vpp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:673
msgid ""
"Lookup a vnode by device number.  The vnode is referenced and returned in "
"the address specified by E<.Fa vpp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:673
#, no-wrap
msgid "Fn vdevgone \"int maj\" \"int min\" \"int minh\" \"enum vtype type\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:680
msgid ""
"Reclaim all vnodes that correspond to the specified minor number range E<.Fa "
"minl> to E<.Fa minh> (endpoints inclusive) of the specified major E<.Fa "
"maj>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:680
#, no-wrap
msgid "Fn vwakeup bp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:688
msgid ""
"Update outstanding I/O count E<.Em vp-\\*[Gt]v_numoutput> for the vnode "
"E<.Em bp-\\*[Gt]b_vp> and do a wakeup if requested and E<.Em "
"vp-\\*[Gt]vflag> has VBWAIT set."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:688
#, no-wrap
msgid "Fn vflushbuf vp sync"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:700
msgid ""
"Flush all dirty buffers to disk for the file with the locked vnode E<.Fa "
"vp>.  The argument E<.Fa sync> specifies whether the I/O should be "
"synchronous and E<.Fn vflushbuf> will sleep until E<.Em "
"vp-\\*[Gt]v_numoutput> is zero and E<.Em vp-\\*[Gt]v_dirtyblkhd> is empty."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:700
#, no-wrap
msgid "Fn vinvalbuf vp flags cred l slpflag slptimeo"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:717
msgid ""
"Flush out and invalidate all buffers associated with locked vnode E<.Fa "
"vp>.  The argument E<.Fa l> and E<.Fa cred> specified the calling process "
"and its credentials.  The E<.Xr ltsleep 9> flag and timeout are specified by "
"the arguments E<.Fa slpflag> and E<.Fa slptimeo> respectively.  If the "
"operation is successful zero is returned, otherwise an appropriate error "
"code is returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:717
#, no-wrap
msgid "Fn vtruncbuf vp lbn slpflag slptimeo"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:733
msgid ""
"Destroy any in-core buffers past the file truncation length for the locked "
"vnode E<.Fa vp>.  The truncation length is specified by E<.Fa lbn>.  E<.Fn "
"vtruncbuf> will sleep while the I/O is performed, The E<.Xr ltsleep 9> flag "
"and timeout are specified by the arguments E<.Fa slpflag> and E<.Fa "
"slptimeo> respectively.  If the operation is successful zero is returned, "
"otherwise an appropriate error code is returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnode.9:733
#, no-wrap
msgid "Fn vprint label vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:741
msgid ""
"This function is used by the kernel to dump vnode information during a "
"panic.  It is only used if the kernel option DIAGNOSTIC is compiled into the "
"kernel.  The argument E<.Fa label> is a string to prefix the information "
"dump of vnode E<.Fa vp>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:745
msgid ""
"The vnode framework is implemented within the file E<.Pa "
"sys/kern/vfs_subr.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:756
msgid ""
"E<.Xr intro 9>, E<.Xr lock 9>, E<.Xr namecache 9>, E<.Xr namei 9>, E<.Xr uvm "
"9>, E<.Xr vattr 9>, E<.Xr vfs 9>, E<.Xr vfsops 9>, E<.Xr vnodeops 9>, E<.Xr "
"vnsubr 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnode.9:766
msgid ""
"The locking protocol is inconsistent.  Many vnode operations are passed "
"locked vnodes on entry but release the lock before they exit.  The locking "
"protocol is used in some places to attempt to make a series of operations "
"atomic (e.g., access check then operation).  This does not work for "
"non-local file systems that do not support locking (e.g., NFS).  The E<.Nm> "
"interface would benefit from a simpler locking protocol."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/vnodeops.9:30
#, no-wrap
msgid "July 11, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/vnodeops.9:31
#, no-wrap
msgid "VNODEOPS 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:80
msgid ""
"E<.Nm vnodeops>, E<.Nm VOP_LOOKUP>, E<.Nm VOP_CREATE>, E<.Nm VOP_MKNOD>, "
"E<.Nm VOP_OPEN>, E<.Nm VOP_CLOSE>, E<.Nm VOP_ACCESS>, E<.Nm VOP_GETATTR>, "
"E<.Nm VOP_SETATTR>, E<.Nm VOP_READ>, E<.Nm VOP_WRITE>, E<.Nm VOP_IOCTL>, "
"E<.Nm VOP_FCNTL>, E<.Nm VOP_POLL>, E<.Nm VOP_KQFILTER>, E<.Nm VOP_REVOKE>, "
"E<.Nm VOP_MMAP>, E<.Nm VOP_FSYNC>, E<.Nm VOP_SEEK>, E<.Nm VOP_REMOVE>, E<.Nm "
"VOP_LINK>, E<.Nm VOP_RENAME>, E<.Nm VOP_MKDIR>, E<.Nm VOP_RMDIR>, E<.Nm "
"VOP_SYMLINK>, E<.Nm VOP_READDIR>, E<.Nm VOP_READLINK>, E<.Nm VOP_ABORTOP>, "
"E<.Nm VOP_INACTIVE>, E<.Nm VOP_RECLAIM>, E<.Nm VOP_LOCK>, E<.Nm VOP_UNLOCK>, "
"E<.Nm VOP_ISLOCKED>, E<.Nm VOP_BMAP>, E<.Nm VOP_PRINT>, E<.Nm VOP_PATHCONF>, "
"E<.Nm VOP_ADVLOCK>, E<.Nm VOP_WHITEOUT>, E<.Nm VOP_GETPAGES>, E<.Nm "
"VOP_PUTPAGES>, E<.Nm VOP_STRATEGY>, E<.Nm VOP_BWRITE>, E<.Nm "
"VOP_GETEXTATTR>, E<.Nm VOP_SETEXTATTR>, E<.Nm VOP_LISTEXTATTR>, E<.Nm "
"VOP_DELETEEXTATTR>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/vnodeops.9:80
#, no-wrap
msgid "vnode operations"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/vnodeops.9:84
#, no-wrap
msgid "sys/dirent.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/vnodeops.9:88
#, no-wrap
msgid "sys/unistd.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/vnodeops.9:89
#, no-wrap
msgid "sys/fcntl.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/vnodeops.9:90
#, no-wrap
msgid "sys/lockf.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:208
msgid ""
"E<.Ft int> E<.Fn VOP_LOOKUP \"struct vnode *dvp\" \"struct vnode **vpp\" "
"\"struct componentname *cnp\"> E<.Ft int> E<.Fn VOP_CREATE \"struct vnode "
"*dvp\" \"struct vnode **vpp\" \"struct componentname *cnp\" \"struct vattr "
"*vap\"> E<.Ft int> E<.Fn VOP_MKNOD \"struct vnode *dvp\" \"struct vnode "
"**vpp\" \"struct componentname *cnp\" \"struct vattr *vap\"> E<.Ft int> "
"E<.Fn VOP_OPEN \"struct vnode *vp\" \"int mode\" \"kauth_cred_t cred\"> "
"E<.Ft int> E<.Fn VOP_CLOSE \"struct vnode *vp\" \"int fflag\" \"kauth_cred_t "
"cred\"> E<.Ft int> E<.Fn VOP_ACCESS \"struct vnode *vp\" \"int mode\" "
"\"kauth_cred_t cred\"> E<.Ft int> E<.Fn VOP_GETATTR \"struct vnode *vp\" "
"\"struct vattr *vap\" \"kauth_cred_t cred\"> E<.Ft int> E<.Fn VOP_SETATTR "
"\"struct vnode *vp\" \"struct vattr *vap\" \"kauth_cred_t cred\"> E<.Ft int> "
"E<.Fn VOP_READ \"struct vnode *vp\" \"struct uio *uio\" \"int ioflag\" "
"\"kauth_cred_t cred\"> E<.Ft int> E<.Fn VOP_WRITE \"struct vnode *vp\" "
"\"struct uio *uio\" \"int ioflag\" \"kauth_cred_t cred\"> E<.Ft int> E<.Fn "
"VOP_IOCTL \"struct vnode *vp\" \"u_long command\" \"void *data\" \"int "
"fflag\" \"kauth_cred_t cred\"> E<.Ft int> E<.Fn VOP_FCNTL \"struct vnode "
"*vp\" \"u_int command\" \"void *data\" \"int fflag\" \"kauth_cred_t cred\"> "
"E<.Ft int> E<.Fn VOP_POLL \"struct vnode *vp\" \"int events\"> E<.Ft int> "
"E<.Fn VOP_KQFILTER \"struct vnode *vp\" \"struct knote *kn\"> E<.Ft int> "
"E<.Fn VOP_REVOKE \"struct vnode *vp\" \"int flags\"> E<.Ft int> E<.Fn "
"VOP_MMAP \"struct vnode *vp\" \"vm_prot_t prot\" \"kauth_cred_t cred\"> "
"E<.Ft int> E<.Fn VOP_FSYNC \"struct vnode *vp\" \"kauth_cred_t cred\" \"int "
"flags\" \"off_t offlo\" \"off_t offhi\"> E<.Ft int> E<.Fn VOP_SEEK \"struct "
"vnode *vp\" \"off_t oldoff\" \"off_t newoff\" \"kauth_cred_t cred\"> E<.Ft "
"int> E<.Fn VOP_REMOVE \"struct vnode *vp\" \"struct vnode *vp\" \"struct "
"componentname *cnp\"> E<.Ft int> E<.Fn VOP_LINK \"struct vnode *dvp\" "
"\"struct vnode *vp\" \"struct componentname *cnp\"> E<.Ft int> E<.Fn "
"VOP_RENAME \"struct vnode *fdvp\" \"struct vnode *fvp\" \"struct "
"componentname *fcnp\" \"struct vnode *tdvp\" \"struct vnode *tvp\" \"struct "
"componentname *tcnp\"> E<.Ft int> E<.Fn VOP_MKDIR \"struct vnode *dvp\" "
"\"struct vnode **vpp\" \"struct componentname *cnp\" \"struct vattr *vap\"> "
"E<.Ft int> E<.Fn VOP_RMDIR \"struct vnode *dvp\" \"struct vnode *vp\" "
"\"struct componentname *cnp\"> E<.Ft int> E<.Fn VOP_SYMLINK \"struct vnode "
"*dvp\" \"struct vnode **vpp\" \"struct componentname *cnp\" \"struct vattr "
"*vap\" \"char *target\"> E<.Ft int> E<.Fn VOP_READDIR \"struct vnode *vp\" "
"\"struct uio *uio\" \"kauth_cred_t cred\" \"int *eofflag\" \"off_t "
"**cookies\" \"int *ncookies\"> E<.Ft int> E<.Fn VOP_READLINK \"struct vnode "
"*vp\" \"struct uio *uio\" \"kauth_cred_t cred\"> E<.Ft int> E<.Fn "
"VOP_ABORTOP \"struct vnode *dvp\" \"struct componentname *cnp\"> E<.Ft int> "
"E<.Fn VOP_INACTIVE \"struct vnode *vp\"> E<.Ft int> E<.Fn VOP_RECLAIM "
"\"struct vnode *vp\"> E<.Ft int> E<.Fn VOP_LOCK \"struct vnode *vp\" \"int "
"flags\"> E<.Ft int> E<.Fn VOP_UNLOCK \"struct vnode *vp\"> E<.Ft int> E<.Fn "
"VOP_ISLOCKED \"struct vnode *vp\"> E<.Ft int> E<.Fn VOP_BMAP \"struct vnode "
"*vp\" \"daddr_t bn\" \"struct vnode **vpp\" \"daddr_t *bnp\" \"int *runp\"> "
"E<.Ft int> E<.Fn VOP_PRINT \"struct vnode *vp\"> E<.Ft int> E<.Fn "
"VOP_PATHCONF \"struct vnode *vp\" \"int name\" \"register_t *retval\"> E<.Ft "
"int> E<.Fn VOP_ADVLOCK \"struct vnode *vp\" \"void *id\" \"int op\" \"struct "
"flock *fl\" \"int flags\"> E<.Ft int> E<.Fn VOP_WHITEOUT \"struct vnode "
"*dvp\" \"struct componentname *cnp\" \"int flags\"> E<.Ft int> E<.Fn "
"VOP_GETPAGES \"struct vnode *vp\" \"voff_t offset\" \"struct vm_page **m\" "
"\"int *count\" \"int centeridx\" \"vm_prot_t access_type\" \"int advice\" "
"\"int flags\"> E<.Ft int> E<.Fn VOP_PUTPAGES \"struct vnode *vp\" \"voff_t "
"offlo\" \"voff_t offhi\" \"int flags\"> E<.Ft int> E<.Fn VOP_STRATEGY "
"\"struct vnode *vp\" \"struct buf *bp\"> E<.Ft int> E<.Fn VOP_BWRITE "
"\"struct vnode *vp\" \"struct buf *bp\"> E<.Ft int> E<.Fn VOP_GETEXTATTR "
"\"struct vnode *vp\" \"int attrnamespace\" \"const char *name\" \"struct uio "
"*uio\" \"size_t *size\" \"kauth_cred_t cred\"> E<.Ft int> E<.Fn "
"VOP_SETEXTATTR \"struct vnode *vp\" \"int attrnamespace\" \"const char "
"*name\" \"struct uio *uio\" \"kauth_cred_t cred\"> E<.Ft int> E<.Fn "
"VOP_LISTEXTATTR \"struct vnode *vp\" \"int attrnamespace\" \"struct uio "
"*uio\" \"size_t *size\" \"kauth_cred_t cred\"> E<.Ft int> E<.Fn "
"VOP_DELETEEXTATTR \"struct vnode *vp\" \"int attrnamespace\" \"const char "
"*name\" \"kauth_cred_t cred\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:210
msgid "Not all header files are required for each function."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:221
msgid ""
"The vnode operations vector describes what operations can be done to the "
"file associated with the vnode.  The system maintains one vnode operations "
"vector for each file system type configured into the kernel.  The vnode "
"operations vector contains a pointer to a function for each operation "
"supported by the file system.  Many of the functions described in the vnode "
"operations vector are closely related to their corresponding system calls.  "
"In most cases, they are called as a result of the system call associated "
"with the operation being invoked."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:225
msgid ""
"Functions in the vnode operations vector are invoked using specialized "
"macros.  The following table gives a summary of the operations."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:227
#, no-wrap
msgid "Sy Macro Ta Sy Description"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:228
#, no-wrap
msgid "\"VOP_LOOKUP\tLookup\" file name in name cache"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:229
#, no-wrap
msgid "\"VOP_CREATE\tCreate\" a new file"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:230
#, no-wrap
msgid "\"VOP_MKNOD\tMake\" a new device"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:231
#, no-wrap
msgid "\"VOP_OPEN\tOpen\" a file"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:232
#, no-wrap
msgid "\"VOP_CLOSE\tClose\" a file"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:233
#, no-wrap
msgid "\"VOP_ACCESS\tDetermine\" file accessibility"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:234
#, no-wrap
msgid "\"VOP_GETATTR\tGet\" file attributes"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:235
#, no-wrap
msgid "\"VOP_SETATTR\tSet\" file attributes"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:236
#, no-wrap
msgid "\"VOP_READ\tRead\" from a file"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:237
#, no-wrap
msgid "\"VOP_WRITE\tWrite\" to a file"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:238
#, no-wrap
msgid "\"VOP_IOCTL\tPerform\" device-specific I/O"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:239
#, no-wrap
msgid "\"VOP_FCNTL\tPerform\" file control"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:240
#, no-wrap
msgid "\"VOP_POLL\tTest\" if poll event has occurred"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:241
#, no-wrap
msgid "\"VOP_KQFILTER\tRegister\" a knote"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:242
#, no-wrap
msgid "\"VOP_REVOKE\tEliminate\" vode activity"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:243
#, no-wrap
msgid "\"VOP_MMAP\tMap\" file into user address space"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:244
#, no-wrap
msgid "\"VOP_FSYNC\tFlush\" pending data to disk"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:245
#, no-wrap
msgid "\"VOP_SEEK\tTest\" if file is seekable"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:246
#, no-wrap
msgid "\"VOP_REMOVE\tRemove\" a file"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:247
#, no-wrap
msgid "\"VOP_LINK\tLink\" a file"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:248
#, no-wrap
msgid "\"VOP_RENAME\tRename\" a file"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:249
#, no-wrap
msgid "\"VOP_MKDIR\tMake\" a new directory"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:250
#, no-wrap
msgid "\"VOP_RMDIR\tRemove\" a directory"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:251
#, no-wrap
msgid "\"VOP_SYMLINK\tCreate\" a symbolic link"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:252
#, no-wrap
msgid "\"VOP_READDIR\tRead\" directory entry"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:253
#, no-wrap
msgid "\"VOP_READLINK\tRead\" contents of a symlink"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:254
#, no-wrap
msgid "\"VOP_ABORTOP\tAbort\" pending operation"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:255
#, no-wrap
msgid "\"VOP_INACTIVE\tRelease\" the inactive vnode"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:256
#, no-wrap
msgid "\"VOP_RECLAIM\tReclaim\" vnode for another file"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:257
#, no-wrap
msgid "\"VOP_LOCK\tSleep\" until vnode lock is free"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:258
#, no-wrap
msgid "\"VOP_UNLOCK\tWake\" up process sleeping on lock"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:259
#, no-wrap
msgid "\"VOP_ISLOCKED\tTest\" if vnode is locked"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:260
#, no-wrap
msgid "\"VOP_BMAP\tLogical\" block number conversion"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:261
#, no-wrap
msgid "\"VOP_PRINT\tPrint\" debugging information"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:262
#, no-wrap
msgid "\"VOP_PATHCONF\tReturn\" POSIX pathconf data"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:263
#, no-wrap
msgid "\"VOP_ADVLOCK\tAdvisory\" record locking"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:264
#, no-wrap
msgid "\"VOP_WHITEOUT\tWhiteout\" vnode"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:265
#, no-wrap
msgid "\"VOP_GETPAGES\tRead\" VM pages from file"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:266
#, no-wrap
msgid "\"VOP_PUTPAGES\tWrite\" VM pages to file"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:267
#, no-wrap
msgid "\"VOP_STRATEGY\tRead/write\" a file system buffer"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:268
#, no-wrap
msgid "\"VOP_BWRITE\tWrite\" a file system buffer"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:269
#, no-wrap
msgid "\"VOP_GETEXTATTR\tGet\" extended attribute"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:270
#, no-wrap
msgid "\"VOP_SETEXTATTR\tSet\" extended attribute"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:271
#, no-wrap
msgid "\"VOP_LISTEXTATTR\tList\" extended attributes"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:272
#, no-wrap
msgid "\"VOP_DELETEEXTATTR\tRemove\" extended attribute"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:277
msgid ""
"The implementation details of the vnode operations vector are not quite what "
"is described here."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:283
msgid ""
"If the file system type does not support a specific operation, it must "
"nevertheless assign an appropriate stub in the vnode operations vector to do "
"the minimum required of it.  In most cases, such functions either do nothing "
"or return an error value to the effect that it is not supported."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:289
msgid ""
"Many of the functions in the vnode operations vector take a componentname "
"structure.  It is used to encapsulate many parameters into a single function "
"argument.  It has the following structure:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:306
#, no-wrap
msgid ""
"struct componentname {\n"
"        /*\n"
"         * Arguments to lookup.\n"
"         */\n"
"        uint32_t cn_nameiop;    /* namei operation */\n"
"        uint32_t cn_flags;      /* flags to namei */\n"
"        kauth_cred_t cn_cred;   /* credentials */\n"
"        /*\n"
"         * Shared between lookup and commit routines.\n"
"         */\n"
"        char    *cn_pnbuf;      /* pathname buffer */\n"
"        const char *cn_nameptr; /* pointer to looked up name */\n"
"        size_t  cn_namelen;     /* length of looked up component */\n"
"        u_long  cn_hash;        /* hash value of looked up name */\n"
"        size_t  cn_consume;     /* chars to consume in lookup() */\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:318
msgid ""
"The top half of the structure is used exclusively for the pathname lookups "
"using E<.Fn VOP_LOOKUP> and is initialized by the caller.  The semantics of "
"the lookup are affected by the lookup operation specified in E<.Em "
"cn_nameiop> and the flags specified in E<.Em cn_flags>.  Valid operations "
"are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:320
#, no-wrap
msgid "LOOKUP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:322
msgid "perform name lookup only"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:322
#, no-wrap
msgid "CREATE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:324
msgid "set up for file creation"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:324
#, no-wrap
msgid "DELETE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:326
msgid "set up for file deletion"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:326
#, no-wrap
msgid "RENAME"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:328
msgid "set up for file renaming"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:328
#, no-wrap
msgid "OPMASK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:330
msgid "mask for operation"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:335
msgid "Valid values for E<.Em cn-\\*[Gt]cn_flags> are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:337
#, no-wrap
msgid "LOCKLEAF"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:339
msgid "lock inode on return"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:339
#, no-wrap
msgid "LOCKPARENT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:341
msgid "want parent vnode returned locked"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:341
#, no-wrap
msgid "NOCACHE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:344
msgid "name must not be left in name cache (see E<.Xr namecache 9>)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:344
#, no-wrap
msgid "FOLLOW"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:346
msgid "follow symbolic links"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:346
#, no-wrap
msgid "NOFOLLOW"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:348
msgid "do not follow symbolic links (pseudo)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:348
#, no-wrap
msgid "MODMASK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:350
msgid "mask of operational modifiers"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:357
msgid ""
"No vnode operations may be called from interrupt context.  Most operations "
"also require the vnode to be locked on entry.  To prevent deadlocks, when "
"acquiring locks on multiple vnodes, the lock of parent directory must be "
"acquired before the lock on the child directory."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:362
msgid ""
"Vnode operations for a file system type generally should not be called "
"directly from the kernel, but accessed indirectly through the high-level "
"convenience functions discussed in E<.Xr vnsubr 9>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:364
#, no-wrap
msgid "Fn VOP_LOOKUP dvp vpp cnp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:381
msgid ""
"Lookup a single pathname component in a given directory.  The argument E<.Fa "
"dvp> is the locked vnode of the directory to search and E<.Fa cnp> is the "
"pathname component to be searched for.  If the pathname component is found, "
"the address of the resulting locked vnode is returned in E<.Fa vpp>.  The "
"operation specified in E<.Em cnp-\\*[Gt]cn_nameiop> indicates E<.Fn "
"VOP_LOOKUP> the reason for requesting the lookup and uses it to cache file "
"system type specific information in the vnode for subsequent operations."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:406
msgid ""
"There are three types of lookups: \".\", \"..\" (ISDOTDOT), and regular.  If "
"the pathname component being searched for is \".\", then E<.Fa dvp> has an "
"extra reference added to it and it is returned in E<.Fa *vpp>.  If the "
"pathname component being search for is \"..\" (ISDOTDOT), E<.Fa dvp> is "
"unlocked, the \"..\" node is locked and then E<.Fa dvp> is relocked.  This "
"process preserves the protocol of always locking nodes from root downward "
"and prevents deadlock.  For other pathname components, E<.Fn VOP_LOOKUP> "
"checks the accessibility of the directory and searches the name cache for "
"the pathname component.  See E<.Xr namecache 9>.  If the pathname is not "
"found in the name cache, the directory is searched for the pathname.  The "
"resulting locked vnode is returned in E<.Fa vpp>.  E<.Fa dvp> is always "
"returned locked."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:423
msgid ""
"On failure E<.Fa *vpp> is E<.Dv NULL>, and E<.Fa *dvp> is left locked.  If "
"the operation is successful E<.Fa *vpp> is locked and zero is returned.  "
"Typically, if E<.Fa *vpp> and E<.Fa dvp> are the same vnode the caller will "
"need to release twice (decrement the reference count) and unlock once."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:423
#, no-wrap
msgid "Fn VOP_CREATE dvp vpp cnp vap"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:440
msgid ""
"Create a new file in a given directory.  The argument E<.Fa dvp> is the "
"locked vnode of the directory to create the new file in and E<.Fa cnp> is "
"the pathname component of the new file.  The argument E<.Fa vap> specifies "
"the attributes that the new file should be created with.  If the file is "
"successfully created, the address of the resulting locked vnode is returned "
"in E<.Fa vpp> and zero is returned.  Regardless of the return value, the "
"directory vnode E<.Fa dvp> will be unlocked on return."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:456
msgid ""
"This function is called after E<.Fn VOP_LOOKUP> when a file is being "
"created.  Normally, E<.Fn VOP_LOOKUP> will have set the SAVENAME flag in "
"E<.Em cnp-\\*[Gt]cn_flags> to keep the memory pointed to by E<.Em "
"cnp-\\*[Gt]cn_pnbuf> valid.  If an error is detected when creating the file, "
"this memory is released.  If the file is created successfully it will be "
"released unless the SAVESTART flags in specified in E<.Em "
"cnp-\\*[Gt]cn_flags>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:456
#, no-wrap
msgid "Fn VOP_MKNOD dvp vpp cnp vap"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:472
msgid ""
"Make a new device-special file in a given directory.  The argument E<.Fa "
"dvp> is the locked vnode of the directory to create the new device-special "
"file in and E<.Fa cnp> is the pathname component of the new device-special "
"file.  The argument E<.Fa vap> specifies the attributes that the new "
"device-special file should be created with.  If the file is successfully "
"created, the address of the resulting locked vnode is returned in E<.Fa vpp> "
"and zero is returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:488
msgid ""
"This function is called after E<.Fn VOP_LOOKUP> when a device-special file "
"is being created.  Normally, E<.Fn VOP_LOOKUP> will have set the SAVENAME "
"flag in E<.Em cnp-\\*[Gt]cn_flags> to keep the memory pointed to by E<.Em "
"cnp-\\*[Gt]cn_pnbuf> valid.  If an error is detected when creating the "
"device-special file, this memory is released.  If the device-special file is "
"created successfully it will be released unless the SAVESTART flags in "
"specified in E<.Em cnp-\\*[Gt]cn_flags>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:488
#, no-wrap
msgid "Fn VOP_OPEN vp mode cred"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:502
msgid ""
"Open a file.  The argument E<.Fa vp> is the vnode of the file to open and "
"E<.Fa mode> specifies the access mode required by the calling process.  The "
"calling credentials are specified by E<.Fa cred>.  The access mode is a set "
"of flags, including FREAD, FWRITE, O_NONBLOCK, O_APPEND, etc.  E<.Fn "
"VOP_OPEN> must be called before a file can be accessed by a thread.  The "
"vnode reference count is incremented."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:509
msgid ""
"E<.Fn VOP_OPEN> expects the vnode E<.Fa vp> to be locked on entry and will "
"leave it locked on return.  If the operation is successful zero is returned, "
"otherwise an appropriate error code is returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:509
#, no-wrap
msgid "Fn VOP_CLOSE vp fflag cred"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:526
msgid ""
"Close a file.  The argument E<.Fa vp> is the vnode of the file to close and "
"E<.Fa fflag> specifies the access mode by the calling process.  The possible "
"flags are E<.Dv FREAD>, E<.Dv FWRITE> and E<.Dv FNONBLOCK>.  The calling "
"credentials are specified by E<.Fa cred>.  E<.Fn VOP_CLOSE> frees resources "
"allocated by E<.Fn VOP_OPEN>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:530 org_netbsd/src/share/man/man9/vnodeops.9:549
msgid ""
"The vnode E<.Fa vp> will be locked on entry and should remain locked on "
"return."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:530
#, no-wrap
msgid "Fn VOP_ACCESS vp mode cred"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:545
msgid ""
"Determine the accessibility (permissions) of the file against the specified "
"credentials.  The argument E<.Fa vp> is the vnode of the file to check, "
"E<.Fa mode> is the type of access required and E<.Fa cred> contains the user "
"credentials to check.  The argument E<.Fa mode> is a mask which can contain "
"VREAD, VWRITE or VEXEC.  If the file is accessible in the specified way, "
"zero is returned, otherwise an appropriate error code is returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:549
#, no-wrap
msgid "Fn VOP_GETATTR vp vap cred"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:567
msgid ""
"Get specific vnode attributes on a file.  The argument E<.Fa vp> is the "
"vnode of the file to get the attributes for.  The argument E<.Fa cred> "
"specifies the calling credentials.  E<.Fn VOP_GETATTR> uses the file system "
"type specific data object E<.Em vp-\\*[Gt]v_data> to reference the "
"underlying file attributes.  Attributes associated with the file are "
"collected by setting the required attribute bits in E<.Em "
"vap-\\*[Gt]va_mask>.  The attributes are returned in E<.Fa vap>.  Attributes "
"which are not available are set to the value VNOVAL."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:570 org_netbsd/src/share/man/man9/vnodeops.9:595
msgid "For more information on vnode attributes see E<.Xr vattr 9>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:570
#, no-wrap
msgid "Fn VOP_SETATTR vp vap cred"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:592
msgid ""
"Set specific vnode attributes on a file.  The argument E<.Fa vp> is the "
"locked vnode of the file to set the attributes for.  The argument E<.Fa "
"cred> specifies the calling credentials.  E<.Fn VOP_SETATTR> uses the file "
"system type specific data object E<.Em vp-\\*[Gt]v_data> to reference the "
"underlying file attributes.  The new attributes are defined in E<.Fa vap>.  "
"Attributes associated with the file are set by setting the required "
"attribute bits in E<.Em vap-\\*[Gt]va_mask>.  Attributes which are not being "
"modified by E<.Fn VOP_SETATTR> should be set to the value VNOVAL.  If the "
"operation is successful zero is returned, otherwise an appropriate error is "
"returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:595
#, no-wrap
msgid "Fn VOP_READ vp uio ioflag cred"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:606
msgid ""
"Read the contents of a file.  The argument E<.Fa vp> is the vnode of the "
"file to read from, E<.Fa uio> is the location to read the data into, E<.Fa "
"ioflag> is a set of flags and E<.Fa cred> are the credentials of the calling "
"process."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:614
msgid ""
"The E<.Fa ioflag> argument is used to give directives and hints to the file "
"system.  When attempting a read, the high 16 bits are used to provide a "
"read-ahead hint (in unit of file system blocks) that the file system should "
"attempt.  The low 16 bits are a bit mask which can contain the following "
"flags:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:616
#, no-wrap
msgid "IO_UNIT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:618
msgid "do I/O as atomic unit"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:618
#, no-wrap
msgid "IO_APPEND"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:620
msgid "append write to end"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:620
#, no-wrap
msgid "IO_SYNC"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:622
msgid "sync I/O file integrity completion"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:622
#, no-wrap
msgid "IO_NODELOCKED"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:624
msgid "underlying node already locked"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:624
#, no-wrap
msgid "IO_NDELAY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:626
msgid "FNDELAY flag set in file table"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:626
#, no-wrap
msgid "IO_DSYNC"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:628
msgid "sync I/O data integrity completion"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:628
#, no-wrap
msgid "IO_ALTSEMANTICS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:630
msgid "use alternate I/O semantics"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:630
#, no-wrap
msgid "IO_NORMAL"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:632
msgid "operate on regular data"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:632
#, no-wrap
msgid "IO_EXT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:634
msgid "operate on extended attributes"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:634
#, no-wrap
msgid "IO_DIRECT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:636
msgid "do not buffer data in the kernel"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:640 org_netbsd/src/share/man/man9/vnodeops.9:660
msgid ""
"Zero is returned on success, otherwise an error is returned.  The vnode "
"should be locked on entry and remains locked on exit."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:640
#, no-wrap
msgid "Fn VOP_WRITE vp uio ioflag cred"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:651
msgid ""
"Write to a file.  The argument E<.Fa vp> is the vnode of the file to write "
"to, E<.Fa uio> is the location of the data to write, E<.Fa ioflag> is a set "
"of flags and E<.Fa cred> are the credentials of the calling process."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:657
msgid ""
"The E<.Fa ioflag> argument is used to give directives and hints to the file "
"system.  The low 16 bits are a bit mask which can contain the same flags as "
"E<.Fn VOP_READ>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:660
#, no-wrap
msgid "Fn VOP_IOCTL vp command data fflag cred"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:678
msgid ""
"Perform device-specific I/O.  The argument E<.Fa vp> is the locked vnode of "
"the file, normally representing a device.  The argument E<.Fa command> "
"specifies the device-specific operation to perform and E<.Fa cnp> provides "
"extra data for the specified operation.  The argument E<.Fa fflags> is a set "
"of flags.  The argument E<.Fa cred> is the caller's credentials.  If the "
"operation is successful, zero is returned, otherwise an appropriate error "
"code is returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:684
msgid ""
"Most file systems do not supply a function for E<.Fn VOP_IOCTL>.  This "
"function implements the E<.Xr ioctl 2> system call."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:684
#, no-wrap
msgid "Fn VOP_FCNTL vp command data fflag cred"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:702
msgid ""
"Perform file control.  The argument E<.Fa vp> is the locked vnode of the "
"file.  The argument E<.Fa command> specifies the operation to perform and "
"E<.Fa cnp> provides extra data for the specified operation.  The argument "
"E<.Fa fflags> is a set of flags.  The argument E<.Fa cred> is the caller's "
"credentials.  If the operation is successful, zero is returned, otherwise an "
"appropriate error code is returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:702
#, no-wrap
msgid "Fn VOP_POLL vp events"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:714
msgid ""
"Test if a poll event has occurred.  The argument E<.Fa vp> is the vnode of "
"the file to poll.  It returns any events of interest as specified by E<.Fa "
"events> that may have occurred for the file.  The argument E<.Fa events> is "
"a set of flags as specified by E<.Xr poll 2>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:714
#, no-wrap
msgid "Fn VOP_KQFILTER vp kn"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:721
msgid ""
"Register a knote E<.Fa kn> with the vnode E<.Fa vn>.  If the operation is "
"successful zero is returned, otherwise an appropriate error code is "
"returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:721
#, no-wrap
msgid "Fn VOP_REVOKE vp flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:734
msgid ""
"Eliminate all activity associated with the vnode E<.Fa vp>.  The argument "
"E<.Fa flags> is a set of flags.  If REVOKEALL is set in E<.Fa flags> all "
"vnodes aliased to the vnode E<.Fa vp> are also eliminated.  If the operation "
"is successful zero is returned, otherwise an appropriate error is returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:734
#, no-wrap
msgid "Fn VOP_MMAP vp prot cred"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:746
msgid ""
"Inform file system that E<.Fa vp> is in the process of being memory mapped.  "
"The argument E<.Fa prot> specifies the vm access protection the vnode is "
"going to be mapped with.  The argument E<.Fa cred> is the caller's "
"credentials.  If the file system allows the memory mapping, zero is "
"returned, otherwise an appropriate error code is returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:754
msgid ""
"Most file systems do not supply a function for E<.Fn VOP_MMAP> and use E<.Fn "
"genfs_mmap> to default for success.  Only file systems which do not "
"integrate with the page cache at all typically want to disallow memory "
"mapping."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:754
#, no-wrap
msgid "Fn VOP_FSYNC vp cred flags offlo offhi"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:775
msgid ""
"Flush pending data buffers for a file to disk.  The argument E<.Fa vp> is "
"the locked vnode of the file for flush.  The argument E<.Fa cred> is the "
"caller's credentials.  The argument E<.Fa flags> is a set of flags.  If "
"FSYNC_WAIT is specified in E<.Fa flags>, the function should wait for I/O to "
"complete before returning.  The argument E<.Fa offlo> and E<.Fa offhi> "
"specify the range of file to flush.  If the operation is successful zero is "
"returned, otherwise an appropriate error code is returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:781
msgid "This function implements the E<.Xr sync 2> and E<.Xr fsync 2> system calls."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:781
#, no-wrap
msgid "Fn VOP_SEEK vp oldoff newoff cred"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:793
msgid ""
"Test if the file is seekable for the specified offset E<.Fa newoff>.  The "
"argument E<.Fa vp> is the locked vnode of the file to test.  For most file "
"systems this function simply tests if E<.Fa newoff> is valid.  If the "
"specified E<.Fa newoff> is less than zero, the function returns error code "
"EINVAL."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:793
#, no-wrap
msgid "Fn VOP_REMOVE dvp vp cnp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:810
msgid ""
"Remove a file.  The argument E<.Fa dvp> is the locked vnode of the directory "
"to remove the file from and E<.Fa vp> is the locked vnode of the file to "
"remove.  The argument E<.Fa cnp> is the pathname component about the file to "
"remove.  If the operation is successful zero is returned, otherwise an "
"appropriate error code is returned.  Both E<.Fa dvp> and E<.Fa vp> are "
"locked on entry and are to be unlocked before returning."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:810
#, no-wrap
msgid "Fn VOP_LINK dvp vp cnp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:828
msgid ""
"Link to a file.  The argument E<.Fa dvp> is the locked node of the directory "
"to create the new link and E<.Fa vp> is the vnode of the file to be linked.  "
"The argument E<.Fa cnp> is the pathname component of the new link.  If the "
"operation is successful zero is returned, otherwise an error code is "
"returned.  The directory vnode E<.Fa dvp> should be locked on entry and will "
"be released and unlocked on return.  The vnode E<.Fa vp> should not be "
"locked on entry and will remain unlocked on return."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:828
#, no-wrap
msgid "Fn VOP_RENAME fdvp fvp fcnp tdvp tvp tcnp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:849
msgid ""
"Rename a file.  The argument E<.Fa fdvp> is the vnode of the old parent "
"directory containing in the file to be renamed and E<.Fa fvp> is the vnode "
"of the file to be renamed.  The argument E<.Fa fcnp> is the pathname "
"component about the file to be renamed.  The argument E<.Fa tdvp> is the "
"vnode of the new directory of the target file and E<.Fa tvp> is the vnode of "
"the target file (if it exists).  The argument E<.Fa tcnp> is the pathname "
"component about the file's new name.  If the operation is successful zero is "
"returned, otherwise an error code is returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:855
msgid ""
"The source directory and file vnodes should be unlocked and their reference "
"counts should be incremented before entry.  The target directory and file "
"vnodes should both be locked on entry.  E<.Fn VOP_RENAME> updates the "
"reference counts prior to returning."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:855
#, no-wrap
msgid "Fn VOP_MKDIR dvp vpp cnp vap"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:870
msgid ""
"Make a new directory in a given directory.  The argument E<.Fa dvp> is the "
"locked vnode of the directory to create the new directory in and E<.Fa cnp> "
"is the pathname component of the new directory.  The argument E<.Fa vap> "
"specifies the attributes that the new directory should be created with.  If "
"the file is successfully created, the address of the resulting locked vnode "
"is returned in E<.Fa vpp> and zero is returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:886
msgid ""
"This function is called after E<.Fn VOP_LOOKUP> when a directory is being "
"created.  Normally, E<.Fn VOP_LOOKUP> will have set the SAVENAME flag in "
"E<.Em cnp-\\*[Gt]cn_flags> to keep the memory pointed to by E<.Em "
"cnp-\\*[Gt]cn_pnbuf> valid.  If an error is detected when creating the "
"directory, this memory is released.  If the directory is created "
"successfully it will be released unless the SAVESTART flags in specified in "
"E<.Em cnp-\\*[Gt]cn_flags>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:886
#, no-wrap
msgid "Fn VOP_RMDIR dvp vp cnp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:902
msgid ""
"Remove a directory in a given directory.  The argument E<.Fa dvp> is the "
"locked vnode of the directory to remove the directory from and E<.Fa vp> is "
"the locked vnode of the directory to remove.  The argument E<.Fa cnp> is the "
"pathname component of the directory.  Zero is returned on success, otherwise "
"an error code is returned.  Both E<.Fa dvp> and E<.Fa vp> should be locked "
"on entry and will be released and unlocked on return."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:902
#, no-wrap
msgid "Fn VOP_SYMLINK dvp vpp cnp vap target"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:920
msgid ""
"Create a symbolic link in a given directory.  The argument E<.Fa dvp> is the "
"locked vnode of the directory to create the symbolic link in and E<.Fa cnp> "
"is the pathname component of the symbolic link.  The argument E<.Fa vap> "
"specifies the attributes that the symbolic link should be created with and "
"E<.Fa target> specifies the pathname of the target of the symbolic link.  If "
"the symbolic link is successfully created, the address of the resulting "
"locked vnode is returned in E<.Fa vpp> and zero is returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:936
msgid ""
"This function is called after E<.Fn VOP_LOOKUP> when a symbolic link is "
"being created.  Normally, E<.Fn VOP_LOOKUP> will have set the SAVENAME flag "
"in E<.Em cnp-\\*[Gt]cn_flags> to keep the memory pointed to by E<.Em "
"cnp-\\*[Gt]cn_pnbuf> valid.  If an error is detected when creating the "
"symbolic link, this memory is released.  If the symbolic link is created "
"successfully it will be released unless the SAVESTART flags in specified in "
"E<.Em cnp-\\*[Gt]cn_flags>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:936
#, no-wrap
msgid "Fn VOP_READDIR vp uio cred eofflag cookies ncookies"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:977
msgid ""
"Read directory entry.  The argument E<.Fa vp> is the vnode of the directory "
"to read the contents of and E<.Fa uio> is the destination location to read "
"the contents into.  The argument E<.Fa cred> is the caller's credentials.  "
"The argument E<.Fa eofflag> is the pointer to a flag which is set by E<.Fn "
"VOP_READDIR> to indicate an end-of-file condition.  If E<.Fa eofflag> is "
"E<.Dv NULL>, the end-of-file condition is not returned.  The arguments E<.Fa "
"cookies> and E<.Fa ncookies> specify the addresses for the list and number "
"of directory seek cookies generated for NFS.  Both E<.Fa cookies> and E<.Fa "
"ncookies> should be E<.Dv NULL> if they aren't required to be returned by "
"E<.Fn VOP_READDIR>.  The directory contents are read into struct dirent "
"structures and E<.Fa uio-\\*[Gt]uio_offset> is set to the offset of the next "
"unread directory entry.  This offset may be used in a following invocation "
"to continue a sequential read of the directory contents.  If the operation "
"is successful zero is returned, otherwise an appropriate error code is "
"returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:980
msgid "The directory should be locked on entry and will remain locked on return."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:993
msgid ""
"In case E<.Fa ncookies> and E<.Fa cookies> are supplied, one cookie should "
"be returned per directory entry.  The value of the cookie for each directory "
"entry should be the offset within the directory where the on-disk version of "
"the following directory entry starts.  That is, for each directory entry "
"E<.Fa i>, the corresponding cookie should refer to the offset of directory "
"entry E<.Fa i + 1>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1000
msgid ""
"Note that the E<.Fa cookies> array must be allocated by the callee using the "
"M_TEMP malloc type as callers of E<.Fn VOP_READDIR> must be able to free the "
"allocation."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1000
#, no-wrap
msgid "Fn VOP_READLINK vp uio cred"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1012
msgid ""
"Read the contents of a symbolic link.  The argument E<.Fa vp> is the locked "
"vnode of the symlink and E<.Fa uio> is the destination location to read the "
"contents into.  The argument E<.Fa cred> is the credentials of the caller.  "
"If the operation is successful zero is returned, otherwise an error code is "
"returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1014
msgid "The vnode should be locked on entry and will remain locked on return."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1014
#, no-wrap
msgid "Fn VOP_ABORTOP dvp cnp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1019
msgid ""
"Abort pending operation on vnode E<.Fa dvp> and free resources allocated in "
"E<.Fa cnp>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1023
msgid ""
"This operation is rarely implemented in file systems and E<.Fn "
"genfs_abortop> is typically used instead."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1023
#, no-wrap
msgid "Fn VOP_INACTIVE vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1039
msgid ""
"Release the inactive vnode.  E<.Fn VOP_INACTIVE> is called when the kernel "
"is no longer using the vnode.  This may be because the reference count "
"reaches zero or it may be that the file system is being forcibly unmounted "
"while there are open files.  It can be used to reclaim space for open but "
"deleted files.  The argument E<.Fa vp> is the locked vnode to be released.  "
"If the operation is successful zero is returned, otherwise an appropriate "
"error code is returned.  The vnode E<.Fa vp> must be locked on entry, and "
"will be unlocked on return."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1039
#, no-wrap
msgid "Fn VOP_RECLAIM vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1053
msgid ""
"Reclaim the vnode for another file system.  E<.Fn VOP_RECLAIM> is called "
"when a vnode is being reused for a different file system.  Any file system "
"specific resources associated with the vnode should be freed.  The argument "
"E<.Fa vp> is the vnode to be reclaimed.  If the operation is successful zero "
"is returned, otherwise an appropriate error code is returned.  The vnode "
"E<.Fa vp> should not be locked on entry, and will remain unlocked on return."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1053
#, no-wrap
msgid "Fn VOP_LOCK vp flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1080
msgid ""
"Sleep until vnode lock is free.  The argument E<.Fa vp> is the vnode of the "
"file to be locked.  The argument E<.Fa flags> is E<.Dv LK_EXCLUSIVE> to take "
"the lock exclusively or E<.Dv LK_SHARED> to take a shared lock.  If E<.Fa "
"flags> contains E<.Dv LK_NOWAIT> and the lock is busy, the operation will "
"return immediately with an error code.  If the operation is successful zero "
"is returned, otherwise an appropriate error code is returned.  E<.Fn "
"VOP_LOCK> is used to serialize access to the file system such as to prevent "
"two writes to the same file from happening at the same time.  Kernel code "
"should use E<.Xr vn_lock 9> to lock a vnode rather than calling E<.Fn "
"VOP_LOCK> directly."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1080
#, no-wrap
msgid "Fn VOP_UNLOCK vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1090
msgid ""
"Wake up process sleeping on lock.  The argument E<.Fa vp> is the vnode of "
"the file to be unlocked.  If the operation is successful zero is returned, "
"otherwise an appropriate error code is returned.  E<.Fn VOP_UNLOCK> is used "
"to serialize access to the file system such as to prevent two writes to the "
"same file from happening at the same time."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1090
#, no-wrap
msgid "Fn VOP_ISLOCKED vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1099
msgid ""
"Test if the vnode E<.Fa vp> is locked.  Possible return values are E<.Dv "
"LK_EXCLUSIVE>, E<.Dv LK_SHARED> or 0 for lock held exclusively by the "
"calling thread, shared lock held by anyone or unlocked, respectively."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1102
msgid ""
"This function must never be used to make locking decisions at run time: it "
"is provided only for diagnostic purposes."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1102
#, no-wrap
msgid "Fn VOP_BMAP vp bn vpp bnp runp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1111
msgid ""
"Convert the logical block number E<.Fa bn> of a file specified by vnode "
"E<.Fa vp> to its physical block number on the disk.  The physical block is "
"returned in E<.Fa bnp>.  In case the logical block is not allocated, \\-1 is "
"used."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1126
msgid ""
"If E<.Fa vpp> is not E<.Dv NULL>, the vnode of the device vnode for the file "
"system is returned in the address specified by E<.Fa vpp>.  If E<.Fa runp> "
"is not E<.Dv NULL>, the number of contiguous blocks starting from the next "
"block after the queried block will be returned in E<.Fa runp>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1126
#, no-wrap
msgid "Fn VOP_PRINT vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1133
msgid ""
"Print debugging information.  The argument E<.Fa vp> is the vnode to print.  "
"If the operation is successful zero is returned, otherwise an appropriate "
"error code is returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1133
#, no-wrap
msgid "Fn VOP_PATHCONF vp name retval"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1150
msgid ""
"Implement POSIX E<.Xr pathconf 2> and E<.Xr fpathconf 2> support.  The "
"argument E<.Fa vp> is the locked vnode to get information about.  The "
"argument E<.Fa name> specified the type of information to return.  The "
"information is returned in the address specified by E<.Fa retval>.  Valid "
"values for E<.Fa name> are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1152
#, no-wrap
msgid "_PC_LINK_MAX"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1154
msgid "return the maximum number of links to a file"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1154
#, no-wrap
msgid "_PC_NAME_MAX"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1156
msgid "return the maximum number of bytes in a file name"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1156
#, no-wrap
msgid "_PC_PATH_MAX"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1158
msgid "return the maximum number of bytes in a pathname"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1158
#, no-wrap
msgid "_PC_PIPE_BUF"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1161
msgid ""
"return the maximum number of bytes which will be written atomically to a "
"pipe"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1161
#, no-wrap
msgid "_PC_CHOWN_RESTRICTED"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1165
msgid ""
"return 1 if appropriate privileges are required for the E<.Xr chown 2> "
"system call, otherwise zero"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1165
#, no-wrap
msgid "_PC_NO_TRUNC"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1167
msgid "return if file names longer than KERN_NAME_MAX are truncated"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1175
msgid ""
"If E<.Fa name> is recognized, E<.Fa *retval> is set to the specified value "
"and zero is returned, otherwise an appropriate error is returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1175
#, no-wrap
msgid "Fn VOP_ADVLOCK vp id op fl flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1188
msgid ""
"Manipulate Advisory record locks on a vnode.  The argument E<.Fa vp> is the "
"vnode on which locks are manipulated.  The argument E<.Fa id> is the id "
"token which is changing the lock and E<.Fa op> is the E<.Xr fcntl 2> "
"operation to perform.  Valid values are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1190
#, no-wrap
msgid "F_SETLK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1192
msgid "set lock"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1192
#, no-wrap
msgid "F_GETLK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1194
msgid "get the first conflicted lock"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1194
#, no-wrap
msgid "F_UNLCK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1196
msgid "clear lock"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1210
msgid ""
"The argument E<.Fa fl> is a description of the lock.  In the case of E<.Dv "
"SEEK_CUR>, The caller should add the current file offset to "
"fl-\\*[Gt]l_start beforehand.  E<.Fn VOP_ADVLOCK> treats E<.Dv SEEK_CUR> as "
"E<.Dv SEEK_SET>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1215
msgid "The argument E<.Fa flags> is the set of flags.  Valid values are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1217
#, no-wrap
msgid "F_WAIT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1219
msgid "wait until lock is granted"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1219
#, no-wrap
msgid "F_FLOCK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1223
msgid "use E<.Xr flock 2> semantics for lock"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1223
#, no-wrap
msgid "F_POSIX"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1225
msgid "use POSIX semantics for lock"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1229
msgid ""
"If the operation is successful zero is returned, otherwise an appropriate "
"error is returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1229
#, no-wrap
msgid "Fn VOP_WHITEOUT dvp cnp flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1235
msgid ""
"Whiteout pathname component in directory with vnode E<.Fa dvp>.  The "
"argument E<.Fa cnp> specifies the pathname component to whiteout."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1235
#, no-wrap
msgid "Fn VOP_GETPAGES vp offset m count centeridx access_type advice flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1257
msgid ""
"Read VM pages from file.  The argument E<.Fa vp> is the locked vnode to read "
"the VM pages from.  The argument E<.Fa offset> is offset in the file to "
"start accessing and E<.Fa m> is an array of VM pages.  The argument E<.Fa "
"count> points a variable that specifies the number of pages to read.  If the "
"operation is successful zero is returned, otherwise an appropriate error "
"code is returned.  If PGO_LOCKED is specified in E<.Em flags>, E<.Fn "
"VOP_GETPAGES> might return less pages than requested.  In that case, the "
"variable pointed to by E<.Em count> will be updated."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1259
msgid "This function is primarily used by the page-fault handing mechanism."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1259
#, no-wrap
msgid "Fn VOP_PUTPAGES vp offlo offhi flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1286
msgid ""
"Write modified (dirty) VM pages to file.  The argument E<.Fa vp> is the "
"vnode to write the VM pages to.  The vnode's vm object lock E<.Va ( "
"v_uobj.vmobjlock>)  must be held by the caller and will be released upon "
"return.  The arguments E<.Fa offlo> and E<.Fa offhi> specify the range of VM "
"pages to write.  In case E<.Fa offhi> is given as 0, all pages at and after "
"the start offset E<.Fa offlo> belonging the vnode E<.Fa vp> will be "
"written.  The argument E<.Fa flags> controls the behavior of the routine and "
"takes the vm pager's flags E<.Dv ( PGO_ -prefixed>).  If the operation is "
"successful zero is returned, otherwise an appropriate error code is "
"returned."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1295
msgid ""
"The function is primarily used by the pageout handling mechanism and is "
"commonly implemented indirectly by E<.Fn genfs_putpages> with the help of "
"E<.Fn VOP_STRATEGY> and E<.Fn VOP_BMAP>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1295
#, no-wrap
msgid "Fn VOP_STRATEGY vp bp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1308
msgid ""
"Read/write a file system buffer.  The argument E<.Fa vp> is the vnode to "
"read/write to.  The argument E<.Fa bp> is the buffer to be read or written.  "
"E<.Fn VOP_STRATEGY> will either read or write data to the file depending on "
"the value of E<.Em bp-\\*[Gt]b_flags>.  If the operation is successful zero "
"is returned, otherwise an appropriate error code is returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1308
#, no-wrap
msgid "Fn VOP_BWRITE vp bp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1318
msgid ""
"Write a file system buffer.  The argument E<.Fa vp> is the vnode to write "
"to.  The argument E<.Fa bp> specifies the buffer to be written.  If the "
"operation is successful zero is returned, otherwise an appropriate error "
"code is returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1318
#, no-wrap
msgid "Fn VOP_GETEXTATTR vp attrnamespace name uio size cred"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1351
msgid ""
"Get an extended attribute.  The argument E<.Fa vp> is the locked vnode of "
"the file or directory from which to retrieve the attribute.  The argument "
"E<.Fa attrnamespace> specifies the extended attribute namespace.  The "
"argument E<.Fa name> is a nul-terminated character string naming the "
"attribute to retrieve.  The argument E<.Fa uio>, if not E<.Dv NULL>, "
"specifies where the extended attribute value is to be written.  The argument "
"E<.Fa size>, if not E<.Dv NULL>, will contain the number of bytes required "
"to read all of the attribute data upon return.  In most cases, E<.Fa uio> "
"will be E<.Dv NULL> when E<.Fa size> is not, and vice versa.  The argument "
"E<.Fa cred> specifies the user credentials to use when authorizing the "
"request."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1351
#, no-wrap
msgid "Fn VOP_SETEXTATTR vp attrnamespace name uio cred"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1369
msgid ""
"Set an extended attribute.  The argument E<.Fa vp> is the locked vnode of "
"the file or directory to which to store the attribute.  The argument E<.Fa "
"namespace> specifies the extended attribute namespace.  The argument E<.Fa "
"name> is a nul-terminated character string naming the attribute to store.  "
"The argument E<.Fa uio> specifies the source of the extended attribute "
"data.  The argument E<.Fa cred> specifies the user credentials to use when "
"authorizing the request."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1369
#, no-wrap
msgid "Fn VOP_LISTEXTATTR vp attrnamespace uio size cred"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1398
msgid ""
"Retrieve the list of extended attributes.  The argument E<.Fa vp> is the "
"locked vnode of the file or directory whose attributes are to be listed.  "
"The argument E<.Fa attrnamespace> specifies the extended attribute "
"namespace.  The argument E<.Fa uio>, if not E<.Dv NULL>, specifies where the "
"extended attribute list is to be written.  The argument E<.Fa size>, if not "
"E<.Dv NULL>, will contain the number of bytes required to read all of the "
"attribute names upon return.  In most cases, E<.Fa uio> will be E<.Dv NULL> "
"when E<.Fa size> is not, and vice versa.  The argument E<.Fa cred> specifies "
"the user credentials to use when authorizing the request."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1398
#, no-wrap
msgid "Fn VOP_DELETEEXTATTR vp attrnamespace name cred"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1410
msgid ""
"Remove attribute E<.Fa name> from file associated with E<.Fa vp>.  The "
"argument E<.Fa attrnamespace> specifies the extended attribute namespace.  "
"If full removal is not supported, the file system should return E<.Er "
"EOPNOTSUPP> to allow the caller to zero out the value with E<.Fn "
"VOP_SETEXTATTR>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1413
#, no-wrap
msgid "Bq Er EACCES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1415
msgid "Access for the specified operation is denied."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1415
#, no-wrap
msgid "Bq Er EDQUOT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1417
msgid "Quota exceeded."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1420
msgid "attempt to read from an illegal offset in the directory; unrecognized input"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1420
#, no-wrap
msgid "Bq Er EIO"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1423
msgid ""
"a read error occurred while reading the directory or reading the contents of "
"a symbolic link"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1423
#, no-wrap
msgid "Bq Er EJUSTRETURN"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1425
msgid "A CREATE or RENAME operation would be successful."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1425
#, no-wrap
msgid "Bq Er ENOATTR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1427
msgid "The requested attribute is not defined for this vnode."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1429
msgid "The component was not found in the directory."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1431
msgid "The file system is full."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1431
#, no-wrap
msgid "Bq Er ENOTDIR"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1433
msgid "The vnode does not represent a directory."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1433
#, no-wrap
msgid "Bq Er ENOTEMPTY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1435
msgid "attempt to remove a directory which is not empty"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1435
#, no-wrap
msgid "Bq Er EPERM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1437
msgid "an attempt was made to change an immutable file"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnodeops.9:1437
#, no-wrap
msgid "Bq Er EROFS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1439
msgid "the file system is read-only"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1448
msgid ""
"E<.Xr extattr 9>, E<.Xr intro 9>, E<.Xr namei 9>, E<.Xr vattr 9>, E<.Xr vfs "
"9>, E<.Xr vfsops 9>, E<.Xr vnode 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnodeops.9:1451
msgid ""
"The vnode operations vector, its functions and the corresponding macros "
"appeared in E<.Bx 4.3>."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/vnsubr.9:30
#, no-wrap
msgid "January 30, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/vnsubr.9:31
#, no-wrap
msgid "VNSUBR 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:46
msgid ""
"E<.Nm vnsubr>, E<.Nm vn_bwrite>, E<.Nm vn_close>, E<.Nm vn_default_error>, "
"E<.Nm vn_isunder>, E<.Nm vn_lock>, E<.Nm vn_markexec>, E<.Nm vn_marktext>, "
"E<.Nm vn_rdwr>, E<.Nm vn_open>, E<.Nm vn_stat>, E<.Nm vn_writechk>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/vnsubr.9:46
#, no-wrap
msgid "high-level convenience functions for vnode operations"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:79
msgid ""
"E<.Ft int> E<.Fn vn_bwrite \"void *ap\"> E<.Ft int> E<.Fn vn_close \"struct "
"vnode *vp\" \"int flags\" \"kauth_cred_t cred\"> E<.Ft int> E<.Fn "
"vn_default_error \"void *v\"> E<.Ft int> E<.Fn vn_isunder \"struct vnode "
"*dvp\" \"struct vnode *rvp\" \"struct lwp *l\"> E<.Ft int> E<.Fn vn_lock "
"\"struct vnode *vp\" \"int flags\"> E<.Ft void> E<.Fn vn_markexec \"struct "
"vnode *vp\"> E<.Ft void> E<.Fn vn_marktext \"struct vnode *vp\"> E<.Ft int> "
"E<.Fn vn_open \"struct nameidata *ndp\" \"int fmode\" \"int cmode\"> E<.Ft "
"int> E<.Fo vn_rdwr> E<.Fa \"enum uio_rw rw\" \"struct vnode *vp\" \"void "
"*base\"> E<.Fa \"int len\" \"off_t offset\" \"enum uio_seg segflg\" \"int "
"ioflg\"> E<.Fa \"kauth_cred_t cred\" \"size_t *aresid\" \"struct lwp *l\"> "
"E<.Fc> E<.Ft int> E<.Fn vn_readdir \"file_t *fp\" \"char *buf\" \"int "
"segflg\" \"u_int count\" \"int *done\" \"struct lwp *l\" \"off_t **cookies\" "
"\"int *ncookies\"> E<.Ft int> E<.Fn vn_stat \"struct vnode *vp\" \"struct "
"stat *sb\"> E<.Ft int> E<.Fn vn_writechk \"struct vnode *vp\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:83
msgid ""
"The high-level functions described in this page are convenience functions "
"for simplified access to the vnode operations described in E<.Xr vnodeops "
"9>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnsubr.9:85
#, no-wrap
msgid "Fn vn_bwrite ap"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:87
msgid "Common code for block write operations."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnsubr.9:87
#, no-wrap
msgid "Fn vn_close vp flags cred"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:104
msgid ""
"Common code for a vnode close.  The argument E<.Fa vp> is the unlocked vnode "
"of the vnode to close.  E<.Fn vn_close> simply locks the vnode, invokes the "
"vnode operation E<.Xr VOP_CLOSE 9> and calls E<.Fn vput> to return the vnode "
"to the freelist or holdlist.  Note that E<.Fn vn_close> expects an unlocked, "
"referenced vnode and will dereference the vnode prior to returning.  If the "
"operation is successful zero is returned, otherwise an appropriate error is "
"returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnsubr.9:104
#, no-wrap
msgid "Fn vn_default_error v"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:108
msgid ""
"A generic \"default\" routine that just returns error.  It is used by a file "
"system to specify unsupported operations in the vnode operations vector."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnsubr.9:108
#, no-wrap
msgid "Fn vn_isunder dvp rvp l"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:125
msgid ""
"Common code to check if one directory specified by the vnode E<.Fa rvp> can "
"be found inside the directory specified by the vnode E<.Fa dvp>.  The "
"argument E<.Fa l> is the calling process.  E<.Fn vn_isunder> is intended to "
"be used in E<.Xr chroot 2>, E<.Xr chdir 2>, E<.Xr fchdir 2>, etc., to ensure "
"that E<.Xr chroot 2> actually means something.  If the operation is "
"successful zero is returned, otherwise 1 is returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnsubr.9:125
#, no-wrap
msgid "Fn vn_lock vp flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:132
msgid ""
"Common code to acquire the lock for vnode E<.Fa vp>.  The argument E<.Fa "
"flags> specifies the flags used to lock the vnode.  There are the following "
"flags:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnsubr.9:134
#, no-wrap
msgid "LK_SHARED"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:136
msgid "shared lock"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnsubr.9:136
#, no-wrap
msgid "LK_EXCLUSIVE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:138
msgid "exclusive lock"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnsubr.9:138
#, no-wrap
msgid "LK_NOWAIT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:140
msgid "do not sleep to await lock"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnsubr.9:140
#, no-wrap
msgid "LK_RETRY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:142
msgid "retry lock operation until locked"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:149
msgid ""
"If the operation is successful zero is returned, otherwise an appropriate "
"error code is returned.  The vnode interlock E<.Em v_interlock> is released "
"on return."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:155
msgid ""
"E<.Fn vn_lock> must not be called when the vnode's reference count is zero.  "
"Instead, E<.Xr vget 9> should be used."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnsubr.9:155
#, no-wrap
msgid "Fn vn_markexec vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:159
msgid ""
"Common code to mark the vnode E<.Fa vp> as containing executable code of a "
"running process."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnsubr.9:159
#, no-wrap
msgid "Fn vn_marktext vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:163
msgid ""
"Common code to mark the vnode E<.Fa vp> as being the text of a running "
"process."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnsubr.9:163
#, no-wrap
msgid "Fn vn_open ndp fmode cmode"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:182
msgid ""
"Common code for vnode open operations.  The pathname is described in the "
"nameidata pointer (see E<.Xr namei 9>).  The arguments E<.Fa fmode> and "
"E<.Fa cmode> specify the E<.Xr open 2> file mode and the access permissions "
"for creation.  E<.Fn vn_open> checks permissions and invokes the E<.Xr "
"VOP_OPEN 9> or E<.Xr VOP_CREATE 9> vnode operations.  If the operation is "
"successful zero is returned and the vnode is locked, otherwise an "
"appropriate error code is returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnsubr.9:182
#, no-wrap
msgid "Fn vn_rdwr rw vp base len offset segflg ioflg cred aresid l"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:210
msgid ""
"Common code to package up an I/O request on a vnode into a uio and then "
"perform the I/O.  The argument E<.Fa rw> specifies whether the I/O is a read "
"E<.Pq Dv UIO_READ> or write E<.Pq Dv UIO_WRITE> operation.  The vnode is "
"specified by E<.Fa vp>.  The arguments E<.Fa l> and E<.Fa cred> are the "
"calling lwp and its credentials.  If E<.Fa ioflg> contains E<.Dv "
"IO_NODELOCKED>, it is expected that the vnode is locked.  E<.Fa ioflg> will "
"be passed to E<.Fn VOP_READ Ns No / Ns Fn VOP_WRITE>.  The remaining "
"arguments specify the uio parameters.  For further information on these "
"parameters see E<.Xr uiomove 9>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnsubr.9:210
#, no-wrap
msgid "Fn vn_readdir fp buf segflg count done l cookies ncookies"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:233
msgid ""
"Common code for reading the contents of a directory.  The argument E<.Fa fp> "
"is the file structure, E<.Fa buf> is the buffer for placing the struct "
"dirent structures.  The arguments E<.Fa cookies> and E<.Fa ncookies> specify "
"the addresses for the list and number of directory seek cookies generated "
"for NFS.  Both E<.Fa cookies> and E<.Fa ncookies> should be E<.Dv NULL> if "
"they aren't required to be returned by E<.Fn vn_readdir>.  If the operation "
"is successful zero is returned, otherwise an appropriate error code is "
"returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnsubr.9:233
#, no-wrap
msgid "Fn vn_stat vp sb"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:246
msgid ""
"Common code for a vnode stat operation.  The vnode is specified by the "
"argument E<.Fa vp>, and E<.Fa sb> is the buffer to return the stat "
"information.  E<.Fn vn_stat> basically calls the vnode operation E<.Xr "
"VOP_GETATTR 9> and transfers the contents of a vattr structure into a struct "
"stat.  If the operation is successful zero is returned, otherwise an "
"appropriate error code is returned."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnsubr.9:246
#, no-wrap
msgid "Fn vn_writechk vp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:252
msgid ""
"Common code to check for write permission on the vnode E<.Fa vp>.  A vnode "
"is read-only if it is in use as a process's text image.  If the vnode is "
"read-only ETEXTBSY is returned, otherwise zero is returned to indicate that "
"the vnode can be written to."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnsubr.9:255
#, no-wrap
msgid "Bq Er EBUSY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:259
msgid "The LK_NOWAIT flag was set and E<.Fn vn_lock> would have slept."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:263
msgid ""
"The vnode has been reclaimed and is dead.  This error is only returned if "
"the LK_RETRY flag is not passed to E<.Fn vn_lock>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/vnsubr.9:263
#, no-wrap
msgid "Bq Er ETXTBSY"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:265
msgid "Cannot write to a vnode since is a process's text image."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:271
msgid ""
"The high-level convenience functions are implemented within the files E<.Pa "
"sys/kern/vfs_vnops.c> and E<.Pa sys/sys/vnode.h>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/vnsubr.9:279
msgid ""
"E<.Xr file 9>, E<.Xr intro 9>, E<.Xr lock 9>, E<.Xr namei 9>, E<.Xr vattr "
"9>, E<.Xr vfs 9>, E<.Xr vnode 9>, E<.Xr vnodeops 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/wdc.9:26
#, no-wrap
msgid "April 18, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/wdc.9:27
#, no-wrap
msgid "WDC 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:31
msgid "E<.Nm wdc>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/wdc.9:31
#, no-wrap
msgid "machine-independent IDE/ATAPI driver"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/wdc.9:33
#, no-wrap
msgid "dev/ata/atavar.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/wdc.9:34
#, no-wrap
msgid "sys/dev/ic/wdcvar.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:39
msgid ""
"E<.Ft int> E<.Fn wdcprobe \"struct channel_softc * chp\"> E<.Ft void> E<.Fn "
"wdcattach \"struct channel_softc * chp\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:52
msgid ""
"The E<.Nm> driver provides the machine independent core functions for "
"driving IDE devices.  IDE devices-specific drivers E<.Po> E<.Xr wd 4> or "
"E<.Xr atapibus 4> E<.Pc> will use services provided by E<.Nm>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:66
msgid ""
"The machine-dependent bus front-end provides informations to E<.Nm> with the "
"E<.Va wdc_softc> and E<.Va channel_softc> structures.  The first one defines "
"global controller properties, and the second contains per-channel "
"informations.  E<.Nm> returns informations about the attached devices in the "
"E<.Va ata_drive_datas> structure."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:88
#, no-wrap
msgid ""
"struct wdc_softc { /* Per controller state */\n"
"        struct device sc_dev;\n"
"        int           cap;\n"
"#define WDC_CAPABILITY_DATA16 0x0001\n"
"#define WDC_CAPABILITY_DATA32 0x0002\n"
"#define WDC_CAPABILITY_MODE   0x0004\n"
"#define WDC_CAPABILITY_DMA    0x0008\n"
"#define WDC_CAPABILITY_UDMA   0x0010\n"
"#define WDC_CAPABILITY_HWLOCK 0x0020\n"
"#define WDC_CAPABILITY_ATA_NOSTREAM 0x0040\n"
"#define WDC_CAPABILITY_ATAPI_NOSTREAM 0x0080\n"
"#define WDC_CAPABILITY_NO_EXTRA_RESETS 0x0100\n"
"#define WDC_CAPABILITY_PREATA 0x0200\n"
"#define WDC_CAPABILITY_IRQACK 0x0400\n"
"#define WDC_CAPABILITY_SINGLE_DRIVE 0x0800\n"
"#define WDC_CAPABILITY_NOIRQ  0x1000\n"
"#define WDC_CAPABILITY_SELECT  0x2000\n"
"        uint8_t      pio_mode;\n"
"        uint8_t      dma_mode;\n"
"        int nchannels;\n"
"        struct channel_softc *channels;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:95
#, no-wrap
msgid ""
"        void            *dma_arg;\n"
"        int            (*dma_init)(void *, int, int, void *, size_t, int);\n"
"        void           (*dma_start)(void *, int, int, int);\n"
"        int            (*dma_finish)(void *, int, int, int);\n"
"#define WDC_DMA_READ 0x01\n"
"#define WDC_DMA_POLL 0x02\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:99
#, no-wrap
msgid ""
"        int            (*claim_hw)(void *, int);\n"
"        void            (*free_hw)(void *);\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:117
#, no-wrap
msgid ""
"struct channel_softc { /* Per channel data */\n"
"        int channel;\n"
"        struct wdc_softc *wdc;\n"
"        bus_space_tag_t       cmd_iot;\n"
"        bus_space_handle_t    cmd_ioh;\n"
"        bus_space_tag_t       ctl_iot;\n"
"        bus_space_handle_t    ctl_ioh;\n"
"        bus_space_tag_t       data32iot;\n"
"        bus_space_handle_t    data32ioh;\n"
"        int ch_flags;\n"
"#define WDCF_ACTIVE   0x01\n"
"#define WDCF_IRQ_WAIT 0x10\n"
"        uint8_t ch_status;\n"
"        uint8_t ch_error;\n"
"        struct ata_drive_datas ch_drive[2];\n"
"        struct channel_queue *ch_queue;\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:132
#, no-wrap
msgid ""
"struct ata_drive_datas {\n"
"    uint8_t drive;\n"
"    uint8_t drive_flags;\n"
"#define DRIVE_ATA   0x01\n"
"#define DRIVE_ATAPI 0x02\n"
"#define DRIVE (DRIVE_ATA|DRIVE_ATAPI)\n"
"#define DRIVE_CAP32 0x04\n"
"#define DRIVE_DMA   0x08\n"
"#define DRIVE_UDMA  0x10\n"
"#define DRIVE_MODE 0x20\n"
"    uint8_t PIO_mode;\n"
"    uint8_t DMA_mode;\n"
"    uint8_t UDMA_mode;\n"
"    uint8_t state;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:136
#, no-wrap
msgid ""
"    struct device *drv_softc;\n"
"    void* chnl_softc;\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:140
msgid ""
"The bus front-end needs to fill in the following elements of E<.Va "
"wdc_softc>:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:141
#, no-wrap
msgid "cap"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:143
msgid "supports one or more of the WDC_CAPABILITY flags"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:143
#, no-wrap
msgid "nchannels"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:145
msgid "number of channels supported by this controller"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:145
#, no-wrap
msgid "channels"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:151
msgid ""
"array of E<.Va struct channel_softc> of size E<.Va nchannels> properly "
"initialised"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:153 org_netbsd/src/share/man/man9/wdc.9:302
msgid "The following elements are optional:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:154
#, no-wrap
msgid "pio_mode"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:155
#, no-wrap
msgid "dma_mode"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:156
#, no-wrap
msgid "dma_arg"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:157
#, no-wrap
msgid "dma_init"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:158
#, no-wrap
msgid "dma_start"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:159
#, no-wrap
msgid "dma_finish"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:160
#, no-wrap
msgid "claim_hw"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:161
#, no-wrap
msgid "free_hw"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:173
msgid ""
"The E<.Dv WDC_CAPABILITY_DATA16> and E<.Dv WDC_CAPABILITY_DATA32> flags "
"informs E<.Nm> whether the controller supports 16- or 32-bit I/O accesses on "
"the data port.  If both are set, a test will be done for each drive using "
"the ATA or ATAPI IDENTIFY command, to automatically select the working mode."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:211
msgid ""
"The E<.Dv WDC_CAPABILITY_DMA> and E<.Dv WDC_CAPABILITY_UDMA> flags are set "
"for controllers supporting the DMA and Ultra-DMA modes.  The bus front-end "
"needs to provide the E<.Fn dma_init>, E<.Fn dma_start> and E<.Fn dma_finish> "
"functions.  E<.Fn dma_init> is called just before issuing a DMA command to "
"the IDE device.  The arguments are, respectively: E<.Va dma_arg>, the "
"channel number, the drive number on this channel, the virtual address of the "
"DMA buffer, the size of the transfer, and the E<.Dv WDC_DMA> flags.  E<.Fn "
"dma_start> is called just after issuing a DMA command to the IDE device.  "
"The arguments are, respectively: E<.Va dma_arg>, the channel number, the "
"drive number on this channel, and the E<.Dv WDC_DMA> flags.  E<.Fn "
"dma_finish> is called once the transfer is complete.  The arguments are, "
"respectively: E<.Va dma_arg>, the channel number, the drive number on this "
"channel, and the E<.Dv WDC_DMA> flags.  E<.Dv WDC_DMA_READ> indicates the "
"direction of the data transfer, and E<.Dv WDC_DMA_POLL> indicates if the "
"transfer will use (or used) interrupts."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:234
msgid ""
"The E<.Dv WDC_CAPABILITY_MODE> flag means that the bus front-end can program "
"the PIO and DMA modes, so E<.Nm> needs to provide back the supported modes "
"for each drive, and set the drives modes.  The E<.Va pio_mode> and E<.Va "
"dma_mode> needs to be set to the highest PIO and DMA mode supported.  If "
"E<.Dv WDC_CAPABILITY_UDMA> is set, then E<.Va dma_mode> must be set to the "
"highest Ultra-DMA mode supported.  If E<.Dv WDC_CAPABILITY_MODE> is not set, "
"E<.Nm> will not attempt to change the current drive's settings, assuming the "
"host's firmware has done it right."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:259
msgid ""
"The E<.Dv WDC_CAPABILITY_HWLOCK> flag is set for controllers needing "
"hardware looking before accessing the I/O ports.  If this flag is set, the "
"bus front-end needs to provide the E<.Fn claim_hw> and E<.Fn free_hw> "
"functions.  E<.Fn claim_hw> will be called when the driver wants to access "
"the controller ports.  The second parameter is set to 1 when it is possible "
"to sleep waiting for the lock, 0 otherwise.  It should return 1 when access "
"has been granted, 0 otherwise.  When access has not been granted and sleep "
"is not allowed, the bus front-end shall call E<.Fn wdcrestart> with the "
"first argument passed to E<.Fn claim_hw> as argument.  This arguments will "
"also be the one passed to E<.Fn free_hw>.  This function is called once the "
"transfer is complete, so that the lock can be released."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:273
msgid ""
"Accesses to the data port are done by using the bus_space stream functions, "
"unless the E<.Dv WDC_CAPABILITY_ATA_NOSTREAM> or E<.Dv "
"WDC_CAPABILITY_ATAPI_NOSTREAM> flags are set.  This should not be used, "
"unless the data bus is not wired properly (which seems common on big-endian "
"systems), and byte-order needs to be preserved for compatibility with the "
"host's firmware.  Also note that the IDE bus is a little-endian bus, so the "
"bus_space functions used for the bus_space tag passed in the E<.Va "
"channel_softc> have to do the appropriate byte-swapping for big-endian "
"systems."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:278
msgid ""
"E<.Dv WDC_CAPABILITY_NO_EXTRA_RESETS> avoid the controller reset at the end "
"of the disks probe.  This reset is needed for some controllers, but causes "
"problems with some others."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:282
msgid ""
"E<.Dv WDC_CAPABILITY_NOIRQ> tells the driver that this controller doesn't "
"have its interrupt lines wired up usefully, so it should always use polled "
"transfers."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:286
msgid ""
"The bus front-end needs to fill in the following elements of E<.Va "
"channel_softc>:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:287
#, no-wrap
msgid "channel"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:289
msgid "The channel number on the controller"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:289
#, no-wrap
msgid "wdc"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:291
msgid "A pointer to the controller's wdc_softc"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:291
#, no-wrap
msgid "cmd_iot, cmd_ioh"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:294
msgid ""
"Bus-space tag and handle for access to the command block registers (which "
"includes the 16-bit data port)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:294
#, no-wrap
msgid "ctl_iot, ctl_ioh"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:296
msgid "Bus-space tag and handle for access to the control block registers"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:296
#, no-wrap
msgid "ch_queue"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:300
msgid ""
"A pointer to a E<.Va struct channel_queue>.  This will hold the queues of "
"outstanding commands for this controller."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:303
#, no-wrap
msgid "data32iot, data32ioh"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:309
msgid ""
"Bus-space tag and handle for 32-bit data accesses.  Only needed if E<.Dv "
"WDC_CAPABILITY_DATA32> is set in the controller's E<.Va wdc_softc>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:319
msgid ""
"E<.Va ch_queue> can point to a common E<.Va struct channel_queue> if the "
"controller doesn't support concurrent access to its different channels.  If "
"all channels are independent, it is recommended that each channel has its "
"own E<.Va ch_queue> (for better performance)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:332
msgid ""
"The bus-specific front-end can use the E<.Fn wdcprobe> function, with a "
"properly initialised E<.Va struct channel_softc> as argument ( E<.Va wdc> "
"can be set to NULL.  This allows E<.Fn wdcprobe> to be easily used in bus "
"front-end probe functions).  This function will return an integer where bit "
"0 will be set if the master device has been found, and 1 if the slave device "
"has been found."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:346
msgid ""
"The bus-specific attach function has to call E<.Fn wdcattach> for each "
"channel, with a pointer to a properly initialised E<.Va channel softc> as "
"argument.  This will probe devices attached to the IDE channel and attach "
"them.  Once this function returns, the E<.Va ch_drive> array of the E<.Va "
"channel_softc> will contain the drive's capabilities.  This can be used to "
"properly initialise the controller's mode, or disable a channel without "
"drives."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:350
msgid "The elements of interest in E<.Va ata_drive_datas> for a bus front-end are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:351
#, no-wrap
msgid "drive"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:353
msgid "The drive number"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:353
#, no-wrap
msgid "drive_flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:359
msgid ""
"Flags indicating the drive capabilities.  A null E<.Va drive_flags> indicate "
"either that no drive is here, or that no driver was found for this device."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:359
#, no-wrap
msgid "PIO_mode, DMA_mode, UDMA_mode"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:363
msgid ""
"the highest supported modes for this drive compatible with the controller's "
"capabilities.  Needs to be reset to the mode to use by the drive, if known."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:363
#, no-wrap
msgid "drv_softc"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:366
msgid "A pointer to the drive's softc.  Can be used to print the drive's name."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:370
msgid "E<.Va drive_flags> handles the following flags:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:371
#, no-wrap
msgid "DRIVE_ATA, DRIVE_ATAPI"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:374
msgid ""
"Gives the drive type, if any.  The shortcut DRIVE can be used to just test "
"the presence/absence of a drive."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:374
#, no-wrap
msgid "DRIVE_CAP32"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:376
msgid "This drive works with 32-bit data I/O."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:376
#, no-wrap
msgid "DRIVE_DMA"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:378
msgid "This drive supports DMA."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:378
#, no-wrap
msgid "DRIVE_UDMA"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:380
msgid "This drive supports Ultra-DMA."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wdc.9:380
#, no-wrap
msgid "DRIVE_MODE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:382
msgid "This drive properly reported its PIO and DMA mode."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:394
msgid ""
"Once the controller has been initialised, it has to reset the E<.Dv "
"DRIVE_DMA> and E<.Dv DRIVE_UDMA>, as well as the values of E<.Va PIO_mode>, "
"E<.Va DMA_mode> and E<.Va UDMA_mode> if the modes to be used are not highest "
"ones supported by the drive."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:397
msgid "E<.Xr wdc 4>, E<.Xr bus_space 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:405
msgid ""
"The wdc core functions are implemented in E<.Pa sys/dev/ic/wdc.c>.  "
"Low-level ATA and ATAPI support is provided by E<.Pa sys/dev/ata_wdc.c> and "
"E<.Pa sys/dev/scsipi/atapi_wdc.c> respectively."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wdc.9:412
msgid ""
"An example of a simple bus front-end can be found in E<.Pa "
"sys/dev/isapnp/wdc_isapnp.c>.  A more complex one, with multiple channels "
"and bus-master DMA support is E<.Pa sys/dev/pci/pciide.c>.  E<.Pa "
"sys/arch/atari/dev/wdc_mb.c> makes use of hardware locking, and also "
"provides an example of bus-front end for a big-endian system, which needs "
"byte-swapping bus_space functions."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/workqueue.9:29
#, no-wrap
msgid "WORKQUEUE 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/workqueue.9:34
msgid "E<.Nm workqueue>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/workqueue.9:34
#, no-wrap
msgid "simple do-it-in-thread-context framework"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/workqueue.9:37
#, no-wrap
msgid "sys/workqueue.h"
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/workqueue.9:53
msgid ""
"E<.Ft int> E<.Fn workqueue_create \"struct workqueue **wqp\" \"const char "
"*name\" \"void (*func)(struct work *, void *)\" \"void *arg\" \"pri_t prio\" "
"\"int ipl\" \"int flags\"> E<.Ft void> E<.Fn workqueue_enqueue \"struct "
"workqueue *wq\" \"struct work *wk\" \"struct cpu_info *ci\"> E<.Ft void> "
"E<.Fn workqueue_destroy \"struct workqueue *wq\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/workqueue.9:58
msgid ""
"The E<.Nm> utility routines are provided to defer work which is needed to be "
"processed in a thread context."
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/workqueue.9:63
msgid ""
"E<.Fn workqueue_create> creates a workqueue.  It takes the following "
"arguments:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/workqueue.9:64
#, no-wrap
msgid "Fa wqp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/workqueue.9:66
msgid "Specify where to store the created workqueue."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/workqueue.9:68
msgid "The name of the workqueue."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/workqueue.9:71
msgid "The function to be called for each E<.Fa work>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/workqueue.9:74
msgid "An argument to be passed as a second argument of E<.Fa func>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/workqueue.9:74
#, no-wrap
msgid "Fa prio"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/workqueue.9:76
msgid "The priority level for the worker threads."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/workqueue.9:78
msgid "The highest IPL at which this workqueue is used."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/workqueue.9:81
msgid ""
"The value of 0 indicates a standard create operation, however the following "
"flags may be bitwise ORed together:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/workqueue.9:82
#, no-wrap
msgid "Dv WQ_MPSAFE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/workqueue.9:85
msgid ""
"Specifies that the workqueue is multiprocessor safe and does its own "
"locking, otherwise the kernel lock will be held while work will be "
"processed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/workqueue.9:85
#, no-wrap
msgid "Dv WQ_PERCPU"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/workqueue.9:88
msgid ""
"Specifies that the workqueue should have a separate queue for each CPU, thus "
"the work could be enqueued on concrete CPUs."
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#. type: Plain text
#: org_netbsd/src/share/man/man9/workqueue.9:97
msgid ""
"E<.Fn workqueue_enqueue> enqueues the work E<.Fa wk> into the workqueue "
"E<.Fa wq>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/workqueue.9:113
msgid ""
"If the E<.Dv WQ_PERCPU> flag was set on workqueue creation, the E<.Fa ci> "
"argument may be used to specify the CPU on which the work should be "
"enqueued.  Also it may be E<.Dv NULL>, then work will be enqueued on the "
"current CPU.  If E<.Dv WQ_PERCPU> flag was not set, E<.Fa ci> must be E<.Dv "
"NULL>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/workqueue.9:119
msgid ""
"The enqueued work will be processed in a thread context.  A work must not be "
"enqueued again until the callback is called by the E<.Nm> framework."
msgstr ""

#.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/workqueue.9:125
msgid ""
"E<.Fn workqueue_destroy> destroys a workqueue and frees associated "
"resources.  The caller should ensure that the workqueue has no work enqueued "
"beforehand."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/workqueue.9:131
msgid ""
"E<.Fn workqueue_create> returns 0 on success.  Otherwise, it returns an "
"E<.Xr errno 2>."
msgstr ""

#.  ------------------------------------------------------------
#. type: Plain text
#: org_netbsd/src/share/man/man9/workqueue.9:137
msgid ""
"The E<.Nm> subsystem is implemented within the file E<.Pa "
"sys/kern/subr_workqueue.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/workqueue.9:141
msgid "E<.Xr callout 9>, E<.Xr condvar 9>, E<.Xr kthread 9>, E<.Xr softint 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/wscons.9:31
#, no-wrap
msgid "WSCONS 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wscons.9:35
msgid "E<.Nm wscons>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/wscons.9:35
#, no-wrap
msgid "machine-independent console support"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wscons.9:42
msgid ""
"The E<.Nm> driver provides a machine-independent framework for workstation "
"consoles.  It consists of several cooperating modules:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wscons.9:46
msgid "display adapters (see E<.Xr wsdisplay 9>)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wscons.9:49
msgid "keyboards (see E<.Xr wskbd 9>)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wscons.9:52
msgid "pointers and mice (see E<.Xr wsmouse 9>)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wscons.9:54
msgid "input event multiplexor"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wscons.9:57
msgid "font handling (see E<.Xr wsfont 9>)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wscons.9:60
msgid "terminal emulation (see E<.Xr wsdisplay 9>)"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wscons.9:64
msgid ""
"The wscons framework replaces the old rcons workstation framework and the "
"various machine-dependent console implementations."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wscons.9:67
msgid ""
"The wscons subsystem is implemented within the directory E<.Pa "
"sys/dev/wscons>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wscons.9:75
msgid ""
"E<.Xr wscons 4>, E<.Xr cons 9>, E<.Xr driver 9>, E<.Xr intro 9>, E<.Xr "
"wsdisplay 9>, E<.Xr wsfont 9>, E<.Xr wskbd 9>, E<.Xr wsmouse 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/wsdisplay.9:30
#, no-wrap
msgid "April 15, 2006"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/wsdisplay.9:31
#, no-wrap
msgid "WSDISPLAY 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:39
msgid ""
"E<.Nm wsdisplay>, E<.Nm wsdisplay_switchtoconsole>, E<.Nm "
"wsdisplay_cnattach>, E<.Nm wsdisplaydevprint>, E<.Nm wsemuldisplaydevprint>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/wsdisplay.9:39
#, no-wrap
msgid "wscons display support"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/wsdisplay.9:41 org_netbsd/src/share/man/man9/wsfont.9:46 org_netbsd/src/share/man/man9/wskbd.9:42 org_netbsd/src/share/man/man9/wsmouse.9:39
#, no-wrap
msgid "dev/wscons/wsconsio.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/wsdisplay.9:43
#, no-wrap
msgid "dev/wscons/wsemulvar.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/wsdisplay.9:44
#, no-wrap
msgid "dev/wscons/wsemul_vt100var.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:57
msgid ""
"E<.Ft void> E<.Fn wsdisplay_switchtoconsole \"\"> E<.Ft void> E<.Fn "
"wsdisplay_cnattach \"const struct wsscreen_descr *type\" \"void *cookie\" "
"\"int ccol\" \"int crow\" \"long defattr\"> E<.Ft void> E<.Fn "
"wsemul_xxx_cnattach \"const struct wsscreen_descr *type\" \"void *cookie\" "
"\"int ccol\" \"int crow\" \"long defattr\"> E<.Ft int> E<.Fn "
"wsdisplaydevprint \"void *aux\" \"const char *pnp\"> E<.Ft int> E<.Fn "
"wsemuldisplaydevprint \"void * aux\" \"const char *pnp\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:66
msgid ""
"The E<.Nm> module is a component of the E<.Xr wscons 9> framework to provide "
"machine-independent display support.  Most of the support is provided by the "
"E<.Xr wsdisplay 4> device driver, which must be a child of the hardware "
"device driver."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:82
msgid ""
"The wscons display interface is complicated by the fact that there are two "
"different interfaces.  The first interface corresponds to the simple "
"bit-mapped display which doesn't provide terminal-emulation and console "
"facilities.  The second interface provides machine-independent terminal "
"emulation for displays that can support glass-tty terminal emulations.  "
"These are character-oriented displays, with row and column numbers starting "
"at zero in the upper left hand corner of the screen.  Display drivers which "
"cannot emulate terminals use the first interface.  In most cases, the "
"low-level hardware driver can use the E<.Xr rasops 9> interface to provide "
"enough support to allow glass-tty terminal emulation.  If the display is not "
"the console, terminal emulation does not make sense and the display operates "
"using the bit-mapped interface."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:88
msgid ""
"The wscons framework allows concurrent displays to be active.  It also "
"provides support for multiple screens for each display and therefore allows "
"a virtual terminal on each screen.  Multiple terminal emulations and fonts "
"can be active at the same time allowing different emulations and fonts for "
"each screen."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:93
msgid ""
"Font manipulation facilities for the terminal emulation interface are "
"available through the E<.Xr wsfont 9> module."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:96
msgid ""
"Display drivers providing support for wscons displays will make use of the "
"following data types:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsdisplay.9:97
#, no-wrap
msgid "Fa struct wsdisplay_accessops"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:104
msgid ""
"A structure used to specify the display access functions invoked by userland "
"program which require direct device access, such as X11.  All displays must "
"provide this structure and pass it to the E<.Xr wsdisplay 4> child device.  "
"It has the following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:118
#, no-wrap
msgid ""
"\tint\t(*ioctl)(void *v, void *vs, u_long cmd,\n"
"\t\t\tvoid *data, int flag, struct lwp *l);\n"
"\tpaddr_t\t(*mmap)(void *v, void *vs, off_t off, int prot);\n"
"\tint\t(*alloc_screen)(void *,\n"
"\t\t\tconst struct wsscreen_descr *, void **,\n"
"\t\t\tint *, int *, long *);\n"
"\tvoid\t(*free_screen)(void *, void *);\n"
"\tint\t(*show_screen)(void *, void *, int,\n"
"\t\t\tvoid (*)(), void *);\n"
"\tint\t(*load_font)(void *, void *,\n"
"\t\t\tstruct wsdisplay_font *);\n"
"\tvoid\t(*pollc)(void *, int);\n"
"\tvoid\t(*scroll)(void *, void *, int);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:149
msgid ""
"The E<.Fa ioctl> member defines the function to be called to perform "
"display-specific ioctl calls.  The E<.Fa mmap> member defines the function "
"for mapping a part of the display device into user address space.  The E<.Fa "
"alloc_screen> member defines a function for allocating a new screen which "
"can be used as a virtual terminal.  The E<.Fa free_screen> member defines a "
"function for de-allocating a screen.  The E<.Fa show_screen> member defines "
"a function for mapping a screen onto the physical display.  This function is "
"used for switching between screens.  The E<.Fa load_font> member defines a "
"function for loading a new font into the display.  The E<.Fa pollc> member "
"defines a function for polling the console.  The E<.Fa scroll> member "
"defines a function for scrolling the contents of the display."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:154 org_netbsd/src/share/man/man9/wsdisplay.9:255
msgid ""
"There is a E<.Fa void *> cookie provided by the display driver associated "
"with these functions, which is passed to them when they are invoked."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:162
msgid ""
"The E<.Fa void *vs> cookie, passed to E<.Fn ioctl> and E<.Fn mmap>, points "
"to the virtual screen on which these operations were executed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsdisplay.9:162
#, no-wrap
msgid "Fa struct wsdisplaydev_attach_args"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:167
msgid ""
"A structure used to attach the E<.Xr wsdisplay 4> child device for the "
"simple bit-mapped interface.  It has the following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:170
#, no-wrap
msgid ""
"\tconst struct wsdisplay_accessops *accessops;\n"
"\tvoid *accesscookie;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:174
msgid ""
"If the full terminal-emulation interface is to be used, then E<.Em struct "
"wsemuldisplaydev_attach_args> should be used instead."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsdisplay.9:174
#, no-wrap
msgid "Fa struct wsemuldisplaydev_attach_args"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:179
msgid ""
"A structure used to attach the E<.Xr wsdisplay 4> child device for the full "
"terminal emulation interface.  It has the following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:184
#, no-wrap
msgid ""
"\tint console;\n"
"\tconst struct wsscreen_list *scrdata;\n"
"\tconst struct wsdisplay_accessops *accessops;\n"
"\tvoid *accesscookie;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:188
msgid ""
"If the simple bit-mapped interface is to be used, then E<.Em struct "
"wsdisplaydev_attach_args> should be used instead."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsdisplay.9:188
#, no-wrap
msgid "Fa struct wsdisplay_emulops"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:195
msgid ""
"A structure used to specify the display emulation functions.  All displays "
"intending to provide terminal emulation must provide this structure and pass "
"it to the E<.Xr wsdisplay 4> child device.  It has the following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:211
#, no-wrap
msgid ""
"\tvoid\t(*cursor)(void *c, int on, int row, int col);\n"
"\tint\t(*mapchar)(void *, int, unsigned int *);\n"
"\tvoid\t(*putchar)(void *c, int row, int col,\n"
"\t\t\tu_int uc, long attr);\n"
"\tvoid\t(*copycols)(void *c, int row, int srccol,\n"
"\t\t\tint dstcol, int ncols);\n"
"\tvoid\t(*erasecols)(void *c, int row, int startcol,\n"
"\t\t\tint ncols, long);\n"
"\tvoid\t(*copyrows)(void *c, int srcrow, int dstrow,\n"
"\t\t\tint nrows);\n"
"\tvoid\t(*eraserows)(void *c, int row, int nrows, long);\n"
"\tint\t(*allocattr)(void *c, int fg, int bg, int flags,\n"
"\t\t\tlong *);\n"
"\tvoid\t(*replaceattr)(void *c, long oldattr,\n"
"\t\t\tlong newattr);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:250
msgid ""
"The E<.Fa cursor> member defines a function for painting (or unpainting, "
"depending on the E<.Va on> parameter) the cursor at the specified position.  "
"The E<.Fa mapchar> member defines a function for changing the character "
"mapped at a given position in the character table.  The E<.Fa putchar> "
"member defines a function for writing a character on the screen, given its "
"position and attribute.  The E<.Fa copycols> member defines a function for "
"copying a set of columns within the same line.  The E<.Fa erasecols> member "
"defines a function for clearing a set of columns in a line, filling the "
"space with the given attribute.  The E<.Fa copyrows> member defines a "
"function for copying a set of complete rows.  The E<.Fa eraserows> member "
"defines a function for clearing a set of complete rows, filling the space "
"with the given attribute.  The E<.Fa allocattr> member defines a function "
"for converting an attribute specification given by its foreground color, "
"background color and flags, to the internal representation used by the "
"underlying graphics driver.  The E<.Fa replaceattr> member defines a "
"function for replacing an attribute by another one across the whole visible "
"part of the screen; this function is optional."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsdisplay.9:255
#, no-wrap
msgid "Fa struct wsscreen_descr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:263
msgid ""
"A structure passed to wscons by the display driver to describe a screen.  "
"All displays which can operate as a console must provide this structure and "
"pass it to the E<.Xr wsdisplay 4> child device.  It contains the following "
"members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:269
#, no-wrap
msgid ""
"        char *name;\n"
"        int ncols, nrows;\n"
"        const struct wsdisplay_emulops *textops;\n"
"        int fontwidth, fontheight;\n"
"        int capabilities;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:275
msgid ""
"The E<.Em capabilities> member is a set of flags describing the screen "
"capabilities.  It can contain the following flags:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsdisplay.9:277
#, no-wrap
msgid "WSSCREEN_WSCOLORS"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:279
msgid "minimal color capability"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsdisplay.9:279
#, no-wrap
msgid "WSSCREEN_REVERSE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:281
msgid "can display reversed"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsdisplay.9:281
#, no-wrap
msgid "WSSCREEN_HILIT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:283
msgid "can highlight (however)"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsdisplay.9:283
#, no-wrap
msgid "WSSCREEN_BLINK"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:285
msgid "can blink"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsdisplay.9:285
#, no-wrap
msgid "WSSCREEN_UNDERLINE"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:287
msgid "can underline"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsdisplay.9:288
#, no-wrap
msgid "Fa struct wsscreen_list"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:292
msgid ""
"A structure passed to wscons by the display driver to tell about its "
"capabilities.  It contains the following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:295
#, no-wrap
msgid ""
"\tint nscreens;\n"
"\tconst struct wsscreen_descr **screens;\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsdisplay.9:296
#, no-wrap
msgid "Fa struct wscons_syncops"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:302
msgid ""
"A structure passed to wscons by the display driver describing the interface "
"for external screen switching/process synchronization.  This structure is "
"optional and only required by displays operating with terminal emulation and "
"intending to support multiple screens.  It contains the following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:307
#, no-wrap
msgid ""
"\tint\t(*detach)(void *, int, void (*)(), void *);\n"
"\tint\t(*attach)(void *, int, void (*)(), void *);\n"
"\tint\t(*check)(void *);\n"
"\tvoid\t(*destroy)(void *);\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsdisplay.9:311
#, no-wrap
msgid "Fn wsdisplay_switchtoconsole \"\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:313
msgid "Switch the console display to its first screen."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsdisplay.9:313
#, no-wrap
msgid "Fn wsdisplay_cnattach type cookie ccol crow defattr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:322
msgid ""
"Attach this display as the console input by specifying the number of columns "
"E<.Fa ccol> and number of rows E<.Fa crows>.  The argument E<.Fa defattr> "
"specifies the default attribute (color) for the console."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsdisplay.9:322
#, no-wrap
msgid "Fn wsemul_xxx_cnattach type cookie ccol crow defattr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:334
msgid ""
"Attach this display as the console with terminal emulation described by the "
"E<.Em xxx> and specifying the number of columns E<.Fa ccol> and number of "
"rows E<.Fa crows>.  The argument E<.Fa defattr> specifies the default "
"attribute (color) for the console.  Different terminal emulations can be "
"active at the same time on one display."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsdisplay.9:334
#, no-wrap
msgid "Fn wsdisplaydevprint aux pnp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:339
msgid ""
"The default wsdisplay printing routine used by E<.Fn config_found>.  (see "
"E<.Xr autoconf 9>)."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsdisplay.9:339
#, no-wrap
msgid "Fn wsemuldisplaydevprint aux pnp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:344
msgid ""
"The default wsemul printing routine used by E<.Fn config_found>.  (see E<.Xr "
"autoconf 9>)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:358
msgid ""
"Display drivers which want to use the wsdisplay module must be a parent to "
"the E<.Xr wsdisplay 4> device and provide an attachment interface.  To "
"attach the E<.Xr wsdisplay 4> device, the display driver must allocate and "
"populate a E<.Fa wsdisplaydev_attach_args> structure with the supported "
"operations and callbacks and call E<.Fn config_found> to perform the attach "
"(see E<.Xr autoconf 9>)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:371
msgid ""
"Display drivers which want to use the wscons terminal emulation module must "
"be a parent to the E<.Xr wsdisplay 4> device and provide a E<.Fa "
"wsemuldisplaydev_attach_args> structure instead of the standard E<.Fa "
"wsdisplaydev_attach_args> to E<.Fn config_found> to perform the attach.  If "
"the display is not the console the attachment is the same as "
"wsdisplaydev_attach_args."
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/wsdisplay.9:371 org_netbsd/src/share/man/man9/wskbd.9:289 org_netbsd/src/share/man/man9/wsmouse.9:193
#, no-wrap
msgid "OPERATION"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:376
msgid ""
"If the display belongs to the system console, it must describe the default "
"screen by invoking E<.Fn wsdisplay_cnattach> at console attach time."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:400
msgid ""
"All display manipulation is performed by the wscons interface by using the "
"callbacks defined in the E<.Em wsdisplay_accessops> structure.  The E<.Fn "
"ioctl> function is called by the wscons interface to perform "
"display-specific ioctl operations (see E<.Xr ioctl 2>).  The argument E<.Fa "
"cmd> to the E<.Fn ioctl> function specifies the specific command to perform "
"using the data E<.Fa data>.  Valid commands are listed in E<.Pa "
"sys/dev/wscons/wsconsio.h> and documented in E<.Xr wsdisplay 4>.  Operations "
"for terminal emulation are performed using the callbacks defined in the "
"E<.Em wsdisplay_emulops> structure."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:413
msgid ""
"The wscons subsystem is implemented within the directory E<.Pa "
"sys/dev/wscons>.  The E<.Nm> module itself is implemented within the file "
"E<.Pa sys/dev/wscons/wsdisplay.c>.  The terminal emulation support is "
"implemented within the files E<.Pa sys/dev/wscons/wsemul_*>.  E<.Xr ioctl 2> "
"operations are listed in E<.Pa sys/dev/wscons/wsconsio.h>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsdisplay.9:422
msgid ""
"E<.Xr ioctl 2>, E<.Xr wsdisplay 4>, E<.Xr autoconf 9>, E<.Xr driver 9>, "
"E<.Xr intro 9>, E<.Xr rasops 9>, E<.Xr wsfont 9>, E<.Xr wskbd 9>, E<.Xr "
"wsmouse 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/wsfont.9:31
#, no-wrap
msgid "WSFONT 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:44
msgid ""
"E<.Nm wsfont>, E<.Nm wsfont_init>, E<.Nm wsfont_matches>, E<.Nm "
"wsfont_find>, E<.Nm wsfont_add>, E<.Nm wsfont_remove>, E<.Nm wsfont_enum>, "
"E<.Nm wsfont_lock>, E<.Nm wsfont_unlock>, E<.Nm wsfont_map_unichar>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/wsfont.9:44
#, no-wrap
msgid "wscons font support"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/wsfont.9:47
#, no-wrap
msgid "dev/wsfont/wsfont.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:68
msgid ""
"E<.Ft void> E<.Fn wsfont_init \"void\"> E<.Ft int> E<.Fn wsfont_matches "
"\"struct wsdisplay_font *font\" \"const char *name\" \"int width\" \"int "
"height\" \"int stride\" \"int flags\"> E<.Ft int> E<.Fn wsfont_find \"const "
"char *name\" \"int width\" \"int height\" \"int stride\" \"int bitorder\" "
"\"int byteorder\" \"int flags\"> E<.Ft int> E<.Fn wsfont_add \"struct "
"wsdisplay_font *font\" \"int copy\"> E<.Ft int> E<.Fn wsfont_remove \"int "
"cookie\"> E<.Ft void> E<.Fn wsfont_enum \"void (*callback)(const char *, "
"int, int, int)\"> E<.Ft int> E<.Fn wsfont_lock \"int cookie\" \"struct "
"wsdisplay_font **ptr\"> E<.Ft int> E<.Fn wsfont_unlock \"int cookie\"> E<.Ft "
"int> E<.Fn wsfont_map_unichar \"struct wsdisplay_font *font\" \"int c\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:79
msgid ""
"The E<.Nm> module is a component of the E<.Xr wscons 9> framework to provide "
"access to display fonts.  Fonts may be loaded dynamically into the kernel or "
"included statically in the kernel at compile time.  Display drivers which "
"emulate a glass-tty console on a bit-mapped display can add, remove and find "
"fonts for use by device-dependent blitter operations."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:84
msgid ""
"The primary data type for manipulating fonts is the E<.Em wsdisplay_font> "
"structure in E<.Pa dev/wscons/wsconsio.h>:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:97
#, no-wrap
msgid ""
"struct wsdisplay_font {\n"
"\tconst char *name;\t/* font name */\n"
"\tint firstchar;\n"
"\tint numchars;\t\t/* size of font table */\n"
"\tint encoding;\t\t/* font encoding */\n"
"\tu_int fontwidth;\t/* character width */\n"
"\tu_int fontheight;\t/* character height */\n"
"\tu_int stride;\n"
"\tint bitorder;\n"
"\tint byteorder;\n"
"\tvoid *data;\t\t/* pointer to font table */\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:101
msgid "The maximum font table size is E<.Em WSDISPLAY_MAXFONTSZ>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:105
msgid "The E<.Nm> framework supports fonts with the following encodings:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsfont.9:106
#, no-wrap
msgid "Dv WSDISPLAY_FONTENC_ISO"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:108
msgid "ISO-encoded fonts."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsfont.9:108
#, no-wrap
msgid "Dv WSDISPLAY_FONTENC_IBM"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:111
msgid ""
"IBM-encoded fonts commonly available for IBM CGA, EGA and VGA display "
"adapters."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsfont.9:111
#, no-wrap
msgid "Dv WSDISPLAY_FONTENC_PCVT"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:114
msgid ""
"PCVT-encoding fonts distributed as part of the old PCVT terminal emulation "
"driver."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsfont.9:114
#, no-wrap
msgid "Dv WSDISPLAY_FONTENC_ISO7"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:116
msgid "ISO-encoded Greek fonts."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsfont.9:116
#, no-wrap
msgid "Dv WSDISPLAY_FONTENC_ISO2"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:118
msgid "ISO-encoded East European fonts."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsfont.9:121
#, no-wrap
msgid "Fn wsfont_init void"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:123
msgid "Initialise the font list with the built-in fonts."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsfont.9:123
#, no-wrap
msgid "Fn wsfont_matches font name width height stride"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:138
msgid ""
"Matches the font E<.Fa font> with the specifications E<.Fa name>, E<.Fa "
"width>, E<.Fa height>, E<.Fa stride> and E<.Fa flags>.  Return zero if not "
"matched and non-zero if matched.  The E<.Fa flags> parameter has the same "
"meaning as in E<.Fn wsfont_find>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsfont.9:138
#, no-wrap
msgid "Fn wsfont_find name width height stride bitorder byteorder flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:153
msgid ""
"Find the font called E<.Fa name> from the fonts loaded into the kernel.  The "
"font aspect is specified by E<.Fa width>, E<.Fa height>, and E<.Fa stride>.  "
"If E<.Fn wsfont_find> is called with any of the parameters as 0, it "
"indicates that we don't care about that aspect of the font.  If the font is "
"found, a (nonnegative-valued) cookie is returned which can be used with the "
"other functions."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:160
msgid ""
"The E<.Fa bitorder> and E<.Fa byteorder> arguments are the bit order and "
"byte order required.  Valid values are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsfont.9:161
#, no-wrap
msgid "Dv WSDISPLAY_FONTORDER_KNOWN"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:163
msgid "The font is in known ordered format and doesn't need converting."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsfont.9:163
#, no-wrap
msgid "Dv WSDISPLAY_FONTORDER_L2R"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:165
msgid "The font is ordered left to right."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsfont.9:165
#, no-wrap
msgid "Dv WSDISPLAY_FONTORDER_R2L"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:167
msgid "The font is ordered right to left."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:173
msgid ""
"The E<.Fa flags> parameter determines what type of font can be returned.  "
"Any combination of the following values is allowed:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsfont.9:174
#, no-wrap
msgid "Dv WSFONT_FIND_BITMAP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:176
msgid "To search bitmap fonts,"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsfont.9:176
#, no-wrap
msgid "Dv WSFONT_FIND_ALPHA"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:178
msgid "to search anti-aliased fonts."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:182
msgid "When more flexibility is required, E<.Fn wsfont_enum> should be used."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsfont.9:182
#, no-wrap
msgid "Fn wsfont_add font copy"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:190
msgid ""
"Add a font E<.Fa font> to the font list.  If the E<.Fa copy> argument is "
"non-zero, then the font is physically copied, otherwise a reference to the "
"original font is made."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsfont.9:190
#, no-wrap
msgid "Fn wsfont_remove cookie"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:196
msgid ""
"Remove the font specified by E<.Fa cookie> from the font list.  The value of "
"cookie was returned by E<.Fn wsfont_add>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsfont.9:196
#, no-wrap
msgid "Fn wsfont_enum callback"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:202
msgid ""
"Enumerate the list of fonts.  For each font in the font list, the E<.Fa "
"callback> function argument is called with the arguments specifying the font "
"name, width, height and stride."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsfont.9:202
#, no-wrap
msgid "Fn wsfont_lock cookie ptr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:216
msgid ""
"Lock access to the font specified by E<.Fa cookie> so that it cannot be "
"unloaded from the kernel while is being used.  If the bit or byte order of "
"the font to be locked differs from what has been requested with E<.Fn "
"wsfont_find> then the glyph data will be modified to match.  At this point "
"it may be necessary for E<.Fn wsfont_lock> to make a copy of the font data; "
"this action is transparent to the caller.  A later call to E<.Fn "
"wsfont_unlock> will free resources used by temporary copies."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:221
msgid ""
"The address of the wsdisplay_font pointer for the specified font is returned "
"in the E<.Fa ptr> argument."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:224
msgid "E<.Fn wsfont_lock> returns zero on success, or an error code on failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsfont.9:224
#, no-wrap
msgid "Fn wsfont_unlock cookie"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:228
msgid ""
"Unlock the font specified by E<.Fa cookie>.  Returns zero on success, or an "
"error code on failure."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsfont.9:228
#, no-wrap
msgid "Fn wsfont_map_unichar font c"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:234
msgid ""
"Remap the unicode character E<.Fa c> to glyph for font E<.Fa font>.  Returns "
"the glyph on success or \\-1 on error."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:240
msgid ""
"The wscons subsystem is implemented within the directory E<.Pa "
"sys/dev/wscons>.  The wsfont subsystem itself is implemented within the file "
"E<.Pa sys/dev/wsfont/wsfont.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsfont.9:247
msgid ""
"E<.Xr wsfont 4>, E<.Xr wsfontload 8>, E<.Xr autoconf 9>, E<.Xr driver 9>, "
"E<.Xr intro 9>, E<.Xr wscons 9>, E<.Xr wsdisplay 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/wskbd.9:31
#, no-wrap
msgid "WSKBD 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:40
msgid ""
"E<.Nm wskbd>, E<.Nm wskbd_input>, E<.Nm wskbd_rawinput>, E<.Nm "
"wskbd_cnattach>, E<.Nm wskbd_cndetach>, E<.Nm wskbddevprint>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/wskbd.9:40
#, no-wrap
msgid "wscons keyboard support"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/wskbd.9:43
#, no-wrap
msgid "dev/wscons/wskbdvar.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/wskbd.9:44
#, no-wrap
msgid "dev/wscons/wsksymdef.h"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/wskbd.9:45
#, no-wrap
msgid "dev/wscons/wsksymvar.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:57
msgid ""
"E<.Ft void> E<.Fn wskbd_input \"struct device *kbddev\" \"u_int type\" \"int "
"value\"> E<.Ft void> E<.Fn wskbd_rawinput \"struct device *kbddev\" \"u_char "
"*buf\" \"int len\"> E<.Ft void> E<.Fn wskbd_cnattach \"const struct "
"wskbd_consops *consops\" \"void *conscookie\" \"const struct wskbd_mapdata "
"*mapdata\"> E<.Ft void> E<.Fn wskbd_cndetach \"\"> E<.Ft int> E<.Fn "
"wskbddevprint \"void *aux\" \"const char *pnp\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:66
msgid ""
"The E<.Nm> module is a component of the E<.Xr wscons 9> framework to provide "
"machine-independent keyboard support.  Most of the support is provided by "
"the E<.Xr wskbd 4> device driver, which must be a child of the hardware "
"device driver."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:69
msgid ""
"Keyboard drivers providing support for wscons keyboards will make use of the "
"following data types:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wskbd.9:70
#, no-wrap
msgid "Fa kbd_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:72
msgid "An opaque type describing keyboard properties."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wskbd.9:72
#, no-wrap
msgid "Fa keysym_t"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:74
msgid "The wscons keyboard-independent symbolic representation of the keypress."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wskbd.9:74
#, no-wrap
msgid "Fa struct wskbd_accessops"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:80
msgid ""
"A structure used to specify the keyboard access functions.  All keyboards "
"must provide this structure and pass it to the E<.Xr wskbd 4> child device.  "
"It has the following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:85
#, no-wrap
msgid ""
"\tint\t(*enable)(void *, int);\n"
"\tvoid\t(*set_leds)(void *, int);\n"
"\tint\t(*ioctl)(void *v, u_long cmd, void *data,\n"
"\t\t\tint flag, struct lwp *l);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:99
msgid ""
"The E<.Fa enable> member defines the function to be called to enable "
"keypress passing to wscons.  The E<.Fa set_leds> member defined the function "
"to be called to set the LEDs on the keyboard.  The E<.Fa ioctl> member "
"defines the function to be called to perform keyboard-specific ioctl calls."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:104 org_netbsd/src/share/man/man9/wskbd.9:123
msgid ""
"There is a E<.Fa void *> cookie provided by the keyboard driver associated "
"with these functions, which is passed to them when they are invoked."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wskbd.9:104
#, no-wrap
msgid "Fa struct wskbd_consops"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:113
msgid ""
"A structure used to specify the keyboard console operations.  All keyboards "
"which can operate as a console must provide this structure and pass it to "
"the E<.Xr wskbd 4> child device.  If the keyboard cannot be a console, it is "
"not necessary to specify this structure.  It has the following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:117
#, no-wrap
msgid ""
"\tvoid\t(*getc)(void *, u_int *, int *);\n"
"\tvoid\t(*pollc)(void *, int);\n"
"\tvoid\t(*bell)(void *, u_int, u_int, u_int);\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wskbd.9:123
#, no-wrap
msgid "Fa struct wscons_keydesc"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:128
msgid ""
"A structure used to describe a keyboard mapping table to convert "
"keyboard-specific keycodes to wscons keysyms.  It has the following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:133
#, no-wrap
msgid ""
"\tkbd_t\tname;\t\t/* name of this map */\n"
"\tkbd_t\tbase;\t\t/* map this one is based on */\n"
"\tint\tmap_size;\t/* size of map */\n"
"\tconst\tkeysym_t *map;\t/* the map itself */\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wskbd.9:134
#, no-wrap
msgid "Fa struct wskbd_mapdata"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:138
msgid ""
"A structure used to describe the keyboard layout and operation to interpret "
"the keyboard layout.  it contains the following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:141
#, no-wrap
msgid ""
"        const struct wscons_keydesc *keydesc;\n"
"        kbd_t layout;\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wskbd.9:142
#, no-wrap
msgid "Fa struct wskbddev_attach_args"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:147
msgid ""
"A structure used to attach the E<.Xr wskbd 4> child device.  It has the "
"following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:152
#, no-wrap
msgid ""
"\tint console;\n"
"\tconst struct wskbd_mapdata *keymap;\n"
"\tconst struct wskbd_accessops *accessops;\n"
"\tvoid *accesscookie;\n"
msgstr ""

#. type: Ss
#: org_netbsd/src/share/man/man9/wskbd.9:154
#, no-wrap
msgid "Keymaps"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:158
msgid ""
"Keymaps are a dense stream of E<.Fa keysym_t>.  A declaration has the "
"following fields:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:165
msgid ""
"E<.Ar pos> E<.Op Ar cmd> E<.Ar normal> E<.Op Ar shift> E<.Op Ar altgr> E<.Op "
"Ar shift-altgr>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:167
msgid "The fields have the following meanings:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wskbd.9:169
#, no-wrap
msgid "Ar pos"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:174
msgid ""
"Always specified as E<.Ns KC( Ns Ar pos>)  and starts the description of key "
"E<.Ar pos>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wskbd.9:174
#, no-wrap
msgid "Ar cmd"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:178
msgid ""
"If the command modifier (KS_Cmd_XXX) is active, the optional command E<.Ar "
"cmd> is invoked."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wskbd.9:178
#, no-wrap
msgid "Ar normal"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:180
msgid "The keysym if no modifiers are active."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wskbd.9:180
#, no-wrap
msgid "Ar shift"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:182
msgid "The keysym if the shift modifier is active."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wskbd.9:182
#, no-wrap
msgid "Ar altgr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:184
msgid "The keysym if the alt-gr modifier is active."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wskbd.9:184
#, no-wrap
msgid "Ar shift-altgr"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:186
msgid "The keysym if the shift-alt-gr modifier is active."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:200
msgid ""
"If the keysym after E<.Ar pos> is not KS_Cmd_XXX, then E<.Ar cmd> is empty.  "
"The E<.Ar shift>, E<.Ar altgr> and E<.Ar shift-altgr> fields are determined "
"from previous fields if they are not specified.  Therefore, there are four "
"valid keysym declarations:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:204
msgid "E<.Ar pos> E<.Op Ar cmd> E<.Ar normal>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:208
msgid "E<.Ar pos> E<.Op Ar cmd> E<.Ar normal Ar shift>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:212
msgid "E<.Ar pos> E<.Op Ar cmd> E<.Ar normal Ar shift Ar altgr>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:216
msgid "E<.Ar pos> E<.Op Ar cmd> E<.Ar normal Ar shift Ar altgr Ar shift-altgr>"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wskbd.9:218
#, no-wrap
msgid "Fn wskbd_input kbddev type value"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:227
msgid ""
"Pass the keypress of value E<.Fa value> and type E<.Fa type> to wscons "
"keyboard driver.  Valid values of E<.Fa type> are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wskbd.9:228
#, no-wrap
msgid "WSCONS_EVENT_KEY_UP"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:230
msgid "Key released."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wskbd.9:230
#, no-wrap
msgid "WSCONS_EVENT_KEY_DOWN"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:232
msgid "Key pressed."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wskbd.9:233
#, no-wrap
msgid "Fn wskbd_rawinput kbddev buf len"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:243
msgid ""
"Pass the raw keypress in the buffer E<.Fa buf> to the wscons keyboard "
"driver.  The buffer is E<.Fa len> bytes long.  This function should only be "
"called if the kernel option E<.Em WSDISPLAY_COMPAT_RAWKBD> is enabled."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wskbd.9:243
#, no-wrap
msgid "Fn wskbd_cnattach consops conscookie mapdata"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:254
msgid ""
"Attach this keyboard as the console input by specifying the console "
"operations E<.Fa consops> and the keyboard mapping table information in "
"E<.Fa mapdata>.  The functions specified in E<.Fa consops> will be called "
"with E<.Fa conscookie> as the first argument."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wskbd.9:254
#, no-wrap
msgid "Fn wskbd_cndetach \"\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:256
msgid "Detach this keyboard as the console input."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wskbd.9:256
#, no-wrap
msgid "Fn wskbddevprint aux pnp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:261
msgid ""
"The default wskbd printing routine used by E<.Fn config_found>.  (see E<.Xr "
"autoconf 9>)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:289
msgid ""
"Keyboard drivers which want to use the wskbd module must be a parent to the "
"E<.Xr wskbd 4> device and provide an attachment interface.  To attach the "
"E<.Xr wskbd 4> device, the keyboard driver must allocate and populate a "
"E<.Fa wskbddev_attach_args> structure with the supported operations and "
"callbacks and call E<.Fn config_found> to perform the attach (see E<.Xr "
"autoconf 9>).  The E<.Fa keymap> member points to the E<.Em wskbd_mapdata> "
"structure which describes the keycode mapping operations.  The E<.Fa "
"accessops> member points to the E<.Em wskbd_accessops> structure which "
"describes the keyboard access operations.  The E<.Fa console> member is a "
"boolean to indicate to wscons whether this keyboard will be used for console "
"input."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:295
msgid ""
"If the keyboard belongs to the system console, it must register the E<.Fa "
"wskbd_consops> structure specifying the console operations via E<.Fn "
"wskbd_cnattach> at console attach time."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:305
msgid ""
"When a keypress arrives from the keyboard, the keyboard driver must perform "
"any necessary character decoding to wscons events and pass the events to "
"wscons via E<.Fn wskbd_input>.  If the kernel is compiled with the option "
"E<.Em WSDISPLAY_COMPAT_RAWKBD>, then the keyboard driver must also pass the "
"raw keyboard data to wscons via E<.Fn wskbd_rawinput>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:328
msgid ""
"The wscons framework calls back into the hardware driver by invoking the "
"functions that are specified in the E<.Em accessops> structure.  The E<.Fn "
"enable> and E<.Fn set_leds> functions are relatively simple and "
"self-explanatory.  The E<.Fn ioctl> function is called by the wscons "
"interface to perform keyboard-specific ioctl operations (see E<.Xr ioctl "
"2>).  The argument E<.Fa cmd> to the E<.Fn ioctl> function specifies the "
"specific command to perform using the data E<.Fa data>.  Valid commands are "
"listed in E<.Pa sys/dev/wscons/wsconsio.h>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:340
msgid ""
"The wscons subsystem is implemented within the directory E<.Pa "
"sys/dev/wscons>.  The E<.Nm> module itself is implement within the files "
"E<.Pa sys/dev/wscons/wskbd.c> and E<.Pa sys/dev/wscons/wskbdutil.c>.  E<.Xr "
"ioctl 2> operations are listed in E<.Pa sys/dev/wscons/wsconsio.h>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wskbd.9:346
msgid ""
"E<.Xr ioctl 2>, E<.Xr autoconf 9>, E<.Xr driver 9>, E<.Xr intro 9>, E<.Xr "
"wsdisplay 9>, E<.Xr wsmouse 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/wsmouse.9:30
#, no-wrap
msgid "November 12, 2006"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/wsmouse.9:31
#, no-wrap
msgid "WSMOUSE 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:37
msgid "E<.Nm wsmouse>, E<.Nm wsmouse_input>, E<.Nm wsmousedevprint>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/wsmouse.9:37
#, no-wrap
msgid "wscons mouse support"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/wsmouse.9:40
#, no-wrap
msgid "dev/wscons/wsmousevar.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:46
msgid ""
"E<.Ft void> E<.Fn wsmouse_input \"struct device *msdev\" \"u_int btns\" "
"\"int x\" \"int y\" \"int z\" \"int w\" \"u_int flags\"> E<.Ft int> E<.Fn "
"wsmousedevprint \"void *aux\" \"const char *pnp\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:55
msgid ""
"The E<.Nm> module is a component of the E<.Xr wscons 9> framework to provide "
"machine-independent mouse support.  Most of the support is provided by the "
"E<.Xr wsmouse 4> device driver, which must be a child of the hardware device "
"driver."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:58
msgid ""
"Mouse drivers providing support for wscons pointer devices will make use of "
"the following data types:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsmouse.9:59
#, no-wrap
msgid "Fa struct wsmouse_accessops"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:65
msgid ""
"A structure used to specify the mouse access functions.  All pointer devices "
"must provide this structure and pass it to the E<.Xr wsmouse 4> child "
"device.  It has the following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:70
#, no-wrap
msgid ""
"\tint\t(*enable)(void *);\n"
"\tint\t(*ioctl)(void *v, u_long cmd, void *data,\n"
"\t\t\tint flag, struct lwp *l);\n"
"\tvoid\t(*disable)(void *);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:84
msgid ""
"The E<.Fa enable> member defines the function to be called to enable "
"monitoring pointer movements and passing these events to wscons.  The E<.Fa "
"disable> member defines the function to disable movement events.  The E<.Fa "
"ioctl> member defines the function to be called to perform mouse-specific "
"ioctl calls."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:89
msgid ""
"There is a E<.Fa void *> cookie provided by the mouse driver associated with "
"these functions, which is passed to them when they are invoked."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsmouse.9:89
#, no-wrap
msgid "Fa struct wsmousedev_attach_args"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:94
msgid ""
"A structure used to attach the E<.Xr wsmouse 4> child device.  It has the "
"following members:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:97
#, no-wrap
msgid ""
"\tconst struct wsmouse_accessops *accessops;\n"
"\tvoid *accesscookie;\n"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsmouse.9:101
#, no-wrap
msgid "Fn wsmouse_input msdev btns x y z w flags"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:104
msgid ""
"Callback from the mouse driver to the wsmouse interface driver.  Arguments "
"are as follows:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsmouse.9:105
#, no-wrap
msgid "Fa msdev"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:113
msgid ""
"This is the E<.Fa struct device> pointer passed from E<.Fn config_found> on "
"attaching the child E<.Xr wsmouse 4> to specify the mouse device."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsmouse.9:113
#, no-wrap
msgid "Fa btns"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:127
msgid ""
"This specifies the current button status.  Bits for pressed buttons (which "
"will cause the E<.Dv WSCONS_EVENT_MOUSE_DOWN> event on E<.Xr wsmouse 4> "
"device) should be set, and bits for released buttons (which will cause the "
"E<.Dv WSCONS_EVENT_MOUSE_UP> event) should be zero.  The left most button "
"state should be in LSB, i.e. for typical three button mouse, the left button "
"is 0x01, the middle button is 0x02, and the right button is 0x04."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsmouse.9:127
#, no-wrap
msgid "Fa x"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:130
msgid ""
"Absolute or relative X-axis value to specify the pointer coordinate.  "
"Rightward (moving the mouse right) is positive."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsmouse.9:130
#, no-wrap
msgid "Fa y"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:134
msgid ""
"Absolute or relative Y-axis value to specify the pointer coordinate.  Upward "
"(moving the mouse forward) is positive.  Note that this aspect is opposite "
"from the one used in the X server dix layer."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsmouse.9:134
#, no-wrap
msgid "Fa z"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:138
msgid ""
"Absolute or relative Z-axis value to specify the pointer coordinate.  "
"Usually this axis is used for the wheel.  Downward (turning the wheel "
"backward) is positive."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsmouse.9:138
#, no-wrap
msgid "Fa w"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:141
msgid ""
"Absolute or relative W-axis value to specify the pointer coordinate.  "
"Usually this axis would be used for the horizontal component of the wheel."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:153
msgid ""
"This argument specifies whether the pointer device and the measurement of "
"the E<.Fa x>, E<.Fa y>, E<.Fa z>, and E<.Fa w> axes is in relative or "
"absolute mode.  Valid values for E<.Fa flags> are:"
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsmouse.9:154
#, no-wrap
msgid "WSMOUSE_INPUT_DELTA"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:156
msgid "Relative mode."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsmouse.9:156
#, no-wrap
msgid "WSMOUSE_INPUT_ABSOLUTE_X"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:160
msgid "Absolute mode in E<.Fa x> axis."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsmouse.9:160
#, no-wrap
msgid "WSMOUSE_INPUT_ABSOLUTE_Y"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:164
msgid "Absolute mode in E<.Fa y> axis."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsmouse.9:164
#, no-wrap
msgid "WSMOUSE_INPUT_ABSOLUTE_Z"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:168
msgid "Absolute mode in E<.Fa z> axis."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsmouse.9:168
#, no-wrap
msgid "WSMOUSE_INPUT_ABSOLUTE_W"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:172
msgid "Absolute mode in E<.Fa w> axis."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/wsmouse.9:174
#, no-wrap
msgid "Fn wsmousedevprint aux pnp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:179
msgid ""
"The default wsmouse printing routine used by E<.Fn config_found>.  (see "
"E<.Xr autoconf 9>)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:193
msgid ""
"Mouse drivers which want to use the wsmouse module must be a parent to the "
"E<.Xr wsmouse 4> device and provide an attachment interface.  To attach the "
"E<.Xr wsmouse 4> device, the mouse driver must allocate and populate a E<.Fa "
"wsmousedev_attach_args> structure with the supported operations and "
"callbacks and call E<.Fn config_found> to perform the attach (see E<.Xr "
"autoconf 9>)."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:198
msgid ""
"When a mouse-movement event is received, the device driver must perform any "
"necessary movement decoding to wscons events and pass the events to wscons "
"via E<.Fn wsmouse_input>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:221
msgid ""
"The wscons framework calls back into the hardware driver by invoking the "
"functions that are specified in the E<.Em accessops> structure.  The E<.Fn "
"enable> and E<.Fn disable> functions are relatively simple and "
"self-explanatory.  The E<.Fn ioctl> function is called by the wscons "
"interface to perform mouse-specific ioctl operations (see E<.Xr ioctl 2>).  "
"The argument E<.Fa cmd> to the E<.Fn ioctl> function specifies the specific "
"command to perform using the data E<.Fa data>.  Valid commands are listed in "
"E<.Pa sys/dev/wscons/wsconsio.h>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:231
msgid ""
"The wscons subsystem is implemented within the directory E<.Pa "
"sys/dev/wscons>.  The E<.Nm> module itself is implement within the file "
"E<.Pa sys/dev/wscons/wsmouse.c>.  E<.Xr ioctl 2> operations are listed in "
"E<.Pa sys/dev/wscons/wsconsio.h>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/wsmouse.9:241
msgid ""
"E<.Xr ioctl 2>, E<.Xr pms 4>, E<.Xr wscons 4>, E<.Xr wsmouse 4>, E<.Xr "
"autoconf 9>, E<.Xr driver 9>, E<.Xr intro 9>, E<.Xr wscons 9>, E<.Xr "
"wsdisplay 9>, E<.Xr wskbd 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/xcall.9:31
#, no-wrap
msgid "XCALL 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/xcall.9:38
msgid "E<.Nm xcall>, E<.Nm xc_broadcast>, E<.Nm xc_unicast>, E<.Nm xc_wait>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/xcall.9:38
#, no-wrap
msgid "cross-call interface"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/xcall.9:40
#, no-wrap
msgid "sys/xcall.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/xcall.9:48
msgid ""
"E<.Vt typedef void (*xcfunc_t)(void *, void *);> E<.Ft uint64_t> E<.Fn "
"xc_broadcast \"u_int flags\" \"xcfunc_t func\" \"void *arg1\" \"void "
"*arg2\"> E<.Ft uint64_t> E<.Fn xc_unicast \"u_int flags\" \"xcfunc_t func\" "
"\"void *arg1\" \"void *arg2\" \"struct cpu_info *ci\"> E<.Ft void> E<.Fn "
"xc_wait \"uint64_t where\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/xcall.9:53
msgid ""
"The machine-independent E<.Nm> interface allows any CPU in the system to "
"request that an arbitrary function be executed on any other CPU."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/xcall.9:63
msgid ""
"Sometimes it is necessary to modify hardware state that is tied directly to "
"individual CPUs E<.Po> such as a CPU's local timer E<.Pc>, and these updates "
"can not be done remotely by another CPU.  The LWP requesting the update may "
"be unable to guarantee that it will be running on the CPU where the update "
"must occur, when the update occurs."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/xcall.9:70
msgid ""
"Additionally, it is sometimes necessary to modify per-CPU software state "
"from a remote CPU.  Where these update operations are so rare or the access "
"to the per-CPU data so frequent that the cost of using locking or atomic "
"operations to provide coherency is prohibitive, another way must be found."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/xcall.9:74
msgid ""
"Cross calls help to solve these types of problem.  However, since this "
"facility is heavyweight, it is expected that it will not be used often."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/xcall.9:84
msgid ""
"E<.Nm> provides a mechanism for making E<.Dq \"low priority\"> cross calls.  "
"The function to be executed runs on the remote CPU within a thread context, "
"and not from a software interrupt, so it can ensure that it is not "
"interrupting other code running on the CPU, and so has exclusive access to "
"the CPU.  Keep in mind that unless disabled, it may cause a kernel "
"preemption."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/xcall.9:93
msgid ""
"E<.Nm> also provides a mechanism for making E<.Dq \"high priority\"> cross "
"calls.  The function to be executed runs on the remote CPU within a E<.Dv "
"IPL_SOFTCLOCK> software interrupt context, possibly interrupting other "
"lower-priority code running on the CPU."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/xcall.9:97
msgid ""
"Functions being called should be relatively lightweight.  They may block on "
"locks, but carefully and minimally, to not interfere with other cross calls "
"in the system."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/xcall.9:99
#, no-wrap
msgid "Fn xc_broadcast flags func arg1 arg2"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/xcall.9:118
msgid ""
"Call E<.Fo \"(*func)\"> E<.Fa \"arg1\"> E<.Fa \"arg2\"> E<.Fc> on all CPUs "
"in the system.  Return a E<.Vt uint64_t> E<.Dq ticket> to E<.Fn xc_wait> on "
"for the cross-call to complete.  E<.Fa flags> should be E<.Dv XC_HIGHPRI> "
"for a \"high priority\" call, and 0 for a \"low priority\" call.  E<.Fn "
"xc_broadcast> should not be called from interrupt context."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/xcall.9:118
#, no-wrap
msgid "Fn xc_unicast flags func arg1 arg2 ci"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/xcall.9:128
msgid ""
"Like E<.Fn xc_broadcast>, but call E<.Fn \"(*func)\"> on only the CPU "
"indicated by E<.Fa ci>.  E<.Fn xc_unicast> also returns a E<.Dq ticket>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/xcall.9:128
#, no-wrap
msgid "Fn xc_wait where"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/xcall.9:138
msgid ""
"Wait on the E<.Dq ticket> returned by a prior E<.Fn xc_broadcast> or E<.Fn "
"xc_unicast> for the corresponding cross-call to complete.  E<.Fn xc_wait> "
"should be called from a thread context."
msgstr ""

#.  .Sh EXAMPLES
#. type: Plain text
#: org_netbsd/src/share/man/man9/xcall.9:145
msgid ""
"The E<.Nm> interface is implemented within the file E<.Pa "
"sys/kern/subr_xcall.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/xcall.9:148
msgid "E<.Xr kpreempt 9>, E<.Xr percpu 9>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/xcall.9:153
msgid "The E<.Nm> interface first appeared in E<.Nx 5.0>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/xcall.9:154
msgid "E<.An Andrew Doran Aq ad@NetBSD.org>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/man9.i386/bios32_service.9:30
#, no-wrap
msgid "June 17, 2001"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/man9.i386/bios32_service.9:31
#, no-wrap
msgid "BIOS32_SERVICE 9 i386"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/bios32_service.9:35
msgid "E<.Nm bios32_service>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/man9.i386/bios32_service.9:35
#, no-wrap
msgid "locate BIOS32 service"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/man9.i386/bios32_service.9:37
#, no-wrap
msgid "i386/bios32.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/bios32_service.9:41
msgid ""
"E<.Ft int> E<.Fn bios32_service \"uint32_t service \" \"bios32_entry_t e\" "
"\"bios32_entry_info_t ei\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/bios32_service.9:50
msgid ""
"The E<.Fn bios32_service> function calls the BIOS32 to locate the specified "
"BIOS32 service E<.Fa service> and fills in the entry point information E<.Fa "
"e> and E<.Fa ei>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/bios32_service.9:51
msgid "E<.Xr bioscall 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/man9.i386/bioscall.9:31
#, no-wrap
msgid "BIOSCALL 9 i386"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/bioscall.9:35
msgid "E<.Nm bioscall>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/man9.i386/bioscall.9:35
#, no-wrap
msgid "call system BIOS function from real mode"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/man9.i386/bioscall.9:37
#, no-wrap
msgid "i386/bioscall.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/bioscall.9:40
msgid "E<.Ft void> E<.Fn bioscall \"int function\" \"struct bioscallregs *regs\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/bioscall.9:48
msgid ""
"The E<.Fn bioscall> function switches the processor into real mode, calls "
"the E<.Tn BIOS> interrupt numbered E<.Fa function>, and returns to protected "
"mode."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/bioscall.9:51
msgid ""
"This function is intended to be called during the initial system bootstrap "
"when necessary to probe devices or pseudo-devices."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/bioscall.9:71
msgid ""
"The register values specified by E<.Fa *regs> (with one exception) are "
"installed before the E<.Tn BIOS> interrupt is called.  The processor flags "
"are handled specially.  Only the following flags are passed to the E<.Tn "
"BIOS> from the registers in E<.Fa regs> (the remainder come from the "
"processor's flags register at the time of the call): E<.Ar PSL_C>, E<.Ar "
"PSL_PF>, E<.Ar PSL_AF>, E<.Ar PSL_Z>, E<.Ar PSL_N>, E<.Ar PSL_D>, E<.Ar "
"PSL_V>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/bioscall.9:77
msgid ""
"The E<.Va bioscallregs> structure is defined to contain structures for each "
"register, to allow access to 32-, 16- or 8-bit wide sections of the "
"registers.  Definitions are provided which simplify access to the union "
"members."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/bioscall.9:85
msgid ""
"The E<.Fn bioscall> function fills in E<.Fa *regs> with the processor "
"registers as returned from the E<.Tn BIOS> call."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/bioscall.9:102
msgid ""
"The Advanced Power Management driver calls E<.Fn bioscall> by setting up a "
"register structure with the E<.Tn APM> installation check and device types "
"in registers E<.Fa ax> and E<.Fa bx>, then calls the E<.Tn BIOS> to fetch "
"the details for calling the E<.Tn APM> support through a protected-mode "
"interface.  The E<.Tn BIOS> returns these details in the registers:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/bioscall.9:107
#, no-wrap
msgid ""
"#include \\*[Lt]i386/bioscall.h\\*[Gt]\n"
"#include \\*[Lt]i386/apmvar.h\\*[Gt]\n"
"struct bioscallregs regs;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/bioscall.9:113
#, no-wrap
msgid ""
"regs.AX = APM_BIOS_FN(APM_INSTALLATION_CHECK);\n"
"regs.BX = APM_DEV_APM_BIOS;\n"
"regs.CX = regs.DX = 0;\n"
"regs.ESI = regs.EDI = regs.EFLAGS = 0;\n"
"bioscall(APM_SYSTEM_BIOS, \\*[Am]regs);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/bioscall.9:117
msgid ""
"E<.Pa sys/arch/i386/i386/bioscall.s>, E<.Pa "
"sys/arch/i386/bioscall/biostramp.S>"
msgstr ""

#. type: Sh
#: org_netbsd/src/share/man/man9/man9.i386/bioscall.9:117 org_netbsd/src/share/man/man9/man9.i386/return_address.9:83 org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:121
#, no-wrap
msgid "REFERENCES"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/bioscall.9:119
msgid "E<.Xr apm 4>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/bioscall.9:124
msgid "The E<.Fn bioscall> function first appeared in E<.Nx 1.3>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/bioscall.9:131
msgid ""
"Not all E<.Tn BIOS> functions are safe to call through the trampoline, as "
"they may depend on system state which has been disturbed or used for other "
"purposes once the E<.Nx> kernel is running."
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/man9.i386/return_address.9:31
#, no-wrap
msgid "RETURN_ADDRESS 9 i386"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/return_address.9:35
msgid "E<.Nm return_address>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/man9.i386/return_address.9:35
#, no-wrap
msgid "return address from call stack"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/man9.i386/return_address.9:37
#, no-wrap
msgid "i386/return.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/return_address.9:40
msgid "E<.Ft void *> E<.Fn return_address \"unsigned int level\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/return_address.9:50
msgid ""
"The E<.Fn return_address> function evaluates to the first return address on "
"the call stack if E<.Fa level> equals 0, or else to the return address for "
"the stack frame E<.Fa level> frames down."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/return_address.9:53
msgid ""
"This function is intended to be called by diagnostic code to record the call "
"stack."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/return_address.9:58
msgid ""
"A special fault handler stops E<.Fn return_address> from crashing the kernel "
"by examining a non-existent or corrupt stack frame."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/return_address.9:66
msgid ""
"Kernel compilation options affect both the ability of E<.Fn return_address> "
"to locate return addresses on the stack, and the programmer's ability to "
"interpret the addresses.  The compiler may optimize away the stack frame "
"pointers that E<.Fn return_address> depends on."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/return_address.9:70
msgid ""
"To use E<.Fn return_address> effecively, try a kernel configuration option "
"such as"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/return_address.9:73
#, no-wrap
msgid ""
"makeoptions     DEBUG=\"-g -fno-omit-frame-pointer \\e\n"
"\t\t       -fno-optimize-sibling-calls -O0\"\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/return_address.9:80
msgid ""
"The E<.Fn return_address> function returns the requested return address, or "
"E<.Dv NULL> if it cannot dissect the call stack."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/return_address.9:83
msgid "E<.Pa sys/arch/i386/i386/copy.S>, E<.Pa sys/arch/i386/include/return.h>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/return_address.9:85
msgid "E<.Xr config 5>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/return_address.9:90
msgid "The E<.Fn return_address> function first appeared in E<.Nx 6.0>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/return_address.9:91
msgid "E<.An \"David Young\" Aq dyoung@NetBSD.org>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/man9.i386/splraise.9:27
#, no-wrap
msgid "February 5, 2010"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/man9.i386/splraise.9:28
#, no-wrap
msgid "SPLRAISE 9"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/splraise.9:33
msgid "E<.Nm spllower>, E<.Nm splraise>"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/man9.i386/splraise.9:35
#, no-wrap
msgid "machine/intr.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/splraise.9:40
msgid "E<.Ft void> E<.Fn spllower \"int s\"> E<.Ft int> E<.Fn splraise \"int s\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/splraise.9:47
msgid ""
"These functions raise and lower the interrupt priority level on i386.  They "
"are used by machine-dependent kernel code to implement the "
"machine-independent E<.Xr spl 9> interface."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/splraise.9:51
msgid ""
"In a multi-CPU system, these functions change the interrupt priority level "
"on the local CPU only.  In general, device drivers should not make use of "
"these functions."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/splraise.9:66
msgid ""
"The E<.Fn spllower> function sets the system priority level to the one "
"encoded in E<.Fa s>, if E<.Fa s> is lower than the current level.  "
"Otherwise, it does not change the level.  Use E<.Fn splx> instead of E<.Fn "
"spllower>, except in extraordinary circumstances."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/splraise.9:81
msgid ""
"The E<.Fn splraise> function sets the system priority level to the one "
"encoded in E<.Fa s>, if E<.Fa s> is greater than the current level, and "
"returns the previous level.  Otherwise, it does not change the level, and it "
"returns the current level.  Except in extraordinary circumstances, do not "
"use E<.Fn splraise>.  Use one of the priority-raising functions defined in "
"E<.Xr spl 9>, instead."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.i386/splraise.9:85
msgid "E<.Xr condvar 9>, E<.Xr mutex 9>, E<.Xr rwlock 9>, E<.Xr spl 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:30
#, no-wrap
msgid "May 21, 1997"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:31
#, no-wrap
msgid "ISR_ADD 9 sun3"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:38
msgid ""
"E<.Nm isr_add>, E<.Nm isr_add_autovect>, E<.Nm isr_add_vectored>, E<.Nm "
"isr_add_custom>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:38
#, no-wrap
msgid "establish interrupt handler"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:40
#, no-wrap
msgid "sun3/autoconf.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:43
#, no-wrap
msgid "typedef int (*isr_func_t)(void *);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:50
msgid ""
"E<.Ft void> E<.Fn isr_add_autovect \"isr_func_t fun\" \"void *arg\" \"int "
"level\"> E<.Ft void> E<.Fn isr_add_vectored \"isr_func_t fun\" \"void *arg\" "
"\"int pri\" \"int vec\"> E<.Ft void> E<.Fn isr_add_custom \"int level\" "
"\"void *fun\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:56
msgid ""
"The E<.Nm> functions establish interrupt handlers into the system interrupt "
"dispatch table and are typically called from device drivers during the "
"autoconfiguration process."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:60
msgid ""
"There are two types of interrupts in the Motorola 68000 architecture, which "
"differ in the way that an interrupt request is mapped to a dispatch function "
"within the interrupt vector table."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:66
msgid ""
"When the CPU detects an asserted signal on one of its interrupt request "
"lines, it suspends normal instruction execution and begins an interrupt "
"acknowledge cycle on the system bus.  During this cycle the interrupting "
"device directs how the CPU is to dispatch its interrupt request."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:73
msgid ""
"If the interrupting device is integrated tightly with the system bus, it "
"provides an 8-bit interrupt vector number to the CPU and a E<.Sy vectored> "
"interrupt occurs.  This vector number points to a vector entry within the "
"interrupt vector table to which instruction execution is immediately "
"transfered."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:82
msgid ""
"If the interrupting device cannot provide a vector number, it asserts a "
"specialized bus line and an E<.Sy autovectored> interrupt occurs.  The "
"vector number to use is determined by adding the interrupt priority E<.Pq "
"0\\(en6> to an autovector base E<.Pq typically Li 18 hexadecimal>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:84
#, no-wrap
msgid "Fn isr_add_autovect"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:93
msgid ""
"Adds the function E<.Fa fun> to the list of interrupt handlers to be called "
"during an autovectored interrupt of priority E<.Fa level>.  The pointer "
"E<.Fa arg> is passed to the function as its first argument."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:93
#, no-wrap
msgid "Fn isr_add_vectored"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:104
msgid ""
"Adds the function E<.Fa fun> to the list of interrupt handlers to be called "
"during a vectored interrupts of priority E<.Fa pri> at dispatch vector "
"number E<.Fa vec>.  The pointer E<.Fa arg> is passed to the function as its "
"first argument."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:104
#, no-wrap
msgid "Fn isr_add_custom"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:111
msgid ""
"Establish function E<.Fa fun> as the interrupt handler for vector E<.Fa "
"level>.  The autovector base number is automatically added to E<.Fa level>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:118
msgid ""
"E<.Fa fun> is called directly as the dispatch handler and must handle all of "
"the specifics of saving the processor state and returning from a processor "
"exception.  These requirements generally dictate that E<.Fa fun> be written "
"in assembler."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:121
msgid "E<.Pa sys/arch/sun3/sun3/isr.c>"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:123
msgid "MC68030 User's Manual, Third edition, MC68030UM/AD Rev 2, Motorola Inc."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.sun3/isr_add.9:124
msgid "There is no way to remove a handler once it has been added."
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/man9.x86/nmi.9:30
#, no-wrap
msgid "March 17, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/man9.x86/nmi.9:31
#, no-wrap
msgid "NMI 9 x86"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/nmi.9:37
msgid "E<.Nm nmi>, E<.Nm nmi_establish>, E<.Nm nmi_disestablish>,"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/man9.x86/nmi.9:37
#, no-wrap
msgid "NMI"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/man9.x86/nmi.9:39
#, no-wrap
msgid "x86/nmi.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/nmi.9:44
msgid ""
"E<.Ft nmi_handler_t *> E<.Fn nmi_establish \"int (*func)(const struct "
"trapframe *, void *)\" \"void *arg\"> E<.Ft void> E<.Fn nmi_disestablish "
"\"nmi_handler_t *handle\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/nmi.9:55
msgid ""
"The E<.Nm> interface lets the kernel establish handlers for x86 Non-Maskable "
"Interrupts (NMIs).  An NMI signals to the processor an exception on a "
"processor, memory controller, or I/O bus that is irrecoverable or else needs "
"attention at a high priority.  A E<.Dq \"debug switch\"> or a "
"performance/watchdog timer may also trigger an NMI."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/nmi.9:61
msgid ""
"An NMI handler will run to completion on the same processor where it began "
"without being preempted by any thread or interrupt except for another NMI.  "
"An NMI handler must prepare for re-entry.  An NMI handler may run "
"simultaneously on more than one CPU."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/nmi.9:73
msgid ""
"Synchronizing access to a shared data structure from an NMI handler is a "
"different challenge than synchronizing access from hardware/software "
"interrupt routines or from kernel threads.  An NMI handler may not perform "
"any operation that may sleep, acquire a mutex, or schedule a software "
"interrupt.  An NMI handler may use E<.Xr atomic_ops 3>.  An NMI handler may "
"reference per-CPU storage E<.Po> E<.Xr percpu 9> E<.Pc>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/nmi.9:75
msgid "An NMI handler may not write to the kernel message buffer."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/man9.x86/nmi.9:77
#, no-wrap
msgid "Fn nmi_establish func arg"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/nmi.9:109
msgid ""
"Call this in thread context to establish a handler for non-maskable "
"interrupts.  Establish E<.Fa func> as one of the handler functions to call "
"when an NMI occurs.  Where E<.Fa tf> is a E<.Vt struct trapframe> "
"representation of the processor context where the NMI was received, and "
"E<.Fa arg> is the argument to E<.Fn nmi_establish>, the kernel will call "
"E<.Fo (*func)> E<.Fa tf> E<.Fa arg> E<.Fc> every time an NMI occurs until "
"the handler is removed with E<.Fn nmi_disestablish>.  E<.Fa func> should "
"return non-zero if it handled a condition that causes NMI, or zero if it did "
"not.  If, for a given NMI, all handlers return zero, the system will panic "
"or enter the kernel debugger, E<.Xr ddb 4>.  E<.Fn nmi_establish> returns "
"E<.Dv NULL> on failure, and a handle for the NMI handler on success."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/man9.x86/nmi.9:109
#, no-wrap
msgid "Fn nmi_disestablish handle"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/nmi.9:116
msgid ""
"Call this in thread context to stop the kernel from calling an NMI handler.  "
"Indicate the handler to disestablish with the E<.Fa handle> returned by "
"E<.Fn nmi_establish>."
msgstr ""

#.  .Sh EXAMPLES
#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/nmi.9:123
msgid ""
"The E<.Nm> interface is implemented within the file E<.Pa "
"sys/arch/x86/x86/nmi.c>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/nmi.9:126
msgid "E<.Xr atomic_ops 3>, E<.Xr ddb 4>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/man9.x86/rdmsr.9:30
#, no-wrap
msgid "October 28, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/man9.x86/rdmsr.9:31
#, no-wrap
msgid "RDMSR 9 x86"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/rdmsr.9:38
msgid "E<.Nm msr>, E<.Nm rdmsr>, E<.Nm rdmsr_safe>, E<.Nm wrmsr>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/man9.x86/rdmsr.9:38
#, no-wrap
msgid "functions for x86 MSRs"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/man9.x86/rdmsr.9:40
#, no-wrap
msgid "x86/cpufunc.h"
msgstr ""

#.  .Ft uint64_t
#.  .Fn rdmsr_locked "u_int msr"
#.  .Ft void
#.  .Fn wrmsr_locked "u_int msr" "u_int" "uint64_t val"
#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/rdmsr.9:51
msgid ""
"E<.Ft uint64_t> E<.Fn rdmsr \"u_int msr\"> E<.Ft int> E<.Fn rdmsr_safe "
"\"u_int msr\" \"uint64_t *valp\"> E<.Ft void> E<.Fn wrmsr \"u_int msr\" "
"\"uint64_t val\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/rdmsr.9:70
msgid ""
"The E<.Dv RDMSR> instruction reads from a x86 model-specific register E<.Pq "
"Dv MSR>.  Conversely, the E<.Dv WRMSR> instruction is used to write to a "
"E<.Dv MSR>.  In E<.Nx> the E<.Fn rdmsr>, E<.Fn rdmsr_safe>, and E<.Fn wrmsr> "
"functions are used to access E<.Dv MSRs>.  The header"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/man9.x86/rdmsr.9:70
#, no-wrap
msgid "x86/specialreg.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/rdmsr.9:74
msgid ""
"includes definitions for some of the commonly used MSRs, that is, control "
"registers that are present in some x86 processor models but unavailable in "
"others."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/man9.x86/rdmsr.9:76
#, no-wrap
msgid "Fn rdmsr msr"
msgstr ""

#.  .It Fn rdmsr_locked "msr"
#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/rdmsr.9:80
msgid "Returns the value read from E<.Fa msr>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/man9.x86/rdmsr.9:80
#, no-wrap
msgid "Fn rdmsr_safe msr valp"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/rdmsr.9:95
msgid ""
"The E<.Fn rdmsr_safe> function is a safer variant of E<.Fn rdmsr>.  Upon "
"successful completion, the function returns zero and the value read from the "
"register E<.Fa msr> is returned in E<.Fa valp>.  If a fault occurs while "
"accessing E<.Fa msr>, E<.Fn rdmsr_safe> returns E<.Dv EFAULT>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/man9.x86/rdmsr.9:95
#, no-wrap
msgid "Fn wrmsr msr val"
msgstr ""

#.  .It Fn wrmsr_locked "msr" "xxx" "val"
#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/rdmsr.9:103
msgid "The E<.Fn wrmsr> function writes E<.Fa val> to the register E<.Fa msr>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/rdmsr.9:117
msgid ""
"Note that even though E<.Fn rdmsr_safe> provides support for reading E<.Dv "
"MSRs> in a safe manner, it is still a good practice to always verify that "
"the given model-specific register is present by using the E<.Dv CPUID> "
"instruction, available in E<.Nx> via E<.Fn x86_cpuid>."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/rdmsr.9:119
msgid "E<.Xr rdtsc 9>, E<.Xr x86_msr_xcall 9>"
msgstr ""

#. type: Dd
#: org_netbsd/src/share/man/man9/man9.x86/tsc.9:30 org_netbsd/src/share/man/man9/man9.x86/x86_msr_xcall.9:30
#, no-wrap
msgid "October 25, 2011"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/man9.x86/tsc.9:31
#, no-wrap
msgid "TSC 9 x86"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/tsc.9:35
msgid "E<.Nm tsc>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/man9.x86/tsc.9:35
#, no-wrap
msgid "Time Stamp Counter"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/man9.x86/tsc.9:37
#, no-wrap
msgid "x86/x86/tsc.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/tsc.9:48
msgid ""
"E<.Ft uint64_t> E<.Fn rdtsc \"void\"> E<.Ft void> E<.Fn tsc_tc_init "
"\"void\"> E<.Ft void> E<.Fn tsc_sync_ap \"struct cpu_info *ci\"> E<.Ft void> "
"E<.Fn tsc_sync_bp \"struct cpu_info *ci\"> E<.Ft void> E<.Fn tsc_sync_drift "
"\"int64_t drift\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/tsc.9:59
msgid ""
"The time stamp counter E<.Pq Tn TSC> is a hardware counter found in all "
"contemporary x86 processors.  The counter is implemented as a 64-bit "
"model-specific register E<.Pq Tn MSR> that is incremented at every clock "
"cycle.  The E<.Tn RDTSC> E<.Pq Dq read time stamp counter> register has been "
"present since the original Pentium."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/tsc.9:74
msgid ""
"Already because of the access method, E<.Tn TSC> has traditionally provided "
"a low-overhead and high-resolution way to obtain E<.Tn CPU> timing "
"information.  Recently, however, this reliability has been undermined by "
"such factors as system sleep states, E<.Tn CPU> E<.Dq hotplugging>, E<.Dq "
"hibernation>, and E<.Tn CPU> frequency scaling."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/tsc.9:88
msgid ""
"These potential new sources of unreliability are easily understandable when "
"one recalls that the counter measures cycles and not E<.Dq time>.  Comparing "
"the cycle counts only makes sense when the clock frequency is stable; to "
"convert the cycle counts to time units, a general equation would be: E<.Dq "
"seconds = cycles / frequency in Hz>.  The use of E<.Tn TSC> as a source of "
"high-resolution timing can be thus discouraged.  But the basic premise is "
"still guaranteed: E<.Tn TSC> is a monotonically increasing counter."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/man9.x86/tsc.9:90
#, no-wrap
msgid "Fn rdtsc \"\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/tsc.9:95
msgid "The E<.Fn rdtsc> function returns the value read from E<.Dv RDTSC>."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/man9.x86/tsc.9:95
#, no-wrap
msgid "Fn tsc_tc_init \"\""
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/tsc.9:103
msgid ""
"The E<.Fn tsc_tc_init> function initializes the E<.Tn TSC> as a E<.Xr "
"timecounter 9>.  The function is called early in the boot process when the "
"processors attach."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/man9.x86/tsc.9:103
#, no-wrap
msgid "Fn tsc_sync_ap ci"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/tsc.9:118
msgid ""
"The E<.Fn tsc_sync_ap> function synchronizes the counter for the boot "
"processor E<.Pq Tn BP>.  The supplied E<.Fa ci> must refer to the E<.Tn BP> "
"itself.  The E<.Nm> interface takes internally care of such issues as "
"out-of-order execution, where instructions are not necessarily performed in "
"the order of execution, possibly causing a misleading cycle count."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/man9.x86/tsc.9:118
#, no-wrap
msgid "Fn tsc_sync_bp ci"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/tsc.9:124
msgid ""
"The E<.Fn tsc_sync_bp> function synchronize the counter for the application "
"processor E<.Fa ci>.  Interrupts must be off at machine-level when the "
"function is called."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/tsc.9:136
msgid ""
"It is necessary to call both E<.Fn tsc_sync_ap> and E<.Fn tsc_sync_bp> "
"during the boot, but additional synchronization may be required also during "
"runtime.  As an example, the E<.Tn TSC> needs to be synchronized for all "
"processors when the system resumes from an E<.Xr acpi 4> sleep state."
msgstr ""

#. type: It
#: org_netbsd/src/share/man/man9/man9.x86/tsc.9:136
#, no-wrap
msgid "Fn tsc_sync_drift drift"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/tsc.9:145
msgid ""
"Finally, the E<.Fn tsc_sync_drift> function records E<.Fa drift>, measured "
"in clock cycles.  This is called when the E<.Tn APs> attach."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/tsc.9:159
msgid ""
"E<.Xr gettimeofday 2>, E<.Xr hpet 4>, E<.Xr hz 9>, E<.Xr rdmsr 9>, E<.Xr "
"timecounter 9>"
msgstr ""

#. type: Dt
#: org_netbsd/src/share/man/man9/man9.x86/x86_msr_xcall.9:31
#, no-wrap
msgid "X86_MSR_XCALL 9 x86"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/x86_msr_xcall.9:35
msgid "E<.Nm x86_msr_xcall>"
msgstr ""

#. type: Nd
#: org_netbsd/src/share/man/man9/man9.x86/x86_msr_xcall.9:35
#, no-wrap
msgid "MSR specific cross-call"
msgstr ""

#. type: In
#: org_netbsd/src/share/man/man9/man9.x86/x86_msr_xcall.9:37
#, no-wrap
msgid "x86/cpu_msr.h"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/x86_msr_xcall.9:40
msgid "E<.Ft void> E<.Fn x86_msr_xcall \"void *arg1\" \"void *arg1\">"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/x86_msr_xcall.9:54
msgid ""
"The E<.Fn x86_msr_xcall> function provides a x86-specific IPI handler "
"suitable for use with the E<.Xr xcall 9> interface.  It can be used to "
"ensure that a given E<.Tn MSR> call is executed on all processors.  The "
"prototype follows the E<.Ft xcfunc_t> function pointer type and the opaque "
"E<.Fa arg1> pointer is casted to the following structure:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/x86_msr_xcall.9:61
#, no-wrap
msgid ""
"struct msr_rw_info {\n"
"\tint\t\tmsr_read;\n"
"\tint\t\tmsr_type;\n"
"\tuint64_t\tmsr_value;\n"
"\tuint64_t\tmsr_mask;\n"
"};\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/x86_msr_xcall.9:80
msgid ""
"This structure must be filled prior to the call.  Two fields are compulsory: "
"E<.Fa msr_type> is used as the address of the E<.Tn MSR> and E<.Fa "
"msr_value> is the value to be written.  If E<.Fa msr_read> is not zero, "
"E<.Fn x86_msr_xcall> will first read from E<.Fa msr_type> and then clear the "
"mask specified in E<.Fa msr_mask> before the write operation."
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/x86_msr_xcall.9:84
msgid ""
"The following example writes a value zero to the E<.Tn MSR_THERM_CONTROL> "
"model-specific register on all processors in the system:"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/x86_msr_xcall.9:87
#, no-wrap
msgid ""
"struct msr_rw_info msr;\n"
"uint64_t xc;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/x86_msr_xcall.9:92
#, no-wrap
msgid ""
"msr.msr_value = 0;\n"
"msr.msr_read = true;\n"
"msr.msr_type = MSR_THERM_CONTROL;\n"
"msr.msr_mask = 0x1e;\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/x86_msr_xcall.9:95
#, no-wrap
msgid ""
"xc = xc_broadcast(0, (xcfunc_t)x86_msr_xcall, &msr, NULL);\n"
"xc_wait(xc);\n"
msgstr ""

#. type: Plain text
#: org_netbsd/src/share/man/man9/man9.x86/x86_msr_xcall.9:98
msgid "E<.Xr rdmsr 9>, E<.Xr xcall 9>"
msgstr ""
